'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const _ClassList = new Map();

const _classProperties = ['superclass', 'isSubclassOf', 'className'];
const _instanceProperties = ['isInstanceOf', 'className'];

_ClassList.registerClass = (classObj, className) => {
  //let className = classObj.className
  //const structInitializer = classObj._initWithData
  //if(typeof className === 'undefined'){
  //  if(typeof structInitializer === 'undefined'){
  //    // doesn't seem to be an instance of NSObject
  //    return
  //  }
  //  className = classObj.prototype.constructor.name
  //}
  if (className.startsWith('_')) {
    return;
  }

  classObj._className = className; // copy utility functions

  if (typeof classObj.superclass === 'undefined' && typeof classObj.prototype !== 'undefined') {
    for (const name of _classProperties) {
      const org = Object.getOwnPropertyDescriptor(NSObject, name);
      Object.defineProperty(classObj, name, org);
    }

    for (const name of _instanceProperties) {
      const org = Object.getOwnPropertyDescriptor(NSObject.prototype, name);
      Object.defineProperty(classObj.prototype, name, org);
    }
  }

  _ClassList.set(className, classObj);
};

/*global Buffer*/

/**
 * The root class of most Objective-C class hierarchies, from which subclasses inherit a basic interface to the runtime system and the ability to behave as Objective-C objects.
 * @access public
 * @see https://developer.apple.com/documentation/objectivec/nsobject
 */

class NSObject {
  /**
   * @access private
   * @type {Object}
   */
  static get _propTypes() {
    return {};
  } // Initializing a Class

  /**
   * Initializes the class before it receives its first message.
   * @access public
   * @returns {void}
   * @desc The runtime sends initialize() to each class in a program just before the class, or any class that inherits from it, is sent its first message from within the program. Superclasses receive this message before their subclasses.The runtime sends the initialize() message to classes in a thread-safe manner. That is, initialize() is run by the first thread to send a message to a class, and any other thread that tries to send a message to that class will block until initialize() completes.The superclass implementation may be called multiple times if subclasses do not implement initialize()—the runtime will call the inherited implementation—or if subclasses explicitly call [super initialize]. If you want to protect yourself from being run multiple times, you can structure your implementation along these lines:+ (void)initialize {
  if (self == [ClassName self]) {
    // ... do the initialization ...
  }
  }
  Because initialize() is called in a blocking manner, it’s important to limit method implementations to the minimum amount of work necessary possible. Specifically, any code that takes locks that might be required by other classes in their initialize() methods is liable to lead to deadlocks. Therefore, you should not rely on initialize() for complex initialization, and should instead limit it to straightforward, class local initialization.Special Considerationsinitialize() is invoked only once per class. If you want to perform independent initialization for the class and for categories of the class, you should implement load() methods.+ (void)initialize {
  if (self == [ClassName self]) {
    // ... do the initialization ...
  }
  }
    * @see https://developer.apple.com/documentation/objectivec/nsobject/1418639-initialize
   */


  static initialize() {}
  /**
   * Invoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading.
   * @access public
   * @returns {void}
   * @desc The load() message is sent to classes and categories that are both dynamically loaded and statically linked, but only if the newly loaded class or category implements a method that can respond.The order of initialization is as follows:All initializers in any framework you link to.All +load methods in your image.All C++ static initializers and C/C++ __attribute__(constructor) functions in your image.All initializers in frameworks that link to you.In addition:A class’s +load method is called after all of its superclasses’ +load methods.A category +load method is called after the class’s own +load method.In a custom implementation of load() you can therefore safely message other unrelated classes from the same image, but any load() methods implemented by those classes may not have run yet.ImportantCustom implementations of the load method for Swift classes bridged to Objective-C are not called automatically.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1418815-load
   */


  static load() {} // Creating, Copying, and Deallocating Objects

  /**
   * Implemented by subclasses to initialize a new object (the receiver) immediately after memory for it has been allocated.
   * @access public
   * @constructor
   * @desc An init() message is coupled with an alloc (or allocWithZone:) message in the same line of code:SomeClass *object = [[SomeClass alloc] init];
  An object isn’t ready to be used until it has been initialized.The init() method defined in the NSObject class does no initialization; it simply returns self. In terms of nullability, callers can assume that the NSObject implemetation of init() does not return nil.In a custom implementation of this method, you must invoke super’s Initialization then initialize and return the new object. If the new object can’t be initialized, the method should return nil. For example, a hypothetical BuiltInCamera class might return nil from its init method if run on a device that has no camera.- (instancetype)init {
    self = [super init];
    if (self) {
        // Initialize self
    }
    return self;
  }
  In some cases, a custom implementation of the init() method might return a substitute object. You must therefore always use the object returned by init(), and not the one returned by alloc or allocWithZone:, in subsequent code.SomeClass *object = [[SomeClass alloc] init];
  - (instancetype)init {
    self = [super init];
    if (self) {
        // Initialize self
    }
    return self;
  }
    * @see https://developer.apple.com/documentation/objectivec/nsobject/1418641-init
   */


  constructor() {
    // Discardable Content Proxy Support
    this._autoContentAccessingProxy = null; // Archiving

    this._classForArchiver = null;
    this._classForCoder = null;
    this._classForKeyedArchiver = null; // Working with Class Descriptions

    this._attributeKeys = null;
    this._classDescription = null;
    this._toManyRelationshipKeys = null;
    this._toOneRelationshipKeys = null; // Scripting

    /**
     * An NSString-keyed dictionary of the receiver's scriptable properties.
     * @type {?Map<string, Object>}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1417254-scriptingproperties
     */

    this.scriptingProperties = null;
    this._classCode = 0; // Instance Properties

    /**
     * Returns a pointer that identifies information about all of the observers that are registered with the observed object.
     * @type {?Object}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1414009-observationinfo
     */

    this.observationInfo = null;
    /**
     * The activation point for the accessibility element, in screen coordinates.
     * @type {CGPoint}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1615179-accessibilityactivationpoint
     */

    this.accessibilityActivationPoint = null;
    /**
     * An array of custom actions to display along with the built-in actions.
     * @type {?UIAccessibilityCustomAction[]}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1615150-accessibilitycustomactions
     */

    this.accessibilityCustomActions = null;
    /**
     * 
     * @type {?UIAccessibilityCustomRotor[]}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1649788-accessibilitycustomrotors
     */

    this.accessibilityCustomRotors = null;
    /**
     * An array of the accessibility elements in the container. 
     * @type {?Object[]}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1615147-accessibilityelements
     */

    this.accessibilityElements = null;
    /**
     * A Boolean value indicating whether the accessibility elements contained within this accessibility element are hidden.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1615080-accessibilityelementshidden
     */

    this.accessibilityElementsHidden = false;
    /**
     * The frame of the accessibility element, in screen coordinates.
     * @type {CGRect}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1615111-accessibilityframe
     */

    this.accessibilityFrame = null;
    /**
     * 
     * @type {?Object[]}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1627578-accessibilityheaderelements
     */

    this.accessibilityHeaderElements = null;
    /**
     * A brief description of the result of performing an action on the accessibility element, in a localized string.
     * @type {?string}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1615093-accessibilityhint
     */

    this.accessibilityHint = null;
    /**
     * A succinct label that identifies the accessibility element, in a localized string.
     * @type {?string}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1615181-accessibilitylabel
     */

    this.accessibilityLabel = null;
    /**
     * The language in which to speak the accessibility element's label, value, and hint.
     * @type {?string}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1615192-accessibilitylanguage
     */

    this.accessibilityLanguage = null;
    /**
     * The navigation style to apply to the object and its elements.
     * @type {UIAccessibilityNavigationStyle}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1615200-accessibilitynavigationstyle
     */

    this.accessibilityNavigationStyle = null;
    /**
     * The path of the element, in screen coordinates.
     * @type {?UIBezierPath}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1615159-accessibilitypath
     */

    this.accessibilityPath = null;
    /**
     * The combination of accessibility traits that best characterize the accessibility element. 
     * @type {UIAccessibilityTraits}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1615202-accessibilitytraits
     */

    this.accessibilityTraits = null;
    /**
     * The value of the accessibility element, in a localized string.
     * @type {?string}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1615117-accessibilityvalue
     */

    this.accessibilityValue = null;
    /**
     * A Boolean value indicating whether VoiceOver should ignore the elements within views that are siblings of the receiver.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1615089-accessibilityviewismodal
     */

    this.accessibilityViewIsModal = false;
    /**
     * A Boolean value indicating whether the receiver is an accessibility element that an assistive application can access.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1615141-isaccessibilityelement
     */

    this.isAccessibilityElement = false;
    /**
     * A Boolean value indicating whether VoiceOver should group together the elements that are children of the receiver, regardless of their positions on the screen.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1615143-shouldgroupaccessibilitychildren
     */

    this.shouldGroupAccessibilityChildren = false;
    this._hashValue = 0;
    this._accessibilityFocusedUIElement = null;
    this._accessibilityNotifiesWhenDestroyed = false;
    this._exposedBindings = null;
    this._objectForWebScript = null;
    this._objectSpecifier = null;
    this._webFrame = null;
    this._webPlugInContainerSelectionColor = null;
    this._isSelectable = false;
    /**
     * @access private
     * @type {boolean}
     */

    this._destroyed = false;
  }
  /**
   * Returns the object returned by copy(with:).
   * @access public
   * @returns {Object} - 
   * @desc This is a convenience method for classes that adopt the NSCopying protocol. An exception is raised if there is no implementation for copy(with:).NSObject does not itself support the NSCopying protocol. Subclasses must support the protocol and implement the copy(with:) method. A subclass version of the copy(with:) method should send the message to super first, to incorporate its implementation, unless the subclass descends directly from NSObject.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1418807-copy
   */


  copy() {
    const obj = new this.constructor(); // TODO: copy variables

    return obj;
  }
  /**
   * Returns the object returned by mutableCopy(with:) where the zone is nil.
   * @access public
   * @returns {Object} - 
   * @desc This is a convenience method for classes that adopt the NSMutableCopying protocol. An exception is raised if there is no implementation for mutableCopy(with:).
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1418978-mutablecopy
   */


  mutableCopy() {
    return null;
  } // Identifying Classes

  /**
   * Returns the class object for the receiver’s superclass.
   * @access public
   * @returns {?Object} - 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1418803-superclass
   */


  static superclass() {
    const superClass = Object.getPrototypeOf(this);

    if (superClass === Object.getPrototypeOf(Object)) {
      return null;
    }

    return superClass;
  }
  /**
   * Returns a Boolean value that indicates whether the receiving class is a subclass of, or identical to, a given class.
   * @access public
   * @param {Object} aClass - A class object.
   * @returns {boolean} - 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1418669-issubclass
   */


  static isSubclassOf(aClass) {
    if (this.className === aClass.className) {
      return true;
    }

    const superClass = this.superclass();

    if (superClass === null) {
      return false;
    }

    if (superClass.className === aClass.className) {
      return true;
    }

    if (superClass.isSubclassOf(aClass)) {
      return true;
    }

    return false;
  }
  /**
   * @access public
   * @param {Object} aClass - A class object.
   * @returns {boolean} -
   */


  isInstanceOf(aClass) {
    return this.constructor.isSubclassOf(aClass);
  } // Testing Class Functionality

  /**
   * Returns a Boolean value that indicates whether instances of the receiver are capable of responding to a given selector.
   * @access public
   * @param {!function} aSelector - A Selector.
   * @returns {boolean} - 
   * @desc If aSelector messages are forwarded to other objects, instances of the class are able to receive those messages without error even though this method returns false.To ask the class whether it, rather than its instances, can respond to a particular message, send to the class instead the  NSObject protocol instance method responds(to:).
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1418555-instancesrespond
   */


  static instancesRespondTo(aSelector) {
    if (typeof this.prototype[aSelector] === 'function') {
      return true;
    }

    return false;
  } // Testing Protocol Conformance

  /**
   * Returns a Boolean value that indicates whether the receiver conforms to a given protocol.
   * @access public
   * @param {Object} protocol - 
   * @returns {boolean} - 
   * @desc A class is said to “conform to” a protocol if it adopts the protocol or inherits from another class that adopts it. Protocols are adopted by listing them within angle brackets after the interface declaration. For example, here MyClass adopts the (fictitious) AffiliationRequests and Normalization protocols:@interface MyClass : NSObject <AffiliationRequests, Normalization>
  A class also conforms to any protocols that are incorporated in the protocols it adopts or inherits. Protocols incorporate other protocols in the same way classes adopt them. For example, here the AffiliationRequests protocol incorporates the Joining protocol:@protocol AffiliationRequests <Joining>
  If a class adopts a protocol that incorporates another protocol, it must also implement all the methods in the incorporated protocol or inherit those methods from a class that adopts it.This method determines conformance solely on the basis of the formal declarations in header files, as illustrated above. It doesn’t check to see whether the methods declared in the protocol are actually implemented—that’s the programmer’s responsibility.The protocol required as this method’s argument can be specified using the @protocol() directive:BOOL canJoin = [MyClass conformsToProtocol:@protocol(Joining)];
  @interface MyClass : NSObject <AffiliationRequests, Normalization>
  @protocol AffiliationRequests <Joining>
  BOOL canJoin = [MyClass conformsToProtocol:@protocol(Joining)];
    * @see https://developer.apple.com/documentation/objectivec/nsobject/1418893-conforms
   */


  static conformsTo(protocol) {
    // TODO: implement
    return false;
  } // Obtaining Information About Methods

  /**
   * Locates and returns the address of the receiver’s implementation of a method so it can be called as a function.
   * @access public
   * @param {!function} aSelector - A Selector that identifies the method for which to return the implementation address. The selector must be a valid and non-NULL. If in doubt, use the responds(to:) method to check before passing the selector to method(for:).
   * @returns {!function} - 
   * @desc If the receiver is an instance, aSelector should refer to an instance method; if the receiver is a class, it should refer to a class method.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1418863-method
   */


  methodFor(aSelector) {
    return null;
  }
  /**
   * Locates and returns the address of the implementation of the instance method identified by a given selector.
   * @access public
   * @param {!function} aSelector - A Selector that identifies the method for which to return the implementation address. The selector must be non-NULL and valid for the receiver. If in doubt, use the responds(to:) method to check before passing the selector to method(for:).
   * @returns {!function} - 
   * @desc An error is generated if instances of the receiver can’t respond to aSelector messages.Use this method to ask the class object for the implementation of instance methods only. To ask the class for the implementation of a class method, send the method(for:) instance method to the class instead.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1418713-instancemethod
   */


  static instanceMethodFor(aSelector) {
    return null;
  } // Describing Objects

  /**
   * Returns a string that represents the contents of the receiving class.
   * @access public
   * @returns {string} - 
   * @desc The debugger’s print-object command invokes this method to produce a textual description of an object.NSObject's implementation of this method simply prints the name of the class.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1418799-description
   */


  static description() {
    return this.className;
  } // Discardable Content Proxy Support

  /**
   * A proxy for the receiving object
   * @type {Object}
   * @desc This property returns a proxy for the receiving object if the receiver adopts the NSDiscardableContent protocol and still has content that has not been discarded.The proxy calls beginContentAccess() on the receiver to keep the content available as long as the proxy lives, and calls endContentAccess() when the proxy is deallocated.The wrapper object is otherwise a subclass of NSProxy and forwards messages to the original receiver object as an NSProxy does.This method can be used to hide an NSDiscardableContent object's content volatility by creating an object that responds to the same messages but holds the contents of the original receiver available as long as the created proxy lives. Thus hidden, the NSDiscardableContent object (by way of the proxy) can be given out to unsuspecting recipients of the object who would otherwise not know they might have to call beginContentAccess() and endContentAccess() around particular usages (specific to each NSDiscardableContent object) of the NSDiscardableContent object.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1409224-autocontentaccessingproxy
   */


  get autoContentAccessingProxy() {
    return this._autoContentAccessingProxy;
  } // Sending Messages

  /**
   * Invokes a method of the receiver on the current thread using the default mode after a delay.
   * @access public
   * @param {function} aSelector - A Selector that identifies the method to invoke. The method should not have a significant return value and should take a single argument of type id, or no arguments.
   * @param {?Object} anArgument - The argument to pass to the method when it is invoked. Pass nil if the method does not take an argument. 
   * @param {number} delay - The minimum time before which the message is sent. Specifying a delay of 0 does not necessarily cause the selector to be performed immediately. The selector is still queued on the thread’s run loop and performed as soon as possible.
   * @returns {void}
   * @desc This method sets up a timer to perform the aSelector message on the current thread’s run loop. The timer is configured to run in the default mode (NSDefaultRunLoopMode). When the timer fires, the thread attempts to dequeue the message from the run loop and perform the selector. It succeeds if the run loop is running and in the default mode; otherwise, the timer waits until the run loop is in the default mode. If you want the message to be dequeued when the run loop is in a mode other than the default mode, use the perform(_:with:afterDelay:inModes:) method instead. If you are not sure whether the current thread is the main thread, you can use the performSelector(onMainThread:with:waitUntilDone:) or performSelector(onMainThread:with:waitUntilDone:modes:) method to guarantee that your selector executes on the main thread. To cancel a queued message, use the cancelPreviousPerformRequests(withTarget:) or cancelPreviousPerformRequests(withTarget:selector:object:) method. Special ConsiderationsThis method registers with the runloop of its current context, and depends on that runloop being run on a regular basis to perform correctly. One common context where you might call this method and end up registering with a runloop that is not automatically run on a regular basis is when being invoked by a dispatch queue. If you need this type of functionality when running on a dispatch queue, you should use dispatch_after(_:_:_:) and related methods to get the behavior you want.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1416176-perform
   */


  performWithAfterDelay(aSelector, anArgument, delay) {}
  /**
   * Invokes a method of the receiver on the current thread using the specified modes after a delay.
   * @access public
   * @param {function} aSelector - A Selector that identifies the method to invoke. The method should not have a significant return value and should take a single argument of type id, or no arguments.
   * @param {?Object} anArgument - The argument to pass to the method when it is invoked. Pass nil if the method does not take an argument. 
   * @param {number} delay - The minimum time before which the message is sent. Specifying a delay of 0 does not necessarily cause the selector to be performed immediately. The selector is still queued on the thread’s run loop and performed as soon as possible.
   * @param {RunLoopMode[]} modes - An array of strings that identify the modes to associate with the timer that performs the selector. This array must contain at least one string. If you specify nil or an empty array for this parameter, this method returns without performing the specified selector. For information about run loop modes, see Run Loops in Threading Programming Guide.
   * @returns {void}
   * @desc This method sets up a timer to perform the aSelector message on the current thread’s run loop. The timer is configured to run in the modes specified by the modes parameter. When the timer fires, the thread attempts to dequeue the message from the run loop and perform the selector. It succeeds if the run loop is running and in one of the specified modes; otherwise, the timer waits until the run loop is in one of those modes. If you want the message to be dequeued when the run loop is in a mode other than the default mode, use the perform(_:with:afterDelay:inModes:) method instead. If you are not sure whether the current thread is the main thread, you can use the performSelector(onMainThread:with:waitUntilDone:) or performSelector(onMainThread:with:waitUntilDone:modes:) method to guarantee that your selector executes on the main thread. To cancel a queued message, use the cancelPreviousPerformRequests(withTarget:) or cancelPreviousPerformRequests(withTarget:selector:object:) method. Special ConsiderationsThis method registers with the runloop of its current context, and depends on that runloop being run on a regular basis to perform correctly. One common context where you might call this method and end up registering with a runloop that is not automatically run on a regular basis is when being invoked by a dispatch queue. If you need this type of functionality when running on a dispatch queue, you should use dispatch_after(_:_:_:) and related methods to get the behavior you want.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1415652-perform
   */


  performWithAfterDelayInModes(aSelector, anArgument, delay, modes) {}
  /**
   * Invokes a method of the receiver on the main thread using the default mode.
   * @access public
   * @param {function} aSelector - A Selector that identifies the method to invoke. The method should not have a significant return value and should take a single argument of type id, or no arguments.
   * @param {?Object} arg - The argument to pass to the method when it is invoked. Pass nil if the method does not take an argument.
   * @param {boolean} wait - A Boolean that specifies whether the current thread blocks until after the specified selector is performed on the receiver on the main thread. Specify true to block this thread; otherwise, specify false to have this method return immediately.If the current thread is also the main thread, and you specify true for this parameter, the message is delivered and processed immediately. 
   * @returns {void}
   * @desc You can use this method to deliver messages to the main thread of your application. The main thread encompasses the application’s main run loop, and is where the NSApplication object receives events. The message in this case is a method of the current object that you want to execute on the thread. This method queues the message on the run loop of the main thread using the common run loop modes—that is, the modes associated with the commonModes constant. As part of its normal run loop processing, the main thread dequeues the message (assuming it is running in one of the common run loop modes) and invokes the desired method. Multiple calls to this method from the same thread cause the corresponding selectors to be queued and performed in the same same order in which the calls were made.You cannot cancel messages queued using this method. If you want the option of canceling a message on the current thread, you must use either the perform(_:with:afterDelay:) or perform(_:with:afterDelay:inModes:) method.Special ConsiderationsThis method registers with the runloop of its current context, and depends on that runloop being run on a regular basis to perform correctly. One common context where you might call this method and end up registering with a runloop that is not automatically run on a regular basis is when being invoked by a dispatch queue. If you need this type of functionality when running on a dispatch queue, you should use dispatch_after(_:_:_:) and related methods to get the behavior you want.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1414900-performselector
   */


  performSelectorOnMainThreadWithWaitUntilDone(aSelector, arg, wait) {}
  /**
   * Invokes a method of the receiver on the main thread using the specified modes.
   * @access public
   * @param {function} aSelector - A Selector that identifies the method to invoke. The method should not have a significant return value and should take a single argument of type id, or no arguments.
   * @param {?Object} arg - The argument to pass to the method when it is invoked. Pass nil if the method does not take an argument.
   * @param {boolean} wait - A Boolean that specifies whether the current thread blocks until after the specified selector is performed on the receiver on the main thread. Specify true to block this thread; otherwise, specify false to have this method return immediately.If the current thread is also the main thread, and you pass true, the message is performed immediately, otherwise the perform is queued to run the next time through the run loop.
   * @param {?string[]} array - An array of strings that identifies the modes in which it is permissible to perform the specified selector. This array must contain at least one string. If you specify nil or an empty array for this parameter, this method returns without performing the specified selector. For information about run loop modes, see Run Loops in Threading Programming Guide.
   * @returns {void}
   * @desc You can use this method to deliver messages to the main thread of your application. The main thread encompasses the application’s mai run loop, and is where the NSApplication object receives events. The message in this case is a method of the current object that you want to execute on the thread. This method queues the message on the run loop of the main thread using the run loop modes specified in the array parameter. As part of its normal run loop processing, the main thread dequeues the message (assuming it is running in one of the specified modes) and invokes the desired method. Multiple calls to this method from the same thread cause the corresponding selectors to be queued and performed in the same same order in which the calls were made, assuming the associated run loop modes for each selector are the same. If you specify different modes for each selector, any selectors whose associated mode does not match the current run loop mode are skipped until the run loop subsequently executes in that mode.You cannot cancel messages queued using this method. If you want the option of canceling a message on the current thread, you must use either the perform(_:with:afterDelay:) or perform(_:with:afterDelay:inModes:) method.Special ConsiderationsThis method registers with the runloop of its current context, and depends on that runloop being run on a regular basis to perform correctly. One common context where you might call this method and end up registering with a runloop that is not automatically run on a regular basis is when being invoked by a dispatch queue. If you need this type of functionality when running on a dispatch queue, you should use dispatch_after(_:_:_:) and related methods to get the behavior you want.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1411637-performselector
   */


  performSelectorOnMainThreadWithWaitUntilDoneModes(aSelector, arg, wait, array) {}
  /**
   * Invokes a method of the receiver on the specified thread using the default mode.
   * @access public
   * @param {function} aSelector - A Selector that identifies the method to invoke. The method should not have a significant return value and should take a single argument of type id, or no arguments.
   * @param {Thread} thr - 
   * @param {?Object} arg - The argument to pass to the method when it is invoked. Pass nil if the method does not take an argument.
   * @param {boolean} wait - A Boolean that specifies whether the current thread blocks until after the specified selector is performed on the receiver on the specified thread. Specify true to block this thread; otherwise, specify false to have this method return immediately.If the current thread and target thread are the same, and you specify true for this parameter, the selector is performed immediately on the current thread. If you specify false, this method queues the message on the thread’s run loop and returns, just like it does for other threads. The current thread must then dequeue and process the message when it has an opportunity to do so.
   * @returns {void}
   * @desc You can use this method to deliver messages to other threads in your application. The message in this case is a method of the current object that you want to execute on the target thread. This method queues the message on the run loop of the target thread using the default run loop modes—that is, the modes associated with the commonModes constant. As part of its normal run loop processing, the target thread dequeues the message (assuming it is running in one of the default run loop modes) and invokes the desired method.You cannot cancel messages queued using this method. If you want the option of canceling a message on the current thread, you must use either the perform(_:with:afterDelay:) or perform(_:with:afterDelay:inModes:) method.Special ConsiderationsThis method registers with the runloop of its current context, and depends on that runloop being run on a regular basis to perform correctly. One common context where you might call this method and end up registering with a runloop that is not automatically run on a regular basis is when being invoked by a dispatch queue. If you need this type of functionality when running on a dispatch queue, you should use dispatch_after(_:_:_:) and related methods to get the behavior you want.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1414476-perform
   */


  performOnWithWaitUntilDone(aSelector, thr, arg, wait) {}
  /**
   * Invokes a method of the receiver on the specified thread using the specified modes.
   * @access public
   * @param {function} aSelector - A Selector that identifies the method to invoke. It should not have a significant return value and should take a single argument of type id, or no arguments.
   * @param {Thread} thr - 
   * @param {?Object} arg - The argument to pass to the method when it is invoked. Pass nil if the method does not take an argument.
   * @param {boolean} wait - A Boolean that specifies whether the current thread blocks until after the specified selector is performed on the receiver on the specified thread. Specify true to block this thread; otherwise, specify false to have this method return immediately. If the current thread and target thread are the same, and you specify true for this parameter, the selector is performed immediately. If you specify false, this method queues the message and returns immediately, regardless of whether the threads are the same or different.
   * @param {?string[]} array - An array of strings that identifies the modes in which it is permissible to perform the specified selector. This array must contain at least one string. If you specify nil or an empty array for this parameter, this method returns without performing the specified selector. For information about run loop modes, see Run Loops in Threading Programming Guide.
   * @returns {void}
   * @desc You can use this method to deliver messages to other threads in your application. The message in this case is a method of the current object that you want to execute on the target thread. This method queues the message on the run loop of the target thread using the run loop modes specified in the array parameter. As part of its normal run loop processing, the target thread dequeues the message (assuming it is running in one of the specified modes) and invokes the desired method. You cannot cancel messages queued using this method. If you want the option of canceling a message on the current thread, you must use either the perform(_:with:afterDelay:) or perform(_:with:afterDelay:inModes:) method instead. Special ConsiderationsThis method registers with the runloop of its current context, and depends on that runloop being run on a regular basis to perform correctly. One common context where you might call this method and end up registering with a runloop that is not automatically run on a regular basis is when being invoked by a dispatch queue. If you need this type of functionality when running on a dispatch queue, you should use dispatch_after(_:_:_:) and related methods to get the behavior you want.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1417922-perform
   */


  performOnWithWaitUntilDoneModes(aSelector, thr, arg, wait, array) {}
  /**
   * Invokes a method of the receiver on a new background thread.
   * @access public
   * @param {function} aSelector - A Selector that identifies the method to invoke. The method should not have a significant return value and should take a single argument of type id, or no arguments.
   * @param {?Object} arg - The argument to pass to the method when it is invoked. Pass nil if the method does not take an argument.
   * @returns {void}
   * @desc This method creates a new thread in your application, putting your application into multithreaded mode if it was not already. The method represented by aSelector must set up the thread environment just as you would for any other new thread in your program. For more information about how to configure and run threads, see Threading Programming Guide. 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1412390-performselector
   */


  performSelectorInBackgroundWith(aSelector, arg) {}
  /**
   * Cancels perform requests previously registered with the perform(_:with:afterDelay:) instance method.
   * @access public
   * @param {Object} aTarget - The target for requests previously registered with the perform(_:with:afterDelay:) instance method.
   * @returns {void}
   * @desc All perform requests having the same target aTarget are canceled. This method removes perform requests only in the current run loop, not all run loops.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1417611-cancelpreviousperformrequests
   */


  static cancelPreviousPerformRequestsWithTarget(aTarget) {}
  /**
   * Cancels perform requests previously registered with perform(_:with:afterDelay:).
   * @access public
   * @param {Object} aTarget - The target for requests previously registered with the perform(_:with:afterDelay:) instance method
   * @param {function} aSelector - The Selector for requests previously registered with the perform(_:with:afterDelay:) instance method.
   * @param {?Object} anArgument - The argument for requests previously registered with the perform(_:with:afterDelay:) instance method. Argument equality is determined using isEqual(_:), so the value need not be the same object that was passed originally. Pass nil to match a request for nil that was originally passed as the argument.
   * @returns {void}
   * @desc All perform requests are canceled that have the same target as aTarget, argument as anArgument, and selector as aSelector. This method removes perform requests only in the current run loop, not all run loops.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1410849-cancelpreviousperformrequests
   */


  static cancelPreviousPerformRequestsWithTargetSelectorObject(aTarget, aSelector, anArgument) {} // Forwarding Messages

  /**
   * Returns the object to which unrecognized messages should first be directed.
   * @access public
   * @param {!function} aSelector - A Selector for a method that the receiver does not implement.
   * @returns {?Object} - 
   * @desc If an object implements (or inherits) this method, and returns a non-nil (and non-self) result, that returned object is used as the new receiver object and the message dispatch resumes to that new object. (Obviously if you return self from this method, the code would just fall into an infinite loop.)If you implement this method in a non-root class, if your class has nothing to return for the given selector then you should return the result of invoking super’s implementation. This method gives an object a chance to redirect an unknown message sent to it before the much more expensive forwardInvocation: machinery takes over. This is useful when you simply want to redirect messages to another object and can be an order of magnitude faster than regular forwarding. It is not useful where the goal of the forwarding is to capture the NSInvocation, or manipulate the arguments or return value during the forwarding.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1418855-forwardingtarget
   */


  forwardingTargetFor(aSelector) {
    return null;
  } // Dynamically Resolving Methods

  /**
   * Dynamically provides an implementation for a given selector for a class method.
   * @access public
   * @param {!function} sel - 
   * @returns {boolean} - 
   * @desc This method allows you to dynamically provide an implementation for a given selector. See resolveInstanceMethod(_:) for further discussion.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1418889-resolveclassmethod
   */


  static resolveClassMethod(sel) {
    return false;
  }
  /**
   * Dynamically provides an implementation for a given selector for an instance method.
   * @access public
   * @param {!function} sel - 
   * @returns {boolean} - 
   * @desc This method and resolveClassMethod(_:) allow you to dynamically provide an implementation for a given selector.An Objective-C method is simply a C function that take at least two arguments—self and _cmd. Using the class_addMethod(_:_:_:_:) function, you can add a function to a class as a method. Given the following function:void dynamicMethodIMP(id self, SEL _cmd)
  {
    // implementation ....
  }
  you can use resolveInstanceMethod: to dynamically add it to a class as a method (called resolveThisMethodDynamically) like this:+ (BOOL) resolveInstanceMethod:(SEL)aSEL
  {
    if (aSEL == @selector(resolveThisMethodDynamically))
    {
          class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, "v@:");
          return YES;
    }
    return [super resolveInstanceMethod:aSel];
  }
  Special ConsiderationsThis method is called before the Objective-C forwarding mechanism is invoked. If responds(to:) or instancesRespond(to:) is invoked, the dynamic method resolver is given the opportunity to provide an IMP for the given selector first.void dynamicMethodIMP(id self, SEL _cmd)
  {
    // implementation ....
  }
  + (BOOL) resolveInstanceMethod:(SEL)aSEL
  {
    if (aSEL == @selector(resolveThisMethodDynamically))
    {
          class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, "v@:");
          return YES;
    }
    return [super resolveInstanceMethod:aSel];
  }
    * @see https://developer.apple.com/documentation/objectivec/nsobject/1418500-resolveinstancemethod
   */


  static resolveInstanceMethod(sel) {
    return false;
  } // Error Handling

  /**
   * Handles messages the receiver doesn’t recognize.
   * @access public
   * @param {!function} aSelector - A Selector that identifies a method not implemented or recognized by the receiver.
   * @returns {void}
   * @desc The runtime system invokes this method whenever an object receives an aSelector message it can’t respond to or forward. This method, in turn, raises an NSInvalidArgumentException, and generates an error message. Any doesNotRecognizeSelector(_:) messages are generally sent only by the runtime system. However, they can be used in program code to prevent a method from being inherited. For example, an NSObject subclass might renounce the copy() or init() method by re-implementing it to include a doesNotRecognizeSelector(_:) message as follows:- (id)copy
  {
    [self doesNotRecognizeSelector:_cmd];
  }
  The _cmd variable is a hidden argument passed to every method that is the current selector; in this example, it identifies the selector for the copy method. This code prevents instances of the subclass from responding to copy messages or superclasses from forwarding copy messages—although responds(to:) will still report that the receiver has access to a copy method.If you override this method, you must call super or raise an invalidArgumentException exception at the end of your implementation. In other words, this method must not return normally; it must always result in an exception being thrown. - (id)copy
  {
    [self doesNotRecognizeSelector:_cmd];
  }
    * @see https://developer.apple.com/documentation/objectivec/nsobject/1418637-doesnotrecognizeselector
   */


  doesNotRecognizeSelector(aSelector) {} // Archiving

  /**
   * Overridden by subclasses to substitute another object in place of the object that was decoded and subsequently received this message.
   * @access public
   * @param {NSCoder} aDecoder - The decoder used to decode the receiver.
   * @returns {?Object} - 
   * @desc You can use this method to eliminate redundant objects created by the coder. For example, if after decoding an object you discover that an equivalent object already exists, you can return the existing object. If a replacement is returned, your overriding method is responsible for releasing the receiver. This method is invoked by NSCoder. NSObject’s implementation simply returns self.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1417074-awakeafter
   */


  awakeAfterUsing(aDecoder) {
    return null;
  }
  /**
   * Overridden to return the names of classes that can be used to decode objects if their class is unavailable.
   * @access public
   * @returns {string[]} - 
   * @desc NSKeyedArchiver calls this method and stores the result inside the archive. If the actual class of an object doesn’t exist at the time of unarchiving, NSKeyedUnarchiver goes through the stored list of classes and uses the first one that does exists as a substitute class for decoding the object. The default implementation of this method returns nil.You can use this method if you introduce a new class into your application to provide some backwards compatibility in case the archive will be read on a system that does not have that class. Sometimes there may be another class which may work nearly as well as a substitute for the new class, and the archive keys and archived state for the new class can be carefully chosen (or compatibility written out) so that the object can be unarchived as the substitute class if necessary.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1411048-classfallbacksforkeyedarchiver
   */


  static classFallbacksForKeyedArchiver() {
    return null;
  }
  /**
   * Overridden by subclasses to substitute a new class during keyed unarchiving.
   * @access public
   * @returns {Object} - 
   * @desc During keyed unarchiving, instances of the receiver will be decoded as members of the returned class. This method overrides the results of the decoder’s class and instance name to class encoding tables.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1410547-classforkeyedunarchiver
   */


  static classForKeyedUnarchiver() {
    return null;
  }
  /**
   * Overridden by subclasses to substitute another object for itself during encoding.
   * @access public
   * @param {NSCoder} aCoder - The coder encoding the receiver.
   * @returns {?Object} - 
   * @desc An object might encode itself into an archive, but encode a proxy for itself if it’s being encoded for distribution. This method is invoked by NSCoder. NSObject’s implementation returns self.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1416843-replacementobject
   */


  replacementObjectFor(aCoder) {
    return null;
  }
  /**
   * Sets the receiver's version number.
   * @access public
   * @param {number} aVersion - The version number for the receiver.
   * @returns {void}
   * @desc The version number is helpful when instances of the class are to be archived and reused later. The default version is 0.Special ConsiderationsThe version number applies to NSArchiver/NSUnarchiver, but not to NSKeyedArchiver/NSKeyedUnarchiver.  A keyed archiver does not encode class version numbers.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1416538-setversion
   */


  static setVersion(aVersion) {}
  /**
   * Returns the version number assigned to the class.
   * @access public
   * @returns {number} - 
   * @desc If no version has been set, the default is 0. Version numbers are needed for decoding or unarchiving, so older versions of an object can be detected and decoded correctly.Caution should be taken when obtaining the version from within an NSCoding protocol or other methods. Use the class name explicitly when getting a class version number:version = [MyClass version];
  Don’t simply send version to the return value of class—a subclass version number may be returned instead.Special ConsiderationsThe version number applies to NSArchiver/NSUnarchiver, but not to NSKeyedArchiver/NSKeyedUnarchiver.  A keyed archiver does not encode class version numbers.version = [MyClass version];
    * @see https://developer.apple.com/documentation/objectivec/nsobject/1415151-version
   */


  static version() {
    return 0;
  }
  /**
   * The class to substitute for the receiver's own class during archiving.
   * @type {?Object}
   * @desc 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1411359-classforarchiver
   */


  get classForArchiver() {
    return this._classForArchiver;
  }
  /**
   * Overridden by subclasses to substitute a class other than its own during coding.
   * @type {Object}
   * @desc This method is invoked by NSCoder. NSObject’s implementation returns the receiver’s class. The private subclasses of a class cluster substitute the name of their public superclass when being archived.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1411876-classforcoder
   */


  get classForCoder() {
    return this._classForCoder;
  }
  /**
   * Subclasses to substitute a new class for instances during keyed archiving.
   * @type {?Object}
   * @desc The object will be encoded as if it were a member of the class. This property is overridden by the encoder class and instance name to class encoding tables. If this property is nil, the result of this property is ignored.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1410512-classforkeyedarchiver
   */


  get classForKeyedArchiver() {
    return this._classForKeyedArchiver;
  } // Working with Class Descriptions

  /**
   * For a given key that defines the name of the relationship from the receiver’s class to another class, returns the name of the relationship from the other class to the receiver’s class.
   * @access public
   * @param {string} relationshipKey - The name of the relationship from the receiver’s class to another class.
   * @returns {?string} - 
   * @desc NSObject’s implementation of inverseForRelationshipKey: simply invokes [[self classDescription] inverseForRelationshipKey:relationshipKey].  To make use of the default implementation, you must therefore implement and register a suitable class description—see NSClassDescription.For example, suppose an Employee class has a relationship named department to a Department class, and that Department has a relationship called employees to Employee. The statement:employee inverseForRelationshipKey:@"department"];
  returns the string employees.employee inverseForRelationshipKey:@"department"];
    * @see https://developer.apple.com/documentation/objectivec/nsobject/1411046-inverse
   */


  inverseForRelationshipKey(relationshipKey) {
    return null;
  }
  /**
   * An array of NSString objects containing the names of immutable values that instances of the receiver's class contain.
   * @type {string[]}
   * @desc NSObject’s implementation of attributeKeys simply calls [[self classDescription] attributeKeys]. To make use of the default implementation, you must therefore implement and register a suitable class description—see NSClassDescription. 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1415656-attributekeys
   */


  get attributeKeys() {
    return this._attributeKeys;
  }
  /**
   * An object containing information about the attributes and relationships of the receiver’s class.
   * @type {NSClassDescription}
   * @desc 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1411858-classdescription
   */


  get classDescription() {
    return this._classDescription;
  }
  /**
   * An array containing the keys for the to-many relationship properties of the receiver.
   * @type {string[]}
   * @desc 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1415662-tomanyrelationshipkeys
   */


  get toManyRelationshipKeys() {
    return this._toManyRelationshipKeys;
  }
  /**
   * The keys for the to-one relationship properties of the receiver, if any.
   * @type {string[]}
   * @desc 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1414814-toonerelationshipkeys
   */


  get toOneRelationshipKeys() {
    return this._toOneRelationshipKeys;
  } // Scripting

  /**
   * Creates and returns one or more scripting objects to be inserted into the specified relationship by copying the passed-in value and setting the properties in the copied object or objects.
   * @access public
   * @param {Object} value - An object or objects to be copied. The type must match the type of the property identified by key. (See also the Discussion section.)For example, if the property is a to-many relationship, value will always be an array of objects to be copied, and this method must therefore return an array of objects.
   * @param {string} key - A key that identifies the relationship into which to insert the copied object or objects.
   * @param {Map<string, Object>} properties - The properties to be set in the copied object or objects.  Derived from the "with properties" parameter of a duplicate command. (See also the Discussion section.)
   * @returns {?Object} - 
   * @desc You can override the copyScriptingValue method to take more control when your application is sent a duplicate command. This method is invoked on the prospective container of the copied object or objects. The properties are derived from the with properties parameter of the duplicate command. The returned objects or objects are then inserted into the container using key-value coding. When this method is invoked by Cocoa, neither the value nor the properties will have yet been coerced using the NSScriptKeyValueCoding method coerceValue(_:forKey:). For sdef-declared scriptability, however, the types of the passed-in objects reliably match the relevant sdef declarations.The default implementation of this method copies scripting objects by sending copyWithZone: to the object or objects specified by value. You override this method for situations where this is not sufficient, such as in Core Data applications, in which new objects must be initialized with [NSManagedObject initWithEntity:insertIntoManagedObjectContext:].
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1410291-copyscriptingvalue
   */


  copyScriptingValueForKeyWithProperties(value, key, properties) {
    return null;
  }
  /**
   * Creates and returns an instance of a scriptable class, setting its contents and properties, for insertion into the relationship identified by the key.
   * @access public
   * @param {Object} objectClass - 
   * @param {string} key - A key that identifies the relationship into which the new class object will be inserted.
   * @param {?Object} contentsValue - Specifies the contents of the object to be created. This may be nil. (See also the Discussion section.)
   * @param {Map<string, Object>} properties - The properties to be set in the new object. (See also the Discussion section.)
   * @returns {?Object} - 
   * @desc You can override the newScriptingObjectOfClass method to take more control when your application is sent a make command. This method is invoked on the prospective container of the new object. The contentsValue and properties are derived from the with contents and with properties parameters of the make command. The returned objects or objects are then inserted into the container using key-value coding.When this method is invoked by Cocoa, neither the contents value nor the properties will have yet been coerced using the NSScriptKeyValueCoding method coerceValue(_:forKey:). For sdef-declared scriptability, however, the types of the passed-in objects reliably match the relevant sdef declarations.The default implementation of this method creates new scripting objects by sending alloc to a class and init to the resulting object. You override this method for situations where this is not sufficient, such as in Core Data applications, in which new objects must be initialized with [NSManagedObject initWithEntity:insertIntoManagedObjectContext:].
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1418458-newscriptingobject
   */


  newScriptingObjectOfForValueForKeyWithContentsValue(objectClass, key, contentsValue, properties) {
    return null;
  }
  /**
   * Given an object specifier, returns the specified object or objects in the receiving container.
   * @access public
   * @param {NSScriptObjectSpecifier} objectSpecifier - An object specifier to be evaluated.
   * @returns {?Object} - 
   * @desc You can override this method to customize the evaluation of object specifiers without requiring that the scripting container make up indexes for contained objects that don't naturally have indexes (as can be the case if you implement indicesOfObjects(byEvaluatingObjectSpecifier:) instead).Your override of this method doesn't need to also invoke any of the NSScriptCommand error signaling methods, though it can, to record very specific information. The NSUnknownKeySpecifierError and NSInvalidIndexSpecifierError numbers are special, in that Cocoa may continue evaluating an outer specifier if they're encountered, for the convenience of scripters.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1409268-scriptingvalue
   */


  scriptingValueFor(objectSpecifier) {
    return null;
  }
  /**
   * The receiver's Apple event type code, as stored in the NSScriptClassDescription object for the object’s class.
   * @type {number}
   * @desc This property is used by Cocoa’s scripting support classes.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1413991-classcode
   */


  get classCode() {
    return this._classCode;
  }
  /**
   * A string containing the name of the class.
   * @type {string}
   * @desc 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1411337-classname
   */


  get className() {
    return this.constructor._className;
  }
  /**
   * A string containing the name of the class.
   * @type {string}
   * @desc 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1411337-classname
   */


  static get className() {
    return this.prototype.constructor._className;
  } // Deprecated Methods

  /**
   * The garbage collector invokes this method on the receiver before disposing of the memory it uses.
   * @deprecated
   * @access public
   * @returns {void}
   * @desc The garbage collector invokes this method on the receiver before disposing of the memory it uses. When garbage collection is enabled, this method is invoked instead of dealloc.You can override this method to relinquish resources the receiver has obtained, as shown in the following example:- (void)finalize {
    if (log_file != NULL) {
        fclose(log_file);
        log_file = NULL;
    }
    [super finalize];
  }
  Typically, however, you are encouraged to relinquish resources prior to finalization if at all possible. For more details, see Implementing a finalize Method.Special ConsiderationsIt is an error to store self into a new or existing live object (colloquially known as “resurrection”), which implies that this method will be called only once. However, the receiver may be messaged after finalization by other objects also being finalized at this time, so your override should guard against future use of resources that have been reclaimed, as shown by the log_file = NULL statement in the example. The finalize method itself will never be invoked more than once for a given object.Importantfinalize methods must be thread-safe.- (void)finalize {
    if (log_file != NULL) {
        fclose(log_file);
        log_file = NULL;
    }
    [super finalize];
  }
    * @see https://developer.apple.com/documentation/objectivec/nsobject/1418513-finalize
   */


  finalize() {} // Instance Properties

  /**
   * 
   * @type {number}
   * @desc 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1418615-hashvalue
   */


  get hashValue() {
    return this._hashValue;
  }
  /**
   * The deepest descendant of the accessibility hierarchy that has the focus.
   * @type {?Object}
   * @desc You can assume that the search for the focus has already been narrowed down to the accessibility element. Override this method to do deeper searching by identifying which child element, if any, may have the focus. If a child element does not have the focus, either return self or, if available, invoke the superclass's implementation. The default NSView and NSCell implementations test whether the accessibility element is an ignored element and, if so, return the element’s first unignored parent; otherwise they return self
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1526100-accessibilityfocuseduielement
   */


  get accessibilityFocusedUIElement() {
    return this._accessibilityFocusedUIElement;
  }
  /**
   * A Boolean value that indicates whether a custom accessibility object sends a notification when its corresponding UI element is destroyed.
   * @type {boolean}
   * @desc In macOS 10.9 and later, a custom accessibility object that is an NSObject subclass can post accessibility notifications if it meets the following criteria:The lifetime of the custom accessibility object must match the lifetime of the corresponding element in the app's UI.Typically, a custom accessibility object that acts as a proxy for an onscreen UI element gets autoreleased and deallocated immediately after the app responds to an accessibility request. Such an object can’t post accessibility notifications, because all registered observers get removed as soon as the object is deallocated. To correct this, an app must guarantee that a custom accessibility object remains allocated for as long as its corresponding UI element remains visible.The object must post the NSAccessibilityUIElementDestroyedNotification  notification at the appropriate time. The appropriate time is most likely to be when the corresponding UI element is removed from the screen, but it can also be when the object itself is deallocated. The object must implement accessibilityNotifiesWhenDestroyed and return true.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1534050-accessibilitynotifieswhendestroy
   */


  get accessibilityNotifiesWhenDestroyed() {
    return this._accessibilityNotifiesWhenDestroyed;
  }
  /**
   * Returns an array containing the bindings exposed by the receiver.
   * @type {string[]}
   * @desc A subclass can override this method to remove bindings that are exposed by a superclass that are not appropriate for the subclass.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1458048-exposedbindings
   */


  get exposedBindings() {
    return this._exposedBindings;
  }
  /**
   * Returns an object that exposes the plug-in’s scripting interface.
   * @type {!Object}
   * @desc The methods of the object are exposed to the script environment. Messages sent to the returned object will be invoked in the scripting environment. See the WebScripting Protocol Reference informal protocol for more details.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1537612-objectforwebscript
   */


  get objectForWebScript() {
    return this._objectForWebScript;
  }
  /**
   * Returns an object specifier for the receiver.
   * @type {?NSScriptObjectSpecifier}
   * @desc 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1409884-objectspecifier
   */


  get objectSpecifier() {
    return this._objectSpecifier;
  }
  /**
   * Returns the WebFrame that contains the plug-in.
   * @type {!WebFrame}
   * @desc Only implemented by containers that are based on the WebKit’s plug-in architecture.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1537727-webframe
   */


  get webFrame() {
    return this._webFrame;
  }
  /**
   * Returns the plug-in selection color.
   * @type {!CGColor}
   * @desc The color should be used for any special drawing when the plug-in is selected.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1536394-webplugincontainerselectioncolor
   */


  get webPlugInContainerSelectionColor() {
    return this._webPlugInContainerSelectionColor;
  }
  /**
   * Returns a Boolean value that indicates whether the key-value coding methods should access the corresponding instance variable directly on finding no accessor method for a property.
   * @type {boolean}
   * @desc The default returns true. Subclasses can override it to return false, in which case the key-value coding methods won’t access instance variables.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1415307-accessinstancevariablesdirectly
   */


  static get accessInstanceVariablesDirectly() {
    return true;
  }
  /**
   * 
   * @type {boolean}
   * @desc 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/2369549-isselectable
   */


  get isSelectable() {
    return this._isSelectable;
  } // Instance Methods

  /**
   * Registers the observer object to receive KVO notifications for the key path relative to the object receiving this message.
   * @access public
   * @param {NSObject} observer - The object to register for KVO notifications. The observer must implement the key-value observing method observeValue(forKeyPath:of:change:context:).
   * @param {string} keyPath - The key path, relative to the object receiving this message, of the property to observe. This value must not be nil.
   * @param {NSKeyValueObservingOptions} [options = []] - A combination of the NSKeyValueObservingOptions values that specifies what is included in observation notifications. For possible values, see NSKeyValueObservingOptions.
   * @param {?Object} context - Arbitrary data that is passed to observer in observeValue(forKeyPath:of:change:context:).
   * @returns {void}
   * @desc Neither the object receiving this message, nor observer, are retained. An object that calls this method must also eventually call either the removeObserver(_:forKeyPath:) or removeObserver(_:forKeyPath:context:) method to unregister the observer when participating in KVO.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1412787-addobserver
   */


  addObserverForKeyPath(observer, keyPath, options = [], context) {}
  /**
   * Implemented to attempt a recovery from an error noted in an application-modal dialog.
   * @access public
   * @param {Error} error - An NSError object that describes the error, including error recovery options.
   * @param {number} recoveryOptionIndex - The index of the user selected recovery option in error's localized recovery array.
   * @returns {boolean} - 
   * @desc Invoked when an error alert is been presented to the user in an application-modal dialog, and the user has selected an error recovery option specified by error.  
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1416402-attemptrecovery
   */


  attemptRecoveryFromErrorOptionIndex(error, recoveryOptionIndex) {
    return false;
  }
  /**
   * Returns a dictionary containing the property values identified by each of the keys in a given array.
   * @access public
   * @param {string[]} keys - An array containing NSString objects that identify properties of the receiver.
   * @returns {Map<string, Object>} - 
   * @desc The default implementation invokes value(forKey:) for each key in keys and substitutes NSNull values in the dictionary for returned nil values.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1411319-dictionarywithvalues
   */


  dictionaryWithValuesForKeys(keys) {
    return null;
  }
  /**
   * Informs the observed object that the specified change has occurred on the indexes for a specified ordered to-many relationship.
   * @access public
   * @param {NSKeyValueChange} changeKind - 
   * @param {Set} indexes - The indexes of the to-many relationship that were affected by the change.
   * @param {string} key - The name of a property that is an ordered to-many relationship.
   * @returns {void}
   * @desc Use this method when implementing key-value-observing compliance manually.Special ConsiderationsYou rarely need to override this method in subclasses, but if you do, be sure to call super. Calls to this method are always paired with a matching call to willChange(_:valuesAt:forKey:).
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1415349-didchange
   */


  didChangeValuesAtForKey(changeKind, indexes, key) {}
  /**
   * Informs the observed object that the value of a given property has changed.
   * @access public
   * @param {string} key - The name of the property that changed.
   * @returns {void}
   * @desc Use this method when implementing key-value observer compliance manually to inform the observed object that the value at key has just changed. Calls to this method are always paired with a matching call to willChangeValue(forKey:).Special ConsiderationsYou rarely need to override this method in subclasses, but if you do, be sure to call super.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1411809-didchangevalue
   */


  didChangeValueForKey(key) {}
  /**
   * Informs the observed object that the specified change was made to a specified unordered to-many relationship.
   * @access public
   * @param {string} key - The name of a property that is an unordered to-many relationship
   * @param {NSKeyValueSetMutationKind} mutationKind - The type of change that was made.
   * @param {Set<AnyHashable>} objects - The objects that were involved in the change (see NSKeyValueSetMutationKind).
   * @returns {void}
   * @desc Use this method when implementing key-value observer compliance manually. Calls to this method are always paired with a matching call to willChangeValue(forKey:withSetMutation:using:).Special ConsiderationsYou rarely need to override this method in subclasses, but if you do, be sure to call super.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1410539-didchangevalue
   */


  didChangeValueForKeyWithSetMutationUsing(key, mutationKind, objects) {}
  /**
   * An NSFileManager object sends this message to its handler for each error it encounters when copying, moving, removing, or linking files or directories. 
   * @deprecated
   * @access public
   * @param {FileManager} fm - 
   * @param {Map<AnyHashable, Object>} errorInfo - A dictionary that contains two or three pieces of information (all NSString objects) related to the error:KeyValue@"Path"The path related to the error (usually the source path)@"Error"A description of the error@"ToPath" The destination path (not all errors)
   * @returns {boolean} - 
   * @desc An NSFileManager object, manager, sends this message for each error it encounters when copying, moving, removing, or linking files or directories. The return value is passed back to the invoker of copyPath:toPath:handler:, movePath:toPath:handler:, removeFileAtPath:handler:, or linkPath:toPath:handler:. If an error occurs and your handler has not implemented this method, the invoking method automatically returns false.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1557005-filemanager
   */


  fileManagerShouldProceedAfterError(fm, errorInfo) {
    return false;
  }
  /**
   * An NSFileManager object sends this message to a handler immediately before attempting to move, copy, rename, or delete, or before attempting to link to a given path.
   * @deprecated
   * @access public
   * @param {FileManager} fm - 
   * @param {string} path - The path or a file or directory that manager is about to attempt to move, copy, rename, delete, or link to.
   * @returns {void}
   * @desc You can implement this method in your handler to monitor file operations.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1557002-filemanager
   */


  fileManagerWillProcessPath(fm, path) {}
  /**
   * Returns a mutable array proxy that provides read-write access to an ordered to-many relationship specified by a given key.
   * @access public
   * @param {string} key - The name of an ordered to-many relationship.
   * @returns {Array} - 
   * @desc Objects added to the mutable array become related to the receiver, and objects removed from the mutable array become unrelated. The default implementation recognizes the same simple accessor methods and array accessor methods as value(forKey:), and follows the same direct instance variable access policies, but always returns a mutable collection proxy object instead of the immutable collection that value(forKey:) would return. The search pattern that mutableArrayValueForKey: uses is described in Accessor Search Patterns in Key-Value Coding Programming Guide.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1416339-mutablearrayvalue
   */


  mutableArrayValueForKey(key) {
    return null;
  }
  /**
   * Returns a mutable array that provides read-write access to the ordered to-many relationship specified by a given key path.
   * @access public
   * @param {string} keyPath - A key path, relative to the receiver, to an ordered to-many relationship.
   * @returns {Array} - 
   * @desc See mutableArrayValue(forKey:) for additional details.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1414937-mutablearrayvalue
   */


  mutableArrayValueForKeyPath(keyPath) {
    return null;
  }
  /**
   * Returns a mutable ordered set that provides read-write access to the uniquing ordered to-many relationship specified by a given key.
   * @access public
   * @param {string} key - The name of a uniquing ordered to-many relationship.
   * @returns {Set} - 
   * @desc Objects added to the mutable set proxy become related to the receiver, and objects removed from the mutable set become unrelated. The default implementation recognizes the same simple accessor methods and set accessor methods as value(forKey:), and follows the same direct instance variable access policies, but always returns a mutable collection proxy object instead of the immutable collection that value(forKey:) would return. The search pattern that mutableOrderedSetValueForKey: uses is described in Accessor Search Patterns in Key-Value Coding Programming Guide.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1415479-mutableorderedsetvalue
   */


  mutableOrderedSetValueForKey(key) {
    return null;
  }
  /**
   * Returns a mutable ordered set that provides read-write access to the uniquing ordered to-many relationship specified by a given key path.
   * @access public
   * @param {string} keyPath - A key path, relative to the receiver, to a uniquing ordered to-many relationship represented by a set.
   * @returns {Set} - 
   * @desc See mutableOrderedSetValue(forKey:) for additional details.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1407188-mutableorderedsetvalue
   */


  mutableOrderedSetValueForKeyPath(keyPath) {
    return null;
  }
  /**
   * Returns a mutable set proxy that provides read-write access to the unordered to-many relationship specified by a given key.
   * @access public
   * @param {string} key - The name of an unordered to-many relationship.
   * @returns {Set} - 
   * @desc Objects added to the mutable set proxy become related to the receiver, and objects removed from the mutable set become unrelated. The default implementation recognizes the same simple accessor methods and set accessor methods as value(forKey:), and follows the same direct instance variable access policies, but always returns a mutable collection proxy object instead of the immutable collection that value(forKey:) would return. The search pattern that mutableSetValueForKey: uses is described in Accessor Search Patterns in Key-Value Coding Programming Guide.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1415105-mutablesetvalue
   */


  mutableSetValueForKey(key) {
    return null;
  }
  /**
   * Returns a mutable set that provides read-write access to the unordered to-many relationship specified by a given key path.
   * @access public
   * @param {string} keyPath - A key path, relative to the receiver, to an unordered to-many relationship.
   * @returns {Set} - 
   * @desc See mutableSetValue(forKey:) for additional details.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1408115-mutablesetvalue
   */


  mutableSetValueForKeyPath(keyPath) {
    return null;
  }
  /**
   * Informs the observing object when the value at the specified key path relative to the observed object has changed.
   * @access public
   * @param {?string} keyPath - The key path, relative to object, to the value that has changed.
   * @param {?Object} object - The source object of the key path keyPath. 
   * @param {?Map<NSKeyValueChangeKey, Object>} change - A dictionary that describes the changes that have been made to the value of the property at the key path keyPath relative to object. Entries are described in Change Dictionary Keys.
   * @param {?Object} context - The value that was provided when the observer was registered to receive key-value observation notifications.
   * @returns {void}
   * @desc For an object to begin sending change notification messages for the value at keyPath, you send it an addObserver(_:forKeyPath:options:context:) message, naming the observing object that should receive the messages. When you are done observing, and in particular before the observing object is deallocated, you send the observed object a removeObserver(_:forKeyPath:) or removeObserver(_:forKeyPath:context:) message to unregister the observer, and stop sending change notification messages.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1416553-observevalue
   */


  observeValueForKeyPathOf(keyPath, object, change, context) {}
  /**
   * Stops the observer object from receiving change notifications for the property specified by the key path relative to the object receiving this message.
   * @access public
   * @param {NSObject} observer - The object to remove as an observer.
   * @param {string} keyPath - A key-path, relative to the object receiving this message, for which observer is registered to receive KVO change notifications.
   * @returns {void}
   * @desc It is an error to call removeObserver(_:forKeyPath:) for an object that has not previously been registered as an observer.Be sure to invoke this method (or removeObserver(_:forKeyPath:context:)) before any object specified in addObserver(_:forKeyPath:options:context:) is deallocated.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1408054-removeobserver
   */


  removeObserverForKeyPath(observer, keyPath) {}
  /**
   * Invoked by setValue(_:forKey:) when it’s given a nil value for a scalar value (such as an int or float).
   * @access public
   * @param {string} key - The name of one of the receiver's properties.
   * @returns {void}
   * @desc Subclasses can override this method to handle the request in some other way, such as by substituting 0 or a sentinel value for nil and invoking setValue(_:forKey:) again or setting the variable directly. The default implementation raises an NSInvalidArgumentException. 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1415174-setnilvalueforkey
   */


  setNilValueForKey(key) {}
  /**
   * Sets the property of the receiver specified by a given key to a given value.
   * @access public
   * @param {?Object} value - The value for the property identified by key.
   * @param {string} key - The name of one of the receiver's properties.
   * @returns {void}
   * @desc If key identifies a to-one relationship, relate the object specified by value to the receiver, unrelating the previously related object if there was one. Given a collection object and a key that identifies a to-many relationship, relate the objects contained in the collection to the receiver, unrelating previously related objects if there were any.  The search pattern that setValue:forKey: uses is described in Accessor Search Patterns in Key-Value Coding Programming Guide.In a reference-counted environment, if the instance variable is accessed directly, value is retained.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1415969-setvalue
   */


  setValueForKey(value, key) {
    if (typeof this[key] === 'undefined') {
      this.setValueForUndefinedKey(value, key);
    } else {
      this[key] = value;
    }
  }
  /**
   * Sets the value for the property identified by a given key path to a given value.
   * @access public
   * @param {?Object} value - The value for the property identified by keyPath.
   * @param {string} keyPath - A key path of the form relationship.property (with one or more relationships): for example “department.name” or “department.manager.lastName.” 
   * @returns {void}
   * @desc The default implementation of this method gets the destination object for each relationship using value(forKey:), and sends the final object a setValue(_:forKey:) message.Special ConsiderationsWhen using this method, and the destination object does not implement an accessor for the value, the default behavior is for that object to retain value rather than copy or assign value.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1418139-setvalue
   */


  setValueForKeyPath(value, keyPath) {
    //console.log('NSObject.setValueForKeyPath: ' + keyPath)
    if (typeof keyPath !== 'string') {
      throw new Error('setValueForKeyPath: keyPath should be string');
    }

    const paths = keyPath.split('.');
    const key = paths.shift();

    if (paths.length === 0) {
      this.setValueForKey(value, key);
      return;
    }

    const target = this.valueForKey(key);

    if (target === null) {
      console.error(`setValueForKeyPath: key ${key} is null.`);
      return;
    } //console.log(`NSObject.setValueForKeyPath: ${keyPath}: key ${key} target ${target}`)


    target.setValueForKeyPath(value, paths.join('.'));
  }
  /**
   * Invoked by setValue(_:forKey:) when it finds no property for a given key.
   * @access public
   * @param {?Object} value - The value for the key identified by key.
   * @param {string} key - A string that is not equal to the name of any of the receiver's properties.
   * @returns {void}
   * @desc Subclasses can override this method to handle the request in some other way. The default implementation raises an NSUndefinedKeyException.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1413490-setvalue
   */


  setValueForUndefinedKey(value, key) {
    throw new Error(`setValueForKey: undefined key: ${key}`);
  }
  /**
   * Sets properties of the receiver with values from a given dictionary, using its keys to identify the properties.
   * @access public
   * @param {Map<string, Object>} keyedValues - A dictionary whose keys identify properties in the receiver. The values of the properties in the receiver are set to the corresponding values in the dictionary.
   * @returns {void}
   * @desc The default implementation invokes setValue(_:forKey:) for each key-value pair, substituting nil for NSNull values in keyedValues.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1417515-setvaluesforkeys
   */


  setValuesForKeys(keyedValues) {}
  /**
   * Returns a Boolean value that indicates whether the value specified by a given pointer is valid for the property identified by a given key.
   * @access public
   * @param {AutoreleasingUnsafeMutablePointer<AnyObject?>} ioValue - A pointer to a new value for the property identified by key. This method may modify or replace the value in order to make it valid.
   * @param {string} inKey - 
   * @returns {void}
   * @throws {Error}
   * @desc The default implementation of this method searches the class of the receiver for a validation method whose name matches the pattern validate<Key>:error:. If such a method is found it is invoked and the result is returned. If no such method is found, true is returned.The sender of the message is never given responsibility for releasing ioValue or outError. See Adding Validation for more information.Handling Errors in Swift:
  In Swift, this method returns Void and is marked with the throws keyword to indicate that it throws an error in cases of failure.
  You call this method in a try expression and handle any errors in the catch clauses of a do statement, as described in Error Handling in The Swift Programming Language (Swift 3.1) and Error Handling in Using Swift with Cocoa and Objective-C (Swift 3.1).
    * @see https://developer.apple.com/documentation/objectivec/nsobject/1416754-validatevalue
   */


  validateValueForKey(ioValue, inKey) {}
  /**
   * Returns a Boolean value that indicates whether the value specified by a given pointer is valid for a given key path relative to the receiver. 
   * @access public
   * @param {AutoreleasingUnsafeMutablePointer<AnyObject?>} ioValue - A pointer to a new value for the property identified by keyPath. This method may modify or replace the value in order to make it valid.
   * @param {string} inKeyPath - 
   * @returns {void}
   * @throws {Error}
   * @desc The default implementation gets the destination object for each relationship using value(forKey:) and returns the result of a validateValue(_:forKey:) message to the final object.Handling Errors in Swift:
  In Swift, this method returns Void and is marked with the throws keyword to indicate that it throws an error in cases of failure.
  You call this method in a try expression and handle any errors in the catch clauses of a do statement, as described in Error Handling in The Swift Programming Language (Swift 3.1) and Error Handling in Using Swift with Cocoa and Objective-C (Swift 3.1).
    * @see https://developer.apple.com/documentation/objectivec/nsobject/1416245-validatevalue
   */


  validateValueForKeyPath(ioValue, inKeyPath) {}
  /**
   * Returns the value for the property identified by a given key.
   * @access public
   * @param {string} key - The name of one of the receiver's properties.
   * @returns {?Object} - 
   * @desc The search pattern that valueForKey: uses to find the correct value to return is described in Accessor Search Patterns in Key-Value Coding Programming Guide.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1412591-value
   */


  valueForKey(key) {
    if (typeof key !== 'string') {
      throw new Error('error: valueForKey(key): key should be string');
    }

    if (typeof this[key] === 'undefined') {
      //console.log('valueForUndefinedKey func: ' + this.valueForUndefinedKey)
      return this.valueForUndefinedKey(key);
    }

    return this[key];
  }
  /**
   * Returns the value for the derived property identified by a given key path.
   * @access public
   * @param {string} keyPath - A key path of the form relationship.property (with one or more relationships); for example “department.name” or “department.manager.lastName”.
   * @returns {?Object} - 
   * @desc The default implementation gets the destination object for each relationship using value(forKey:) and returns the result of a value(forKey:) message to the final object.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1416468-value
   */


  valueForKeyPath(keyPath) {
    if (typeof keyPath !== 'string') {
      throw new Error('valueForKeyPath(keyPath): keyPath should be string');
    }

    const paths = keyPath.split('.');
    const key = paths.shift();
    const value = this.valueForKey(key);

    if (paths.length === 0) {
      return value;
    }

    if (value === null) {
      return null;
    }

    return value.valueForKeyPath(paths.join('.'));
  }
  /**
   * Invoked by value(forKey:) when it finds no property corresponding to a given key.
   * @access public
   * @param {string} key - A string that is not equal to the name of any of the receiver's properties.
   * @returns {?Object} - 
   * @desc Subclasses can override this method to return an alternate value for undefined keys. The default implementation raises an NSUndefinedKeyException.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1413457-value
   */


  valueForUndefinedKey(key) {
    return undefined; //throw new Error(`valueForKey: undefined key: ${key}`)
  }
  /**
   * Informs the observed object that the specified change is about to be executed at given indexes for a specified ordered to-many relationship.
   * @access public
   * @param {NSKeyValueChange} changeKind - 
   * @param {Set} indexes - The indexes of the to-many relationship that will be affected by the change.
   * @param {string} key - The name of a property that is an ordered to-many relationship.
   * @returns {void}
   * @desc Use this method when implementing key-value-observing compliance manually.ImportantAfter the values have been changed, a corresponding didChange(_:valuesAt:forKey:) must be invoked with the same parameters.Special ConsiderationsYou rarely need to override this method in subclasses, but if you do, be sure to call super.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1412271-willchange
   */


  willChangeValuesAtForKey(changeKind, indexes, key) {}
  /**
   * Informs the observed object that the value of a given property is about to change.
   * @access public
   * @param {string} key - The name of the property that will change.
   * @returns {void}
   * @desc Use this method when implementing key-value observer compliance manually to inform the observed object that the value at key is about to change.The change type of this method is NSKeyValueChangeSetting.ImportantAfter the values have been changed, a corresponding didChangeValue(forKey:) must be invoked with the same parameter. Special ConsiderationsYou rarely need to override this method in subclasses, but if you do, be sure to call super.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1416222-willchangevalue
   */


  willChangeValueForKey(key) {}
  /**
   * Informs the observed object that the specified change is about to be made to a specified unordered to-many relationship.
   * @access public
   * @param {string} key - The name of a property that is an unordered to-many relationship
   * @param {NSKeyValueSetMutationKind} mutationKind - The type of change that will be made.
   * @param {Set<AnyHashable>} objects - The objects that are involved in the change (see NSKeyValueSetMutationKind).
   * @returns {void}
   * @desc Use this method when implementing key-value observer compliance manually.ImportantAfter the values have been changed, a corresponding didChangeValue(forKey:withSetMutation:using:) must be invoked with the same parameters.Special ConsiderationsYou rarely need to override this method in subclasses, but if you do, be sure to call super.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1412323-willchangevalue
   */


  willChangeValueForKeyWithSetMutationUsing(key, mutationKind, objects) {}
  /**
   * 
   * @access public
   * @param {!QLPreviewPanel} panel - 
   * @returns {boolean} - 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1504653-acceptspreviewpanelcontrol
   */


  acceptsPreviewPanelControl(panel) {
    return false;
  }
  /**
   * Returns a localized description of the specified action.
   * @deprecated
   * @access public
   * @param {string} action - The action attribute.
   * @returns {?string} - 
   * @desc User interface classes must implement this method to return descriptions for all actions returned from accessibilityActionNames(). A button, for example, might return the string "press” for the NSAccessibilityPressAction action. Subclasses should invoke the superclass's implementation, if it exists, to obtain the descriptions of any inherited actions.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1533500-accessibilityactiondescription
   */


  accessibilityActionDescription(action) {
    return null;
  }
  /**
   * Returns an array of action names supported by the accessibility element.
   * @deprecated
   * @access public
   * @returns {Object[]} - 
   * @desc User interface classes must implement this method. Subclasses should invoke the superclass's implementation, if it exists, and append additional action names or remove unsupported actions. See Constants for some common action names.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1527905-accessibilityactionnames
   */


  accessibilityActionNames() {
    return null;
  }
  /**
   * Returns the count of the specified accessibility array attribute.
   * @access public
   * @param {string} attribute - The accessibility array attribute.
   * @returns {number} - 
   * @desc If attribute is not an array, an exception is raised.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1527138-accessibilityarrayattributecount
   */


  accessibilityArrayAttributeCount(attribute) {
    return 0;
  }
  /**
   * Returns a subarray of values of an accessibility array attribute.
   * @access public
   * @param {string} attribute - The accessibility array attribute.
   * @param {number} index - The starting index.
   * @param {number} maxCount - The maximum desired number of items requested.
   * @returns {Object[]} - 
   * @desc Note that this method does not take a range. The maximum count is the maximum desired number of items requested by an accessibility client. This number may be beyond the bounds of your array.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1535909-accessibilityarrayattributevalue
   */


  accessibilityArrayAttributeValues(attribute, index, maxCount) {
    return null;
  }
  /**
   * Returns an array of attribute names supported by the receiver.
   * @deprecated
   * @access public
   * @returns {Object[]} - 
   * @desc User interface classes must implement this method. Subclasses should invoke the superclass's implementation, if it exists, and append additional attributes or remove unsupported attributes. See Constants for lists of attribute names.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1525181-accessibilityattributenames
   */


  accessibilityAttributeNames() {
    return null;
  }
  /**
   * Returns the value of the specified attribute in the receiver.
   * @deprecated
   * @access public
   * @param {string} attribute - The name of the attribute. See Constants for lists of attribute names.
   * @returns {?Object} - 
   * @desc User interface classes must implement this method. Subclasses should invoke the superclass's implementation, if it exists, if attribute is not implemented in the subclass.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1532465-accessibilityattributevalue
   */


  accessibilityAttributeValue(attribute) {
    return null;
  }
  /**
   * Returns the value of the receiver's parameterized attribute corresponding to the specified attribute name and parameter.
   * @deprecated
   * @access public
   * @param {string} attribute - The name of the attribute. See Constants for lists of attribute names.
   * @param {?Object} parameter - The parameter.
   * @returns {?Object} - 
   * @desc If you implement this method, also implement accessibilityParameterizedAttributeNames().
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1524809-accessibilityattributevalue
   */


  accessibilityAttributeValueForParameter(attribute, parameter) {
    return null;
  }
  /**
   * Returns the deepest descendant of the accessibility hierarchy that contains the specified point.
   * @access public
   * @param {CGPoint} point - The point being hit-tested, in lower-left relative screen coordinates.
   * @returns {?Object} - 
   * @desc You can assume that the specified point has already been determined to lie within the accessibility element's frame. Override this method to do deeper hit-testing by identifying which child element, if any, contains the point. NSMatrix, for example, identifies which of its cells contains the point and propagates the hit-test to it. If the specified point is not contained within one of the accessibility element's children, either return self or, if available, invoke the superclass's implementation. The default NSView and NSCell implementations test whether the accessibility element is an ignored element and, if it is, return the receiver's first unignored parent; otherwise they return self.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1526136-accessibilityhittest
   */


  accessibilityHitTest(point) {
    return null;
  }
  /**
   * Returns the index of the specified accessibility child in the parent.
   * @access public
   * @param {Object} child - The accessibility child of an object.
   * @returns {number} - 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1533558-accessibilityindex
   */


  accessibilityIndexOfChild(child) {
    return 0;
  }
  /**
   * Returns a Boolean value that indicates whether the value for the specified attribute in the receiver can be set.
   * @deprecated
   * @access public
   * @param {string} attribute - The name of the attribute. See Constants for lists of attribute names.
   * @returns {boolean} - 
   * @desc User interface classes must implement this method. Subclasses should invoke the superclass's implementation, if it exists, if attribute is not implemented in the subclass.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1529207-accessibilityisattributesettable
   */


  accessibilityIsAttributeSettable(attribute) {
    return false;
  }
  /**
   * Returns a Boolean value indicating whether the receiver should be ignored in the parent-child accessibility hierarchy.
   * @deprecated
   * @access public
   * @returns {boolean} - 
   * @desc When asking for an object's children, do not include ignored children; instead, replace the ignored children with their own unignored children. The same applies when asking for an object's parent: skip the ignored parent and treat the first unignored ancestor as the real parent.  Likewise, when a hit-test or focus test is satisfied by an ignored element, use the element's first unignored ancestor (or descendant in certain cases, such as single-celled controls) instead.Ignored elements let you provide a simplified version of the view and object ownership hierarchies. Accessibility clients can bypass intermediate objects, letting users access the real user interface objects more quickly. For example, NSControl objects are ignored when they are single-celled; the visible parent-child relationship is between the control's parent (or a higher ancestor if the parent is ignored, too) and the control's cell.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1526439-accessibilityisignored
   */


  accessibilityIsIgnored() {
    return false;
  }
  /**
   * Returns a list of parameterized attribute names supported by the receiver.
   * @deprecated
   * @access public
   * @returns {Object[]} - 
   * @desc If you implement this method, also implement accessibilityAttributeValue(_:forParameter:).
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1525455-accessibilityparameterizedattrib
   */


  accessibilityParameterizedAttributeNames() {
    return null;
  }
  /**
   * Performs the action associated with the specified action.
   * @deprecated
   * @access public
   * @param {string} action - The action to perform.
   * @returns {void}
   * @desc User interface classes must implement this method to handle all the actions returned from accessibilityActionNames(). Subclasses should invoke the superclass's implementation, if it exists, if action is not implemented in the subclass.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1533528-accessibilityperformaction
   */


  accessibilityPerformAction(action) {}
  /**
   * Overrides the specified attribute in the receiver or adds it if it does not exist, and sets its value to the specified value.
   * @deprecated
   * @access public
   * @param {?Object} value - The attribute value to be set. 
   * @param {string} attribute - The name of the attribute. See Constants for lists of attribute names.
   * @returns {boolean} - 
   * @desc This method is for changing the set of attributes on an instance, as an alternative to subclassing.This method works only on objects whose class already implements the NSAccessibility protocol. If the specified attribute is already supported by the object, the value specified by this method wins.If the specified attribute does not exist, it is created outside the NSAccessibility protocol, so accessibilityAttributeNames still returns the old list, which does not contain the new attribute. Likewise, accessibilityAttributeValue does not return attributes created by the override process nor does it return their overridden values.The values of overridden attributes are not settable by accessibility clients.If you need to undo the effect of using this method, call it again, passing nil for the value.Ensure that you invoke this method on the actual object that represents the user interface element. For example, for NSButton, use the underlying NSButtonCell object. NSButton itself is ignored by accessibility.This method works only on an object representing a single user interface element. So, for example, you cannot use it when a single object represents multiple user interface elements, as with NSSegmentedCell, which has only a single object but provides user interface elements for each segment.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1535843-accessibilitysetoverridevalue
   */


  accessibilitySetOverrideValueForAttribute(value, attribute) {
    return false;
  }
  /**
   * Sets the value of the specified attribute in the receiver to the specified value.
   * @deprecated
   * @access public
   * @param {?Object} value - The attribute value to be set.
   * @param {string} attribute - The name of the attribute. See Constants for lists of attribute names.
   * @returns {void}
   * @desc User interface classes must implement this method if any of its attributes are settable. Subclasses should invoke the superclass's implementation, if it exists, if attribute is not implemented in the subclass.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1528477-accessibilitysetvalue
   */


  accessibilitySetValueForAttribute(value, attribute) {}
  /**
   * Sent to the delegate to request the property the action applies to.
   * @access public
   * @returns {!string} - 
   * @desc See Table 1The documentation for property-list constants for the properties for person and group records.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1411302-actionproperty
   */


  actionProperty() {
    return null;
  }
  /**
   * Sent by Cocoa’s built-in scripting support during execution of get or set script commands to find out if the delegate can handle operations on the specified key-value key.
   * @access public
   * @param {NSApplication} sender - The app object associated with the delegate. 
   * @param {string} key - The key to be handled.
   * @returns {boolean} - 
   * @desc The method should return true if the delegate for the app sender handles the key specified by key, which means it can get or set the scriptable property or element that corresponds to that key. The app implements methods for each of the keys that it handles, where the method name matches the key.For example, a scriptable app that doesn’t use Cocoa’s document-based app architecture can implement this method to supply its own document ordering. Such an app might want to do this because the standard app delegate expects to work with a document-based app. The TextEdit app (whose source is distributed with macOS developer tools) provides the following implementation:return [key isEqualToString:@"orderedDocuments"];
  TextEdit then implements the orderedDocuments method in its controller class to return an ordered list of documents. An app with its own window ordering might add a test for the key orderedWindows so that its delegate can provide its own version of orderedWindows.ImportantCocoa scripting does not invoke this method for script commands other than get or set. For information on working with other commands, see Script Commands in Cocoa Scripting Guide.return [key isEqualToString:@"orderedDocuments"];
    * @see https://developer.apple.com/documentation/objectivec/nsobject/1494285-application
   */


  applicationDelegateHandlesKey(sender, key) {
    return false;
  }
  /**
   * Sent to the delegate to indicate the authorization object has been created or changed. If you have saved a copy of the authorization object for your own purposes, you should discard it and call authorization for a new authorization object.
   * @access public
   * @param {!SFAuthorizationView} view - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1411010-authorizationviewcreatedauthoriz
   */


  authorizationViewCreatedAuthorization(view) {}
  /**
   * Sent to the delegate to indicate the user was authorized and the authorization view was changed to unlocked.
   * @access public
   * @param {!SFAuthorizationView} view - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1411002-authorizationviewdidauthorize
   */


  authorizationViewDidAuthorize(view) {}
  /**
   * Sent to the delegate to indicate the user was deauthorized and the authorization view was changed to locked.
   * @access public
   * @param {!SFAuthorizationView} view - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1411017-authorizationviewdiddeauthorize
   */


  authorizationViewDidDeauthorize(view) {}
  /**
   * Sent to the delegate to indicate that the view’s visibility has changed.
   * @access public
   * @param {!SFAuthorizationView} view - 
   * @returns {void}
   * @desc This delegate method, if present, is called whenever the isHidden method is called to show or hide the view.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1411034-authorizationviewdidhide
   */


  authorizationViewDidHide(view) {}
  /**
   * Sent to the delegate to indicate that deauthorization is about to occur.
   * @access public
   * @param {!SFAuthorizationView} view - 
   * @returns {void}
   * @desc This method is called after deauthorization has been approved (either you called the deauthorize: method, or the user clicked an open lock icon and the authorizationViewShouldDeauthorize: delegate method did not cancel the operation), and before the user is deauthorized (that is, before the authorizationViewDidDeauthorize: delegate method is called). 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1410992-authorizationviewreleasedauthori
   */


  authorizationViewReleasedAuthorization(view) {}
  /**
   * Sent to the delegate when a user clicks the open lock icon.
   * @access public
   * @param {!SFAuthorizationView} view - 
   * @returns {number} - 
   * @desc  The delegate can react to this before deauthorization happens and avoid it by returning false. This delegate method is not called when you call the deauthorize: method.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1411006-authorizationviewshoulddeauthori
   */


  authorizationViewShouldDeauthorize(view) {
    return 0;
  }
  /**
   * Prepares the receiver for service after it has been loaded from an Interface Builder archive, or nib file.
   * @access public
   * @returns {void}
   * @desc The nib-loading infrastructure sends an awakeFromNib message to each object recreated from a nib archive, but only after all the objects in the archive have been loaded and initialized. When an object receives an awakeFromNib message, it is guaranteed to have all its outlet and action connections already established.You must call the super implementation of awakeFromNib to give parent classes the opportunity to perform any additional initialization they require. Although the default implementation of this method does nothing, many UIKit classes provide non-empty implementations. You may call the super implementation at any point during your own awakeFromNib method.NoteDuring Interface Builder’s test mode, this message is also sent to objects instantiated from loaded Interface Builder plug-ins. Because plug-ins link against the framework containing the object definition code, Interface Builder is able to call their awakeFromNib method when present. The same is not true for custom objects that you create for your Xcode projects. Interface Builder knows only about the defined outlets and actions of those objects; it does not have access to the actual code for them.During the instantiation process, each object in the archive is unarchived and then initialized with the method befitting its type. Objects that conform to the NSCoding protocol (including all subclasses of UIView and UIViewController) are initialized using their initWithCoder: method. All objects that do not conform to the NSCoding protocol are initialized using their init method. After all objects have been instantiated and initialized, the nib-loading code reestablishes the outlet and action connections for all of those objects. It then calls the awakeFromNib method of the objects. For more detailed information about the steps followed during the nib-loading process, see Nib Files in Resource Programming Guide.ImportantBecause the order in which objects are instantiated from an archive is not guaranteed, your initialization methods should not send messages to other objects in the hierarchy. Messages to other objects can be sent safely from within an awakeFromNib method. Typically, you implement awakeFromNib for objects that require additional set up that cannot be done at design time. For example, you might use this method to customize the default configuration of any controls to match user preferences or the values in other controls. You might also use it to restore individual controls to some previous state of your application. 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1402907-awakefromnib
   */


  awakeFromNib() {}
  /**
   * 
   * @access public
   * @param {!QLPreviewPanel} panel - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1504204-beginpreviewpanelcontrol
   */


  beginPreviewPanelControl(panel) {}
  /**
   * Establishes a binding between a given property of the receiver and the property of a given object specified by a given key path.
   * @access public
   * @param {string} binding - The key path for a property of the receiver previously exposed using the exposeBinding(_:) method.
   * @param {Object} observable - 
   * @param {string} keyPath - A key path to a property reachable from observableController. The elements in the path must be key-value observing compliant (see Key-Value Observing Programming Guide).
   * @param {?Map<string, Object>} [options = null] - A dictionary containing options for the binding, such as placeholder objects or an NSValueTransformer identifier as described in Constants. This value is optional—pass nil to specify no options.
   * @returns {void}
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1458185-bind
   */


  bindToWithKeyPath(binding, observable, keyPath, options = null) {}
  /**
   * Returns an array of candidates.
   * @access public
   * @param {!Object} sender - The client object requesting the candidates.
   * @returns {!Object[]} - 
   * @desc An input method should look up its currently composed string and return a list of candidate strings that that string might map to.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1385360-candidates
   */


  candidates(sender) {
    return null;
  }
  /**
   * Implements custom help behavior for the modal panel.
   * @access public
   * @param {!SFCertificatePanel} sender - The certificate panel for which to implement custom help.
   * @returns {number} - 
   * @desc You can use this delegate method to implement custom help if you call the setShowsHelp: method to display a help button in the sheet or panel. If you are not implementing custom help, do not implement this method.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1514145-certificatepanelshowhelp
   */


  certificatePanelShowHelp(sender) {
    return 0;
  }
  /**
   * Sent to the first responder when the user selects a color in an NSColorPanel object.
   * @access public
   * @param {?Object} sender - The NSColorPanel sending the message.
   * @returns {void}
   * @desc When the user selects a color in an NSColorPanel object, the panel sends a changeColor(_:) action message to the first responder. You can override this method in any responder that needs to respond to a color change. 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1532638-changecolor
   */


  changeColor(sender) {}
  /**
   * Informs responders of a font change.
   * @access public
   * @param {?Object} sender - The object that sent the message.
   * @returns {void}
   * @desc Generally this change is because the user changed the font either in the selection of a rich text field or in a whole plain text field. Any object that contains a font the user can change must respond to the changeFont(_:) message by sending a convert(_:) message back to sender (an NSFontManager object) for each font in the selection. For more information, see Responding to Font Changes.Be aware that selectedFont at this point may return unpredictable results. The font in this property may not be the last font selected, or there may be multiple fonts selected at the time changeFont(_:) is called. The use of selectedFont from within changeFont(_:) is strongly discouraged.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1462311-changefont
   */


  changeFont(sender) {}
  /**
   * Implements custom help behavior for the modal panel.
   * @access public
   * @param {!SFChooseIdentityPanel} sender - The choose identity panel for which to implement custom help.
   * @returns {number} - 
   * @desc You can use this delegate method to implement custom help if you call the setShowsHelp: method to display a help button in the sheet or panel. If you are not implementing custom help, do not implement this method. 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1514140-chooseidentitypanelshowhelp
   */


  chooseIdentityPanelShowHelp(sender) {
    return 0;
  }
  /**
   * 
   * @deprecated
   * @access public
   * @param {Object} annotationClass - 
   * @returns {Object} - 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1436089-class
   */


  classForAnnotationClass(annotationClass) {
    return null;
  }
  /**
   * 
   * @deprecated
   * @access public
   * @returns {Object} - 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1436049-classforpage
   */


  classForPage() {
    return null;
  }
  /**
   * Uses type info from the class description and NSScriptCoercionHandler to attempt to convert value for key to the proper type, if necessary.
   * @access public
   * @param {?Object} value - 
   * @param {string} key - 
   * @returns {?Object} - 
   * @desc  The method coerceValueFor<Key>: is used if it exists.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1416527-coercevalue
   */


  coerceValueForKey(value, key) {
    return null;
  }
  /**
   * Informs the controller that the composition should be committed.
   * @access public
   * @param {!Object} sender - The client object requesting the input method to commit the composition.
   * @returns {void}
   * @desc If an input method implements this method, it is called when the client wants to end the composition session immediately. A typical response would be to call the insertText method of the client and then clean up any per-session buffers and variables. After receiving this message an input method should consider the given composition session finished.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1385539-commitcomposition
   */


  commitComposition(sender) {}
  /**
   * Returns whether the receiver was able to commit any pending edits.
   * @access public
   * @returns {boolean} - 
   * @desc A commit is denied if the receiver fails to apply the changes to the model object, perhaps due to a validation error.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1458190-commitediting
   */


  commitEditing() {
    return false;
  }
  /**
   * Attempt to commit pending edits, returning an error in the case of failure.
   * @access public
   * @returns {void}
   * @throws {Error}
   * @desc During autosaving, commit editing may fail, due to a pending edit. Rather than interrupt the user with an unexpected alert, this method provides the caller with the option to either present the error or fail silently, leaving the pending edit in place and the user's editing uninterrupted. In your implementation of this method, you should attempt to commit editing, but if there is a failure return false and in error an error object to be presented or ignored as appropriate. Handling Errors in Swift:
  In Swift, this method returns Void and is marked with the throws keyword to indicate that it throws an error in cases of failure.
  You call this method in a try expression and handle any errors in the catch clauses of a do statement, as described in Error Handling in The Swift Programming Language (Swift 3.1) and Error Handling in Using Swift with Cocoa and Objective-C (Swift 3.1).
    * @see https://developer.apple.com/documentation/objectivec/nsobject/1458181-commiteditingandreturnerror
   */


  commitEditingAndReturnError() {}
  /**
   * Attempt to commit any currently edited results of the receiver.
   * @access public
   * @param {?Object} delegate - 
   * @param {?function} didCommitSelector - 
   * @param {?Object} contextInfo - 
   * @returns {void}
   * @desc The receiver must have been registered as the editor of an object using objectDidBeginEditing:, and has not yet been unregistered by a subsequent invocation of objectDidEndEditing:. When the committing has either succeeded or failed, send the following message to the specified object. The didCommitSelector method must have the following method signature: - (void)editor:(id)editor didCommit:(BOOL)didCommit contextInfo:(void *)contextInfo
  If an error occurs while attempting to commit, for example if key-value coding validation fails, an implementation of this method should typically send the NSView in which editing is being done a presentError:modalForWindow:delegate:didRecoverSelector:contextInfo: message, specifying the view's containing window.- (void)editor:(id)editor didCommit:(BOOL)didCommit contextInfo:(void *)contextInfo
    * @see https://developer.apple.com/documentation/objectivec/nsobject/1458179-commitediting
   */


  commitEditingWithDelegateDidCommit(delegate, didCommitSelector, contextInfo) {}
  /**
   * Return the current composed string.
   * @access public
   * @param {!Object} sender - The client object requesting the string.
   * @returns {!Object} - 
   * @desc  A composed string refers to the buffer that an input method typically maintains to mirror the text contained in the active inline area. It is called the composed string to reflect the fact that the input method composed the string by converting the characters input by the user. In addition, using the term composed string makes it easier to differentiate between an input method  buffer and the text in the active inline area that the user sees. 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1385416-composedstring
   */


  composedString(sender) {
    return null;
  }
  /**
   * Called after an input parameter in the composition parameter view has been edited.
   * @access public
   * @param {!QCCompositionParameterView} parameterView - The composition parameter view in which the parameter changed.
   * @param {!string} portKey - A key for one of the composition parameters, which is provided to you by the Quartz Composer engine.
   * @returns {void}
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1505265-compositionparameterview
   */


  compositionParameterViewDidChangeParameterWithKey(parameterView, portKey) {}
  /**
   * Allows you to define which composition parameters are visible in the user interface when the composition parameter view refreshes.  
   * @access public
   * @param {!QCCompositionParameterView} parameterView - The composition parameter view in which the selection changed.
   * @param {!string} portKey - A key for one of the composition parameters, which is provided to you by the Quartz Composer engine.
   * @param {!Map<AnyHashable, Object>} [portAttributes = new Map()] - A dictionary of the attributes that you want to display in the user interface.
   * @returns {boolean} - 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1503523-compositionparameterview
   */


  compositionParameterViewShouldDisplayParameterWithKeyAttributes(parameterView, portKey, portAttributes = new Map()) {
    return false;
  }
  /**
   * Performs custom tasks when the selected composition in the composition picker view changes. 
   * @access public
   * @param {!QCCompositionPickerView} pickerView - The composition picker view in which the selection changed.
   * @param {!QCComposition} composition - The selected composition or nil if the previously selected composition is no longer selected.
   * @returns {void}
   * @desc Quartz Composer invokes this method when the selected composition in the composition picker view changes. Implement this method if you want to perform custom tasks at that time.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1447352-compositionpickerview
   */


  compositionPickerViewDidSelect(pickerView, composition) {}
  /**
   * Performs custom tasks when the composition picker view starts animating a composition.
   * @access public
   * @param {!QCCompositionPickerView} pickerView - The composition picker view in which the composition started animating.
   * @returns {void}
   * @desc Quartz Composer invokes  this method when  the composition picker view starts animating a composition. Implement this method if you want to perform custom tasks at that time.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1447342-compositionpickerviewdidstartani
   */


  compositionPickerViewDidStartAnimating(pickerView) {}
  /**
   * Performs custom tasks when the composition picker view stops animating a composition.
   * @access public
   * @param {!QCCompositionPickerView} pickerView - The composition picker view in which the composition stopped animating.
   * @returns {void}
   * @desc Quartz Composer invokes  this method whenever the composition picker view stops animating a composition. Implement this method if you want to perform custom tasks at that time.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1447348-compositionpickerviewwillstopani
   */


  compositionPickerViewWillStopAnimating(pickerView) {}
  /**
   * Sent when a control with editable text begins an editing session.
   * @access public
   * @param {Notification} obj - 
   * @returns {void}
   * @desc This method is invoked when the user begins editing text in a control such as a text field or a form field. The control posts a NSControlTextDidBeginEditing notification, and if the control’s delegate implements this method, it is automatically registered to receive the notification. Use the key @"NSFieldEditor" to obtain the field editor from the userInfo dictionary of the notification object.  See controlTextDidEndEditing(_:) for an explanation of why you may not always get one invocation of controlTextDidBeginEditing(_:) for each invocation of controlTextDidEndEditing(_:).
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1428934-controltextdidbeginediting
   */


  controlTextDidBeginEditing(obj) {}
  /**
   * Sent when the text in the receiving control changes. 
   * @access public
   * @param {Notification} obj - 
   * @returns {void}
   * @desc This method is invoked when text in a control such as a text field or form changes. The control posts a NSControlTextDidChange notification, and if the control’s delegate implements this method, it is automatically registered to receive the notification. Use the key @"NSFieldEditor" to obtain the field editor from the userInfo dictionary of the notification object.  
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1428982-controltextdidchange
   */


  controlTextDidChange(obj) {}
  /**
   * Sent when a control with editable text ends an editing session.
   * @access public
   * @param {Notification} obj - 
   * @returns {void}
   * @desc This method is invoked when the user stops editing text in a control such as a text field or form. The control posts a NSControlTextDidEndEditing notification, and if the control’s delegate implements this method, it is automatically registered to receive the notification. Use the key @"NSFieldEditor" to obtain the field editor from the userInfo dictionary of the notification object.  WarningIn some cases, such as when editing within an instance of NSOutlineView, this method may be invoked without a previous invocation of controlTextDidBeginEditing(_:). You will only get the controlTextDidBeginEditing: notification if the user actually types something, but you can get the controlTextDidEndEditing: notification if the user just double-clicks the field and then clicks outside the field, without typing.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1428847-controltextdidendediting
   */


  controlTextDidEndEditing(obj) {}
  /**
   * Processes a command  generated by user action such as typing certain keys or pressing the mouse button.
   * @access public
   * @param {!function} aSelector - The action associated with the key down event. The selector can be an action specified in the input method  dictionary of keys and actions (that is, an action specific to the input method) or one of the NSResponder action methods such as insertNewline: or deleteBackward:. By definition such action methods do not return a value.
   * @param {!Object} sender - The client object sending the key down event.
   * @returns {boolean} - 
   * @desc This method is called when the system binds a key down event to an action method. If you implement this method you should test if it is appropriate to call the action method before actually calling it, because calling the action method implies that you agree to handle the command. Suppose you have implemented a version of insertNewline:  that terminates the conversion session and sends the fully converted text to the client. However, if you conversion buffer is empty, you want the application to receive the return key that triggered the call to insertNewline:. In that case, when didCommandBySelector:client: is called you should test your buffer before calling your implementation of insertNewline:. If the buffer is empty, return false to indicate that the return key should be passed on to the application. If the buffer is not empty, call insertNewline: and then return true as the result of didCommandBySelector:client:.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1385394-didcommand
   */


  didCommandByClient(aSelector, sender) {
    return false;
  }
  /**
   * Called for every match found during a find operation.
   * @access public
   * @param {PDFSelection} instance - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1436046-didmatchstring
   */


  didMatchString(instance) {}
  /**
   * Causes the receiver to discard any changes, restoring the previous values.
   * @access public
   * @returns {void}
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1458076-discardediting
   */


  discardEditing() {}
  /**
   * Called when the PDFDocumentDidBeginFindNotification notification is posted. 
   * @access public
   * @param {Notification} notification - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1436080-documentdidbegindocumentfind
   */


  documentDidBeginDocumentFind(notification) {}
  /**
   * Called when the PDFDocumentDidBeginPageFindNotification notification is posted.
   * @access public
   * @param {Notification} notification - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1436094-documentdidbeginpagefind
   */


  documentDidBeginPageFind(notification) {}
  /**
   * Called when the PDFDocumentDidEndFindNotification notification is posted.
   * @access public
   * @param {Notification} notification - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1436068-documentdidenddocumentfind
   */


  documentDidEndDocumentFind(notification) {}
  /**
   * Called when the PDFDocumentDidEndPageFindNotification notification is posted. 
   * @access public
   * @param {Notification} notification - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1436064-documentdidendpagefind
   */


  documentDidEndPageFind(notification) {}
  /**
   * Called when the PDFDocumentDidFindMatchNotification notification is posted.
   * @access public
   * @param {Notification} notification - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1436044-documentdidfindmatch
   */


  documentDidFindMatch(notification) {}
  /**
   * Called when the PDFDocumentDidUnlockNotification notification is posted.
   * @access public
   * @param {Notification} notification - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1436029-documentdidunlock
   */


  documentDidUnlock(notification) {}
  /**
   * Returns a Boolean value that indicates whether the receiver contains a given object.
   * @access public
   * @param {Object} object - The object to search for in the receiver.
   * @returns {boolean} - 
   * @desc Currently, doesContain(_:) messages are never sent to any object from within Cocoa itself. The default implementation for this method provided by NSObject returns true if the receiver is actually an NSArray object and an indexOfObjectIdentical(to:) message sent to the same object would return something other than NSNotFound.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1393848-doescontain
   */


  doesContain(object) {
    return false;
  }
  /**
   * 
   * @access public
   * @param {!QLPreviewPanel} panel - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1505044-endpreviewpanelcontrol
   */


  endPreviewPanelControl(panel) {}
  /**
   * Implemented by the delegate to evaluate whether the delegating NSExceptionHandler instance should handle a given exception.
   * @access public
   * @param {!NSExceptionHandler} sender - The NSExceptionHandler object sending the message.
   * @param {!NSException} exception - An NSException object describing the exception to be evaluated.
   * @param {number} aMask - The bit mask indicating the types of exceptions handled by the NSExceptionHandler object. See Logging and Handling Constants and System Hang Constants for descriptions of the possible enum constants.
   * @returns {boolean} - 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1489854-exceptionhandler
   */


  exceptionHandlerShouldHandleMask(sender, exception, aMask) {
    return false;
  }
  /**
   * Implemented by the delegate to evaluate whether the delegating NSExceptionHandler instance should log a given exception.
   * @access public
   * @param {!NSExceptionHandler} sender - The NSExceptionHandler object sending the message.
   * @param {!NSException} exception - An NSException object describing the exception to be evaluated.
   * @param {number} aMask - The bit mask indicating the types of exceptions logged by the NSExceptionHandler object. See Logging and Handling Constants and System Hang Constants for descriptions of the possible enum constants.
   * @returns {boolean} - 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1489856-exceptionhandler
   */


  exceptionHandlerShouldLogExceptionMask(sender, exception, aMask) {
    return false;
  }
  /**
   * 
   * @access public
   * @param {!OBEXFileTransferServices} inServices - 
   * @param {OBEXError} inError - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1430046-filetransferservicesabortcomplet
   */


  fileTransferServicesAbortCompleteError(inServices, inError) {}
  /**
   * 
   * @access public
   * @param {!OBEXFileTransferServices} inServices - 
   * @param {OBEXError} inError - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1428872-filetransferservicesconnectionco
   */


  fileTransferServicesConnectionCompleteError(inServices, inError) {}
  /**
   * 
   * @access public
   * @param {!OBEXFileTransferServices} inServices - 
   * @param {OBEXError} inError - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1432094-filetransferservicescopyremotefi
   */


  fileTransferServicesCopyRemoteFileCompleteError(inServices, inError) {}
  /**
   * 
   * @access public
   * @param {!OBEXFileTransferServices} inServices - 
   * @param {!Map<AnyHashable, Object>} inProgressDescription - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1431422-filetransferservicescopyremotefi
   */


  fileTransferServicesCopyRemoteFileProgressTransferProgress(inServices, inProgressDescription) {}
  /**
   * 
   * @access public
   * @param {!OBEXFileTransferServices} inServices - 
   * @param {OBEXError} inError - 
   * @param {!string} inFolderName - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1430913-filetransferservicescreatefolder
   */


  fileTransferServicesCreateFolderCompleteErrorFolder(inServices, inError, inFolderName) {}
  /**
   * 
   * @access public
   * @param {!OBEXFileTransferServices} inServices - 
   * @param {OBEXError} inError - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1434806-filetransferservicesdisconnectio
   */


  fileTransferServicesDisconnectionCompleteError(inServices, inError) {}
  /**
   * 
   * @access public
   * @param {!OBEXFileTransferServices} inServices - 
   * @param {OBEXError} inError - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1432086-filetransferservicesfilepreparat
   */


  fileTransferServicesFilePreparationCompleteError(inServices, inError) {}
  /**
   * 
   * @access public
   * @param {!OBEXFileTransferServices} inServices - 
   * @param {OBEXError} inError - 
   * @param {!string} inPath - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1432583-filetransferservicespathchangeco
   */


  fileTransferServicesPathChangeCompleteErrorFinalPath(inServices, inError, inPath) {}
  /**
   * 
   * @access public
   * @param {!OBEXFileTransferServices} inServices - 
   * @param {OBEXError} inError - 
   * @param {!string} inItemName - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1434702-filetransferservicesremoveitemco
   */


  fileTransferServicesRemoveItemCompleteErrorRemovedItem(inServices, inError, inItemName) {}
  /**
   * 
   * @access public
   * @param {!OBEXFileTransferServices} inServices - 
   * @param {OBEXError} inError - 
   * @param {!Object[]} inListing - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1434777-filetransferservicesretrievefold
   */


  fileTransferServicesRetrieveFolderListingCompleteErrorListing(inServices, inError, inListing) {}
  /**
   * 
   * @access public
   * @param {!OBEXFileTransferServices} inServices - 
   * @param {OBEXError} inError - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1434240-filetransferservicessendfilecomp
   */


  fileTransferServicesSendFileCompleteError(inServices, inError) {}
  /**
   * 
   * @access public
   * @param {!OBEXFileTransferServices} inServices - 
   * @param {!Map<AnyHashable, Object>} inProgressDescription - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1430365-filetransferservicessendfileprog
   */


  fileTransferServicesSendFileProgressTransferProgress(inServices, inProgressDescription) {}
  /**
   * Performs cleanup when the scripting environment is reset.
   * @access public
   * @returns {void}
   * @desc This method is invoked on objects exposed to the scripting environment just before the scripting environment is reset. After invocation, the receiving object will no longer be referenced by the scripting environment. Further references to WebScriptObject instances created by the exposed object will be invalid and may produce unpredictable results.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1528546-finalizeforwebscript
   */


  finalizeForWebScript() {}
  /**
   * Requests permission from the Font panel delegate to display the given font name in the Font panel.
   * @deprecated
   * @access public
   * @param {Object} sender - 
   * @param {string} fontName - The full PostScript name of the font to display, such as Helvetica-BoldOblique or Helvetica-Narrow-Bold.
   * @returns {boolean} - 
   * @desc In macOS versions 10.2 and earlier, this method is invoked repeatedly as necessary whenever the Font panel needs updating, such as when the Font panel is first loaded, and when the user selects a family name to see which typefaces in that family are available. Your implementation should execute fairly quickly to ensure the responsiveness of the Font panel.Important
  This delegate method is not called in macOS versions 10.3 and later.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1462359-fontmanager
   */


  fontManagerWillIncludeFont(sender, fontName) {
    return false;
  }
  /**
   * Handles key down and mouse events.
   * @access public
   * @param {!NSEvent} event - The event to handle.
   * @param {!Object} sender - The client object sending the event.
   * @returns {boolean} - 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1385363-handle
   */


  handleClient(event, sender) {
    return false;
  }
  /**
   * Performs custom tasks when the user right-clicks the image browser view background.
   * @access public
   * @param {!IKImageBrowserView} aBrowser - An image browser view.
   * @param {!NSEvent} event - The event that invoked the method.
   * @returns {void}
   * @desc This method signals  that the user either right-clicked the background or left-clicked it with the Alt key pressed. You can implement this method if you want to perform custom tasks at that time.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1503526-imagebrowser
   */


  imageBrowserBackgroundWasRightClickedWith(aBrowser, event) {}
  /**
   * Performs custom tasks when the user double-clicks an item in the image browser view.
   * @access public
   * @param {!IKImageBrowserView} aBrowser - An image browser view.
   * @param {number} index - The index of the cell.
   * @returns {void}
   * @desc This method signals that the user double-clicked an item in the image browser view. You can implement this method if you want to perform custom tasks at that time.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1504701-imagebrowser
   */


  imageBrowserCellWasDoubleClickedAt(aBrowser, index) {}
  /**
   * Performs custom tasks when the user right-clicks an item in the image browser view. 
   * @access public
   * @param {!IKImageBrowserView} aBrowser - An image browser view.
   * @param {number} index - The index of the cell.
   * @param {!NSEvent} event - The event that invoked the method.
   * @returns {void}
   * @desc This method signals that the user either right-clicked an item in the browser or left-clicked the item with the Alt key pressed. You can implement this method if you want to perform custom tasks at that time.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1503802-imagebrowser
   */


  imageBrowserCellWasRightClickedAtWith(aBrowser, index, event) {}
  /**
   * Returns the group at the specified index.
   * @access public
   * @param {!IKImageBrowserView} aBrowser - An image browser view.
   * @param {number} index - The index of the group you want to retrieve.
   * @returns {!Map<AnyHashable, Object>} - 
   * @desc This method is optional.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1503488-imagebrowser
   */


  imageBrowserGroupAt(aBrowser, index) {
    return null;
  }
  /**
   * Returns an object for the item in an image browser view that corresponds to the specified index.
   * @access public
   * @param {!IKImageBrowserView} aBrowser - An image browser view.
   * @param {number} index - The index of the item you want to retrieve.
   * @returns {!Object} - 
   * @desc Your data source must implement this method. The returned object must implement the required methods of the IKImageBrowserItem protocol. 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1504064-imagebrowser
   */


  imageBrowserItemAt(aBrowser, index) {
    return null;
  }
  /**
   * Signals that the specified items should be moved to the specified destination. 
   * @access public
   * @param {!IKImageBrowserView} aBrowser - An image browser view.
   * @param {!Set} indexes - The indexes of the items that should be reordered.
   * @param {number} destinationIndex - The starting index of the destination the items should be moved to.
   * @returns {boolean} - 
   * @desc This method is optional. It is invoked by the image browser view after  Image Kit determines  that a reordering operation should be applied. The data source should update itself by reordering its elements. 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1503616-imagebrowser
   */


  imageBrowserMoveItemsAtTo(aBrowser, indexes, destinationIndex) {
    return false;
  }
  /**
   * Signals that a remove operation should be applied to the specified items.
   * @access public
   * @param {!IKImageBrowserView} aBrowser - An image browser view.
   * @param {!Set} indexes - The indexes of the items that should be removed.
   * @returns {void}
   * @desc This method is optional. It is invoked by the image browser after  Image Kit determines  that a remove operation should be applied. In response, the data source should update itself by removing the specified items.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1503834-imagebrowser
   */


  imageBrowserRemoveItemsAt(aBrowser, indexes) {}
  /**
   * Signals that a drag should begin.
   * @access public
   * @param {!IKImageBrowserView} aBrowser - An image browser view.
   * @param {!Set} itemIndexes - The indexes of the items that should be dragged.
   * @param {!NSPasteboard} pasteboard - The pasteboard to copy the items to.
   * @returns {number} - 
   * @desc This method is optional. It is invoked after Image Kit determines that a drag should begin, but before the drag has been started. 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1504208-imagebrowser
   */


  imageBrowserWriteItemsAtTo(aBrowser, itemIndexes, pasteboard) {
    return 0;
  }
  /**
   * Performs custom tasks when the selection changes.
   * @access public
   * @param {!IKImageBrowserView} aBrowser - An image browser view.
   * @returns {void}
   * @desc This method signals that the user changes the selection in the image browser view. You can implement this method if you want to perform custom tasks at that time.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1503765-imagebrowserselectiondidchange
   */


  imageBrowserSelectionDidChange(aBrowser) {}
  /**
   * Returns the image to display.
   * @access public
   * @returns {!Object} - 
   * @desc Your data source must implement this method. This method  is called frequently, so the receiver should cache the returned instance.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1504801-imagerepresentation
   */


  imageRepresentation() {
    return null;
  }
  /**
   * Returns the representation type of the image to display.
   * @access public
   * @returns {!string} - 
   * @desc Your data source must implement this method.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1503547-imagerepresentationtype
   */


  imageRepresentationType() {
    return null;
  }
  /**
   *  Returns the display subtitle of the image.
   * @access public
   * @returns {!string} - 
   * @desc This method is optional.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1503725-imagesubtitle
   */


  imageSubtitle() {
    return null;
  }
  /**
   * Returns the display title of the image. 
   * @access public
   * @returns {!string} - 
   * @desc This method is optional.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1504080-imagetitle
   */


  imageTitle() {
    return null;
  }
  /**
   * Returns a unique string that identifies the data source item.
   * @access public
   * @returns {!string} - 
   * @desc Your data source must implement this method. The image browser view uses this identifier to associate the data source item and  its cache.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1503516-imageuid
   */


  imageUID() {
    return null;
  }
  /**
   * Returns the version of the item. 
   * @access public
   * @returns {number} - 
   * @desc This method is optional. The receiver can return a new version to let the image browser know that it should not use its cache for the item.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1504444-imageversion
   */


  imageVersion() {
    return 0;
  }
  /**
   * Returns the indices of the specified container objects.
   * @access public
   * @param {NSScriptObjectSpecifier} specifier - An object specifier for the container objects for which to obtain the indices.
   * @returns {?number[]} - 
   * @desc  Containers that want to evaluate some specifiers on their own should implement this method. If this method returns nil, the object specifier will go on to do its own evaluation, so you should only return nil if that's the behavior you want, or if an error occurs. If this method returns an array, the object specifier will use the NSNumber objects in it as the indices. So, if you evaluate the specifier and there are no objects that match, you should return an empty array, not nil. If you find only one object, you should still return its index in an array. Returning an array with a single index where the index is – is interpreted to mean all the objects.For an example implementation, see "Implementing Object Specifiers" in Object Specifiers in Cocoa Scripting Guide
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1417806-indicesofobjects
   */


  indicesOfObjectsByEvaluatingObjectSpecifier(specifier) {
    return null;
  }
  /**
   * Returns a dictionary describing the receiver’s binding.
   * @access public
   * @param {string} binding - The name of a binding.
   * @returns {?Map<string, Object>} - 
   * @desc This method is mostly for use by subclasses which want to analyze the existing bindings of an object.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1458122-infoforbinding
   */


  infoForBinding(binding) {
    return null;
  }
  /**
   * Handles key down events that do not map to an action method.
   * @access public
   * @param {!string} string - The key down event, which is the text input by the client.
   * @param {!Object} sender - The client object sending the key down events.
   * @returns {boolean} - 
   * @desc An input method should implement this method when using key binding (that is, it implements didCommand(by:client:)).
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1385446-inputtext
   */


  inputTextClient(string, sender) {
    return false;
  }
  /**
   * Receives Unicode, the key code that generated it, and any modifier flags.
   * @access public
   * @param {!string} string - The text input by the client.
   * @param {number} keyCode - The key code for the associated Unicode.
   * @param {number} flags - The modifier flags.
   * @param {!Object} sender - The client object.
   * @returns {boolean} - 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1385436-inputtext
   */


  inputTextKeyModifiersClient(string, keyCode, flags, sender) {
    return false;
  }
  /**
   * Inserts an object at the specified index in the collection specified by the passed key.
   * @access public
   * @param {Object} value - 
   * @param {number} index - 
   * @param {string} key - 
   * @returns {void}
   * @desc  The method insertIn<Key>:atIndex: is invoked if it exists. If no corresponding scripting-KVC-compliant method (insertIn<Key>:atIndex: ) is found, this method invokes mutableArrayValueForKey: and mutates the result.Note Prior to OS X version 10.4, this method did not invoke -mutableArrayValueForKey:.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1417619-insertvalue
   */


  insertValueAtInPropertyWithKey(value, index, key) {}
  /**
   * Inserts an object in the collection specified by the passed key.
   * @access public
   * @param {Object} value - 
   * @param {string} key - 
   * @returns {void}
   * @desc  The method insertIn<Key>: is used if it exists. Otherwise, raises an NSUndefinedKeyException. This is part of Cocoa’s scripting support for inserting newly-created objects into containers without explicitly specifying a location.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1416203-insertvalue
   */


  insertValueInPropertyWithKey(value, key) {}
  /**
   * Executes when a script attempts to invoke a method on an exposed object directly.
   * @access public
   * @param {!Object[]} _arguments - 
   * @returns {!Object} - 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1528543-invokedefaultmethod
   */


  invokeDefaultMethodWithArguments(_arguments) {
    return null;
  }
  /**
   * Handles undefined method invocation from the scripting environment.
   * @access public
   * @param {!string} name - The name of the undefined method.
   * @param {!Object[]} _arguments - 
   * @returns {!Object} - 
   * @desc This method is invoked when a script attempts to invoke a method not directly exported to the scripting environment. You should return the result of the invocation, converted appropriately for the scripting environment.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1528562-invokeundefinedmethod
   */


  invokeUndefinedMethodFromWebScriptWithArguments(name, _arguments) {
    return null;
  }
  /**
   * Returns a Boolean value that indicates whether receiver is considered to be “like” a given string when the case of characters in the receiver is ignored.
   * @access public
   * @param {string} object - 
   * @returns {boolean} - 
   * @desc Currently, isCaseInsensitiveLike(_:) messages are never sent to any object from within Cocoa itself.The default implementation for this method provided by NSObject returns false. NSString also provides an implementation of this method, which returns true if the receiver matches a pattern described by aString, ignoring the case of the characters in the receiver.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1393837-iscaseinsensitivelike
   */


  isCaseInsensitiveLike(object) {
    return false;
  }
  /**
   * Returns a Boolean value that indicates whether the receiver is equal to another given object.
   * @access public
   * @param {?Object} object - The object with which to compare the receiver.
   * @returns {boolean} - 
   * @desc During the evaluation of an NSWhoseSpecifier object that contains a test whose operator is NSEqualToComparison, an isEqual(to:) message may be sent to each potentially specified object, if neither the potentially specified object nor the object being tested against implements a scriptingIsEqual(to:) method.The default implementation for this method provided by NSObject returns true if an isEqualTo: message sent to the same object would return true.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1393823-isequal
   */


  isEqualTo(object) {
    return false;
  }
  /**
   * Returns a Boolean value that indicates whether the receiver is greater than another given object.
   * @access public
   * @param {?Object} object - The object with which to compare the receiver.
   * @returns {boolean} - 
   * @desc During the evaluation of an NSWhoseSpecifier object that contains a test whose operator is NSGreaterThanComparison, an isGreaterThan(_:) message may be sent to each potentially specified object, if the potentially specified object does not implement a scriptingIsGreaterThan(_:) method and the object being tested against does not implement a scriptingIsLessThanOrEqual(to:) method.The default implementation for this method provided by NSObject returns true if a compare: message sent to the same object would return NSOrderedDescending.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1393885-isgreaterthan
   */


  isGreaterThan(object) {
    return false;
  }
  /**
   * Returns a Boolean value that indicates whether the receiver is greater than or equal to another given object.
   * @access public
   * @param {?Object} object - The object with which to compare the receiver.
   * @returns {boolean} - 
   * @desc During the evaluation of an NSWhoseSpecifier object that contains a test whose operator is NSGreaterThanOrEqualToComparison, anisGreaterThanOrEqual(to:) message may be sent to each potentially specified object, if the potentially specified object does not implement a scriptingIsGreaterThanOrEqual(to:) method and the object being tested against does not implement a scriptingIsLessThan(_:) method.The default implementation for this method provided by NSObject returns true if a compare: message sent to the same object would return NSOrderedSame or NSOrderedDescending.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1393862-isgreaterthanorequal
   */


  isGreaterThanOrEqualTo(object) {
    return false;
  }
  /**
   * Returns a Boolean value that indicates whether the receiver is less than another given object.
   * @access public
   * @param {?Object} object - The object with which to compare the receiver.
   * @returns {boolean} - 
   * @desc During the evaluation of an NSWhoseSpecifier object that contains a test whose operator is NSLessThanComparison, an isLessThan(_:) message may be sent to each potentially specified object, if the potentially specified object does not implement a scriptingIsLessThan(_:) method and the object being tested against does not implement a scriptingIsGreaterThanOrEqual(to:) method.The default implementation for this method provided by NSObject method returns true if a compare: message sent to the same object would return NSOrderedAscending.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1393841-islessthan
   */


  isLessThan(object) {
    return false;
  }
  /**
   * Returns a Boolean value that indicates whether the receiver is less than or equal to another given object. 
   * @access public
   * @param {?Object} object - The object with which to compare the receiver.
   * @returns {boolean} - 
   * @desc During the evaluation of an NSWhoseSpecifier object that contains a test whose operator is NSLessThanOrEqualToComparison, an isLessThanOrEqual(to:) message may be sent to each potentially specified object, if the potentially specified object does not implement a scriptingIsLessThanOrEqual(to:) method and the object being tested against does not implement a scriptingIsGreaterThan(_:) method.The default implementation for this method provided by NSObject method returns true if a compare: message sent to the same object would return NSOrderedAscending or NSOrderedSame.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1393827-islessthanorequal
   */


  isLessThanOrEqualTo(object) {
    return false;
  }
  /**
   * Returns a Boolean value that indicates whether the receiver is "like" another given object.
   * @access public
   * @param {string} object - The object with which to compare the receiver.
   * @returns {boolean} - 
   * @desc Currently, isLike(_:) messages are never sent to any object from within Cocoa itself.The default implementation for this method provided by NSObject method returns false. NSString also provides an implementation of this method, which returns true if the receiver matches a pattern described by object.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1393866-islike
   */


  isLike(object) {
    return false;
  }
  /**
   * Returns a Boolean value that indicates whether the receiver is not equal to another given object.
   * @access public
   * @param {?Object} object - The object with which to compare the receiver.
   * @returns {boolean} - 
   * @desc Currently, isNotEqual(to:) messages are never sent to any object from within Cocoa itself.The default implementation for this method provided by NSObject method returns true if an isEqual: message sent to the same object would return false.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1393843-isnotequal
   */


  isNotEqualTo(object) {
    return false;
  }
  /**
   * Invoked when a resolution changes occurs for the window that hosts the layer.
   * @access public
   * @param {CALayer} layer - The layer whose scale and content might need updating.
   * @param {number} newScale - The new scale of the window. 
   * @param {NSWindow} window - The window that hosts the layer.
   * @returns {boolean} - 
   * @desc When a resolution change occurs for a given window, the system traverses the layer trees in that window to decide what action, if any, to take for each layer. The system queries the layer’s delegate to determine whether to change the layer’s contentsScale property to the new scale (either 2.0 or 1.0). Note that you don’t need to manage NSImage contents and that this method is not called on the delegate of a layer whose content is an NSImage object.If the delegate returns true, it should make any corresponding changes to the layer’s properties, as required by the resolution change. For example, a layer whose contents contain a CGImage object needs to determine whether an alternate CGImage object is available for the new scale factor. If the delegate finds a suitable CGImage object, then in addition to returning true, it should set the appropriate CGImage object as the layer’s new contents.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1483574-layer
   */


  layerShouldInheritContentsScaleFrom(layer, newScale, window) {
    return false;
  }
  /**
   * Returns the names of the files that the receiver promises to create at a specified location.
   * @deprecated
   * @access public
   * @param {string} dropDestination - A URL object that identifies the location at which the promised files will be created.
   * @returns {?string[]} - 
   * @desc This method is invoked when the drop has been accepted by the destination and the destination, in the case of another Cocoa application, invokes the NSDraggingInfo method namesOfPromisedFilesDropped(atDestination:). For long operations, you can cache dropDestination and defer the creation of the files until the draggedImage:endedAt:operation: method to avoid blocking the destination application.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1416082-namesofpromisedfilesdropped
   */


  namesOfPromisedFilesDroppedAtDestination(dropDestination) {
    return null;
  }
  /**
   * Returns the number of groups in an image browser view.
   * @access public
   * @param {!IKImageBrowserView} aBrowser - An image browser view.
   * @returns {number} - 
   * @desc This method is optional.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1503514-numberofgroups
   */


  numberOfGroupsInImageBrowser(aBrowser) {
    return 0;
  }
  /**
   * Returns the number of records managed by the data source object.
   * @access public
   * @param {!IKImageBrowserView} aBrowser - An image browser view.
   * @returns {number} - 
   * @desc Your data source must implement this method. An  IKImageView object uses this method to determine how many cells it should create and display.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1503497-numberofitems
   */


  numberOfItemsInImageBrowser(aBrowser) {
    return 0;
  }
  /**
   * This message should be sent to the receiver when editor has uncommitted changes that can affect the receiver.
   * @access public
   * @param {Object} editor - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1458092-objectdidbeginediting
   */


  objectDidBeginEditing(editor) {}
  /**
   * This message should be sent to the receiver when editor has finished editing a property belonging to the receiver.
   * @access public
   * @param {Object} editor - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1458187-objectdidendediting
   */


  objectDidEndEditing(editor) {}
  /**
   * Returns an array describing the options for the specified binding.
   * @access public
   * @param {string} binding - The name of a binding
   * @returns {NSAttributeDescription[]} - 
   * @desc The NSAttributeDescription instances in the array are used by Interface Builder to build the options editor user interface of the bindings inspector.The option name displayed for the option in the bindings inspector is based on the value of the NSAttributeDescription method name. The type of editor displayed for the option in the bindings inspector is based on the value of the  NSAttributeDescription method attributeType.The default value displayed in the bindings inspector for the option is based on the value of the NSAttributeDescription method defaultValue.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1458174-optiondescriptionsforbinding
   */


  optionDescriptionsForBinding(binding) {
    return null;
  }
  /**
   * Return the a string that consists of the precomposed unicode characters.
   * @access public
   * @param {!Object} sender - The client object requesting the original string.
   * @returns {!string} - 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1385400-originalstring
   */


  originalString(sender) {
    return null;
  }
  /**
   * Implemented by an owner object to provide promised data.
   * @access public
   * @param {NSPasteboard} sender - The pasteboard that requires the specified data for a paste operation.
   * @param {string} type - The type of data the owner object must provide.
   * @returns {void}
   * @desc The receiver should have been previously declared in a declareTypes(_:owner:) message.The requested data should be written to sender using the setData(_:forType:), setPropertyList(_:forType:), or setString(_:forType:) method. The pasteboard(_:provideDataForType:) messages may also be sent to the owner when the application is shut down through an application’s terminate(_:) method. This is the method that is invoked in response to a Quit command. Thus the user can copy something to the pasteboard, quit the application, and still paste the data that was copied. A pasteboard(_:provideDataForType:) message is sent only if the specified type of data has not already been supplied to the pasteboard. Instead of writing all data types when the cut or copy operation is done, an application can choose to implement this method to provide the data for certain types only when they are requested.If an application writes data to the pasteboard in the richest, and therefore most preferred, type at the time of a cut or copy operation, its pasteboard(_:provideDataForType:) method can simply read that data from the pasteboard, convert it to the requested type, and write it back to the pasteboard as the new type.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1525907-pasteboard
   */


  pasteboardProvideDataForType(sender, type) {}
  /**
   * Notifies a prior owner of the specified pasteboard (and owners of representations on the pasteboard) that the pasteboard has changed owners.
   * @access public
   * @param {NSPasteboard} sender - The pasteboard object whose owner changed.
   * @returns {void}
   * @desc Pasteboard owners only need to implement this method if they need to know when they have lost ownership.The owner is not able to read the contents of the pasteboard when responding to this method. The owner should be prepared to receive this method at any time, even from within the declareTypes(_:owner:) method used to declare ownership.Once an owner has provided all of its data for declared types, it will not receive a pasteboardChangedOwner: message. If, therefore, you are maintaining an object just for the purpose of providing data lazily, rather than relying solely on receipt of a pasteboardChangedOwner: message you need to keep track of what types were promised and what types have been provided. When all the types have been provided, you may release the owner.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1532824-pasteboardchangedowner
   */


  pasteboardChangedOwner(sender) {}
  /**
   * Sent to the delegate to perform the action.
   * @access public
   * @param {!ABPerson} person - The person on which the action will be taken.
   * @param {!string} identifier - The unique identifier of the selected value.
   * @returns {void}
   * @desc If the property returned by actionProperty() is a multivalue property, identifier contains the unique identifier of the value selected. The person being displayed in the Address Book application’s card view when the rollover menu is accesses is passed as person.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1411298-performaction
   */


  performActionFor(person, identifier) {}
  /**
   * Called when a designable object is created in Interface Builder.
   * @access public
   * @returns {void}
   * @desc When Interface Builder instantiates a class with the IB_DESIGNABLE attribute, it calls this method to let the resulting object know that it was created at design time. You can implement this method in your designable classes and use it to configure their design-time appearance. For example, you might use the method to configure a custom text control with a default string. The system does not call this method; only Interface Builder calls it.Interface Builder waits until all objects in a graph have been created and initialized before calling this method. So if your object’s runtime configuration relies on subviews or parent views, those objects should exist by the time this method is called.Your implementation of this method must call super at some point so that parent classes can perform their own custom setup.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1402908-prepareforinterfacebuilder
   */


  prepareForInterfaceBuilder() {}
  /**
   * Supplies data to a CIImage object.
   * @access public
   * @param {Object} data - A pointer to image data. Note that data[0] refers to the first byte of the requested subimage, not the larger image buffer.
   * @param {number} rowbytes - The number of bytes per row.
   * @param {number} x - The x origin of the image data.
   * @param {number} y - The y origin of the image data.
   * @param {number} width - The width of the image data.
   * @param {number} height - The height of the image data.
   * @param {?Object} info - User supplied data, which is optional.
   * @returns {void}
   * @desc  You can supply the image provider to these methods of the CIImage class: imageWithImageProvider:size::format:colorSpace:options: to create a CIImage object from image datainit(imageProvider:size:_:format:colorSpace:options:) to initialize an existing CIImage with dataYou initialize the given bitmap with the subregion specified by the arguments x, y, width, and height. The subregion uses the local coordinate space of the image, with the origin at the upper-left corner of the image. If you change the virtual memory mapping of the buffer specified by the data argument (such as by using vm_copy to modify it), the behavior is undefined.That this callback always requests the full image data regardless of what is actually visible. All of the image is loaded or none of it is. The exception is when you create a tiled image by specifying the kCIImageProviderTileSize option. In this case, only the needed tiles are requested.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1438175-provideimagedata
   */


  provideImageDataBytesPerRowOriginSizeUserInfo(data, rowbytes, x, y, width, height, info) {}
  /**
   * 
   * @access public
   * @param {!QuartzFilterManager} sender - 
   * @param {!QuartzFilter} filter - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1504951-quartzfiltermanager
   */


  quartzFilterManagerDidAdd(sender, filter) {}
  /**
   * 
   * @access public
   * @param {!QuartzFilterManager} sender - 
   * @param {!QuartzFilter} filter - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1503494-quartzfiltermanager
   */


  quartzFilterManagerDidModifyFilter(sender, filter) {}
  /**
   * 
   * @access public
   * @param {!QuartzFilterManager} sender - 
   * @param {!QuartzFilter} filter - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1503483-quartzfiltermanager
   */


  quartzFilterManagerDidRemove(sender, filter) {}
  /**
   * 
   * @access public
   * @param {!QuartzFilterManager} sender - 
   * @param {!QuartzFilter} filter - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1503484-quartzfiltermanager
   */


  quartzFilterManagerDidSelect(sender, filter) {}
  /**
   * 
   * @access public
   * @param {!Object} controller - 
   * @param {!IOBluetoothDevice} device - 
   * @param {!UnsafeMutablePointer<BluetoothHCILinkQualityInfo>} info - 
   * @param {IOReturn} error - 
   * @returns {void}
   * @desc This delegate gets invoked when an read link quality command complete event occurs. This could occur because you invoked it by issuing an -readLinkQualityForDevice: command, or someone else did from another app on the same controller.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1430075-readlinkquality
   */


  readLinkQualityForDeviceComplete(controller, device, info, error) {}
  /**
   * 
   * @access public
   * @param {!Object} controller - 
   * @param {!IOBluetoothDevice} device - 
   * @param {!UnsafeMutablePointer<BluetoothHCIRSSIInfo>} info - 
   * @param {IOReturn} error - 
   * @returns {void}
   * @desc This delegate gets invoked when an RSSI command complete event occurs. This could occur because you invoked it by issuing an -readRSSIForDevice: command, or someone else did from another app on the same controller.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1428399-readrssi
   */


  readRSSIForDeviceComplete(controller, device, info, error) {}
  /**
   * Removes the object at the specified index from the collection specified by the passed key.
   * @access public
   * @param {number} index - 
   * @param {string} key - 
   * @returns {void}
   * @desc  The method removeFrom<Key>AtIndex: is invoked if it exists. If no corresponding scripting-KVC-compliant method (-removeFrom<Key>AtIndex:) is found, this method invokes -mutableArrayValueForKey: and mutates the result.Note Prior to OS X version 10.4, this method did not invoke -mutableArrayValueForKey:.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1408773-removevalue
   */


  removeValueAtFromPropertyWithKey(index, key) {}
  /**
   * Replaces the object at the specified index in the collection specified by the passed key.
   * @access public
   * @param {number} index - 
   * @param {string} key - 
   * @param {Object} value - 
   * @returns {void}
   * @desc  The method replaceIn<Key>:atIndex: is invoked if it exists. If no corresponding scripting-KVC-compliant method (-replaceIn<Key>atIndex:) is found, this method invokes -mutableArrayValueForKey: and mutates the result.Note Prior to OS X version 10.4, this method did not invoke -mutableArrayValueForKey:.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1411225-replacevalue
   */


  replaceValueAtInPropertyWithKeyWithValue(index, key, value) {}
  /**
   * Called to determine if the specified uniform type identifier should be shown in the save panel.
   * @access public
   * @param {!IKSaveOptions} saveOptions - The IKSaveOptions instance that called the delegate.
   * @param {!string} utType - The uniform type identifier to test.
   * @returns {boolean} - 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1503501-saveoptions
   */


  saveOptionsShouldShowUTType(saveOptions, utType) {
    return false;
  }
  /**
   * Returns true if, in a scripting comparison, the compared object matches the beginning of object. A default implementation is provided for NSString and NSAttributedString.
   * @access public
   * @param {Object} object - 
   * @returns {boolean} - 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1393858-scriptingbegins
   */


  scriptingBeginsWith(object) {
    return false;
  }
  /**
   * Returns true if, in a scripting comparison, the compared object contains object. A default implementation is provided for NSString and NSAttributedString.
   * @access public
   * @param {Object} object - 
   * @returns {boolean} - 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1393821-scriptingcontains
   */


  scriptingContains(object) {
    return false;
  }
  /**
   * Returns true if, in a scripting comparison, the compared object matches the end of object. A default implementation is provided for NSString and NSAttributedString.
   * @access public
   * @param {Object} object - 
   * @returns {boolean} - 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1393819-scriptingends
   */


  scriptingEndsWith(object) {
    return false;
  }
  /**
   * Returns true if, in a scripting comparison, the compared object is equal to object. A default implementation is provided for NSString and NSAttributedString.
   * @access public
   * @param {Object} object - 
   * @returns {boolean} - 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1393835-scriptingisequal
   */


  scriptingIsEqualTo(object) {
    return false;
  }
  /**
   * Returns true if, in a scripting comparison, the compared object is greater than object. A default implementation is provided for NSString and NSAttributedString.
   * @access public
   * @param {Object} object - 
   * @returns {boolean} - 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1393831-scriptingisgreaterthan
   */


  scriptingIsGreaterThan(object) {
    return false;
  }
  /**
   * Returns true if, in a scripting comparison, the compared object is greater than or equal to object. A default implementation is provided for NSString and NSAttributedString.
   * @access public
   * @param {Object} object - 
   * @returns {boolean} - 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1393829-scriptingisgreaterthanorequal
   */


  scriptingIsGreaterThanOrEqualTo(object) {
    return false;
  }
  /**
   * Returns true if, in a scripting comparison, the compared object is less than object. A default implementation is provided for NSString and NSAttributedString.
   * @access public
   * @param {Object} object - 
   * @returns {boolean} - 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1393887-scriptingislessthan
   */


  scriptingIsLessThan(object) {
    return false;
  }
  /**
   * Returns true if, in a scripting comparison, the compared object is less than or equal to object. A default implementation is provided for NSString and NSAttributedString.
   * @access public
   * @param {Object} object - 
   * @returns {boolean} - 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1393825-scriptingislessthanorequal
   */


  scriptingIsLessThanOrEqualTo(object) {
    return false;
  }
  /**
   * Sent to the delegate to determine whether the action should be enabled.
   * @access public
   * @param {!ABPerson} person - The person on which the action will be taken.
   * @param {!string} identifier - The unique identifier of the selected value.
   * @returns {boolean} - 
   * @desc If the property returned by actionProperty() is a multivalue property, identifier contains the unique identifier of the value selected.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1411300-shouldenableaction
   */


  shouldEnableActionFor(person, identifier) {
    return false;
  }
  /**
   * 
   * @deprecated
   * @access public
   * @param {Notification} notification - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1532645-textstoragedidprocessediting
   */


  textStorageDidProcessEditing(notification) {}
  /**
   * 
   * @deprecated
   * @access public
   * @param {Notification} notification - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1533957-textstoragewillprocessediting
   */


  textStorageWillProcessEditing(notification) {}
  /**
   * Sent to the delegate to request the title of the menu item for the action.
   * @access public
   * @param {!ABPerson} person - The person on which the action will be taken.
   * @param {!string} identifier - The unique identifier of the value for which the menu item will be displayed.
   * @returns {!string} - 
   * @desc If the property returned by actionProperty() is a multivalue property, identifier contains the unique identifier of the value selected.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1411304-title
   */


  titleFor(person, identifier) {
    return null;
  }
  /**
   * Removes a given binding between the receiver and a controller.
   * @access public
   * @param {string} binding - The name of a binding.
   * @returns {void}
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1458088-unbind
   */


  unbind(binding) {}
  /**
   * Returns the mode mask corresponding to the expected font panel mode.
   * @access public
   * @param {NSFontPanel} fontPanel - 
   * @returns {number} - 
   * @desc The mode masks are defined in Mode Masks. The Font Panel has the ability to hide elements that are not applicable for a given context by having the target respond to validModesForFontPanel(_:). If the target desires a font panel mode other than the standard mode mask, it must respond to this method.This message is sent up the responder chain to the first responder implementing the method. Ideally that object should be the first responder found that also implements changeFont(_:).
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1534415-validmodesforfontpanel
   */


  validModesForFontPanel(fontPanel) {
    return 0;
  }
  /**
   * Implemented to override the default action of enabling or disabling a specific menu item.
   * @access public
   * @param {NSMenuItem} menuItem - An NSMenuItem object that represents the menu item.
   * @returns {boolean} - 
   * @desc The object implementing this method must be the target of menuItem. You can determine which menu item menuItem is by querying it for its tag or action. The following example disables the menu item associated with the nextRecord action method when the selected line in a table view is the last one; conversely, it disables the menu item with priorRecord as its action method when the selected row is the first one in the table view. (The countryKeys array contains names that appear in the table view.)- (BOOL)validateMenuItem:(NSMenuItem *)item {
    int row = [tableView selectedRow];
    if ([item action] == @selector(nextRecord) &&
        (row == [countryKeys indexOfObject:[countryKeys lastObject]])) {
        return NO;
    }
    if ([item action] == @selector(priorRecord) && row == 0) {
        return NO;
    }
    return YES;
  }
  - (BOOL)validateMenuItem:(NSMenuItem *)item {
    int row = [tableView selectedRow];
    if ([item action] == @selector(nextRecord) &&
        (row == [countryKeys indexOfObject:[countryKeys lastObject]])) {
        return NO;
    }
    if ([item action] == @selector(priorRecord) && row == 0) {
        return NO;
    }
    return YES;
  }
    * @see https://developer.apple.com/documentation/objectivec/nsobject/1518160-validatemenuitem
   */


  validateMenuItem(menuItem) {
    return false;
  }
  /**
   * If this method is implemented and returns false, NSToolbar will disable theItem; returning true causes theItem to be enabled.
   * @access public
   * @param {NSToolbarItem} item - 
   * @returns {boolean} - 
   * @desc NSToolbar only calls this method for image items.Note
  validateToolbarItem(_:) is called very frequently, so it must be efficient.If the receiver is the target for the actions of multiple toolbar items, it’s necessary to determine which toolbar item theItem refers to by testing the itemIdentifier.-(BOOL)validateToolbarItem:(NSToolbarItem *)toolbarItem
  {
    BOOL enable = NO;
    if ([[toolbarItem itemIdentifier] isEqual:SaveDocToolbarItemIdentifier]) {
        // We will return YES (enable the save item)
        // only when the document is dirty and needs saving
        enable = [self isDocumentEdited];
    } else if ([[toolbarItem itemIdentifier] isEqual:NSToolbarPrintItemIdentifier]) {
        // always enable print for this window
        enable = YES;
    }
    return enable;
  }
  -(BOOL)validateToolbarItem:(NSToolbarItem *)toolbarItem
  {
    BOOL enable = NO;
    if ([[toolbarItem itemIdentifier] isEqual:SaveDocToolbarItemIdentifier]) {
        // We will return YES (enable the save item)
        // only when the document is dirty and needs saving
        enable = [self isDocumentEdited];
    } else if ([[toolbarItem itemIdentifier] isEqual:NSToolbarPrintItemIdentifier]) {
        // always enable print for this window
        enable = YES;
    }
    return enable;
  }
    * @see https://developer.apple.com/documentation/objectivec/nsobject/1524282-validatetoolbaritem
   */


  validateToolbarItem(item) {
    return false;
  }
  /**
   * Retrieves an indexed object from the collection specified by the passed key.
   * @access public
   * @param {number} index - 
   * @param {string} key - 
   * @returns {?Object} - 
   * @desc  This actually works with a single-value key as well if index is 0. The method valueIn<Key>AtIndex: is used if it exists.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1407605-value
   */


  valueAtInPropertyWithKey(index, key) {
    return null;
  }
  /**
   * Returns the class of the value that will be returned for the specified binding.
   * @access public
   * @param {string} binding - The name of a binding.
   * @returns {?Object} - 
   * @desc This method is used by Interface Builder to determine the appropriate transformers for a binding. Implementation of this method is optional.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1458101-valueclassforbinding
   */


  valueClassForBinding(binding) {
    return null;
  }
  /**
   * Retrieves a named object from the collection specified by the passed key.
   * @access public
   * @param {string} name - 
   * @param {string} key - 
   * @returns {?Object} - 
   * @desc  The method valueIn<Key>WithName: is used if it exists. Otherwise, raises an NSUndefinedKeyException.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1418031-value
   */


  valueWithNameInPropertyWithKey(name, key) {
    return null;
  }
  /**
   * Retrieves an object by ID from the collection specified by the passed key.
   * @access public
   * @param {Object} uniqueID - 
   * @param {string} key - 
   * @returns {?Object} - 
   * @desc  The method valueIn<Key>WithUniqueID: is invoked if it exists. Otherwise, raises an NSUndefinedKeyException. The declared type of uniqueID in the constructed method must be id, NSNumber *, NSString *, or one of the scalar types that can be encapsulated by NSNumber.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1407321-value
   */


  valueWithUniqueIDInPropertyWithKey(uniqueID, key) {
    return null;
  }
  /**
   * Returns the tool tip string to be displayed due to the cursor pausing at location point within the tool tip rectangle identified by tag in the view view.
   * @access public
   * @param {NSView} view - 
   * @param {NSToolTipTag} tag - 
   * @param {CGPoint} point - 
   * @param {?Object} data - 
   * @returns {string} - 
   * @desc  userData is additional information provided by the creator of the tool tip rectangle.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1483693-view
   */


  viewStringForToolTipUserData(view, tag, point, data) {
    return '';
  }
  /**
   * Loads a URL into a web frame.
   * @access public
   * @param {!URLRequest} request - The request that specifies the URL.
   * @param {!string} target - The frame into which the URL is loaded.
   * @returns {void}
   * @desc If the frame specified by target is not found, a new window is opened, loaded with the URL request, and given the specified frame name. If target is nil, the frame enclosing the plug-in is loaded with the URL request.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1536649-webplugincontainerload
   */


  webPlugInContainerLoadInFrame(request, target) {}
  /**
   * Tells the container to show a status message.
   * @access public
   * @param {!string} message - The status message to be displayed.
   * @returns {void}
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1537604-webplugincontainershowstatus
   */


  webPlugInContainerShowStatus(message) {}
  /**
   * Prepares the plug-in for deallocation.
   * @access public
   * @returns {void}
   * @desc Typically, this method frees the memory and other resources used by the plug-in. For example, if the plug-in had a copy of a WebPlugInContainer object, this method should relinquish ownership of that object. Do not send any other messages to the plug-in after invoking this method, because calling this method destroys the plug-in. No other methods in this interface may be called after the application has called this method.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1536659-webplugindestroy
   */


  webPlugInDestroy() {}
  /**
   * Initializes the plug-in.
   * @access public
   * @returns {void}
   * @desc Tells the plug-in to perform one-time initialization. This method must be called only once per instance of the plug-in object, before any other methods in the protocol are called.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1537623-webplugininitialize
   */


  webPlugInInitialize() {}
  /**
   * Invoked when an error occurs loading the main resource.
   * @access public
   * @param {!Error} error - An error object containing details of why the connection failed to load the request successfully.
   * @returns {void}
   * @desc This message is invoked when the underlying NSURLConnection object for the main resource sends the connection:didFailWithError: message to its delegate.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1536829-webpluginmainresourcedidfailwith
   */


  webPlugInMainResourceDidFailWithError(error) {}
  /**
   * Invoked when the connection successfully finishes loading data.
   * @access public
   * @returns {void}
   * @desc This message is invoked when the WebPlugInShouldLoadMainResourceKey plug-in command-line argument is set to false and the underlying NSURLConnection object for the main resource sends the connectionDidFinishLoading: message to its delegate.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1537693-webpluginmainresourcedidfinishlo
   */


  webPlugInMainResourceDidFinishLoading() {}
  /**
   * Invoked when the connection receives sufficient data to construct the URL response for its request.
   * @access public
   * @param {!URLResponse} response - The URL response for the connection's request.
   * @returns {void}
   * @desc This message is invoked when the WebPlugInShouldLoadMainResourceKey plug-in command-line argument is set to false and the underlying NSURLConnection object for the main resource sends the connection:didReceiveResponse: message to its delegate.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1537895-webpluginmainresourcedidreceive
   */


  webPlugInMainResourceDidReceive(response) {}
  /**
   * Controls plug-in behavior based on its selection.
   * @access public
   * @param {boolean} isSelected - If true, the plug-in is currently selected. Otherwise, it is not selected.
   * @returns {void}
   * @desc This may be used, for example, to change the plug-in’s appearance when it is selected by the user.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1536477-webpluginsetisselected
   */


  webPlugInSetIsSelected(isSelected) {}
  /**
   * Tells the plug-in to start normal operation.
   * @access public
   * @returns {void}
   * @desc The plug-in usually begins its primary task (such as drawing, playing sounds, or animating) in this method. This method may be called more than once, provided that the application has already called webPlugInInitialize() and that each call to this method is followed later by a call to webPlugInStop().
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1536197-webpluginstart
   */


  webPlugInStart() {}
  /**
   * Tells the plug-in to stop normal operation.
   * @access public
   * @returns {void}
   * @desc This method may be called more than once, provided that the application has already called webPlugInInitialize() and that each call to this method is preceded by a call to webPlugInStart().
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1536433-webpluginstop
   */


  webPlugInStop() {}
  /**
   * Invoked when the receiver's workflow encounters an error.
   * @access public
   * @param {AMWorkflowController} controller - The controller object sending the message.
   * @param {Error} error - If a workflow error occurs, upon return contains an instance of NSError that describes the problem.
   * @returns {void}
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1419652-workflowcontroller
   */


  workflowControllerDidError(controller, error) {}
  /**
   * Invoked when an action in the receiver's workflow is finished running.
   * @access public
   * @param {AMWorkflowController} controller - The controller object sending the message.
   * @param {AMAction} action - The workflow action that ran.
   * @returns {void}
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1419675-workflowcontroller
   */


  workflowControllerDidRun(controller, action) {}
  /**
   * Invoked when an action in the receiver's workflow is about to run.
   * @access public
   * @param {AMWorkflowController} controller - The controller object sending the message.
   * @param {AMAction} action - The workflow action that will run.
   * @returns {void}
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1419720-workflowcontroller
   */


  workflowControllerWillRun(controller, action) {}
  /**
   * Tells the delegate that the workflow controller object has stopped.
   * @access public
   * @param {AMWorkflowController} controller - The workflow controller object that stopped.
   * @returns {void}
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1419770-workflowcontrollerdidstop
   */


  workflowControllerDidStop(controller) {}
  /**
   * Tells the delegate that the workflow controller object is about to stop.
   * @access public
   * @param {AMWorkflowController} controller - The workflow controller object to be stopped.
   * @returns {void}
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1419598-workflowcontrollerwillstop
   */


  workflowControllerWillStop(controller) {}
  /**
   * Tells the element to activate itself and report the success or failure of the operation.
   * @access public
   * @returns {boolean} - 
   * @desc You can use this method to make complex controls more readily accessible to users. The accessibility system calls this method when a VoiceOver user double taps the selected element. Your implementation of this method should activate the element and perform whatever other tasks it deems appropriate. For example, you might use the method to activate a control that requires a complex gesture and would be difficult for VoiceOver users to perform, possibly because the gesture has a different meaning when VoiceOver is running.After performing any tasks, return an appropriate Boolean value to indicate success or failure.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1615165-accessibilityactivate
   */


  accessibilityActivate() {
    return false;
  }
  /**
   * 
   * @access public
   * @returns {?Set<String>} - 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1615206-accessibilityassistivetechnology
   */


  accessibilityAssistiveTechnologyFocusedIdentifiers() {
    return null;
  }
  /**
   * Tells the accessibility element to decrement the value of its content.
   * @access public
   * @returns {void}
   * @desc If your element has the UIAccessibilityTraitAdjustable trait, you must implement this method. Use this method to decrement the value of the element. For example, a UISlider object uses this method to decrement its value by an appropriate amount. 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1615169-accessibilitydecrement
   */


  accessibilityDecrement() {}
  /**
   * Returns the accessibility element at the specified index.
   * @access public
   * @param {number} index - The index of the accessibility element.
   * @returns {?Object} - 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1615084-accessibilityelement
   */


  accessibilityElementAt(index) {
    return null;
  }
  /**
   * Returns the number of accessibility elements in the container.
   * @access public
   * @returns {number} - 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1615149-accessibilityelementcount
   */


  accessibilityElementCount() {
    return 0;
  }
  /**
   * Sent after an assistive technology has set its virtual focus on the accessibility element.
   * @access public
   * @returns {void}
   * @desc Override accessibilityElementDidBecomeFocused if you need to know when an assistive technology has set its virtual focus on an accessibility element.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1615183-accessibilityelementdidbecomefoc
   */


  accessibilityElementDidBecomeFocused() {}
  /**
   * Sent after an assistive technology has removed its virtual focus from an accessibility element.
   * @access public
   * @returns {void}
   * @desc Override accessibilityElementDidLoseFocus if you need to know when an assistive technology has removed its virtual focus from an accessibility element. Note that accessibilityElementDidLoseFocus is sent before accessibilityElementDidBecomeFocused().
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1615082-accessibilityelementdidlosefocus
   */


  accessibilityElementDidLoseFocus() {}
  /**
   * Returns a Boolean value indicating whether an assistive technology is focused on the accessibility element.
   * @access public
   * @returns {boolean} - 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1615190-accessibilityelementisfocused
   */


  accessibilityElementIsFocused() {
    return false;
  }
  /**
   * Tells the accessibility element to increment the value of its content.
   * @access public
   * @returns {void}
   * @desc If your element has the UIAccessibilityTraitAdjustable trait, you must implement this method. Use this method to increment the value of the element. For example, a UISlider object uses this method to increment its value by an appropriate amount. 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1615076-accessibilityincrement
   */


  accessibilityIncrement() {}
  /**
   * Dismisses a modal view and returns the success or failure of the action.
   * @access public
   * @returns {boolean} - 
   * @desc Implement this method on an element or containing view that can be revealed modally or in a hierarchy. When a VoiceOver user performs a dismiss action, this method dismisses the view. For example, you might implement this method for a popover in order to give users a deliberate dismiss action to perform that closes the popover.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1615091-accessibilityperformescape
   */


  accessibilityPerformEscape() {
    return false;
  }
  /**
   * Performs a salient action.
   * @access public
   * @returns {boolean} - 
   * @desc The exact action performed by this method depends your app, typically toggling the most important state of the app. For example, in the Phone app it answers and ends phone calls, in the Music app it plays and pauses playback, in the Clock app it starts and stops a timer, and in the Camera app it takes a picture.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1615137-accessibilityperformmagictap
   */


  accessibilityPerformMagicTap() {
    return false;
  }
  /**
   * Scrolls screen content in an application-specific way and returns the success or failure of the action.
   * @access public
   * @param {UIAccessibilityScrollDirection} direction - A constant that specifies the direction of the scrolling action. See UIAccessibilityScrollDirection for descriptions of valid constants.
   * @returns {boolean} - 
   * @desc Implement this method if a view in the view hierarchy supports a scroll by page action.If the scrolling action succeeds for the specified direction, return true and post the UIAccessibilityPageScrolledNotification notification. If the scrolling action fails, accessibilityScroll: is called on a parent view in the hierarchy.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1615161-accessibilityscroll
   */


  accessibilityScroll(direction) {
    return false;
  }
  /**
   * Returns the index of the specified accessibility element.
   * @access public
   * @param {Object} element - The accessibility element.
   * @returns {number} - 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1615078-index
   */


  indexOfAccessibilityElement(element) {
    return 0;
  } // Type Methods

  /**
   * Returns a Boolean value that indicates whether the observed object supports automatic key-value observation for the given key.
   * @access public
   * @param {string} key - 
   * @returns {boolean} - 
   * @desc The default implementation returns true. Starting in OS X 10.5, the default implementation of this method searches the receiving class for a method whose name matches the pattern +automaticallyNotifiesObserversOf<Key>, and returns the result of invoking that method if it is found. Any found methods must return BOOL. If no such method is found true is returned.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1409370-automaticallynotifiesobservers
   */


  static automaticallyNotifiesObserversForKey(key) {
    return false;
  }
  /**
   * 
   * @access public
   * @returns {string} - 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1418711-debugdescription
   */


  static debugDescription() {
    return '';
  }
  /**
   * 
   * @access public
   * @returns {number} - 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1418561-hash
   */


  static hash() {
    return 0;
  }
  /**
   * Returns a set of key paths for properties whose values affect the value of the specified key.
   * @access public
   * @param {string} key - The key whose value is affected by the key paths.
   * @returns {Set<String>} - 
   * @desc When an observer for the key is registered with an instance of the receiving class, key-value observing itself automatically observes all of the key paths for the same instance, and sends change notifications for the key to the observer when the value for any of those key paths changes.The default implementation of this method searches the receiving class for a method whose name matches the pattern +keyPathsForValuesAffecting<Key>, and returns the result of invoking that method if it is found. Any such method must return an NSSet. If no such method is found, an NSSet that is computed from information provided by previous invocations of the now-deprecated setKeys:triggerChangeNotificationsForDependentKey: method is returned, for backward binary compatibility.You can override this method when the getter method of one of your properties computes a value to return using the values of other properties, including those that are located by key paths. Your override should typically call super and return a set that includes any members in the set that result from doing that (so as not to interfere with overrides of this method in superclasses).NoteYou must not override this method when you add a computed property to an existing class using a category, overriding methods in categories is unsupported. In that case, implement a matching +keyPathsForValuesAffecting<Key> to take advantage of this mechanism.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1414299-keypathsforvaluesaffectingvalue
   */


  static keyPathsForValuesAffectingValueForKey(key) {
    return null;
  }
  /**
   * Returns an object that will be used as the placeholder for the binding, when a key value coding compliant property of an instance of the receiving class returns the value specified by marker, and no other placeholder has been specified. 
   * @access public
   * @param {?Object} marker - 
   * @param {string} binding - 
   * @returns {?Object} - 
   * @desc The marker can be nil or one of the constants described in Selection Markers.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1458203-defaultplaceholder
   */


  static defaultPlaceholderForMarkerWithBinding(marker, binding) {
    return null;
  }
  /**
   * Exposes the specified binding, advertising its availability. 
   * @access public
   * @param {string} binding - The key path for the property to be exposed.
   * @returns {void}
   * @desc The bound property will be accessed using key-value-coding compliant methods. This method is typically invoked in the class’s initialize implementation.Bindings exposed using exposeBinding will be exposed automatically in exposedBindings unless that method explicitly filters them out, for example in subclasses.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1458184-exposebinding
   */


  static exposeBinding(binding) {}
  /**
   * Returns whether a key should be hidden from the scripting environment.
   * @access public
   * @param {!UnsafePointer<Int8>} name - The name of the attribute.
   * @returns {boolean} - 
   * @desc The default value is true.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1528545-iskeyexcluded
   */


  static isKeyExcludedFromWebScript(name) {
    return false;
  }
  /**
   * Returns whether a selector should be hidden from the scripting environment.
   * @access public
   * @param {!function} selector - 
   * @returns {boolean} - 
   * @desc Only methods with valid parameters and return types are exported to the WebKit JavaScript environment. The valid types are Objective-C objects and scalars. The default value is true.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1528532-isselectorexcluded
   */


  static isSelectorExcludedFromWebScript(selector) {
    return false;
  }
  /**
   * Sets placeholder as the default placeholder for the binding, when a key value coding compliant property of an instance of the receiving class returns the value specified by marker, and no other placeholder has been specified.
   * @access public
   * @param {?Object} placeholder - 
   * @param {?Object} marker - 
   * @param {string} binding - 
   * @returns {void}
   * @desc The marker can be nil or one of the constants described in Selection Markers.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1458194-setdefaultplaceholder
   */


  static setDefaultPlaceholderForMarkerWithBinding(placeholder, marker, binding) {}
  /**
   * Returns the scripting environment name for an attribute specified by a key.
   * @access public
   * @param {!UnsafePointer<Int8>} name - The name of the attribute.
   * @returns {!string} - 
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1528541-webscriptname
   */


  static webScriptNameForKey(name) {
    return null;
  }
  /**
   * Returns the scripting environment name for a selector.
   * @access public
   * @param {!function} selector - 
   * @returns {!string} - 
   * @desc It is your responsibility to ensure that the returned name is unique to the script invoking this method. If this method returns nil or you do not implement it, the default name for the selector is constructed as follows: A colon (“:”) in the Objective-C selector is replaced by an underscore (“_”).An underscore in the Objective-C selector is prefixed with a dollar sign (“$”).A dollar sign in the Objective-C selector is prefixed with another dollar sign.The following table shows examples of how the default name is constructed:Objective-C selectorDefault script name for selectorsetFlag:setFlag_setFlag:forKey:withAttributes:setFlag_forKey_withAttributes_propertiesForExample_Object:propertiesForExample$_Object_set_$_forKey:withDictionary:set$_$$_$_forKey_withDictionary_Since the default construction for a method name can be confusing depending on its Objective-C name, you should implement this method and return a more human-readable name.Objective-C selectorDefault script name for selectorsetFlag:setFlag_setFlag:forKey:withAttributes:setFlag_forKey_withAttributes_propertiesForExample_Object:propertiesForExample$_Object_set_$_forKey:withDictionary:set$_$$_$_forKey_withDictionary_
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1528539-webscriptname
   */


  static webScriptNameFor(selector) {
    return null;
  }

  static get supportsSecureCoding() {
    return true;
  }

  static initWithCoder(coder) {
    //console.log('initWithCoder: ' + this.className)
    let propTypes = {}; // check if all property names are registered

    for (const key of Object.keys(coder._refObj)) {
      if (key.charAt(0) === '$') {
        continue;
      }

      if (typeof this._propTypes[key] === 'undefined') {
        //console.warn(`unknown key ${key}`)
        if (this._propTypes.$unknownKey && this._propTypes.$unknownKey(key) !== null) {
          propTypes[key] = this._propTypes.$unknownKey(key); //console.warn(`unknown key: ${key} => ${propTypes[key]}`)
        } else {
          console.error(`${this.className}: property ${key} not registered`);
          throw new Error(`${this.className}: property ${key} not registered`);
        }
      } else {
        propTypes[key] = this._propTypes[key];
      }
    }

    const props = this._loadProperties(coder, propTypes);

    const propNames = props.names;
    const propValues = props.values;
    let instance = null;

    if (typeof this._propTypes.$constructor === 'function') {
      instance = this._propTypes.$constructor(propNames, propValues, coder);
    } else {
      instance = new this();
    }

    this._setProperties(instance, propNames, propValues, coder);

    return instance;
  }
  /**
   * @access private
   * @param {NSCoder} coder -
   * @param {Object} propTypes -
   * @returns {Object} -
   */


  static _loadProperties(coder, propTypes) {
    const propNames = {};
    const propValues = {};

    for (const key of Object.keys(propTypes)) {
      //console.log(`key: ${key}`)
      if (!coder.containsValueForKey(key)) {
        console.log(`!coder.containsValueForKey ${key}`);
        continue;
      }

      const def = propTypes[key];
      let type = '';
      let propName = key;

      if (typeof def === 'string') {
        type = def;
      } else if (Array.isArray(def)) {
        type = def[0];

        if (def.length >= 2) {
          propName = def[1];
        }
      } //console.log(`type: ${type}, propName: ${propName}`)


      let value = null;

      switch (type) {
        case 'boolean':
          value = coder.decodeBoolForKey(key);
          break;

        case 'bytes':
          value = coder.decodeBytesForKeyReturnedLength(key, null);
          break;

        case 'double':
          value = coder.decodeDoubleForKey(key);
          break;

        case 'float':
          value = coder.decodeFloatForKey(key);
          break;

        case 'integer':
          value = coder.decodeCIntForKey(key);
          break;

        case 'int32':
          value = coder.decodeInt32ForKey(key);
          break;

        case 'int64':
          value = coder.decodeInt64ForKey(key);
          break;

        case 'point':
          value = coder.decodePointForKey(key);
          break;

        case 'rect':
          value = coder.decodeRectForKey(key);
          break;

        case 'size':
          value = coder.decodeSizeForKey(key);
          break;

        case 'plist':
          value = coder.decodePropertyListForKey(key);
          break;

        case 'string':
          value = coder.decodeObjectForKey(key);

          if (typeof value !== 'string') {
            //console.error(`${key}: value is not String type`)
            throw new Error(`${key}: value is not String type`);
          }

          break;

        default:
          {
            const classObj = _ClassList.get(type);

            if (typeof classObj === 'undefined') {
              //console.error(`unknown class name: ${type}`)
              throw new Error(`unknown class name: ${type}`);
            }

            if (coder._refObj[key] instanceof Buffer) {
              value = coder.decodeObjectOfTypeForKey(classObj, key);

              if (!(value instanceof classObj)) {
                //console.error(`${key}: value is not an instance of ${type}`)
                throw new Error(`${key}: value is not an instance of ${type}`);
              }
            } else {
              value = coder.decodeObjectForKey(key);

              if (value === '$null') {
                value = null;
              } else if (value instanceof Promise) ; else if (!(value instanceof classObj)) {
                const exception = ['NSObject', // => Super class of NS*
                'NSData', 'NSMutableData', // => Buffer
                'NSArray', 'NSMutableArray', // => Array
                'NSDictionary', 'NSMutableDictionary', // => Object
                'NSColor', // => SKColor
                'NSURL' // => String
                ];

                if (exception.indexOf(classObj.className) < 0) {
                  //console.error(`${key}: value is not an instance of ${type}`)
                  throw new Error(`${key}: value is not an instance of ${type}`);
                }
              }
            }
          }
      } //if(Array.isArray(value)){
      //  console.log(`value: Array[${value.length}]`)
      //}else if(typeof value === 'symbol'){
      //  console.log('value: Symbol()')
      //}else{
      //  console.log(`value: ${value}`)
      //}


      propValues[key] = value;
      propNames[key] = propName;
    }

    return {
      names: propNames,
      values: propValues
    };
  }
  /**
   * @access private
   * @param {Object} instance -
   * @param {string[]} propNames -
   * @param {Object[]} propValues -
   * @param {NSCoder} coder -
   * @returns {void}
   */


  static _setProperties(instance, propNames, propValues, coder) {
    for (const key of Object.keys(propValues)) {
      this._setProperty(instance, propNames[key], propValues[key], key, coder);
    }
  }
  /**
   * @access private
   * @param {Object} instance -
   * @param {string[]} propName -
   * @param {Object[]} propValue -
   * @param {string} key -
   * @param {NSCoder} coder -
   * @returns {void}
   */


  static _setProperty(instance, propName, propValue, key, coder) {
    if (propValue instanceof Promise) {
      propValue.then(loadedValue => {
        this._setProperty(instance, propName, loadedValue, key, coder);
      });
    } else if (typeof propName === 'function') {
      propName(instance, propValue, key, coder);
    } else if (propName !== null) {
      instance[propName] = propValue;
    }
  }

  _destroy() {
    if (this._destroyed) {
      throw new Error('_destroy() called twice');
    }

    this._destroyed = true;

    this._execDestroy();
  }

  _execDestroy() {// destroy objects
  }

}

/**
 * An object that stores color data and sometimes opacity (that is, alpha value). 
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/uikit/uicolor
 */

class SKColor extends NSObject {
  static get _propTypes() {
    return {
      $constructor: (propNames, propValues) => {
        if (typeof propValues.NSColorSpace !== 'undefined') {
          // initialize for NSColor

          /*
          const buf = propValues.NSRGB || propValues.NSWhite
          const ascii = buf.toString('ascii')
          const values = ascii.split(' ')
          const space = propValues.NSColorSpace - 1
          switch(space){
            case NSColorSpaceModel.gray:
              break
            case NSColorSpaceModel.RGB: {
              const r = parseFloat(values[0])
              const g = parseFloat(values[1])
              const b = parseFloat(values[2])
              const a = 1.0
              console.log(`NSColor -> SKColor: r:${r} g:${g} b:${b} a:${a}`)
              return new SKColor(r, g, b, a)
            }
            case NSColorSpaceModel.CMYK:
              if(propValues.NSWhite){
                const w = parseFloat(values[0])
                return new SKColor(w, w, w, 1.0)
              }
              break
            case NSColorSpaceModel.LAB:
              break
            case NSColorSpaceModel.deviceN:
              break
            case NSColorSpaceModel.indexed:
              break
            case NSColorSpaceModel.patterned:
              break
          }
          console.error(`unknown color space: ${propValues.NSColorSpace}`)
          throw new Error(`unknown color space: ${propValues.NSColorSpace}`)
          */
          if (typeof propValues.NSRGB !== 'undefined') {
            const ascii = propValues.NSRGB.toString('ascii');
            const values = ascii.split(' ');
            const r = parseFloat(values[0]);
            const g = parseFloat(values[1]);
            const b = parseFloat(values[2]);
            const a = 1.0; //console.log(`NSColor -> SKColor NSRGB: r:${r} g:${g} b:${b} a:${a}`)
            //if(propValues.NSColorSpace === 1){
            //  return new SKColor(1, 1, 1, 1)
            //}

            return new SKColor(r, g, b, a);
          } else if (typeof propValues.NSWhite !== 'undefined') {
            const ascii = propValues.NSWhite.toString('ascii');
            const values = ascii.split(' ');
            const w = parseFloat(values[0]);
            const a = 1.0; //console.log(`NSColor -> SKColor NSWhite: r:${w} g:${w} b:${w} a:${a}`)

            return new SKColor(w, w, w, a);
          }

          console.error('unknown color space');
          throw new Error('unknown color space');
        } // TODO: implement


        return new SKColor();
      },
      // for NSColor
      NSRGB: ['bytes', null],
      NSWhite: ['bytes', null],
      NSComponents: ['bytes', null],
      NSColorSpace: ['integer', null],
      NSCustomColorSpace: ['NSColorSpace', null]
    };
  }
  /**
   * @access private
   * @param {Buffer} data -
   * @param {number} [offset = 0] -
   * @param {boolean} [bigEndian = false] -
   * @returns {SKColor}
   */


  static _initWithData(data, offset = 0, bigEndian = false) {
    const instance = new SKColor();

    if (bigEndian) {
      instance.red = data.readFloatBE(offset + 0);
      instance.green = data.readFloatBE(offset + 4);
      instance.blue = data.readFloatBE(offset + 8);
      instance.alpha = data.readFloatBE(offset + 12);
    } else {
      instance.red = data.readFloatLE(offset + 0);
      instance.green = data.readFloatLE(offset + 4);
      instance.blue = data.readFloatLE(offset + 8);
      instance.alpha = data.readFloatLE(offset + 12);
    }

    return instance;
  } // Initializers

  /**
   * 
   * @access public
   * @constructor
   * @param {number} red - 
   * @param {number} green - 
   * @param {number} blue - 
   * @param {number} alpha - 
   * @see https://developer.apple.com/documentation/uikit/uicolor/1625015-init
   */


  constructor(red, green, blue, alpha) {
    super();
    /**
     * @type {number}
     */

    this.red = red;
    /**
     * @type {number}
     */

    this.green = green;
    /**
     * @type {number}
     */

    this.blue = blue;
    /**
     * @type {number}
     */

    this.alpha = alpha;
  } // Creating a Color Object with a Predefined Color

  /**
   * A color object in the sRGB color space whose grayscale value is 0.0 and whose alpha value is 1.0.
   * @type {SKColor}
   * @desc 
   * @see https://developer.apple.com/documentation/uikit/uicolor/1621929-black
   */


  static get black() {
    return new SKColor(0.0, 0.0, 0.0, 1.0);
  }
  /**
   * A color object whose RGB values are 0.0, 0.0, and 1.0 and whose alpha value is 1.0.
   * @type {SKColor}
   * @desc 
   * @see https://developer.apple.com/documentation/uikit/uicolor/1621947-blue
   */


  static get blue() {
    return new SKColor(0.0, 0.0, 1.0, 1.0);
  }
  /**
   * A color object whose RGB values are 0.6, 0.4, and 0.2 and whose alpha value is 1.0.
   * @type {SKColor}
   * @desc 
   * @see https://developer.apple.com/documentation/uikit/uicolor/1621950-brown
   */


  static get brown() {
    return new SKColor(0.6, 0.4, 0.2, 1.0);
  }
  /**
   * A color object whose grayscale and alpha values are both 0.0.
   * @type {SKColor}
   * @desc 
   * @see https://developer.apple.com/documentation/uikit/uicolor/1621945-clear
   */


  static get clear() {
    return new SKColor(0.0, 0.0, 0.0, 0.0);
  }
  /**
   * A color object whose RGB values are 0.0, 1.0, and 1.0 and whose alpha value is 1.0.
   * @type {SKColor}
   * @desc 
   * @see https://developer.apple.com/documentation/uikit/uicolor/1621942-cyan
   */


  static get cyan() {
    return new SKColor(0.0, 1.0, 1.0, 1.0);
  }
  /**
   * A color object whose grayscale value is 1/3 and whose alpha value is 1.0.
   * @type {SKColor}
   * @desc 
   * @see https://developer.apple.com/documentation/uikit/uicolor/1621952-darkgray
   */


  static get darkGray() {
    const third = 1.0 / 3.0;
    return new SKColor(third, third, third, 1.0);
  }
  /**
   * A color object whose grayscale value is 0.5 and whose alpha value is 1.0.
   * @type {SKColor}
   * @desc 
   * @see https://developer.apple.com/documentation/uikit/uicolor/1621941-gray
   */


  static get gray() {
    return new SKColor(0.5, 0.5, 0.5, 1.0);
  }
  /**
   * A color object whose RGB values are 0.0, 1.0, and 0.0 and whose alpha value is 1.0.
   * @type {SKColor}
   * @desc 
   * @see https://developer.apple.com/documentation/uikit/uicolor/1621946-green
   */


  static get green() {
    return new SKColor(0.0, 1.0, 0.0, 1.0);
  }
  /**
   * A color object whose grayscale value is 2/3 and whose alpha value is 1.0.
   * @type {SKColor}
   * @desc 
   * @see https://developer.apple.com/documentation/uikit/uicolor/1621932-lightgray
   */


  static get lightGray() {
    const twoThirds = 2.0 / 3.0;
    return new SKColor(twoThirds, twoThirds, twoThirds, 1.0);
  }
  /**
   * A color object whose RGB values are 1.0, 0.0, and 1.0 and whose alpha value is 1.0.
   * @type {SKColor}
   * @desc 
   * @see https://developer.apple.com/documentation/uikit/uicolor/1621934-magenta
   */


  static get magenta() {
    return new SKColor(1.0, 0.0, 1.0, 1.0);
  }
  /**
   * A color object whose RGB values are 1.0, 0.5, and 0.0 and whose alpha value is 1.0.
   * @type {SKColor}
   * @desc 
   * @see https://developer.apple.com/documentation/uikit/uicolor/1621956-orange
   */


  static get orange() {
    return new SKColor(1.0, 0.5, 0.0, 1.0);
  }
  /**
   * A color object whose RGB values are 0.5, 0.0, and 0.5 and whose alpha value is 1.0.
   * @type {SKColor}
   * @desc 
   * @see https://developer.apple.com/documentation/uikit/uicolor/1621923-purple
   */


  static get purple() {
    return new SKColor(0.5, 0.0, 0.5, 1.0);
  }
  /**
   * A color object whose RGB values are 1.0, 0.0, and 0.0 and whose alpha value is 1.0.
   * @type {SKColor}
   * @desc 
   * @see https://developer.apple.com/documentation/uikit/uicolor/1621924-red
   */


  static get red() {
    return new SKColor(1.0, 0.0, 0.0, 1.0);
  }
  /**
   * A color object whose grayscale value is 1.0 and whose alpha value is 1.0.
   * @type {SKColor}
   * @desc 
   * @see https://developer.apple.com/documentation/uikit/uicolor/1621920-white
   */


  static get white() {
    return new SKColor(1.0, 1.0, 1.0, 1.0);
  }
  /**
   * A color object whose RGB values are 1.0, 1.0, and 0.0 and whose alpha value is 1.0.
   * @type {SKColor}
   * @desc 
   * @see https://developer.apple.com/documentation/uikit/uicolor/1621953-yellow
   */


  static get yellow() {
    return new SKColor(1.0, 1.0, 0.0, 1.0);
  } // Creating a Custom UIColor Object in a Specific Color Space

  /**
   * Initializes and returns a color object using the specified opacity and grayscale values. 
   * @access public
   * @param {number} white - The grayscale value of the color object. On applications linked for iOS 10 or later, the color is specified in an extended color space, and the input value  is never clamped. On earlier versions of iOS, white values below 0.0 are interpreted as 0.0, and values above 1.0 are interpreted as 1.0.
   * @param {number} alpha - The opacity value of the color object, specified as a value from 0.0 to 1.0. Alpha values below 0.0 are interpreted as 0.0, and values above 1.0 are interpreted as 1.0
   * @returns {void}
   * @desc On applications linked on iOS 10 or later, the input parameters are not clamped. On earlier versions of iOS, values below 0.0 are interpreted as 0.0, and values above 1.0 are interpreted as 1.0.
   * @see https://developer.apple.com/documentation/uikit/uicolor/1621944-init
   */
  //init(white, alpha) {
  //}
  // Creating a UIColor Object from another Representation of Color

  /**
   * Creates and returns a color object that has the same color space and component values as the receiver, but has the specified alpha component. 
   * @access public
   * @param {number} alpha - The opacity value of the new color object, specified as a value from 0.0 to 1.0. Alpha values below 0.0 are interpreted as 0.0, and values above 1.0 are interpreted as 1.0
   * @returns {SKColor} - 
   * @desc A subclass with explicit opacity components should override this method to return a color with the specified alpha.
   * @see https://developer.apple.com/documentation/uikit/uicolor/1621922-withalphacomponent
   */


  withAlphaComponent(alpha) {
    return new SKColor(this.red, this.green, this.blue, alpha);
  } // Creating a UIColor Object that Draws Using a Pattern

  /**
   * Initializes and returns a color object using the specified Quartz color reference. 
   * @access public
   * @param {Image} image - The image to use when creating the pattern color. 
   * @returns {void}
   * @desc You can use pattern colors to set the fill or stroke color just as you would a solid color. During drawing, the image in the pattern color is tiled as necessary to cover the given area. By default, the phase of the returned color is 0, which causes the top-left corner of the image to be aligned with the drawing origin. To change the phase, make the color the current color and then use the setPatternPhase(_:) function to change the phase.
   * @see https://developer.apple.com/documentation/uikit/uicolor/1621933-init
   */


  initPatternImage(image) {} // Setting the Graphics Context’s Drawing Color

  /**
   * Sets the color of subsequent stroke and fill operations to the color that the receiver represents. 
   * @access public
   * @returns {void}
   * @desc If you subclass UIColor, you must implement this method in your subclass. Your custom implementation should modify both the stroke and fill color in the current graphics context by setting them both to the color represented by the receiver.
   * @see https://developer.apple.com/documentation/uikit/uicolor/1621928-set
   */


  set() {}
  /**
   * Sets the color of subsequent fill operations to the color that the receiver represents.
   * @access public
   * @returns {void}
   * @desc If you subclass UIColor, you must implement this method in your subclass. Your custom implementation should modify the fill color in the current graphics context by setting it to the color represented by the receiver.
   * @see https://developer.apple.com/documentation/uikit/uicolor/1621926-setfill
   */


  setFill() {}
  /**
   * Sets the color of subsequent stroke operations to the color that the receiver represents.
   * @access public
   * @returns {void}
   * @desc If you subclass UIColor, you must implement this method in your subclass. Your custom implementation should modify the stroke color in the current graphics context by setting it to the color represented by the receiver.
   * @see https://developer.apple.com/documentation/uikit/uicolor/1621948-setstroke
   */


  setStroke() {} // Retrieving Color Information

  /**
   * Returns the components that make up the color in the HSB color space.
   * @access public
   * @returns {Object} -
   * @property {number} color.hue - On return, the hue component of the color object. On applications linked for iOS 10 or later, the hue component is specified in an extended range color space and can have any value. Values between 0.0 and 1.0 are inside the sRGB color gamut. On earlier versions of iOS, the specified value is always between 0.0 and 1.0.
   * @property {number} color.saturation - On return, the saturation component of the color object. On applications linked for iOS 10 or later, the saturation component is specified in an extended range color space and can have any value. Values between 0.0 and 1.0 are inside the sRGB color gamut. On earlier versions of iOS, the specified value is always between 0.0 and 1.0.
   * @property {number} color.brightness - On return, the brightness component of the color object. On applications linked for iOS 10 or later, the brightness component is specified in an extended range color space and can have any value. Values between 0.0 and 1.0 are inside the sRGB color gamut. On earlier versions of iOS, the specified value is always between 0.0 and 1.0.
   * @property {number} color.alpha - On return, the opacity component of the color object, specified as a value between 0.0 and 1.0.
   * @desc If the color is in a compatible color space, the color is converted into the HSB color space and its components are returned to your application. If the color is not in a compatible color space, the parameters are unchanged.
   * @see https://developer.apple.com/documentation/uikit/uicolor/1621949-gethue
   */


  getHSBA() {
    // TODO: implement
    const color = {
      hue: 0,
      saturation: 0,
      brightness: 0,
      alpha: 0
    };
    return color;
  }
  /**
   * Returns the components that make up the color in the RGB color space.
   * @access public
   * @param {number} red -
   * @param {number} green -
   * @param {number} blue -
   * @param {number} alpha -
   * @returns {Object} -
   * @property {number} color.red - On return, the red component of the color object. On applications linked for iOS 10 or later, the red component is specified in an extended range sRGB color space and can have any value. Values between 0.0 and 1.0 are inside the sRGB color gamut. On earlier versions of iOS, the specified value is always between 0.0 and 1.0.
   * @property {number} color.green - On return, the green component of the color object. On applications linked for iOS 10 or later, the green component is specified in an extended range sRGB color space and can have any value. Values between 0.0 and 1.0 are inside the sRGB color gamut. On earlier versions of iOS, the specified value is always between 0.0 and 1.0.
   * @property {number} color.blue - On return, the blue component of the color object. On applications linked for iOS 10 or later, the blue component is specified in an extended range sRGB color space and can have any value. Values between 0.0 and 1.0 are inside the sRGB color gamut. On earlier versions of iOS, the specified value is always between 0.0 and 1.0.
   * @property {number} color.alpha - On return, the opacity component of the color object, specified as a value between 0.0 and 1.0.
   * @desc If the color is in a compatible color space, the color is converted into RGB format and its components are returned to your application. If the color is not in a compatible color space, the parameters are unchanged.
   * @see https://developer.apple.com/documentation/uikit/uicolor/1621919-getred
   */


  getRGBA(red, green, blue, alpha) {
    const color = {
      red: this.red,
      green: this.green,
      blue: this.blue,
      alpha: this.alpha
    };
    return color;
  }
  /**
   * Returns the grayscale components of the color.
   * @access public
   * @param {?UnsafeMutablePointer<CGFloat>} white - On return, the grayscale component of the color object. On applications linked for iOS 10 or later, the grayscale component is specified in an extended range gray color space and can have any value. Values between 0.0 and 1.0 are inside the sRGB color gamut. On earlier versions of iOS, the specified value is always between 0.0 and 1.0.
   * @param {?UnsafeMutablePointer<CGFloat>} alpha - On return, the opacity component of the color object, specified as a value between 0.0 and 1.0.
   * @returns {boolean} - 
   * @desc If the color is in a compatible color space, the color is converted into grayscale format and returned to your application. If the color is not in a compatible color space, the parameters are unchanged.
   * @see https://developer.apple.com/documentation/uikit/uicolor/1621927-getwhite
   */
  //getWhite(white, alpha) {
  //  return false
  //}

  /**
   * HTML color representation
   * @access public
   * @type {string}
   */


  get htmlColor() {
    const r = Math.round(this.red * 255);
    const g = Math.round(this.green * 255);
    const b = Math.round(this.blue * 255);
    return `rgba(${r}, ${g}, ${b}, ${this.alpha})`;
  }
  /**
   * HTML color representation
   * @access public
   * @type {string}
   */


  get hexColor() {
    const r = Math.round(this.red * 255).toString(16);
    const g = Math.round(this.green * 255).toString(16);
    const b = Math.round(this.blue * 255).toString(16);
    return `#${r}${g}${b}`;
  }
  /**
   * @access private
   * @returns {SKColor} -
   */


  _copy() {
    return new SKColor(this.red, this.green, this.blue, this.alpha);
  }
  /**
   * @access private
   * @param {SKColor} c -
   * @param {number} rate -
   * @returns {SKColor} -
   */


  _lerp(c, rate) {
    const r = new SKColor();
    r.red = this.red + rate * (c.red - this.red);
    r.green = this.green + rate * (c.green - this.green);
    r.blue = this.blue + rate * (c.blue - this.blue);
    r.alpha = this.alpha + rate * (c.alpha - this.alpha);
    return r;
  }

  zero() {
    return new SKColor(0, 0, 0, 0);
  }
  /**
   * @access public
   * @param {SKColor} c -
   * @returns {SKColor} -
   */


  add(c) {
    const r = new SKColor();
    r.red = this.red + c.red;
    r.green = this.green + c.green;
    r.blue = this.blue + c.blue;
    r.alpha = this.alpha + c.alpha;
    return r;
  }
  /**
   * @access public
   * @param {SKColor} c -
   * @returns {SKColor} -
   */


  sub(c) {
    const r = new SKColor();
    r.red = this.red - c.red;
    r.green = this.green - c.green;
    r.blue = this.blue - c.blue;
    r.alpha = this.alpha - c.alpha;
    return r;
  }
  /**
   * @access private
   * @param {number} val -
   * @returns {number} -
   */


  _srgbToLinear(val) {
    if (val <= 0.04045) {
      return val / 12.92;
    }

    return Math.pow((val + 0.055) / 1.055, 2.4);
  }
  /**
   * @access private
   * @param {number} val -
   * @returns {number} -
   */


  _linearToSrgb(val) {
    if (val <= 0.0031308) {
      return val * 12.92;
    }

    return 1.055 * Math.pow(val, 1.0 / 2.4);
  }
  /**
   * @access public
   * @returns {SKColor} -
   */


  srgbToLinear() {
    const r = new SKColor();
    r.red = this._srgbToLinear(this.red);
    r.green = this._srgbToLinear(this.green);
    r.blue = this._srgbToLinear(this.blue);
    r.alpha = this.alpha;
    return r;
  }
  /**
   * @access public
   * @returns {SKColor} -
   */


  linearToSrgb() {
    const r = new SKColor();
    r.red = this._linearToSrgb(this.red);
    r.green = this._linearToSrgb(this.green);
    r.blue = this._linearToSrgb(this.blue);
    r.alpha = this.alpha;
    return r;
  }
  /**
   * @access public
   * @returns {number[]} -
   */


  floatArray() {
    return [this.red, this.green, this.blue, this.alpha];
  }
  /**
   * @access public
   * @returns {Float32Array} -
   */


  float32Array() {
    return new Float32Array([this.red, this.green, this.blue, this.alpha]);
  }

}

/**
 * dummy class for NSKeyedArchiver/Unarchiver
 * @access public
 * @extends {NSObject}
 */

class NSColor extends NSObject {
  /**
   * @access public
   * @param {NSCoder} coder -
   * @returns {_Buffer} -
   */
  static initWithCoder(coder) {
    return SKColor.initWithCoder(coder);
  }

}

/**
 * The type of the color-space mode constants listed in Color Space Models.
 * @typedef {Object} NSColorSpaceModel
 * @property {number} CMYK - 
 * @property {number} LAB - 
 * @property {number} RGB - 
 * @property {number} deviceN - 
 * @property {number} gray - 
 * @property {number} indexed - 
 * @property {number} patterned - 
 * @property {number} unknown - 
 * @see https://developer.apple.com/documentation/appkit/nscolorspacemodel
 */

const NSColorSpaceModel = {
  gray: 0,
  RGB: 1,
  CMYK: 2,
  LAB: 3,
  deviceN: 4,
  indexed: 5,
  patterned: 6,
  unknown: -1
};

//import AVAudioNodeBus from './AVAudioNodeBus'
//import AVAudioFrameCount from './AVAudioFrameCount'
//import AVAudioNodeTapBlock from './AVAudioNodeTapBlock'
//import AVAudioTime from './AVAudioTime'
//import AUAudioUnit from './AUAudioUnit'

/**
 * The AVAudioNode class is an abstract class for an audio generation, processing, or I/O block.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/avfoundation/avaudionode
 */

class AVAudioNode extends NSObject {
  /**
   * constructor
   * @access public
   * @constructor
   */
  constructor() {
    super(); // Configuring an Input Format Bus

    this._numberOfInputs = 0; // Creating and Output Format Bus

    this._numberOfOutputs = 0; // Getting the Audio Engine for the Node

    this._engine = null; // Getting the Latest Node Render Time

    this._lastRenderTime = null; // Instance Properties

    this._auAudioUnit = null;
    this._latency = 0;
    this._outputPresentationLatency = 0;
  } // Configuring an Input Format Bus

  /**
   * Returns the input format for the specified bus.
   * @access public
   * @param {AVAudioNodeBus} bus - The bus.
   * @returns {AVAudioFormat} - 
   * @see https://developer.apple.com/documentation/avfoundation/avaudionode/1390147-inputformat
   */


  inputFormatForBus(bus) {
    return null;
  }
  /**
   * The name of an input bus.
   * @access public
   * @param {AVAudioNodeBus} bus - The input bus.
   * @returns {?string} - 
   * @see https://developer.apple.com/documentation/avfoundation/avaudionode/1387710-name
   */


  nameForInputBus(bus) {
    return null;
  }
  /**
   * The number of input busses for the node.
   * @type {number}
   * @desc 
   * @see https://developer.apple.com/documentation/avfoundation/avaudionode/1390585-numberofinputs
   */


  get numberOfInputs() {
    return this._numberOfInputs;
  } // Creating and Output Format Bus

  /**
   * Returns the output format for the specified bus.
   * @access public
   * @param {AVAudioNodeBus} bus - The bus.
   * @returns {AVAudioFormat} - 
   * @see https://developer.apple.com/documentation/avfoundation/avaudionode/1389195-outputformat
   */


  outputFormatForBus(bus) {
    return null;
  }
  /**
   * The name of the output bus.
   * @access public
   * @param {AVAudioNodeBus} bus - The output bus.
   * @returns {?string} - 
   * @see https://developer.apple.com/documentation/avfoundation/avaudionode/1390811-name
   */


  nameForOutputBus(bus) {
    return null;
  }
  /**
   * The number of output busses for the node.
   * @type {number}
   * @desc 
   * @see https://developer.apple.com/documentation/avfoundation/avaudionode/1385916-numberofoutputs
   */


  get numberOfOutputs() {
    return this._numberOfOutputs;
  } // Installing and Removing An Audio Tap

  /**
   * Installs an audio tap on the bus to record. monitor, and observe the output of the node
   * @access public
   * @param {AVAudioNodeBus} bus - The node output bus to which to attach the tap.
   * @param {AVAudioFrameCount} bufferSize - The requested size of the incoming buffers. The implementation may choose another size.
   * @param {?AVAudioFormat} format - If non-nil, attempts to apply this as the format of the specified output bus.This should only be done when attaching to an output bus which is not connected to another node; an error will result otherwise. The tap and connection formats (if non-nil) on the specified bus should be identical. Otherwise, the latter operation will override any previously set format.For AVAudioOutputNode, tap format must be specified as nil.
   * @param {AVAudioNodeTapBlock} tapBlock - A block to be called with audio buffers. See AVAudioNodeTapBlock for the block parameters.
   * @returns {void}
   * @desc Only one tap may be installed on any bus. Taps may be safely installed and removed while the engine is running.AVAudioEngine *engine = [[AVAudioEngine alloc] init];
  AVAudioInputNode *input = [engine inputNode];
  AVAudioFormat *format = [input outputFormatForBus: 0];
  [input installTapOnBus: 0 bufferSize: 8192 format: format block: ^(AVAudioPCMBuffer *buf, AVAudioTime *when) {
  // ‘buf' contains audio captured from input node at time 'when'
  }];
  ....
  // start engine
  ImportantThe tapBlock may be invoked on a thread other than the main thread.AVAudioEngine *engine = [[AVAudioEngine alloc] init];
  AVAudioInputNode *input = [engine inputNode];
  AVAudioFormat *format = [input outputFormatForBus: 0];
  [input installTapOnBus: 0 bufferSize: 8192 format: format block: ^(AVAudioPCMBuffer *buf, AVAudioTime *when) {
  // ‘buf' contains audio captured from input node at time 'when'
  }];
  ....
  // start engine
    * @see https://developer.apple.com/documentation/avfoundation/avaudionode/1387122-installtap
   */


  installTapOnBusBlock(bus, bufferSize, format, tapBlock) {}
  /**
   * Removes an audio tap on a bus.
   * @access public
   * @param {AVAudioNodeBus} bus - The node output bus whose tap is to be removed.
   * @returns {void}
   * @see https://developer.apple.com/documentation/avfoundation/avaudionode/1388717-removetap
   */


  removeTapOnBus(bus) {} // Getting the Audio Engine for the Node

  /**
   * The audio engine of the node.
   * @type {?AVAudioEngine}
   * @desc Returns nil if the node is not attached to an audio engine.
   * @see https://developer.apple.com/documentation/avfoundation/avaudionode/1386896-engine
   */


  get engine() {
    return this._engine;
  } // Getting the Latest Node Render Time

  /**
   * The time for which the node most recently rendered.
   * @type {?AVAudioTime}
   * @desc Return nil if the engine is not running or if the node is not connected to an input or output node.
   * @see https://developer.apple.com/documentation/avfoundation/avaudionode/1385978-lastrendertime
   */


  get lastRenderTime() {
    return this._lastRenderTime;
  } // Reset the Audio Node

  /**
   * Clear a unit's previous processing state.
   * @access public
   * @returns {void}
   * @see https://developer.apple.com/documentation/avfoundation/avaudionode/1385976-reset
   */


  reset() {} // Instance Properties

  /**
   * 
   * @type {AUAudioUnit}
   * @desc 
   * @see https://developer.apple.com/documentation/avfoundation/avaudionode/2866396-auaudiounit
   */


  get auAudioUnit() {
    return this._auAudioUnit;
  }
  /**
   * 
   * @type {number}
   * @desc 
   * @see https://developer.apple.com/documentation/avfoundation/avaudionode/2875482-latency
   */


  get latency() {
    return this._latency;
  }
  /**
   * 
   * @type {number}
   * @desc 
   * @see https://developer.apple.com/documentation/avfoundation/avaudionode/2875483-outputpresentationlatency
   */


  get outputPresentationLatency() {
    return this._outputPresentationLatency;
  }

}

class AVAudioMixerNode extends AVAudioNode {
  constructor() {
    super();
    this._gainNode = null;
  }

  get volume() {
    return this._gainNode.gain.value;
  }

  set volume(newValue) {
    this._gainNode.gain.value = newValue;
  }

}

const baseTime = Date.UTC(2001, 0, 1, 0, 0, 0, 0);
/**
 * Returns the current system absolute time.
 * @access public
 * @returns {number} - The current absolute time.
 * @desc Absolute time is measured in seconds relative to the absolute reference date of Jan 1 2001 00:00:00 GMT. A positive value represents a date after the reference date, a negative value represents a date before it. For example, the absolute time -32940326 is equivalent to December 16th, 1999 at 17:54:34. Repeated calls to this function do not guarantee monotonically increasing results. The system time may decrease due to synchronization with external time references or due to an explicit user change of the clock.
 * @see https://developer.apple.com/documentation/corefoundation/1543542-cfabsolutetimegetcurrent
 */

function CFAbsoluteTimeGetCurrent() {
  return (Date.now() - baseTime) * 0.001;
}

/**
 * Compositing operations for images.
 * @typedef {Object} CGBlendMode
 * @property {number} normal - Paints the source image samples over the background image samples.
 * @property {number} multiply - Multiplies the source image samples with the background image samples. This results in colors that are at least as dark as either of the two contributing sample colors.
 * @property {number} screen - Multiplies  the inverse of the source image samples with the inverse of the background image samples. This results in colors that are at least as light as either of the two contributing sample colors.
 * @property {number} overlay - 
 * @property {number} darken - 
 * @property {number} lighten - 
 * @property {number} colorDodge - Brightens the background image samples to reflect the source image samples. Source image sample values that specify black do not produce a change.
 * @property {number} colorBurn - Darkens the background image samples to reflect the source image samples. Source image sample values that specify white do not produce a change.
 * @property {number} softLight - 
 * @property {number} hardLight - 
 * @property {number} difference - 
 * @property {number} exclusion - Produces an effect similar to that produced by difference, but with lower contrast. Source image sample values that are black don’t produce a change; white inverts the background color values.
 * @property {number} hue - Uses the luminance and saturation values of the background with the hue of the source image.
 * @property {number} saturation - Uses the luminance and hue values of the background with the saturation of the source image. Areas of the background that have no saturation (that is, pure gray areas) don’t produce a change.
 * @property {number} color - Uses the luminance values of the background with the hue and saturation values of the source image. This mode preserves the gray levels in the image. You can use this mode to color monochrome images or to tint color images.
 * @property {number} luminosity - Uses the hue and saturation of the background with the luminance of the source image. This mode creates an effect that is inverse to the effect created by color.
 * @property {number} clear - R = 0
 * @property {number} copy - R = S
 * @property {number} sourceIn - R = S*Da
 * @property {number} sourceOut - R = S*(1 - Da)
 * @property {number} sourceAtop - R = S*Da + D*(1 - Sa)
 * @property {number} destinationOver - R = S*(1 - Da) + D
 * @property {number} destinationIn - R = D*Sa
 * @property {number} destinationOut - R = D*(1 - Sa)
 * @property {number} destinationAtop - R = S*(1 - Da) + D*Sa
 * @property {number} xor - R = S*(1 - Da) + D*(1 - Sa). This XOR mode is only nominally related to the classical bitmap XOR operation, which is not supported by Core Graphics
 * @property {number} plusDarker - R = MAX(0, 1 - ((1 - D) + (1 - S)))
 * @property {number} plusLighter - R = MIN(1, S + D)
 * @see https://developer.apple.com/documentation/coregraphics/cgblendmode
 */

const CGBlendMode = {
  normal: 0,
  multiply: 1,
  screen: 2,
  overlay: 3,
  darken: 4,
  lighten: 5,
  colorDodge: 6,
  colorBurn: 7,
  softLight: 8,
  hardLight: 9,
  difference: 10,
  exclusion: 11,
  hue: 12,
  saturation: 13,
  color: 14,
  luminosity: 15,
  clear: 16,
  copy: 17,
  sourceIn: 18,
  sourceOut: 19,
  sourceAtop: 20,
  destinationOver: 21,
  destinationIn: 22,
  destinationOut: 23,
  destinationAtop: 24,
  xor: 25,
  plusDarker: 26,
  plusLighter: 27
};

/**
 * Styles for rendering the endpoint of a stroked line.
 * @typedef {Object} CGLineCap
 * @property {number} butt - A line with a squared-off end. Core Graphics draws the line to extend only to the exact endpoint of the path. This is the default.
 * @property {number} round - A line with a rounded end. Core Graphics draws the line to extend beyond the endpoint of the path. The line ends with a semicircular arc with a radius of 1/2 the line’s width, centered on the endpoint.
 * @property {number} square - A line with a squared-off end. Core Graphics extends the line beyond the endpoint of the path for a distance equal to half the line width.
 * @see https://developer.apple.com/documentation/coregraphics/cglinecap
 */

const CGLineCap = {
  butt: 0,
  round: 1,
  square: 2
};

/**
 * Junction types for stroked lines.
 * @typedef {Object} CGLineJoin
 * @property {number} miter - 
 * @property {number} round - A join with a rounded end. Core Graphics draws the line to extend beyond the endpoint of the path. The line ends with a semicircular arc with a radius of 1/2 the line’s width, centered on the endpoint.
 * @property {number} bevel - A join with a squared-off end. Core Graphics draws the line to extend beyond the endpoint of the path, for a distance of 1/2 the line’s width.
 * @see https://developer.apple.com/documentation/coregraphics/cglinejoin
 */

const CGLineJoin = {
  miter: 0,
  round: 1,
  bevel: 2
};

/**
 * A mutable graphics path: a mathematical description of shapes or lines to be drawn in a graphics context.
 * @access public
 * @see https://developer.apple.com/documentation/coregraphics/cgmutablepath
 */

class CGMutablePath {
  // Creating Graphics Paths

  /**
   * Creates a mutable graphics path.
   * @access public
   * @constructor
   * @see https://developer.apple.com/documentation/coregraphics/cgmutablepath/1411209-init
   */
  constructor() {} // Copying a Graphics Path

  /**
   * Creates a mutable copy of an existing graphics path.
   * @access public
   * @returns {?CGMutablePath} - 
   * @desc You can modify a mutable graphics path by calling the various path geometry functions, such as addArc(_:x:y:radius:startAngle:endAngle:clockwise:), addLineTo(_:x:y:), and moveTo(_:x:y:).
   * @see https://developer.apple.com/documentation/coregraphics/cgpath/1411196-mutablecopy
   */


  mutableCopy() {
    return null;
  }
  /**
   * Creates a mutable copy of a graphics path transformed by a transformation matrix.
   * @access public
   * @param {?UnsafePointer<CGAffineTransform>} transform - A pointer to an affine transformation matrix, or NULL if no transformation is needed. If specified, Core Graphics applies the transformation to all elements of the new path.
   * @returns {?CGMutablePath} - 
   * @see https://developer.apple.com/documentation/coregraphics/cgpath/1411150-mutablecopy
   */


  mutableCopyUsing(transform) {
    return null;
  } // Constructing a Graphics Path

  /**
   * Begins a new subpath at the specified point.  
   * @access public
   * @param {CGPoint} point - The point, in user space coordinates, at which to start a new subpath.
   * @param {CGAffineTransform} transform - An affine transform to apply to the point before adding to the path. Defaults to the identity transform if not specified.
   * @returns {void}
   * @desc The specified point becomes the start point of a new subpath. The current point is set to this start point.
   * @see https://developer.apple.com/documentation/coregraphics/cgmutablepath/2427143-move
   */


  moveTo(point, transform) {}
  /**
   * Appends a straight line segment from the current point to the specified point. 
   * @access public
   * @param {CGPoint} point - The location, in user space coordinates, for the end of the new line segment.
   * @param {CGAffineTransform} transform - An affine transform to apply to the point before adding to the path. Defaults to the identity transform if not specified.
   * @returns {void}
   * @desc After adding the line segment, the current point is set to the endpoint of the line segment.
   * @see https://developer.apple.com/documentation/coregraphics/cgmutablepath/2427121-addline
   */


  addLineTo(point, transform) {}
  /**
   * Adds a sequence of connected straight-line segments to the path. 
   * @access public
   * @param {CGPoint[]} points - An array of values that specify the start and end points of the line segments to draw. Each point in the array specifies a position in user space. The first point in the array specifies the initial starting point.
   * @param {CGAffineTransform} transform - An affine transform to apply to the points before adding to the path. Defaults to the identity transform if not specified.
   * @returns {void}
   * @desc Calling this convenience method is equivalent to calling the move(to:transform:) method with the first value in the points array, then calling the addLine(to:transform:) method for each subsequent point until the array is exhausted. After calling this method, the path's current point is the last point in the array.
   * @see https://developer.apple.com/documentation/coregraphics/cgmutablepath/2427154-addlines
   */


  addLinesBetween(points, transform) {}
  /**
   * Adds a rectangular subpath to the path. 
   * @access public
   * @param {CGRect} rect - A rectangle, specified in user space coordinates.
   * @param {CGAffineTransform} transform - An affine transform to apply to the rectangle before adding to the path. Defaults to the identity transform if not specified.
   * @returns {void}
   * @desc This is a convenience function that adds a rectangle to a path, starting by moving to the bottom left corner and then adding lines counter-clockwise to create a rectangle, closing the subpath.
   * @see https://developer.apple.com/documentation/coregraphics/cgmutablepath/2427119-addrect
   */


  addRect(rect, transform) {}
  /**
   * Adds a set of rectangular subpaths to the path. 
   * @access public
   * @param {CGRect[]} rects - An array of rectangles, specified in user space coordinates.
   * @param {CGAffineTransform} transform - An affine transform to apply to the rectangles before adding to the path. Defaults to the identity transform if not specified.
   * @returns {void}
   * @desc Calling this convenience method is equivalent to repeatedly calling the addRect(_:transform:) method for each rectangle in the array.
   * @see https://developer.apple.com/documentation/coregraphics/cgmutablepath/2427131-addrects
   */


  addRects(rects, transform) {}
  /**
   * Adds an ellipse that fits inside the specified rectangle. 
   * @access public
   * @param {CGRect} rect - A rectangle that defines the area for the ellipse to fit in.
   * @param {CGAffineTransform} transform - An affine transform to apply to the ellipse before adding to the path. Defaults to the identity transform if not specified.
   * @returns {void}
   * @desc The ellipse is approximated by a sequence of Bézier curves. Its center is the midpoint of the rectangle defined by the rect parameter. If the rectangle is square, then the ellipse is circular with a radius equal to one-half the width (or height) of the rectangle. If the rect parameter specifies a rectangular shape, then the major and minor axes of the ellipse are defined by the width and height of the rectangle.The ellipse forms a complete subpath of the path—that is, the ellipse drawing starts with a move-to operation and ends with a close-subpath operation, with all moves oriented in the clockwise direction.
   * @see https://developer.apple.com/documentation/coregraphics/cgmutablepath/2427120-addellipse
   */


  addEllipseIn(rect, transform) {}
  /**
   *  Adds a subpath to the path, in the shape of a rectangle with rounded corners.
   * @access public
   * @param {CGRect} rect - The rectangle to add, specified in user space coordinates.
   * @param {number} cornerWidth - The horizontal size, in user space coordinates, for rounded corner sections.
   * @param {number} cornerHeight - The vertical size, in user space coordinates, for rounded corner sections.
   * @param {CGAffineTransform} transform - An affine transform to apply to the rectangle before adding to the path. Defaults to the identity transform if not specified.
   * @returns {void}
   * @desc This convenience method is equivalent to a move operation to start the subpath followed by a series of arc and line operations that construct the rounded rectangle. Each corner of the rounded rectangle is one-quarter of an ellipse with axes equal to the cornerWidth and cornerHeight parameters. The rounded rectangle forms a closed subpath oriented in the clockwise direction.
   * @see https://developer.apple.com/documentation/coregraphics/cgmutablepath/2427144-addroundedrect
   */


  addRoundedRectIn(rect, cornerWidth, cornerHeight, transform) {}
  /**
   * Adds an arc of a circle to the path, specified with a radius and angles. 
   * @access public
   * @param {CGPoint} center - The center of the arc, in user space coordinates.
   * @param {number} radius - The radius of the arc, in user space coordinates.
   * @param {number} startAngle - The angle to the starting point of the arc, measured in radians from the positive x-axis.
   * @param {number} endAngle - The angle to the end point of the arc, measured in radians from the positive x-axis.
   * @param {boolean} clockwise - true to make a clockwise arc; false to make a counterclockwise arc.
   * @param {CGAffineTransform} transform - An affine transform to apply to the arc before adding to the path. Defaults to the identity transform if not specified.
   * @returns {void}
   * @desc This method calculates starting and ending points using the radius and angles you specify, uses a sequence of cubic Bézier curves to approximate a segment of a circle between those points, and then appends those curves to the path.The clockwise parameter determines the direction in which the arc is created; the actual direction of the final path is dependent on the transform parameter and the current transform of a context where the path is drawn. In a flipped coordinate system (the default for UIView drawing methods in iOS), specifying a clockwise arc results in a counterclockwise arc after the transformation is applied.If the path already contains a subpath, this method adds a line connecting the current point to the starting point of the arc. If the current path is empty, his method creates a new subpath whose starting point is the starting point of the arc. The ending point of the arc becomes the new current point of the path.
   * @see https://developer.apple.com/documentation/coregraphics/cgmutablepath/2427140-addarc
   */


  addArc(center, radius, startAngle, endAngle, clockwise, transform) {}
  /**
   * Adds an arc of a circle to the path, specified with a radius and a difference in angle.  
   * @access public
   * @param {CGPoint} center - The center of the arc, in user space coordinates.
   * @param {number} radius - The radius of the arc, in user space coordinates.
   * @param {number} startAngle - The angle to the starting point of the arc, measured in radians from the positive x-axis.
   * @param {number} delta - The difference, measured in radians, between the starting angle and ending angle of the arc. A positive value creates a counter-clockwise arc (in user space coordinates), and vice versa.
   * @param {CGAffineTransform} transform - An affine transform to apply to the arc before adding to the path. Defaults to the identity transform if not specified.
   * @returns {void}
   * @desc This method calculates starting and ending points using the radius and angles you specify, uses a sequence of cubic Bézier curves to approximate a segment of a circle between those points, and then appends those curves to the path.The delta parameter determines both the length of the arc the direction in which the arc is created; the actual direction of the final path is dependent on the transform parameter and the current transform of a context where the path is drawn. In a flipped coordinate system (the default for UIView drawing methods in iOS), specifying a clockwise arc results in a counterclockwise arc after the transformation is applied.If the path already contains a subpath, this method adds a line connecting the current point to the starting point of the arc. If the current path is empty, his method creates a new subpath whose starting point is the starting point of the arc. The ending point of the arc becomes the new current point of the path.
   * @see https://developer.apple.com/documentation/coregraphics/cgmutablepath/2427147-addrelativearc
   */


  addRelativeArc(center, radius, startAngle, delta, transform) {}
  /**
   * Adds a cubic Bézier curve to the path, with the specified end point and control points. 
   * @access public
   * @param {CGPoint} end - The point, in user space coordinates, at which to end the curve.
   * @param {CGPoint} control1 - The first control point of the curve, in user space coordinates.
   * @param {CGPoint} control2 - The second control point of the curve, in user space coordinates.
   * @param {CGAffineTransform} transform - An affine transform to apply to the curve before adding to the path. Defaults to the identity transform if not specified.
   * @returns {void}
   * @desc This method constructs a curve starting from the path's current point and ending at the specified end point, with curvature defined by the two control points. After this method appends that curve to the current path, the end point of the curve becomes the path's current point.
   * @see https://developer.apple.com/documentation/coregraphics/cgmutablepath/2427158-addcurve
   */


  addCurveTo(end, control1, control2, transform) {}
  /**
   * Adds a quadratic Bézier curve to the path, with the specified end point and control point. 
   * @access public
   * @param {CGPoint} end - The point, in user space coordinates, at which to end the curve.
   * @param {CGPoint} control - The control point of the curve, in user space coordinates.
   * @param {CGAffineTransform} transform - An affine transform to apply to the curve before adding to the path. Defaults to the identity transform if not specified.
   * @returns {void}
   * @desc This method constructs a curve starting from the path's current point and ending at the specified end point, with curvature defined by the control point. After this method appends that curve to the current path, the end point of the curve becomes the path's current point.
   * @see https://developer.apple.com/documentation/coregraphics/cgmutablepath/2427128-addquadcurve
   */


  addQuadCurveTo(end, control, transform) {}
  /**
   * Appends another path object to the path. 
   * @access public
   * @param {CGPath} path - The path to add.
   * @param {CGAffineTransform} transform - An affine transform to apply to the path parameter before adding to this path. Defaults to the identity transform if not specified.
   * @returns {void}
   * @desc If the path parameter is a non-empty empty path, its path elements are appended in order to this path. Afterward, the start point and current point of this path are those of the last subpath in the path parameter.
   * @see https://developer.apple.com/documentation/coregraphics/cgmutablepath/2427150-addpath
   */


  addPath(path, transform) {}
  /**
   * Closes and completes a subpath in a mutable graphics path.
   * @access public
   * @returns {void}
   * @desc Appends a line from the current point to the starting point of the current subpath and ends the subpath. After closing the subpath, your application can begin a new subpath without first calling moveTo(_:x:y:). In this case, a new subpath is implicitly created with a starting and current point equal to the previous subpath’s starting point.
   * @see https://developer.apple.com/documentation/coregraphics/cgmutablepath/1411188-closesubpath
   */


  closeSubpath() {}

}

//import CGLineCap from './CGLineCap'
//import CGLineJoin from './CGLineJoin'
//import CGMutablePath from './CGMutablePath'
//import CGPoint from './CGPoint'
//import CGPathFillRule from './CGPathFillRule'
//import CGPathApplierFunction from './CGPathApplierFunction'

const _typeID = null;
/**
 * An immutable graphics path: a mathematical description of shapes or lines to be drawn in a graphics context.
 * @access public
 * @see https://developer.apple.com/documentation/coregraphics/cgpath
 */

class CGPath {
  // Creating Graphics Paths

  /**
   * Create an immutable path of a rectangle.
   * @access public
   * @constructor
   * @param {CGRect} rect - The rectangle to add.
   * @param {?UnsafePointer<CGAffineTransform>} transform - A pointer to an affine transformation matrix, or NULL if no transformation is needed. If specified, Core Graphics applies the transformation to the rectangle before it is added to the path.
   * @desc This is a convenience function that creates a path of an rectangle. Using this convenience function is more efficient than creating a mutable path and adding an rectangle to it.Calling this function is equivalent to using minX and related functions to find the corners of the rectangle, then using the moveTo(_:x:y:), addLineTo(_:x:y:), and closeSubpath() functions to draw the rectangle. 
   * @see https://developer.apple.com/documentation/coregraphics/cgpath/1411155-init
   */
  constructor(rect, transform) {
    // Examining a Graphics Path
    this._boundingBox = null;
    this._boundingBoxOfPath = null;
    this._currentPoint = null;
    this._isEmpty = false;
  }
  /**
   * Create an immutable path of an ellipse.
   * @access public
   * @param {CGRect} rect - The rectangle that bounds the ellipse.
   * @param {?UnsafePointer<CGAffineTransform>} transform - A pointer to an affine transformation matrix, or NULL if no transformation is needed. If specified, Core Graphics applies the transformation to the ellipse before it is added to the path.
   * @returns {void}
   * @desc This is a convenience function that creates a path of an ellipse. Using this convenience function is more efficient than creating a mutable path and adding an ellipse to it.The ellipse is approximated by a sequence of Bézier curves. Its center is the midpoint of the rectangle defined by the rect parameter. If the rectangle is square, then the ellipse is circular with a radius equal to one-half the width (or height) of the rectangle. If the rect parameter specifies a rectangular shape, then the major and minor axes of the ellipse are defined by the width and height of the rectangle. The ellipse forms a complete subpath of the path—that is, the ellipse drawing starts with a move-to operation and ends with a close-subpath operation, with all moves oriented in the clockwise direction. If you supply an affine transform, then the constructed Bézier curves that define the ellipse are transformed before they are added to the path.
   * @see https://developer.apple.com/documentation/coregraphics/cgpath/1411177-init
   */


  initEllipseIn(rect, transform) {
    // Examining a Graphics Path
    this._boundingBox = null;
    this._boundingBoxOfPath = null;
    this._currentPoint = null;
    this._isEmpty = false;
  }
  /**
   * Create an immutable path of a rounded rectangle.
   * @access public
   * @param {CGRect} rect - The rectangle to add.
   * @param {number} cornerWidth - The width of the rounded corner sections.
   * @param {number} cornerHeight - The height of the rounded corner sections.
   * @param {?UnsafePointer<CGAffineTransform>} transform - A pointer to an affine transformation matrix, or NULL if no transformation is needed. If specified, Core Graphics applies the transformation to the rectangle before it is added to the path.
   * @returns {void}
   * @desc This is a convenience function that creates a path of an rounded rectangle. Using this convenience function is more efficient than creating a mutable path and adding an rectangle to it.Each corner of the rounded rectangle is one-quarter of an ellipse with axes equal to the cornerWidth and cornerHeight parameters. The rounded rectangle forms a complete subpath and is oriented in the clockwise direction.
   * @see https://developer.apple.com/documentation/coregraphics/cgpath/1411218-init
   */


  initRoundedRect(rect, cornerWidth, cornerHeight, transform) {
    // Examining a Graphics Path
    this._boundingBox = null;
    this._boundingBoxOfPath = null;
    this._currentPoint = null;
    this._isEmpty = false;
  } // Copying a Graphics Path

  /**
   * Creates an immutable copy of a graphics path.
   * @access public
   * @returns {?CGPath} - 
   * @see https://developer.apple.com/documentation/coregraphics/cgpath/1411211-copy
   */


  copy() {
    return null;
  }
  /**
   * Creates an immutable copy of a graphics path transformed by a transformation matrix.
   * @access public
   * @param {?UnsafePointer<CGAffineTransform>} transform - A pointer to an affine transformation matrix, or NULL if no transformation is needed. If specified, Core Graphics applies the transformation to all elements of the new path.
   * @returns {?CGPath} - 
   * @see https://developer.apple.com/documentation/coregraphics/cgpath/1411161-copy
   */


  copyUsing(transform) {
    return null;
  }
  /**
   * Returns a new path equivalent to the results of drawing the path with a dashed stroke.
   * @access public
   * @param {number} phase - A value that specifies how far into the dash pattern the line starts, in units of the user space. For example, a value of 0 draws a line starting with the beginning of a dash pattern, and a value of 3 means the line is drawn with the dash pattern starting at three units from its beginning. 
   * @param {number[]} lengths - An array of values that specify the lengths, in user space coordinates, of the painted and unpainted segments  of the dash pattern.For example, the array [2,3] sets a dash pattern that alternates between a 2-unit-long painted segment and a 3-unit-long unpainted segment. The array [1,3,4,2] sets the pattern to a 1-unit painted segment, a 3-unit unpainted segment, a 4-unit painted segment, and a 2-unit unpainted segment.Pass an empty array to clear the dash pattern so that all stroke drawing in the context uses solid lines.
   * @param {CGAffineTransform} transform - An affine transform to apply to the path before dashing. Defaults to the identity transform if not specified.
   * @returns {CGPath} - 
   * @desc The new path is created so that filling the new path draws the same pixels as stroking the original path with the specified dash parameters.
   * @see https://developer.apple.com/documentation/coregraphics/cgpath/2427137-copy
   */


  copyDashingWithPhase(phase, lengths, transform) {
    return null;
  }
  /**
   * Returns a new path equivalent to the results of drawing the path with a solid stroke. 
   * @access public
   * @param {number} lineWidth - The line width to use, in user space units. The value must be greater than 0.
   * @param {CGLineCap} lineCap - The line cap style to render. (For equivalent CGContext drawing methods, the default style is butt.) 
   * @param {CGLineJoin} lineJoin - The line join style to render. (For equivalent CGContext drawing methods, the default style is miter.) 
   * @param {number} miterLimit - A value that limits how sharp individual corners in the path can be when using the miter line join style. When the ratio of a the length required for a mitered corner to the line width exceeds this value, that corner uses the bevel style instead.
   * @param {CGAffineTransform} transform - An affine transform to apply to the path before dashing. Defaults to the identity transform if not specified.
   * @returns {CGPath} - 
   * @desc The new path is created so that filling the new path draws the same pixels as stroking the original path with the specified line style.
   * @see https://developer.apple.com/documentation/coregraphics/cgpath/2427133-copy
   */


  copyStrokingWithWidth(lineWidth, lineCap, lineJoin, miterLimit, transform) {
    return null;
  }
  /**
   * Creates a mutable copy of an existing graphics path.
   * @access public
   * @returns {?CGMutablePath} - 
   * @desc You can modify a mutable graphics path by calling the various path geometry functions, such as addArc(_:x:y:radius:startAngle:endAngle:clockwise:), addLineTo(_:x:y:), and moveTo(_:x:y:).
   * @see https://developer.apple.com/documentation/coregraphics/cgpath/1411196-mutablecopy
   */


  mutableCopy() {
    return null;
  }
  /**
   * Creates a mutable copy of a graphics path transformed by a transformation matrix.
   * @access public
   * @param {?UnsafePointer<CGAffineTransform>} transform - A pointer to an affine transformation matrix, or NULL if no transformation is needed. If specified, Core Graphics applies the transformation to all elements of the new path.
   * @returns {?CGMutablePath} - 
   * @see https://developer.apple.com/documentation/coregraphics/cgpath/1411150-mutablecopy
   */


  mutableCopyUsing(transform) {
    return null;
  } // Examining a Graphics Path

  /**
   * Returns whether the specified point is interior to the path.
   * @access public
   * @param {CGPoint} point - The point to check.
   * @param {CGPathFillRule} rule - The rule for determining which areas to treat as the interior of the path. Defaults to the winding rule if not specified.
   * @param {CGAffineTransform} transform - An affine transform to apply to the point before checking for containment in the path. Defaults to the identity transform if not specified.
   * @returns {boolean} - 
   * @desc A point is contained in a path if it would be inside the painted region when the path is filled.
   * @see https://developer.apple.com/documentation/coregraphics/cgpath/2427117-contains
   */


  containsUsing(point, rule, transform) {
    return false;
  }
  /**
   * Indicates whether or not a graphics path represents a rectangle.
   * @access public
   * @param {?UnsafeMutablePointer<CGRect>} rect - On input, a pointer to an uninitialized rectangle. If the specified path represents a rectangle, on return contains a copy of the rectangle. 
   * @returns {boolean} - 
   * @see https://developer.apple.com/documentation/coregraphics/cgpath/1411163-isrect
   */


  isRect(rect) {
    return false;
  }
  /**
   * Returns the bounding box containing all points in a graphics path.
   * @type {CGRect}
   * @desc The bounding box is the smallest rectangle completely enclosing all points in the path, including control points for Bézier and quadratic curves. 
   * @see https://developer.apple.com/documentation/coregraphics/cgpath/1411165-boundingbox
   */


  get boundingBox() {
    return this._boundingBox;
  }
  /**
   * Returns the bounding box of a graphics path.
   * @type {CGRect}
   * @desc The path bounding box is the smallest rectangle completely enclosing all points in the path but not including control points for Bézier and quadratic curves. 
   * @see https://developer.apple.com/documentation/coregraphics/cgpath/1411200-boundingboxofpath
   */


  get boundingBoxOfPath() {
    return this._boundingBoxOfPath;
  }
  /**
   * Returns the current point in a graphics path.
   * @type {CGPoint}
   * @desc If the path is empty—that is, if it has no elements—this function returns CGPointZero (see CGGeometry). To determine whether a path is empty, use isEmpty.
   * @see https://developer.apple.com/documentation/coregraphics/cgpath/1411132-currentpoint
   */


  get currentPoint() {
    return this._currentPoint;
  }
  /**
   * Indicates whether or not a graphics path is empty.
   * @type {boolean}
   * @desc An empty path contains no elements.
   * @see https://developer.apple.com/documentation/coregraphics/cgpath/1411149-isempty
   */


  get isEmpty() {
    return this._isEmpty;
  } // Applying a Function to the Elements of a Path

  /**
   * For each element in a graphics path, calls a custom applier function.
   * @access public
   * @param {?Object} info - A pointer to the user data that Core Graphics will pass to the function being applied, or NULL.
   * @param {CGPathApplierFunction} _function - 
   * @returns {void}
   * @desc For each element in the specified path, Core Graphics calls the applier function, which can examine (but not modify) the element.
   * @see https://developer.apple.com/documentation/coregraphics/cgpath/1411203-apply
   */


  apply(info, _function) {} // Working with Core Foundation Types

  /**
   * Returns the Core Foundation type identifier for Core Graphics graphics paths.
   * @type {CFTypeID}
   * @desc 
   * @see https://developer.apple.com/documentation/coregraphics/cgpath/1411192-typeid
   */


  static get typeID() {
    return _typeID;
  } // Initializers

  /**
   * Creates a dashed copy of another path.
   * @access public
   * @param {CGPath} path - The path to copy.
   * @param {?UnsafePointer<CGAffineTransform>} transform - A pointer to an affine transformation matrix, or NULL if no transformation is needed. If specified, Core Graphics applies the transformation to elements of the converted path before adding them to the new path.
   * @param {number} phase - A value that specifies how far into the dash pattern the line starts, in units of the user space. For example, passing a value of 3 means the line is drawn with the dash pattern starting at three units from its beginning. Passing a value of 0 draws a line starting with the beginning of a dash pattern.
   * @param {?UnsafePointer<CGFloat>} lengths - An array of values that specify the lengths of the painted segments and unpainted segments, respectively, of the dash pattern—or NULL for no dash pattern.For example, passing an array with the values [2,3] sets a dash pattern that alternates between a 2-user-space-unit-long painted segment and a 3-user-space-unit-long unpainted segment. Passing the values [1,3,4,2] sets the pattern to a 1-unit painted segment, a 3-unit unpainted segment, a 4-unit painted segment, and a 2-unit unpainted segment.
   * @param {number} count - If the lengths parameter specifies an array, pass the number of elements in the array. Otherwise, pass 0.
   * @returns {void}
   * @desc The new path is created so that filling the new path draws the same pixels as stroking the original path with the specified dash parameters.
   * @see https://developer.apple.com/documentation/coregraphics/cgpath/1411134-init
   */


  init__byDashing(path, transform, phase, lengths, count) {
    // Examining a Graphics Path
    this._boundingBox = null;
    this._boundingBoxOfPath = null;
    this._currentPoint = null;
    this._isEmpty = false;
  }
  /**
   * Creates a stroked copy of another path.
   * @access public
   * @param {CGPath} path - The path to copy.
   * @param {?UnsafePointer<CGAffineTransform>} transform - A pointer to an affine transformation matrix, or NULL if no transformation is needed. If specified, Core Graphics applies the transformation to elements of the converted path before adding them to the new path.
   * @param {number} lineWidth - The line width to use, in user space units. The value must be greater than 0.
   * @param {CGLineCap} lineCap - A line cap style constant—butt (the default), round, or square. 
   * @param {CGLineJoin} lineJoin - A line join value—miter (the default), round, or bevel. 
   * @param {number} miterLimit - The miter limit to use.
   * @returns {void}
   * @desc The new path is created so that filling the new path draws the same pixels as stroking the original path.If the line join style is set to kCGLineJoinMiter, Core Graphics uses the miter limit to determine whether the lines should be joined with a bevel instead of a miter. Core Graphics divides the length of the miter by the line width. If the result is greater than the miter limit, Core Graphics converts the style to a bevel. 
   * @see https://developer.apple.com/documentation/coregraphics/cgpath/1411128-init
   */


  init__byStroking(path, transform, lineWidth, lineCap, lineJoin, miterLimit) {
    // Examining a Graphics Path
    this._boundingBox = null;
    this._boundingBoxOfPath = null;
    this._currentPoint = null;
    this._isEmpty = false;
  }

}

/**
 * Defines a callback function that can view an element in a graphics path.
 * @type {function(): void}
 * @returns {void}
 * @see https://developer.apple.com/documentation/coregraphics/cgpathapplierfunction
 */

const CGPathApplierFunction = () => {};

/**
 * Rules for determining which regions are interior to a path, used by the fillPath(using:) and clip(using:) methods.
 * @typedef {Object} CGPathFillRule
 * @property {number} evenOdd - A rule that considers a region to be interior to a path based on the number of times it is enclosed by path elements.
 * @property {number} winding - A rule that considers a region to be interior to a path if the winding number for that region is nonzero.
 * @see https://developer.apple.com/documentation/coregraphics/cgpathfillrule
 */

const CGPathFillRule = {
  evenOdd: 1,
  winding: 0
};

/**
 * A structure that contains a point in a two-dimensional coordinate system.
 * @access public
 * @see https://developer.apple.com/documentation/coregraphics/cgpoint
 */

class CGPoint {
  // Creating Point Values

  /**
   * Creates a point with coordinates specified as integer values.   
   * @access public
   * @constructor
   * @param {number} x - 
   * @param {number} y - 
   * @see https://developer.apple.com/documentation/coregraphics/cgpoint/1455965-init
   */
  constructor(x = 0, y = 0) {
    // Geometric Properties
    this.x = x;
    this.y = y;
  } // Special Values

  /**
   * The point with location (0,0).
   * @type {CGPoint}
   * @desc 
   * @see https://developer.apple.com/documentation/coregraphics/cgpoint/1454433-zero
   */


  static get zero() {
    return new CGPoint(0, 0);
  } // Geometric Properties
  // Transforming Points

  /**
   * Returns the point resulting from an affine transformation of an existing point.
   * @access public
   * @param {CGAffineTransform} t - The affine transform to apply. 
   * @returns {CGPoint} - 
   * @see https://developer.apple.com/documentation/coregraphics/cgpoint/1454251-applying
   */


  applying(t) {
    return null;
  } // Alternate Representations

  /**
   * Creates a point from a canonical dictionary representation.
   * @access public
   * @param {Map} dict - A dictionary containing x and y values for the point to create, in the format used by the dictionaryRepresentation property.
   * @returns {void}
   * @see https://developer.apple.com/documentation/coregraphics/cgpoint/2427118-init
   */


  static pointWithDictionaryRepresentation(dict) {
    return new CGPoint(dict.get('x'), dict.get('y'));
  }
  /**
   * Returns a dictionary representation of the specified point.
   * @type {Map}
   * @desc 
   * @see https://developer.apple.com/documentation/coregraphics/cgpoint/1455382-dictionaryrepresentation
   */


  get dictionaryRepresentation() {
    const map = new Map();
    map.set('x', this.x);
    map.set('y', this.y);
    return map;
  }
  /**
   * A textual representation of the point's coordinate values. 
   * @type {string}
   * @desc 
   * @see https://developer.apple.com/documentation/coregraphics/cgpoint/1645825-debugdescription
   */


  get debugDescription() {
    return `{x: ${this.x}, y: ${this.y}}`;
  }
  /**
   * A representation of the point's structure and display style for use in debugging.
   * @type {Mirror}
   * @desc Mirrors are used by playgrounds and the debugger.
   * @see https://developer.apple.com/documentation/coregraphics/cgpoint/1645834-custommirror
   */


  get customMirror() {
    return null;
  }
  /**
   * A representation of the point for use in Playgrounds.
   * @type {PlaygroundQuickLook}
   * @desc 
   * @see https://developer.apple.com/documentation/coregraphics/cgpoint/1645835-customplaygroundquicklook
   */


  get customPlaygroundQuickLook() {
    return null;
  } // Comparing Points

  /**
   * Returns whether two points are equal. 
   * @access public
   * @param {CGPoint} point2 - 
   * @returns {boolean} - 
   * @see https://developer.apple.com/documentation/coregraphics/cgpoint/1456179-equalto
   */


  equalTo(point2) {
    const epsilon = 0.00001;
    return Math.abs(this.x - point2.x) < epsilon && Math.abs(this.y - point2.y) < epsilon;
  }
  /**
   * @access public
   * @returns {CGPoint} -
   */


  copy() {
    return new CGPoint(this.x, this.y);
  }

  zero() {
    return new CGPoint(0, 0);
  }
  /**
   * @access public
   * @param {CGPoint} p -
   * @returns {CGPoint} -
   */


  add(p) {
    const r = new CGPoint();
    r.x = this.x + p.x;
    r.y = this.y + p.y;
    return r;
  }
  /**
   * @access public
   * @param {CGPoint} p -
   * @returns {CGPoint} -
   */


  sub(p) {
    const r = new CGPoint();
    r.x = this.x - p.x;
    r.y = this.y - p.y;
    return r;
  }
  /**
   * @access public
   * @param {number} n -
   * @returns {CGPoint} -
   */


  mul(n) {
    const r = new CGPoint();
    r.x = this.x * n;
    r.y = this.y * n;
    return r;
  }
  /**
   * @access public
   * @param {CGPoint} p -
   * @returns {number} -
   */


  dot(p) {
    return this.x * p.x + this.y * p.y;
  }
  /**
   * @access public
   * @param {CGPoint} p -
   * @param {number} rate -
   * @returns {CGPoint} -
   */


  lerp(p, rate) {
    const r = new CGPoint();
    r.x = this.x + rate * (p.x - this.x);
    r.y = this.y + rate * (p.y - this.y);
    return r;
  }
  /**
   * @access public
   * @returns {CGPoint} -
   */


  normalize() {
    const len = this.length();
    const r = new CGPoint();

    if (len === 0) {
      return r;
    }

    const sqr = 1.0 / len;
    r.x = this.x * sqr;
    r.y = this.y * sqr;
    return r;
  }
  /**
   * @access public
   * @returns {number} -
   */


  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  /**
   * @access public
   * @returns {number[]} -
   */


  floatArray() {
    return [this.x, this.y];
  }
  /**
   * @access public
   * @returns {Float32Array} -
   */


  float32Array() {
    return new Float32Array([this.x, this.y]);
  }

}

/**
 * A structure that contains width and height values.
 * @access public
 * @see https://developer.apple.com/documentation/coregraphics/cgsize
 */

class CGSize {
  /**
   * @access private
   * @param {Buffer} data -
   * @param {number} [offset = 0] -
   * @param {boolean} [bigEndian = false] -
   * @returns {CGSize} -
   */
  static _initWithData(data, offset = 0, bigEndian = false) {
    throw new Error('not implemented');
  } // Initializers

  /**
   * Creates a size with dimensions specified as floating-point values.    
   * @access public
   * @constructor
   * @param {number} width - 
   * @param {number} height - 
   * @see https://developer.apple.com/documentation/coregraphics/cgsize/1454915-init
   */


  constructor(width, height) {
    // Geometric Properties
    this.width = width;
    this.height = height;
  } // Geometric Properties
  // Special Values

  /**
   * The size whose width and height are both zero.
   * @type {CGSize}
   * @desc 
   * @see https://developer.apple.com/documentation/coregraphics/cgsize/1455512-zero
   */


  static get zero() {
    return new CGSize(0, 0);
  } // Transforming Sizes

  /**
   * Returns the height and width resulting from a transformation of an existing height and width.
   * @access public
   * @param {CGAffineTransform} t - The affine transform to apply. 
   * @returns {CGSize} - 
   * @see https://developer.apple.com/documentation/coregraphics/cgsize/1454806-applying
   */


  applying(t) {
    return null;
  } // Alternate Representations

  /**
   * Creates a size from a canonical dictionary representation. 
   * @access public
   * @param {Map} dict - A dictionary containing width and height values for the size to create, in the format used by the dictionaryRepresentation property.
   * @returns {void}
   * @see https://developer.apple.com/documentation/coregraphics/cgsize/2427155-init
   */


  static sizeWithDictionaryRepresentation(dict) {
    return new CGSize(dict.get('width'), dict.get('height'));
  }
  /**
   * Returns a dictionary representation of the specified size.
   * @type {Map}
   * @desc 
   * @see https://developer.apple.com/documentation/coregraphics/cgsize/1455274-dictionaryrepresentation
   */


  get dictionaryRepresentation() {
    const map = new Map();
    map.set('width', this.width);
    map.set('height', this.height);
    return map;
  }
  /**
   * A textual representation of the size's dimensions.  
   * @type {string}
   * @desc 
   * @see https://developer.apple.com/documentation/coregraphics/cgsize/1645822-debugdescription
   */


  get debugDescription() {
    return `{width: ${this.width}, height: ${this.height}}`;
  }
  /**
   * A representation of the size's structure and display style for use in debugging. 
   * @type {Mirror}
   * @desc 
   * @see https://developer.apple.com/documentation/coregraphics/cgsize/1645828-custommirror
   */


  get customMirror() {
    return null;
  }
  /**
   * A representation of the size for use in Playgrounds. 
   * @type {PlaygroundQuickLook}
   * @desc 
   * @see https://developer.apple.com/documentation/coregraphics/cgsize/1645830-customplaygroundquicklook
   */


  get customPlaygroundQuickLook() {
    return null;
  } // Comparing Sizes

  /**
   * Returns whether two sizes are equal. 
   * @access public
   * @param {CGSize} size2 - 
   * @returns {boolean} - 
   * @see https://developer.apple.com/documentation/coregraphics/cgsize/1455176-equalto
   */


  equalTo(size2) {
    const epsilon = 0.00001;
    return Math.abs(this.width - size2.width) < epsilon && Math.abs(this.height - size2.height) < epsilon;
  }

  zero() {
    return new CGSize(0, 0);
  }

  add(size2) {
    return new CGSize(this.width + size2.width, this.height + size2.height);
  }

  sub(size2) {
    return new CGSize(this.width - size2.width, this.height - size2.height);
  }
  /**
   * @access public
   * @param {CGSize} s -
   * @param {number} rate -
   * @returns {CGSize} -
   */


  lerp(s, rate) {
    const w = this.width + rate * (s.width - this.width);
    const h = this.height + rate * (s.height - this.height);
    return new CGSize(w, h);
  }

  copy() {
    return new CGSize(this.width, this.height);
  }

}

/**
 * A structure that contains the location and dimensions of a rectangle.
 * @access public
 * @see https://developer.apple.com/documentation/coregraphics/cgrect
 */

class CGRect {
  // Creating Rectangle Values

  /**
   * Creates a rectangle with the specified origin and size.
   * @access public
   * @constructor
   * @param {CGPoint} origin - 
   * @param {CGSize} size - 
   * @see https://developer.apple.com/documentation/coregraphics/cgrect/1454856-init
   */
  constructor(origin, size) {
    // Basic Geometric Properties
    this.origin = origin.copy();
    this.size = size.copy();
  } // Special Values

  /**
   * The rectangle whose origin and size are both zero.
   * @type {CGRect}
   * @desc The zero rectangle is equivalent to one created by calling CGRect(x: 0, y: 0, width: 0, height: 0).
   * @see https://developer.apple.com/documentation/coregraphics/cgrect/1455437-zero
   */


  static get zero() {
    return new CGRect(new CGPoint(0, 0), new CGSize(0, 0));
  } // Basic Geometric Properties
  // Calculated Geometric Properties

  /**
   * Returns the height of a rectangle.
   * @type {number}
   * @desc Regardless of whether the height is stored in the CGRect data structure as a positive or negative number, this function returns the height as if the rectangle were standardized. That is, the result is never a negative number.
   * @see https://developer.apple.com/documentation/coregraphics/cgrect/1455645-height
   */


  get height() {
    if (this.isNull) {
      return 0;
    }

    return Math.abs(this.size.height);
  }
  /**
   * Returns the width of a rectangle.
   * @type {number}
   * @desc Regardless of whether the width is stored in the CGRect data structure as a positive or negative number, this function returns the width as if the rectangle were standardized.  That is, the result is never a negative number.
   * @see https://developer.apple.com/documentation/coregraphics/cgrect/1454758-width
   */


  get width() {
    if (this.isNull) {
      return 0;
    }

    return Math.abs(this.size.width);
  }
  /**
   * Returns the smallest value for the x-coordinate of the rectangle.
   * @type {number}
   * @desc 
   * @see https://developer.apple.com/documentation/coregraphics/cgrect/1455948-minx
   */


  get minX() {
    if (this.size.width < 0) {
      return this.origin.x + this.size.width;
    }

    return this.origin.x;
  }
  /**
   * Returns the x- coordinate that establishes the center of a rectangle.
   * @type {number}
   * @desc 
   * @see https://developer.apple.com/documentation/coregraphics/cgrect/1456175-midx
   */


  get midX() {
    return this.origin.x + this.size.width * 0.5;
  }
  /**
   * Returns the largest value of the x-coordinate for the rectangle.
   * @type {number}
   * @desc 
   * @see https://developer.apple.com/documentation/coregraphics/cgrect/1454334-maxx
   */


  get maxX() {
    if (this.size.width > 0) {
      return this.origin.x + this.size.width;
    }

    return this.origin.x;
  }
  /**
   * Returns the smallest value for the y-coordinate of the rectangle.
   * @type {number}
   * @desc 
   * @see https://developer.apple.com/documentation/coregraphics/cgrect/1454832-miny
   */


  get minY() {
    if (this.size.height < 0) {
      return this.origin.y + this.size.height;
    }

    return this.origin.y;
  }
  /**
   * Returns the y-coordinate that establishes the center of the rectangle.
   * @type {number}
   * @desc 
   * @see https://developer.apple.com/documentation/coregraphics/cgrect/1456550-midy
   */


  get midY() {
    return this.origin.y + this.size.height * 0.5;
  }
  /**
   * Returns the largest value for the y-coordinate of the rectangle.
   * @type {number}
   * @desc 
   * @see https://developer.apple.com/documentation/coregraphics/cgrect/1454060-maxy
   */


  get maxY() {
    if (this.size.height > 0) {
      return this.origin.y + this.size.height;
    }

    return this.origin.y;
  } // Creating Derived Rectangles

  /**
   * Applies an affine transform to a rectangle.
   * @access public
   * @param {CGAffineTransform} t - The affine transform to apply to the rect parameter.
   * @returns {CGRect} - 
   * @desc Because affine transforms do not preserve rectangles in general, this function returns the smallest rectangle that contains the transformed corner points of the rect parameter. If the affine transform t consists solely of scaling and translation operations, then the returned rectangle coincides with the rectangle constructed from the four transformed corners.
   * @see https://developer.apple.com/documentation/coregraphics/cgrect/1455875-applying
   */


  applying(t) {
    return null;
  }
  /**
   * Returns a rectangle that is smaller or larger than the source rectangle, with the same center point.
   * @access public
   * @param {number} dx - The x-coordinate value to use for adjusting the source rectangle. To create an inset rectangle, specify a positive value. To create a larger, encompassing rectangle, specify a negative value.
   * @param {number} dy - The y-coordinate value to use for adjusting the source rectangle. To create an inset rectangle, specify a positive value. To create a larger, encompassing rectangle, specify a negative value.
   * @returns {CGRect} - 
   * @desc The rectangle is standardized and then the inset parameters are applied. If the resulting rectangle would have a negative height or width, a null rectangle is returned.
   * @see https://developer.apple.com/documentation/coregraphics/cgrect/1454218-insetby
   */


  insetBy(dx, dy) {
    const newX = this.minX + dx;
    const newY = this.minY + dy;
    const newWidth = this.size.width - dx * 2;
    const newHeight = this.size.height - dy * 2;
    return new CGRect(new CGPoint(newX, newY), new CGSize(newWidth, newHeight));
  }
  /**
   * Returns a rectangle with an origin that is offset from that of the source rectangle.
   * @access public
   * @param {number} dx - The offset value for the x-coordinate.
   * @param {number} dy - The offset value for the  y-coordinate.
   * @returns {CGRect} - 
   * @see https://developer.apple.com/documentation/coregraphics/cgrect/1454841-offsetby
   */


  offsetBy(dx, dy) {
    return new CGRect(new CGPoint(this.origin.x + dx, this.origin.y + dy), this.size);
  }
  /**
   * Returns the smallest rectangle that contains the two source rectangles.
   * @access public
   * @param {CGRect} r2 - Another rectangle to be combined with this rectangle.
   * @returns {CGRect} - 
   * @desc Both rectangles are standardized prior to calculating the union. If either of the rectangles is a null rectangle, a copy of the other rectangle is returned (resulting in a null rectangle if both rectangles are null). Otherwise a rectangle that completely contains the source rectangles is returned.
   * @see https://developer.apple.com/documentation/coregraphics/cgrect/1455837-union
   */


  union(r2) {
    if (this.isNull && r2.isNull) {
      return new CGRect(new CGPoint(0, 0), null);
    } else if (this.isNull) {
      return r2.copy();
    } else if (r2.isNull) {
      return this.copy();
    }

    const minX = this.minX < r2.minX ? this.minX : r2.minX;
    const maxX = this.maxX > r2.maxX ? this.maxX : r2.maxX;
    const minY = this.minY < r2.minY ? this.minY : r2.minY;
    const maxY = this.maxY > r2.maxY ? this.maxY : r2.maxY;
    const width = maxX - minX;
    const height = maxY - minY;
    return new CGRect(new CGPoint(minX, minY), new CGSize(width, height));
  }
  /**
   * Returns the intersection of two rectangles.
   * @access public
   * @param {CGRect} r2 - Another rectangle to intersect with this rectangle.
   * @returns {CGRect} - 
   * @desc Both rectangles are standardized prior to calculating the intersection.
   * @see https://developer.apple.com/documentation/coregraphics/cgrect/1455346-intersection
   */


  intersection(r2) {
    if (this.isNull || r2.isNull) {
      return new CGRect(new CGPoint(0, 0), null);
    }

    const minX = this.minX > r2.minX ? this.minX : r2.minX;
    const maxX = this.maxX < r2.maxX ? this.maxX : r2.maxX;
    const minY = this.minY > r2.minY ? this.minY : r2.minY;
    const maxY = this.maxY < r2.maxY ? this.maxY : r2.maxY;
    const width = maxX - minX;
    const height = maxY - minY;

    if (width < 0 || height < 0) {
      return new CGRect(new CGPoint(0, 0), null);
    }

    return new CGRect(new CGPoint(minX, minY), new CGSize(width, height));
  }
  /**
   * Creates two rectangles by dividing the original rectangle. 
   * @access public
   * @param {number} atDistance - A distance from the rectangle side specified in the fromEdge parameter, defining the line along which to divide the rectangle.
   * @param {CGRectEdge} fromEdge - The side of the rectangle from which to measure the atDistance parameter, defining the line along which to divide the rectangle.
   * @returns {{slice: CGRect, remainder: CGRect}} - 
   * @desc Together the fromEdge and atDistance parameters define a line (parallel to the specified edge of the rectangle and at the specified distance from that edge) that divides the rectangle into two component rectangles.
   * @see https://developer.apple.com/documentation/coregraphics/cgrect/2299988-divided
   */


  dividedFrom(atDistance, fromEdge) {
    return null;
  }
  /**
   * Returns a rectangle with a positive width and height.
   * @type {CGRect}
   * @desc 
   * @see https://developer.apple.com/documentation/coregraphics/cgrect/1456432-standardized
   */


  get standardized() {
    const r = this.copy();

    if (this.isNull) {
      return CGRect.zero;
    }

    if (this.width < 0) {
      r.origin.x = this.origin.x + this.width;
      r.size.width = -this.width;
    }

    if (this.height < 0) {
      r.origin.y = this.origin.y + this.height;
      r.size.height = -this.height;
    }

    return r;
  }
  /**
   * Returns the smallest rectangle that results from converting the source rectangle values to integers.
   * @type {CGRect}
   * @desc 
   * @see https://developer.apple.com/documentation/coregraphics/cgrect/1456348-integral
   */


  get integral() {
    return null;
  } // Checking Characteristics

  /**
   * Returns whether two rectangles intersect.
   * @access public
   * @param {CGRect} rect2 - The rectangle to test for intersection with this rectangle.
   * @returns {boolean} - 
   * @see https://developer.apple.com/documentation/coregraphics/cgrect/1454747-intersects
   */


  intersects(rect2) {
    const r = this.intersection(rect2);
    return this.width > 0 && this.height > 0;
  }
  /**
   * Returns whether a rectangle contains a specified point.
   * @access public
   * @param {CGPoint} point - The point to examine. 
   * @returns {boolean} - 
   * @desc A point is considered inside the rectangle if its coordinates lie inside the rectangle or on the minimum X or minimum Y edge.
   * @see https://developer.apple.com/documentation/coregraphics/cgrect/1456316-contains
   */


  contains(point) {
    return point.x >= this.minX && point.x <= this.maxX && point.y >= this.minY && point.y <= this.maxY;
  }
  /**
   * Returns whether a rectangle has zero width or height, or is a null rectangle.
   * @type {boolean}
   * @desc An empty rectangle is either a null rectangle or a valid rectangle with zero height or width.
   * @see https://developer.apple.com/documentation/coregraphics/cgrect/1454917-isempty
   */


  get isEmpty() {
    return this.isNull || this.size.height === 0 || this.size.width === 0;
  }
  /**
   * Returns whether a rectangle is infinite.
   * @type {boolean}
   * @desc An infinite rectangle is one that has no defined bounds. Infinite rectangles can be created as output from a tiling filter. For example, the Core Image framework perspective tile filter creates an image whose extent is described by an infinite rectangle.
   * @see https://developer.apple.com/documentation/coregraphics/cgrect/1455008-isinfinite
   */


  get isInfinite() {
    return this.size.width === Infinity && this.size.height === Infinity;
  }
  /**
   * Returns whether the rectangle is equal to the null rectangle.
   * @type {boolean}
   * @desc A null rectangle is the equivalent of an empty set. For example, the result of intersecting two disjoint rectangles is a null rectangle. A null rectangle cannot be drawn and interacts with other rectangles in special ways.
   * @see https://developer.apple.com/documentation/coregraphics/cgrect/1455471-isnull
   */


  get isNull() {
    return this.size === null;
  } // Alternate Representations

  /**
   * Creates a rectangle from a canonical dictionary representation. 
   * @access public
   * @param {Map} dict - A dictionary containing x, y, width, and height values for the rectangle to create, in the format used by the dictionaryRepresentation property.
   * @returns {void}
   * @see https://developer.apple.com/documentation/coregraphics/cgrect/2427139-init
   */


  initDictionaryRepresentation(dict) {
    // Basic Geometric Properties
    this.origin = dict.get('origin');
    this.size = dict.get('size');
  }
  /**
   * Returns a dictionary representation of the provided rectangle.
   * @type {Map}
   * @desc 
   * @see https://developer.apple.com/documentation/coregraphics/cgrect/1455760-dictionaryrepresentation
   */


  get dictionaryRepresentation() {
    const map = new Map();
    map.set('origin', this.origin);
    map.set('size', this.size);
    return map;
  }
  /**
   * 
   * @type {string}
   * @desc A textual representation of the rectangle's origin and size values. 
   * @see https://developer.apple.com/documentation/coregraphics/cgrect/1645823-debugdescription
   */


  get debugDescription() {
    if (this.size === null) {
      return '{null}';
    }

    const origin = this.origin ? this.origin.debugDescription() : '{null}';
    const size = this.size ? this.size.debugDescription() : '{null}';
    return `{origin:${origin}, size:${size}}`;
  }
  /**
   * A representation of the rectangle's structure and display style for use in debugging. 
   * @type {Mirror}
   * @desc 
   * @see https://developer.apple.com/documentation/coregraphics/cgrect/1645833-custommirror
   */


  get customMirror() {
    return null;
  }
  /**
   * A representation of the rectangle for use in Playgrounds. 
   * @type {PlaygroundQuickLook}
   * @desc 
   * @see https://developer.apple.com/documentation/coregraphics/cgrect/1645827-customplaygroundquicklook
   */


  get customPlaygroundQuickLook() {
    return null;
  } // Comparing Rectangles

  /**
   * Returns whether two rectangles are equal in size and position.
   * @access public
   * @param {CGRect} rect2 - The rectangle to compare this rectangle with.
   * @returns {boolean} - 
   * @see https://developer.apple.com/documentation/coregraphics/cgrect/1456516-equalto
   */


  equalTo(rect2) {
    if (this.origin === null || rect2.origin === null) {
      return false;
    }

    if (this.size === null || rect2.size === null) {
      return false;
    }

    return this.origin.equalTo(rect2.origin) && this.size.equalTo(rect2.size);
  }

  zero() {
    return new CGRect(new CGPoint(0, 0), new CGRect(0, 0));
  }

  add(rect2) {
    return new CGRect(this.origin.add(rect2.origin), this.size.add(rect2.size));
  }

  sub(rect2) {
    return new CGRect(this.origin.sub(rect2.origin), this.size.sub(rect2.size));
  }
  /**
   * @access public
   * @param {CGRect} r -
   * @param {number} rate -
   * @returns {CGRect} -
   */


  lerp(r, rate) {
    const origin = this.origin.lerp(r.origin, rate);
    const size = this.size.lerp(r.size, rate);
    return new CGRect(origin, size);
  }

  copy() {
    return new CGRect(this.origin, this.size);
  }
  /**
   * @access public
   * @param {number} x -
   * @param {number} y -
   * @param {number} width -
   * @param {number} height -
   * @returns {CGRect} -
   */


  static rectWithXYWidthHeight(x, y, width, height) {
    const point = new CGPoint(x, y);
    const size = new CGSize(width, height);
    return new CGRect(point, size);
  }

}

/**
 * A structure that contains a two-dimensional vector.
 * @access public
 * @see https://developer.apple.com/documentation/coregraphics/cgvector
 */

class CGVector {
  // Initializers

  /**
   * Creates a vector with components specified as integer values.
   * @access public
   * @constructor
   * @param {number} dx - 
   * @param {number} dy - 
   * @see https://developer.apple.com/documentation/coregraphics/cgvector/1456249-init
   */
  constructor(dx = 0, dy = 0) {
    // Geometric Properties
    this._dx = dx;
    this._dy = dy;
  } // Special Values

  /**
   * The vector whose components are both zero.
   * @type {CGVector}
   * @desc 
   * @see https://developer.apple.com/documentation/coregraphics/cgvector/1454067-zero
   */


  get zero() {
    return new CGVector();
  }

}

/**
 * DispatchObject is the base class for many dispatch types, including DispatchQueue, DispatchGroup, and DispatchSource. 
 * @access public
 * @see https://developer.apple.com/documentation/dispatch/dispatchobject
 */

class DispatchObject {
  /**
   * constructor
   * @access public
   * @constructor
   */
  constructor() {} // nothing to do
  // Instance Methods

  /**
   * Activates the dispatch object.
   * @access public
   * @returns {void}
   * @desc Once a dispatch object has been activated, it cannot change its target queue.
   * @see https://developer.apple.com/documentation/dispatch/dispatchobject/1641002-activate
   */


  activate() {}
  /**
   * Resume the invocation of block objects on a dispatch object.
   * @access public
   * @returns {void}
   * @desc Calling this function decrements the suspension count of a suspended dispatch queue or dispatch event source object. While the count is greater than zero, the object remains suspended. When the suspension count returns to zero, any blocks submitted to the dispatch queue or any events observed by the dispatch source while suspended are delivered.With one exception, each call to resume() must balance a call to suspend(). New dispatch event source objects returned by dispatch_source_create(_:_:_:_:) have a suspension count of 1 and must be resumed before any events are delivered. This approach allows your application to fully configure the dispatch event source object prior to delivery of the first event. In all other cases, it is undefined to call resume() more times than suspend(), which would result in a negative suspension count.
   * @see https://developer.apple.com/documentation/dispatch/dispatchobject/1452929-resume
   */


  resume() {}
  /**
   * Sets the target queue for the given object.
   * @access public
   * @param {?DispatchQueue} queue - The new target queue for the object. The queue is retained, and the previous one, if any, is released. This parameter cannot be NULL.
   * @returns {void}
   * @desc An object's target queue is responsible for processing the object. The target queue determines the queue on which the object's finalizer is invoked. In addition, modifying the target queue of some objects changes their behavior:Dispatch queues:A dispatch queue's priority is inherited from its target queue. Use the dispatch_get_global_queue(_:_:) function to obtain a suitable target queue of the desired priority.If you submit a block to a serial queue, and the serial queue’s target queue is a different serial queue, that block is not invoked concurrently with blocks submitted to the target queue or to any other queue with that same target queue.ImportantIf you modify the target queue for a queue, you must be careful to avoid creating cycles in the queue hierarchy.Dispatch sources:A dispatch source's target queue specifies where its event handler and cancellation handler blocks are submitted.Dispatch I/O channels:A dispatch I/O channel's target queue specifies where its I/O operations are executed. This may affect the priority of the resulting I/O operations. For example, if the channel's target queue's priority is set to DISPATCH_QUEUE_PRIORITY_BACKGROUND, then any I/O operations performed by read(offset:length:queue:ioHandler:) or write(offset:data:queue:ioHandler:) on that queue are throttled when there is I/O contention.
   * @see https://developer.apple.com/documentation/dispatch/dispatchobject/1452989-settarget
   */


  setTarget(queue) {}
  /**
   * Suspends the invocation of block objects on a dispatch object.
   * @access public
   * @returns {void}
   * @desc By suspending a dispatch object, your application can temporarily prevent the execution of any blocks associated with that object. The suspension occurs after completion of any blocks running at the time of the call. Calling this function increments the suspension count of the object, and calling resume() decrements it. While the count is greater than zero, the object remains suspended, so you must balance each suspend() call with a matching resume() call.Any blocks submitted to a dispatch queue or events observed by a dispatch source are delivered once the object is resumed. 
   * @see https://developer.apple.com/documentation/dispatch/dispatchobject/1452801-suspend
   */


  suspend() {}

}

let _main = null;
/**
 * DispatchQueue manages the execution of work items. Each work item submitted to a queue is processed on a pool of threads managed by the system.
 * @access public
 * @extends {DispatchObject}
 * @see https://developer.apple.com/documentation/dispatch/dispatchqueue
 */

class DispatchQueue extends DispatchObject {
  // Initializers

  /**
   * 
   * @access public
   * @param {string} label - 
   * @param {DispatchQoS} qos - 
   * @param {DispatchQueue.Attributes} attributes - 
   * @param {DispatchQueue.AutoreleaseFrequency} autoreleaseFrequency - 
   * @param {?DispatchQueue} target - 
   * @constructor
   * @see https://developer.apple.com/documentation/dispatch/dispatchqueue/2300059-init
   */
  constructor(label, qos, attributes, autoreleaseFrequency, target) {
    super();
    /**
     * @access private
     * @type {string}
     */

    this._label = label;
    /**
     * @access private
     * @type {DispatchQoS}
     */

    this._qos = qos;
    /**
     * @access private
     * @type {DispatchQueue.Attributes}
     */

    this._attributes = attributes;
    /**
     * @access private
     * @type {DispatchQueue.AutoreleaseFrequency}
     */

    this._target = target;
  }
  /**
   * Creates a new dispatch queue to which blocks can be submitted.
   * @access public
   * @param {?UnsafePointer<Int8>} label - A string label to attach to the queue to uniquely identify it in debugging tools such as Instruments, sample, stackshots, and crash reports.  Because applications, libraries, and frameworks can all create their own dispatch queues, a reverse-DNS naming style (com.example.myqueue) is recommended.  This parameter is optional and can be NULL.
   * @param {?__OS_dispatch_queue_attr} attr - In macOS 10.7 and later or iOS 4.3 and later, specify DISPATCH_QUEUE_SERIAL (or NULL) to create a serial queue or specify DISPATCH_QUEUE_CONCURRENT to create a concurrent queue. In earlier versions, you must specify NULL for this parameter.
   * @returns {void}
   * @desc Blocks submitted to a serial queue are executed one at a time in FIFO order. Note, however, that blocks submitted to independent queues may be executed concurrently with respect to each other. Blocks submitted to a concurrent queue are dequeued in FIFO order but may run concurrently if resources are available to do so.If your app isn’t using ARC, you should call dispatch_release on a dispatch queue when it’s no longer needed. Any pending blocks submitted to a queue hold a reference to that queue, so the queue is not deallocated until all pending blocks have completed.
   * @see https://developer.apple.com/documentation/dispatch/dispatchqueue/1453030-init
   */


  init__label(label, attr) {
    // Instance Properties
    this._label = '';
    this._qos = null;
  }
  /**
   * 
   * @access public
   * @param {?UnsafePointer<Int8>} label - 
   * @param {?__OS_dispatch_queue_attr} attr - 
   * @param {?DispatchQueue} target - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/dispatch/dispatchqueue/1642205-init
   */


  init__labelQueue(label, attr, target) {
    // Instance Properties
    this._label = '';
    this._qos = null;
  } // Instance Methods

  /**
   * 
   * @access public
   * @param {DispatchWorkItem} workItem - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/dispatch/dispatchqueue/1452870-sync
   */


  syncExecute(workItem) {}
  /**
   * 
   * @access public
   * @param {DispatchWorkItem} workItem - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/dispatch/dispatchqueue/2016103-async
   */


  asyncExecute(workItem) {}
  /**
   * 
   * @access public
   * @param {DispatchTime} deadline - 
   * @param {DispatchWorkItem} execute - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/dispatch/dispatchqueue/2300020-asyncafter
   */


  asyncAfter(deadline, execute) {
    const delay = deadline - Date.now();
    window.setTimeout(() => {
      execute();
    }, delay);
  }
  /**
   * 
   * @access public
   * @param {DispatchTime} deadline - 
   * @param {DispatchQoS} qos - 
   * @param {DispatchWorkItemFlags} flags - 
   * @param {function(): void} work - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/dispatch/dispatchqueue/2300100-asyncafter
   */


  asyncAfterExecute(deadline, qos, flags, work) {}
  /**
   * 
   * @access public
   * @param {DispatchSpecificKey<T>} key - 
   * @returns {?T} - 
   * @see https://developer.apple.com/documentation/dispatch/dispatchqueue/1780751-getspecific
   */


  getSpecific(key) {
    return null;
  }
  /**
   * 
   * @access public
   * @param {DispatchSpecificKey<T>} key - 
   * @param {T} value - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/dispatch/dispatchqueue/1780629-setspecific
   */


  setSpecific(key, value) {}
  /**
   * 
   * @access public
   * @param {DispatchWorkItemFlags} flags - 
   * @returns {void}
   * @throws {Error}
   * @see https://developer.apple.com/documentation/dispatch/dispatchqueue/2016077-sync
   */


  sync(flags) {} // Instance Properties

  /**
   * 
   * @type {string}
   * @desc 
   * @see https://developer.apple.com/documentation/dispatch/dispatchqueue/1780825-label
   */


  get label() {
    return this._label;
  }
  /**
   * 
   * @type {DispatchQoS}
   * @desc 
   * @see https://developer.apple.com/documentation/dispatch/dispatchqueue/1781008-qos
   */


  get qos() {
    return this._qos;
  } // Type Properties

  /**
   * 
   * @type {DispatchQueue}
   * @desc 
   * @see https://developer.apple.com/documentation/dispatch/dispatchqueue/1781006-main
   */


  static get main() {
    return _main;
  } // Type Methods

  /**
   * 
   * @access public
   * @param {number} iterations - 
   * @param {function(arg1: number): void} work - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/dispatch/dispatchqueue/2016088-concurrentperform
   */


  static concurrentPerformExecute(iterations, work) {}
  /**
   * 
   * @deprecated
   * @access public
   * @param {DispatchQueue.GlobalQueuePriority} priority - 
   * @returns {DispatchQueue} - 
   * @see https://developer.apple.com/documentation/dispatch/dispatchqueue/2300070-global
   */


  static global(priority) {
    return null;
  }

} //_main = new DispatchQueue("com.apple.main-thread", new DispatchQoS(DispatchQoS.userInteractive, 0))

_main = new DispatchQueue('com.apple.main-thread', null);

/**
 * DispatchTime represents a point in time relative to the default clock with nanosecond precision. On Apple platforms, the default clock is based on the Mach absolute time unit.
 * @access public
 * @see https://developer.apple.com/documentation/dispatch/dispatchtime
 */

class DispatchTime {
  // Initializers

  /**
   * Creates a time relative to the system clock that ticks since boot.
   * @access public
   * @constructor
   * @param {UInt64} uptimeNanoseconds - The number of nanoseconds since boot, excluding any time the system spent asleep.
   * @desc On Apple platforms, this clock is the same as the value returned by mach_absolute_time when converted into nanoseconds.
   * @see https://developer.apple.com/documentation/dispatch/dispatchtime/2300057-init
   */
  constructor(uptimeNanoseconds) {
    // Instance Properties
    this._uptimeNanoseconds = uptimeNanoseconds;
  } // Instance Properties

  /**
   * Returns the number of nanoseconds since boot, excluding any time the system spent asleep.
   * @type {UInt64}
   * @desc 
   * @see https://developer.apple.com/documentation/dispatch/dispatchtime/2300047-uptimenanoseconds
   */


  get uptimeNanoseconds() {
    throw new Error('uptimeNanoseconds: not implemented');
  } // Type Properties

  /**
   * Returns a time in the distant future.
   * @access public
   * @returns {DispatchTime} -
   * @desc You can pass this value to methods that schedule work to have the system wait indefinitely for a particular event to occur or condition to be met.
   * @see https://developer.apple.com/documentation/dispatch/dispatchtime/1780795-distantfuture
   */


  static get distantFuture() {} // Type Methods

  /**
   * Returns the current time.
   * @access public
   * @returns {DispatchTime} - 
   * @see https://developer.apple.com/documentation/dispatch/dispatchtime/1780853-now
   */


  static now() {
    return Date.now();
  }

}

/**
 * DispatchTimeInterval represents a number of seconds, millisconds, microseconds, or nanoseconds. You use DispatchTimeInterval values to specify the interval at which a DispatchSourceTimer fires or I/O handlers are invoked for a DispatchIO channel, as well as to increment and decrement DispatchTime values.
 * @typedef {Object} DispatchTimeInterval
 * @property {function} seconds - A number of seconds.
 * @property {function} milliseconds - A number of milliseconds.
 * @property {function} microseconds - A number of microseconds.
 * @property {function} nanoseconds - A number of nanoseconds.
 * @see https://developer.apple.com/documentation/dispatch/dispatchtimeinterval
 */

const DispatchTimeInterval = {
  seconds: value => {
    return value * 1000.0;
  },
  milliseconds: value => {
    return value;
  },
  microseconds: value => {
    return value * 0.001;
  },
  nanoseconds: value => {
    return value * 0.000001;
  }
};

const _Name = {
  AVAudioEngineConfigurationChange: Symbol(),
  AVAudioSessionInterruption: Symbol(),
  AVAudioSessionMediaServicesWereLost: Symbol(),
  AVAudioSessionMediaServicesWereReset: Symbol(),
  AVAudioSessionRouteChange: Symbol(),
  AVAudioSessionSilenceSecondaryAudioHint: Symbol(),
  AVAudioUnitComponentTagsDidChange: Symbol(),
  CKAccountChanged: Symbol(),
  CLKComplicationServerActiveComplicationsDidChange: Symbol(),
  CNContactStoreDidChange: Symbol(),
  EKEventStoreChanged: Symbol(),
  HKUserPreferencesDidChange: Symbol(),
  HMCharacteristicPropertySupportsEvent: Symbol(),
  NSBundleResourceRequestLowDiskSpace: Symbol(),
  NSCalendarDayChanged: Symbol(),
  NSDidBecomeSingleThreaded: Symbol(),
  NSExtensionHostDidBecomeActive: Symbol(),
  NSExtensionHostDidEnterBackground: Symbol(),
  NSExtensionHostWillEnterForeground: Symbol(),
  NSExtensionHostWillResignActive: Symbol(),
  NSFileHandleConnectionAccepted: Symbol(),
  NSFileHandleDataAvailable: Symbol(),
  NSFileHandleReadToEndOfFileCompletion: Symbol(),
  NSHTTPCookieManagerAcceptPolicyChanged: Symbol(),
  NSHTTPCookieManagerCookiesChanged: Symbol(),
  NSManagedObjectContextDidSave: Symbol(),
  NSManagedObjectContextObjectsDidChange: Symbol(),
  NSManagedObjectContextWillSave: Symbol(),
  NSMetadataQueryDidFinishGathering: Symbol(),
  NSMetadataQueryDidStartGathering: Symbol(),
  NSMetadataQueryDidUpdate: Symbol(),
  NSMetadataQueryGatheringProgress: Symbol(),
  NSPersistentStoreCoordinatorStoresDidChange: Symbol(),
  NSPersistentStoreCoordinatorStoresWillChange: Symbol(),
  NSPersistentStoreCoordinatorWillRemoveStore: Symbol(),
  NSProcessInfoPowerStateDidChange: Symbol(),
  NSSystemClockDidChange: Symbol(),
  NSSystemTimeZoneDidChange: Symbol(),
  NSThreadWillExit: Symbol(),
  NSURLCredentialStorageChanged: Symbol(),
  NSUbiquityIdentityDidChange: Symbol(),
  NSUndoManagerCheckpoint: Symbol(),
  NSUndoManagerDidCloseUndoGroup: Symbol(),
  NSUndoManagerDidOpenUndoGroup: Symbol(),
  NSUndoManagerDidRedoChange: Symbol(),
  NSUndoManagerDidUndoChange: Symbol(),
  NSUndoManagerWillCloseUndoGroup: Symbol(),
  NSUndoManagerWillRedoChange: Symbol(),
  NSUndoManagerWillUndoChange: Symbol(),
  NSWillBecomeMultiThreaded: Symbol(),
  PKPassLibraryDidChange: Symbol(),
  PKPassLibraryRemotePaymentPassesDidChange: Symbol(),
  UIAccessibilityAnnouncementDidFinish: Symbol(),
  UIAccessibilityElementFocused: Symbol(),
  WKAudioFilePlayerItemDidPlayToEndTime: Symbol(),
  WKAudioFilePlayerItemFailedToPlayToEndTime: Symbol(),
  WKAudioFilePlayerItemTimeJumped: Symbol(),
  ABPeoplePickerDisplayedPropertyDidChange: Symbol(),
  ABPeoplePickerGroupSelectionDidChange: Symbol(),
  ABPeoplePickerNameSelectionDidChange: Symbol(),
  ABPeoplePickerValueSelectionDidChange: Symbol(),
  ACAccountStoreDidChange: Symbol(),
  AVAssetChapterMetadataGroupsDidChange: Symbol(),
  AVAssetContainsFragmentsDidChange: Symbol(),
  AVAssetDurationDidChange: Symbol(),
  AVAssetMediaSelectionGroupsDidChange: Symbol(),
  AVAssetTrackSegmentsDidChange: Symbol(),
  AVAssetTrackTimeRangeDidChange: Symbol(),
  AVAssetTrackTrackAssociationsDidChange: Symbol(),
  AVAssetWasDefragmented: Symbol(),
  AVCaptureDeviceWasConnected: Symbol(),
  AVCaptureDeviceWasDisconnected: Symbol(),
  AVCaptureInputPortFormatDescriptionDidChange: Symbol(),
  AVCaptureSessionDidStartRunning: Symbol(),
  AVCaptureSessionDidStopRunning: Symbol(),
  AVCaptureSessionRuntimeError: Symbol(),
  AVFragmentedMovieContainsMovieFragmentsDidChange: Symbol(),
  AVFragmentedMovieDurationDidChange: Symbol(),
  AVFragmentedMovieTrackSegmentsDidChange: Symbol(),
  AVFragmentedMovieTrackTimeRangeDidChange: Symbol(),
  AVFragmentedMovieTrackTotalSampleDataLengthDidChange: Symbol(),
  AVFragmentedMovieWasDefragmented: Symbol(),
  AVPlayerItemDidPlayToEndTime: Symbol(),
  AVPlayerItemFailedToPlayToEndTime: Symbol(),
  AVPlayerItemNewAccessLogEntry: Symbol(),
  AVPlayerItemNewErrorLogEntry: Symbol(),
  AVPlayerItemPlaybackStalled: Symbol(),
  AVPlayerItemTimeJumped: Symbol(),
  AVSampleBufferDisplayLayerFailedToDecode: Symbol(),
  CWBSSIDDidChange: Symbol(),
  CWCountryCodeDidChange: Symbol(),
  CWLinkDidChange: Symbol(),
  CWLinkQualityDidChange: Symbol(),
  CWModeDidChange: Symbol(),
  CWPowerDidChange: Symbol(),
  CWSSIDDidChange: Symbol(),
  CWScanCacheDidUpdate: Symbol(),
  GCControllerDidConnect: Symbol(),
  GCControllerDidDisconnect: Symbol(),
  IKFilterBrowserFilterDoubleClick: Symbol(),
  IKFilterBrowserFilterSelected: Symbol(),
  IKFilterBrowserWillPreviewFilter: Symbol(),
  IOBluetoothHostControllerPoweredOff: Symbol(),
  IOBluetoothHostControllerPoweredOn: Symbol(),
  IOBluetoothL2CAPChannelPublished: Symbol(),
  IOBluetoothL2CAPChannelTerminated: Symbol(),
  MKAnnotationCalloutInfoDidChange: Symbol(),
  NEFilterConfigurationDidChange: Symbol(),
  NEVPNConfigurationChange: Symbol(),
  NEVPNStatusDidChange: Symbol(),
  announcementRequested: Symbol(),
  applicationActivated: Symbol(),
  applicationDeactivated: Symbol(),
  applicationHidden: Symbol(),
  applicationShown: Symbol(),
  created: Symbol(),
  drawerCreated: Symbol(),
  focusedUIElementChanged: Symbol(),
  focusedWindowChanged: Symbol(),
  helpTagCreated: Symbol(),
  layoutChanged: Symbol(),
  mainWindowChanged: Symbol(),
  moved: Symbol(),
  resized: Symbol(),
  rowCollapsed: Symbol(),
  rowCountChanged: Symbol(),
  rowExpanded: Symbol(),
  selectedCellsChanged: Symbol(),
  selectedChildrenChanged: Symbol(),
  selectedChildrenMoved: Symbol(),
  selectedColumnsChanged: Symbol(),
  selectedRowsChanged: Symbol(),
  selectedTextChanged: Symbol(),
  sheetCreated: Symbol(),
  titleChanged: Symbol(),
  uiElementDestroyed: Symbol(),
  unitsChanged: Symbol(),
  valueChanged: Symbol(),
  windowCreated: Symbol(),
  windowDeminiaturized: Symbol(),
  windowMiniaturized: Symbol(),
  windowMoved: Symbol(),
  windowResized: Symbol(),
  progressMarkNotification: Symbol(),
  antialiasThresholdChangedNotification: Symbol(),
  NSAppleEventManagerWillProcessFirstEvent: Symbol(),
  didBecomeActiveNotification: Symbol(),
  didChangeOcclusionStateNotification: Symbol(),
  didChangeScreenParametersNotification: Symbol(),
  didFinishLaunchingNotification: Symbol(),
  didFinishRestoringWindowsNotification: Symbol(),
  didHideNotification: Symbol(),
  didResignActiveNotification: Symbol(),
  didUnhideNotification: Symbol(),
  didUpdateNotification: Symbol(),
  willBecomeActiveNotification: Symbol(),
  willFinishLaunchingNotification: Symbol(),
  willHideNotification: Symbol(),
  willResignActiveNotification: Symbol(),
  willTerminateNotification: Symbol(),
  willUnhideNotification: Symbol(),
  willUpdateNotification: Symbol(),
  columnConfigurationDidChangeNotification: Symbol(),
  NSClassDescriptionNeededForClass: Symbol(),
  didChangeNotification: Symbol(),
  colorDidChangeNotification: Symbol(),
  selectionDidChangeNotification: Symbol(),
  selectionIsChangingNotification: Symbol(),
  willDismissNotification: Symbol(),
  willPopUpNotification: Symbol(),
  contextHelpModeDidActivateNotification: Symbol(),
  contextHelpModeDidDeactivateNotification: Symbol(),
  textDidBeginEditingNotification: Symbol(),
  textDidChangeNotification: Symbol(),
  textDidEndEditingNotification: Symbol(),
  currentControlTintDidChangeNotification: Symbol(),
  didCloseNotification: Symbol(),
  didOpenNotification: Symbol(),
  willCloseNotification: Symbol(),
  willOpenNotification: Symbol(),
  fontSetChangedNotification: Symbol(),
  registryDidChangeNotification: Symbol(),
  didAddItemNotification: Symbol(),
  didBeginTrackingNotification: Symbol(),
  didChangeItemNotification: Symbol(),
  didEndTrackingNotification: Symbol(),
  didRemoveItemNotification: Symbol(),
  didSendActionNotification: Symbol(),
  willSendActionNotification: Symbol(),
  columnDidMoveNotification: Symbol(),
  columnDidResizeNotification: Symbol(),
  itemDidCollapseNotification: Symbol(),
  itemDidExpandNotification: Symbol(),
  itemWillCollapseNotification: Symbol(),
  itemWillExpandNotification: Symbol(),
  NSPersistentStoreDidImportUbiquitousContentChanges: Symbol(),
  didShowNotification: Symbol(),
  willShowNotification: Symbol(),
  preferredScrollerStyleDidChangeNotification: Symbol(),
  rowsDidChangeNotification: Symbol(),
  colorSpaceDidChangeNotification: Symbol(),
  didEndLiveMagnifyNotification: Symbol(),
  didEndLiveScrollNotification: Symbol(),
  didLiveScrollNotification: Symbol(),
  willStartLiveMagnifyNotification: Symbol(),
  willStartLiveScrollNotification: Symbol(),
  didChangeAutomaticCapitalizationNotification: Symbol(),
  didChangeAutomaticDashSubstitutionNotification: Symbol(),
  didChangeAutomaticPeriodSubstitutionNotification: Symbol(),
  didChangeAutomaticQuoteSubstitutionNotification: Symbol(),
  didChangeAutomaticSpellingCorrectionNotification: Symbol(),
  didChangeAutomaticTextReplacementNotification: Symbol(),
  didResizeSubviewsNotification: Symbol(),
  willResizeSubviewsNotification: Symbol(),
  systemColorsDidChangeNotification: Symbol(),
  selectedAlternativeStringNotification: Symbol(),
  didBeginEditingNotification: Symbol(),
  didEndEditingNotification: Symbol(),
  keyboardSelectionDidChangeNotification: Symbol(),
  NSTextStorageDidProcessEditing: Symbol(),
  NSTextStorageWillProcessEditing: Symbol(),
  didChangeSelectionNotification: Symbol(),
  didChangeTypingAttributesNotification: Symbol(),
  willChangeNotifyingTextViewNotification: Symbol(),
  willAddItemNotification: Symbol(),
  boundsDidChangeNotification: Symbol(),
  didUpdateTrackingAreasNotification: Symbol(),
  frameDidChangeNotification: Symbol(),
  globalFrameDidChangeNotification: Symbol(),
  didBecomeKeyNotification: Symbol(),
  didBecomeMainNotification: Symbol(),
  didChangeBackingPropertiesNotification: Symbol(),
  didChangeScreenNotification: Symbol(),
  didChangeScreenProfileNotification: Symbol(),
  didDeminiaturizeNotification: Symbol(),
  didEndLiveResizeNotification: Symbol(),
  didEndSheetNotification: Symbol(),
  didEnterFullScreenNotification: Symbol(),
  didEnterVersionBrowserNotification: Symbol(),
  didExitFullScreenNotification: Symbol(),
  didExitVersionBrowserNotification: Symbol(),
  didExposeNotification: Symbol(),
  didMiniaturizeNotification: Symbol(),
  didMoveNotification: Symbol(),
  didResignKeyNotification: Symbol(),
  didResignMainNotification: Symbol(),
  didResizeNotification: Symbol(),
  willBeginSheetNotification: Symbol(),
  willEnterFullScreenNotification: Symbol(),
  willEnterVersionBrowserNotification: Symbol(),
  willExitFullScreenNotification: Symbol(),
  willExitVersionBrowserNotification: Symbol(),
  willMiniaturizeNotification: Symbol(),
  willMoveNotification: Symbol(),
  willStartLiveResizeNotification: Symbol(),
  accessibilityDisplayOptionsDidChangeNotification: Symbol(),
  activeSpaceDidChangeNotification: Symbol(),
  didActivateApplicationNotification: Symbol(),
  didChangeFileLabelsNotification: Symbol(),
  didDeactivateApplicationNotification: Symbol(),
  didHideApplicationNotification: Symbol(),
  didLaunchApplicationNotification: Symbol(),
  didMountNotification: Symbol(),
  didPerformFileOperationNotification: Symbol(),
  didRenameVolumeNotification: Symbol(),
  didTerminateApplicationNotification: Symbol(),
  didUnhideApplicationNotification: Symbol(),
  didUnmountNotification: Symbol(),
  didWakeNotification: Symbol(),
  screensDidSleepNotification: Symbol(),
  screensDidWakeNotification: Symbol(),
  sessionDidBecomeActiveNotification: Symbol(),
  sessionDidResignActiveNotification: Symbol(),
  willLaunchApplicationNotification: Symbol(),
  willPowerOffNotification: Symbol(),
  willSleepNotification: Symbol(),
  willUnmountNotification: Symbol(),
  PDFDocumentDidBeginFind: Symbol(),
  PDFDocumentDidBeginPageFind: Symbol(),
  PDFDocumentDidBeginPageWrite: Symbol(),
  PDFDocumentDidBeginWrite: Symbol(),
  PDFDocumentDidEndFind: Symbol(),
  PDFDocumentDidEndPageFind: Symbol(),
  PDFDocumentDidEndPageWrite: Symbol(),
  PDFDocumentDidEndWrite: Symbol(),
  PDFDocumentDidFindMatch: Symbol(),
  PDFDocumentDidUnlock: Symbol(),
  PDFThumbnailViewDocumentEdited: Symbol(),
  PDFViewAnnotationHit: Symbol(),
  PDFViewAnnotationWillHit: Symbol(),
  PDFViewChangedHistory: Symbol(),
  PDFViewCopyPermission: Symbol(),
  PDFViewDisplayBoxChanged: Symbol(),
  PDFViewDisplayModeChanged: Symbol(),
  PDFViewDocumentChanged: Symbol(),
  PDFViewPageChanged: Symbol(),
  PDFViewPrintPermission: Symbol(),
  PDFViewScaleChanged: Symbol(),
  PDFViewSelectionChanged: Symbol(),
  PDFViewVisiblePagesChanged: Symbol(),
  QCCompositionPickerPanelDidSelectComposition: Symbol(),
  QCCompositionPickerViewDidSelectComposition: Symbol(),
  QCCompositionRepositoryDidUpdate: Symbol(),
  QCViewDidStartRendering: Symbol(),
  QCViewDidStopRendering: Symbol(),
  WebHistoryAllItemsRemoved: Symbol(),
  WebHistoryItemChanged: Symbol(),
  WebHistoryItemsAdded: Symbol(),
  WebHistoryItemsRemoved: Symbol(),
  WebHistoryLoaded: Symbol(),
  WebHistorySaved: Symbol(),
  WebPreferencesChanged: Symbol(),
  WebViewDidBeginEditing: Symbol(),
  WebViewDidChange: Symbol(),
  WebViewDidChangeSelection: Symbol(),
  WebViewDidChangeTypingStyle: Symbol(),
  WebViewDidEndEditing: Symbol(),
  WebViewProgressEstimateChanged: Symbol(),
  WebViewProgressFinished: Symbol(),
  WebViewProgressStarted: Symbol(),
  abDatabaseChanged: Symbol(),
  abDatabaseChangedExternally: Symbol(),
  quartzFilterManagerDidAddFilter: Symbol(),
  quartzFilterManagerDidModifyFilter: Symbol(),
  quartzFilterManagerDidRemoveFilter: Symbol(),
  quartzFilterManagerDidSelectFilter: Symbol(),
  EAAccessoryDidConnect: Symbol(),
  EAAccessoryDidDisconnect: Symbol(),
  MPMovieDurationAvailable: Symbol(),
  MPMovieMediaTypesAvailable: Symbol(),
  MPMovieNaturalSizeAvailable: Symbol(),
  MPMoviePlayerDidEnterFullscreen: Symbol(),
  MPMoviePlayerDidExitFullscreen: Symbol(),
  MPMoviePlayerIsAirPlayVideoActiveDidChange: Symbol(),
  MPMoviePlayerLoadStateDidChange: Symbol(),
  MPMoviePlayerNowPlayingMovieDidChange: Symbol(),
  MPMoviePlayerPlaybackDidFinish: Symbol(),
  MPMoviePlayerPlaybackStateDidChange: Symbol(),
  MPMoviePlayerReadyForDisplayDidChange: Symbol(),
  MPMoviePlayerScalingModeDidChange: Symbol(),
  MPMoviePlayerThumbnailImageRequestDidFinish: Symbol(),
  MPMoviePlayerTimedMetadataUpdated: Symbol(),
  MPMoviePlayerWillEnterFullscreen: Symbol(),
  MPMoviePlayerWillExitFullscreen: Symbol(),
  MPMovieSourceTypeAvailable: Symbol(),
  SKCloudServiceCapabilitiesDidChange: Symbol(),
  SKStorefrontIdentifierDidChange: Symbol(),
  TVTopShelfItemsDidChange: Symbol(),
  UIAccessibilityAssistiveTouchStatusDidChange: Symbol(),
  UIAccessibilityBoldTextStatusDidChange: Symbol(),
  UIAccessibilityClosedCaptioningStatusDidChange: Symbol(),
  UIAccessibilityDarkerSystemColorsStatusDidChange: Symbol(),
  UIAccessibilityGrayscaleStatusDidChange: Symbol(),
  UIAccessibilityGuidedAccessStatusDidChange: Symbol(),
  UIAccessibilityHearingDevicePairedEarDidChange: Symbol(),
  UIAccessibilityInvertColorsStatusDidChange: Symbol(),
  UIAccessibilityMonoAudioStatusDidChange: Symbol(),
  UIAccessibilityReduceMotionStatusDidChange: Symbol(),
  UIAccessibilityReduceTransparencyStatusDidChange: Symbol(),
  UIAccessibilityShakeToUndoDidChange: Symbol(),
  UIAccessibilitySpeakScreenStatusDidChange: Symbol(),
  UIAccessibilitySpeakSelectionStatusDidChange: Symbol(),
  UIAccessibilitySwitchControlStatusDidChange: Symbol(),
  UIApplicationDidBecomeActive: Symbol(),
  UIApplicationDidEnterBackground: Symbol(),
  UIApplicationDidFinishLaunching: Symbol(),
  UIApplicationDidReceiveMemoryWarning: Symbol(),
  UIApplicationSignificantTimeChange: Symbol(),
  UIApplicationUserDidTakeScreenshot: Symbol(),
  UIApplicationWillEnterForeground: Symbol(),
  UIApplicationWillResignActive: Symbol(),
  UIApplicationWillTerminate: Symbol(),
  UIContentSizeCategoryDidChange: Symbol(),
  UIDeviceProximityStateDidChange: Symbol(),
  UIScreenBrightnessDidChange: Symbol(),
  UIScreenDidConnect: Symbol(),
  UIScreenDidDisconnect: Symbol(),
  UIScreenModeDidChange: Symbol(),
  UITableViewSelectionDidChange: Symbol(),
  UITextFieldTextDidBeginEditing: Symbol(),
  UITextFieldTextDidChange: Symbol(),
  UITextFieldTextDidEndEditing: Symbol(),
  UITextInputCurrentInputModeDidChange: Symbol(),
  UITextViewTextDidBeginEditing: Symbol(),
  UITextViewTextDidChange: Symbol(),
  UITextViewTextDidEndEditing: Symbol(),
  UIViewControllerShowDetailTargetDidChange: Symbol(),
  UIWindowDidBecomeHidden: Symbol(),
  UIWindowDidBecomeKey: Symbol(),
  UIWindowDidBecomeVisible: Symbol(),
  UIWindowDidResignKey: Symbol(),
  ALAssetsLibraryChanged: Symbol(),
  AVCaptureDeviceSubjectAreaDidChange: Symbol(),
  AVCaptureSessionInterruptionEnded: Symbol(),
  AVCaptureSessionWasInterrupted: Symbol(),
  CTRadioAccessTechnologyDidChange: Symbol(),
  MFMessageComposeViewControllerTextMessageAvailabilityDidChange: Symbol(),
  MPMediaLibraryDidChange: Symbol(),
  MPMediaPlaybackIsPreparedToPlayDidChange: Symbol(),
  MPMusicPlayerControllerNowPlayingItemDidChange: Symbol(),
  MPMusicPlayerControllerPlaybackStateDidChange: Symbol(),
  MPMusicPlayerControllerVolumeDidChange: Symbol(),
  MPVolumeViewWirelessRouteActiveDidChange: Symbol(),
  MPVolumeViewWirelessRoutesAvailableDidChange: Symbol(),
  NKIssueDownloadCompleted: Symbol(),
  UIApplicationBackgroundRefreshStatusDidChange: Symbol(),
  UIApplicationDidChangeStatusBarFrame: Symbol(),
  UIApplicationDidChangeStatusBarOrientation: Symbol(),
  UIApplicationWillChangeStatusBarFrame: Symbol(),
  UIApplicationWillChangeStatusBarOrientation: Symbol(),
  UIDeviceBatteryLevelDidChange: Symbol(),
  UIDeviceBatteryStateDidChange: Symbol(),
  UIDeviceOrientationDidChange: Symbol(),
  UIDocumentStateChanged: Symbol(),
  UIKeyboardDidChangeFrame: Symbol(),
  UIKeyboardDidHide: Symbol(),
  UIKeyboardDidShow: Symbol(),
  UIKeyboardWillChangeFrame: Symbol(),
  UIKeyboardWillHide: Symbol(),
  UIKeyboardWillShow: Symbol(),
  UIMenuControllerDidHideMenu: Symbol(),
  UIMenuControllerDidShowMenu: Symbol(),
  UIMenuControllerMenuFrameDidChange: Symbol(),
  UIMenuControllerWillHideMenu: Symbol(),
  UIMenuControllerWillShowMenu: Symbol(),
  UIPasteboardChanged: Symbol(),
  UIPasteboardRemoved: Symbol(),
  UIApplicationProtectedDataDidBecomeAvailable: Symbol(),
  UIApplicationProtectedDataWillBecomeUnavailable: Symbol(),
  didChangeAutomaticTextCompletionNotification: Symbol(),
  MPMusicPlayerControllerQueueDidChange: Symbol(),
  GKPlayerAuthenticationDidChangeNotificationName: Symbol(),
  GKPlayerDidChangeNotificationName: Symbol(),
  NEDNSProxyConfigurationDidChange: Symbol(),
  SKStorefrontCountryCodeDidChange: Symbol(),
  UIAccessibilityVoiceOverStatusDidChange: Symbol(),
  UIFocusDidUpdate: Symbol(),
  UIFocusMovementDidFail: Symbol()
  /**
   * An object containing information broadcast to registered observers that bridges to Notification; use NSNotification when you need reference semantics or other Foundation-specific behavior. 
   * @access public
   * @extends {NSObject}
   * @see https://developer.apple.com/documentation/foundation/nsnotification
   */

};
class NSNotification extends NSObject {
  // Creating Notifications

  /**
   * Initializes a notification with the data from an unarchiver.
   * @access public
   * @param {NSCoder} aDecoder - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/foundation/nsnotification/1412464-init
   */
  initCoder(aDecoder) {}
  /**
   * Returns a new notification object with a specified name and object.
   * @access public
   * @param {NSNotification.Name} aName - The name for the new notification. May not be nil.
   * @param {?Object} anObject - The object for the new notification.
   * @returns {void}
   * @see https://developer.apple.com/documentation/foundation/nsnotification/1417440-init
   */


  initNameObject(aName, anObject) {}
  /**
   * Initializes a notification with a specified name, object, and user information.
   * @access public
   * @param {NSNotification.Name} name - 
   * @param {?Object} object - The object for the new notification.
   * @param {?Map<AnyHashable, Object>} [userInfo = null] - The user information dictionary for the new notification. May be nil.
   * @returns {void}
   * @see https://developer.apple.com/documentation/foundation/nsnotification/1415764-init
   */


  constructor(name, object, userInfo = null) {
    super(); // Getting Notification Information

    this._name = name;
    this._object = object;
    this._userInfo = userInfo;
  } // Getting Notification Information

  /**
   * The name of the notification.
   * @type {NSNotification.Name}
   * @desc Typically you use this property to find out what kind of notification you are dealing with when you receive a notification.Special ConsiderationsNotification names can be any string. To avoid name collisions, you might want to use a prefix that’s specific to your application.
   * @see https://developer.apple.com/documentation/foundation/nsnotification/1416472-name
   */


  get name() {
    return this._name;
  }
  /**
   * The object associated with the notification.
   * @type {?Object}
   * @desc This is often the object that posted this notification. It may be nil.Typically you use this method to find out what object a notification applies to when you receive a notification.
   * @see https://developer.apple.com/documentation/foundation/nsnotification/1414469-object
   */


  get object() {
    return this._object;
  }
  /**
   * The user information dictionary associated with the receiver.
   * @type {?Map<AnyHashable, Object>}
   * @desc May be nil.The user information dictionary stores any additional objects that objects receiving the notification might use.For example, in the Application Kit, NSControl objects post the NSControlTextDidChangeNotification whenever the field editor (an NSText object) changes text inside the NSControl. This notification provides the NSControl object as the notification's associated object. In order to provide access to the field editor, the NSControl object posting the notification adds the field editor to the notification's user information dictionary. Objects receiving the notification can access the field editor and the NSControl object posting the notification as follows:- (void)controlTextDidBeginEditing:(NSNotification *)notification
  {
    NSText *fieldEditor = [notification.userInfo
        objectForKey:@"NSFieldEditor"];               // the field editor
    NSControl *postingObject = notification.object;   // the object that posted the notification
    ...
  }
  - (void)controlTextDidBeginEditing:(NSNotification *)notification
  {
    NSText *fieldEditor = [notification.userInfo
        objectForKey:@"NSFieldEditor"];               // the field editor
    NSControl *postingObject = notification.object;   // the object that posted the notification
    ...
  }
    * @see https://developer.apple.com/documentation/foundation/nsnotification/1409222-userinfo
   */


  get userInfo() {
    return this._userInfo;
  } // Structures

  /**
   * @type {Object} Name
   * @property {Symbol} AVAudioEngineConfigurationChange Posted when the audio engine configuration changes.
   * @property {Symbol} AVAudioSessionInterruption Posted when an audio interruption occurs.
   * @property {Symbol} AVAudioSessionMediaServicesWereLost Posted when the media server is terminated.
   * @property {Symbol} AVAudioSessionMediaServicesWereReset Posted when the media server restarts.
   * @property {Symbol} AVAudioSessionRouteChange Posted when the system’s audio route changes.
   * @property {Symbol} AVAudioSessionSilenceSecondaryAudioHint Posted when the primary audio from other applications starts and stops.
   * @property {Symbol} AVAudioUnitComponentTagsDidChange The component tags changed.
   * @property {Symbol} CKAccountChanged Notification posted when the status of the signed-in iCloud account may have changed.
   * @property {Symbol} CLKComplicationServerActiveComplicationsDidChange Posted went the set of active complications changes.
   * @property {Symbol} CNContactStoreDidChange Posted notifications when changes occur in another CNContactStore.
    * @property {Symbol} EKEventStoreChanged Posted whenever changes are made to the Calendar database, including adding, removing, and changing events or reminders. Individual changes are not described. When you receive this notification, you should refetch all EKEvent and EKReminder objects you have accessed, as they are considered stale. If you are actively editing an event and do not wish to refetch it unless it is absolutely necessary to do so, you can call the refresh method on it. If the method returns true, you do not need to refetch the event.
   * @property {Symbol} HKUserPreferencesDidChange Notifies observers whenever the user changes his or her preferred units.
   * @property {Symbol} HMCharacteristicPropertySupportsEvent The characteristic supports notifications using the event connection established by the controller. The event connection provides unidirectional communication from the accessory to the controller.
   * @property {Symbol} NSBundleResourceRequestLowDiskSpace Posted after the system detects that the amount of available disk space is getting low. The notification is posted to the default notification center.
   * @property {Symbol} NSCalendarDayChanged A notification that is posted whenever the calendar day of the system changes, as determined by the system calendar, locale, and time zone.
   * @property {Symbol} NSDidBecomeSingleThreaded Not implemented.
   * @property {Symbol} NSExtensionHostDidBecomeActive Posted when the extension’s host app moves from the inactive to the active state.
   * @property {Symbol} NSExtensionHostDidEnterBackground Posted when the extension’s host app begins running in the background.
   * @property {Symbol} NSExtensionHostWillEnterForeground Posted when the extension’s host app begins running in the foreground.
   * @property {Symbol} NSExtensionHostWillResignActive Posted when the extension’s host app moves from the active to the inactive state.
   * @property {Symbol} NSFileHandleConnectionAccepted This notification is posted when an NSFileHandle object establishes a socket connection between two processes, creates an NSFileHandle object for one end of the connection, and makes this object available to observers by putting it in the userInfo dictionary.
   * @property {Symbol} NSFileHandleDataAvailable This notification is posted when the file handle determines that data is currently available for reading in a file or at a communications channel.
   * @property {Symbol} NSFileHandleReadToEndOfFileCompletion This notification is posted when the file handle reads all data in the file or, if a communications channel, until the other process signals the end of data.
   * @property {Symbol} NSHTTPCookieManagerAcceptPolicyChanged This notification is posted when the acceptance policy of the NSHTTPCookieStorage instance has changed.
   * @property {Symbol} NSHTTPCookieManagerCookiesChanged This notification is posted when the cookies stored in the NSHTTPCookieStorage instance have changed.
   * @property {Symbol} NSManagedObjectContextDidSave A notification that the context completed a save.
   * @property {Symbol} NSManagedObjectContextObjectsDidChange A notification of changes made to managed objects associated with this context.
   * @property {Symbol} NSManagedObjectContextWillSave A notification that the context is about to save.
   * @property {Symbol} NSMetadataQueryDidFinishGathering Posted when the receiver has finished with the initial result-gathering phase of the query.
   * @property {Symbol} NSMetadataQueryDidStartGathering Posted when the receiver begins with the initial result-gathering phase of the query.
   * @property {Symbol} NSMetadataQueryDidUpdate Posted when the receiver’s results have changed during the live-update phase of the query.
   * @property {Symbol} NSMetadataQueryGatheringProgress Posted as the receiver is collecting results during the initial result-gathering phase of the query.
   * @property {Symbol} NSPersistentStoreCoordinatorStoresDidChange Posted whenever persistent stores are added to or removed from a persistent store coordinator, or when store UUIDs change.
   * @property {Symbol} NSPersistentStoreCoordinatorStoresWillChange Posted before the list of open persistent stores changes.
   * @property {Symbol} NSPersistentStoreCoordinatorWillRemoveStore Posted whenever a persistent store is removed from a persistent store coordinator.
   * @property {Symbol} NSProcessInfoPowerStateDidChange Posted when the power state (Low Power Mode is enabled or disabled) of an iOS device changes. 
   * @property {Symbol} NSSystemClockDidChange A notification posted whenever the system clock is changed. 
   * @property {Symbol} NSSystemTimeZoneDidChange A notification posted when the time zone changes.
   * @property {Symbol} NSThreadWillExit An NSThread object posts this notification when it receives the exit() message, before the thread exits. Observer methods invoked to receive this notification execute in the exiting thread, before it exits.
   * @property {Symbol} NSURLCredentialStorageChanged This notification is posted when the set of stored credentials changes.
   * @property {Symbol} NSUbiquityIdentityDidChange Sent after the iCloud (“ubiquity”) identity has changed.
   * @property {Symbol} NSUndoManagerCheckpoint Posted whenever an NSUndoManager object opens or closes an undo group (except when it opens a top-level group) and when checking the redo stack in canRedo. 
   * @property {Symbol} NSUndoManagerDidCloseUndoGroup Posted after an NSUndoManager object closes an undo group, which occurs in the implementation of the endUndoGrouping() method.
   * @property {Symbol} NSUndoManagerDidOpenUndoGroup Posted whenever an NSUndoManager object opens an undo group, which occurs in the implementation of the beginUndoGrouping() method. 
   * @property {Symbol} NSUndoManagerDidRedoChange Posted just after an NSUndoManager object performs a redo operation (redo()).
   * @property {Symbol} NSUndoManagerDidUndoChange Posted just after an NSUndoManager object performs an undo operation.
   * @property {Symbol} NSUndoManagerWillCloseUndoGroup Posted before an NSUndoManager object closes an undo group, which occurs in the implementation of the endUndoGrouping() method.
   * @property {Symbol} NSUndoManagerWillRedoChange Posted just before an NSUndoManager object performs a redo operation (redo()).
   * @property {Symbol} NSUndoManagerWillUndoChange Posted just before an NSUndoManager object performs an undo operation.
   * @property {Symbol} NSWillBecomeMultiThreaded Posted when the first thread is detached from the current thread. The NSThread class posts this notification at most once—the first time a thread is detached using detachNewThreadSelector(_:toTarget:with:) or the start() method. Subsequent invocations of those methods do not post this notification. Observers of this notification have their notification method invoked in the main thread, not the new thread. The observer notification methods always execute before the new thread begins executing.
   * @property {Symbol} PKPassLibraryDidChange Posted after the pass library has been changed.
   * @property {Symbol} PKPassLibraryRemotePaymentPassesDidChange Posted when an Apple Pay card is added to or removed from a device that is paired with the current iOS device (for example, Apple Watch). 
   * @property {Symbol} UIAccessibilityAnnouncementDidFinish Posted by UIKit when the system has finished reading an announcement.
   * @property {Symbol} UIAccessibilityElementFocused 
   * @property {Symbol} WKAudioFilePlayerItemDidPlayToEndTime Posted when the item has played successfully to its end time.
   * @property {Symbol} WKAudioFilePlayerItemFailedToPlayToEndTime Posted when the item failed to play to its end time.
   * @property {Symbol} WKAudioFilePlayerItemTimeJumped Posted when the item’s current time has changed discontinuously. 
   * @property {Symbol} ABPeoplePickerDisplayedPropertyDidChange Posted when the displayed property in the record list is changed.
   * @property {Symbol} ABPeoplePickerGroupSelectionDidChange Posted when the selection in the group list is changed.
   * @property {Symbol} ABPeoplePickerNameSelectionDidChange Posted when the selection in the name list is changed.
   * @property {Symbol} ABPeoplePickerValueSelectionDidChange Posted when the selection in a multivalue property is changed.
   * @property {Symbol} ACAccountStoreDidChange Posted when the accounts managed by this account store changed in the database. There is no userInfo dictionary associated with this notification.
   * @property {Symbol} AVAssetChapterMetadataGroupsDidChange 
   * @property {Symbol} AVAssetContainsFragmentsDidChange 
   * @property {Symbol} AVAssetDurationDidChange 
   * @property {Symbol} AVAssetMediaSelectionGroupsDidChange 
   * @property {Symbol} AVAssetTrackSegmentsDidChange 
   * @property {Symbol} AVAssetTrackTimeRangeDidChange 
   * @property {Symbol} AVAssetTrackTrackAssociationsDidChange 
   * @property {Symbol} AVAssetWasDefragmented 
   * @property {Symbol} AVCaptureDeviceWasConnected Posted when a new device becomes available.
   * @property {Symbol} AVCaptureDeviceWasDisconnected Posted when an existing device becomes unavailable.
   * @property {Symbol} AVCaptureInputPortFormatDescriptionDidChange Posted if the value of the capture input port’sformatDescription property changes.
   * @property {Symbol} AVCaptureSessionDidStartRunning Posted when a capture session starts.
   * @property {Symbol} AVCaptureSessionDidStopRunning Posted when a capture session stops.
   * @property {Symbol} AVCaptureSessionRuntimeError Posted if an error occurred during a capture session.
   * @property {Symbol} AVFragmentedMovieContainsMovieFragmentsDidChange 
   * @property {Symbol} AVFragmentedMovieDurationDidChange 
   * @property {Symbol} AVFragmentedMovieTrackSegmentsDidChange 
   * @property {Symbol} AVFragmentedMovieTrackTimeRangeDidChange 
   * @property {Symbol} AVFragmentedMovieTrackTotalSampleDataLengthDidChange 
   * @property {Symbol} AVFragmentedMovieWasDefragmented 
   * @property {Symbol} AVPlayerItemDidPlayToEndTime Posted when the item has played to its end time.
   * @property {Symbol} AVPlayerItemFailedToPlayToEndTime Posted when the item failed to play to its end time.
   * @property {Symbol} AVPlayerItemNewAccessLogEntry Posted when a new access log entry has been added.
   * @property {Symbol} AVPlayerItemNewErrorLogEntry Posted when a new error log entry has been added.
   * @property {Symbol} AVPlayerItemPlaybackStalled Posted when some media did not arrive in time to continue playback.
   * @property {Symbol} AVPlayerItemTimeJumped Posted when the item’s current time has changed discontinuously.
   * @property {Symbol} AVSampleBufferDisplayLayerFailedToDecode Posted when a buffer display layer failed to decode.
   * @property {Symbol} CWBSSIDDidChange 
   * @property {Symbol} CWCountryCodeDidChange 
   * @property {Symbol} CWLinkDidChange 
   * @property {Symbol} CWLinkQualityDidChange 
   * @property {Symbol} CWModeDidChange 
   * @property {Symbol} CWPowerDidChange 
   * @property {Symbol} CWSSIDDidChange 
   * @property {Symbol} CWScanCacheDidUpdate 
   * @property {Symbol} GCControllerDidConnect Posted immediately after a new controller is connected to the device.
   * @property {Symbol} GCControllerDidDisconnect Posted immediately after a controller is disconnected from the device.
   * @property {Symbol} IKFilterBrowserFilterDoubleClick Posted when the user double-clicks a filter in the filter browser. 
   * @property {Symbol} IKFilterBrowserFilterSelected Posted when the user clicks a filter name in the filter browser. 
   * @property {Symbol} IKFilterBrowserWillPreviewFilter Posted before showing a filter preview, allowing an application to set the parameters of a filter.
   * @property {Symbol} IOBluetoothHostControllerPoweredOff 
   * @property {Symbol} IOBluetoothHostControllerPoweredOn 
   * @property {Symbol} IOBluetoothL2CAPChannelPublished 
   * @property {Symbol} IOBluetoothL2CAPChannelTerminated 
   * @property {Symbol} MKAnnotationCalloutInfoDidChange Notifies observers that the title or subtitle information of an annotation object changed.
   * @property {Symbol} NEFilterConfigurationDidChange Posted after the filter configuration stored in the Network Extension preferences changes.
   * @property {Symbol} NEVPNConfigurationChange Posted after the VPN configuration stored in the Network Extension preferences changes.
   * @property {Symbol} NEVPNStatusDidChange Posted when the status of the VPN connection changes.
   * @property {Symbol} announcementRequested This notification is posted whenever an accessibility element needs to make an announcement to the user. This notification requires a userInfo dictionary with the key announcement and a localized string containing the announcement. To help an assistive app determine the importance of the announcement, add the appropriate priority to the userInfo dictionary.
   * @property {Symbol} applicationActivated This notification is posted after the app has been activated. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
   * @property {Symbol} applicationDeactivated This notification is posted after the app has been deactivated.  Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
   * @property {Symbol} applicationHidden This notification is posted after the app is hidden. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
   * @property {Symbol} applicationShown This notification is posted after the app is shown. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
   * @property {Symbol} created This notification is posted after an accessibility element is created. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
   * @property {Symbol} drawerCreated This notification is posted after a drawer appears. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
   * @property {Symbol} focusedUIElementChanged This notification is posted after an accessibility element gains focus. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
   * @property {Symbol} focusedWindowChanged This notification is posted after the key window changes. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
   * @property {Symbol} helpTagCreated This notification is posted after a help tag appears. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
   * @property {Symbol} layoutChanged This notification is posted after the UI changes in a way that requires the attention of an accessibility client. This notification should be accompanied by a userInfo dictionary with the key uiElements and an array containing the UI elements that have been added or changed. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
   * @property {Symbol} mainWindowChanged This notification is posted after the main window changes. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
   * @property {Symbol} moved This notification is posted after an accessibility element moves. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
   * @property {Symbol} resized This notification is posted after an accessibility element’s size changes. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
   * @property {Symbol} rowCollapsed This notification is posted after a row collapses. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
   * @property {Symbol} rowCountChanged This notification is posted after a row is added or deleted. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
   * @property {Symbol} rowExpanded This notification is posted after a row expands. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
   * @property {Symbol} selectedCellsChanged This notification is posted after one or more cells in a cell-based table are selected or deselected. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
   * @property {Symbol} selectedChildrenChanged This notification is posted after one or more child elements are selected or deselected. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
   * @property {Symbol} selectedChildrenMoved This notification is posted after the selected items in a layout area move. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
   * @property {Symbol} selectedColumnsChanged This notification is posted after one or more columns are selected or deselected. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
   * @property {Symbol} selectedRowsChanged This notification is posted after one or more rows are selected or deselected. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
   * @property {Symbol} selectedTextChanged This notification is posted after text is selected or deselected.  Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
   * @property {Symbol} sheetCreated This notification is posted after a sheet appears.  Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
   * @property {Symbol} titleChanged This notification is posted after an accessibility element’s title changes. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
   * @property {Symbol} uiElementDestroyed This notification is posted after an accessibility element is destroyed. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
   * @property {Symbol} unitsChanged This notification is posted after the units in a layout area change. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
   * @property {Symbol} valueChanged This notification is posted after an accessibility element’s value changes. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
   * @property {Symbol} windowCreated This notification is posted after a new window appears. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
   * @property {Symbol} windowDeminiaturized This notification is posted after a window is restored to full size from the Dock.  Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
   * @property {Symbol} windowMiniaturized This notification is posted after a window is put in the Dock. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
   * @property {Symbol} windowMoved This notification is posted after a window moves.  Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
   * @property {Symbol} windowResized This notification is posted after a window’s size changes. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
   * @property {Symbol} progressMarkNotification Posted when the current progress of a running animation reaches one of its progress marks.
   * @property {Symbol} antialiasThresholdChangedNotification Posted after the threshold for anti-aliasing changes.
   * @property {Symbol} NSAppleEventManagerWillProcessFirstEvent Posted by NSAppleEventManager before it first dispatches an Apple event. Your application can use this notification to avoid registering any Apple event handlers until the first time at which they may be needed.
   * @property {Symbol} didBecomeActiveNotification Posted immediately after the app becomes active.
   * @property {Symbol} didChangeOcclusionStateNotification Posted when the app’s occlusion state changes.
   * @property {Symbol} didChangeScreenParametersNotification Posted when the configuration of the displays attached to the computer is changed.
   * @property {Symbol} didFinishLaunchingNotification Posted at the end of the finishLaunching() method to indicate that the app has completed launching and is ready to run.
   * @property {Symbol} didFinishRestoringWindowsNotification Posted when the app is finished restoring windows.
   * @property {Symbol} didHideNotification Posted at the end of the hide(_:) method to indicate that the app is now hidden.
   * @property {Symbol} didResignActiveNotification Posted immediately after the app gives up its active status to another app.
   * @property {Symbol} didUnhideNotification Posted at the end of the unhideWithoutActivation() method to indicate that the app is now visible.
   * @property {Symbol} didUpdateNotification Posted at the end of the updateWindows() method to indicate that the app has finished updating its windows.
   * @property {Symbol} willBecomeActiveNotification Posted immediately before the app becomes active.
   * @property {Symbol} willFinishLaunchingNotification Posted at the start of the finishLaunching() method to indicate that the app has completed its initialization process and is about to finish launching.
   * @property {Symbol} willHideNotification Posted at the start of the hide(_:) method to indicate that the app is about to be hidden.
   * @property {Symbol} willResignActiveNotification Posted immediately before the app gives up its active status to another app.
   * @property {Symbol} willTerminateNotification Posted by the terminate(_:) method to indicate that the app will terminate.
   * @property {Symbol} willUnhideNotification Posted at the start of the unhideWithoutActivation() method to indicate that the app is about to become visible.
   * @property {Symbol} willUpdateNotification Posted at the start of the updateWindows() method to indicate that the app is about to update its windows.
   * @property {Symbol} columnConfigurationDidChangeNotification Notifies the delegate when the width of a browser column has changed.
   * @property {Symbol} NSClassDescriptionNeededForClass Posted by init(for:) when a class description cannot be found for a class.
   * @property {Symbol} didChangeNotification 
   * @property {Symbol} colorDidChangeNotification Posted when the color of the NSColorPanel is set, as when NSColorPanel is invoked.
   * @property {Symbol} selectionDidChangeNotification Posted after the pop-up list selection of the NSComboBox changes. 
   * @property {Symbol} selectionIsChangingNotification Posted whenever the pop-up list selection of the NSComboBox is changing. 
   * @property {Symbol} willDismissNotification Posted whenever the pop-up list of the NSComboBox is about to be dismissed.
   * @property {Symbol} willPopUpNotification Posted whenever the pop-up list of the NSComboBox is going to be displayed. 
   * @property {Symbol} contextHelpModeDidActivateNotification Posted when the application enters context-sensitive help mode. This typically happens when the user holds down the Help key.
   * @property {Symbol} contextHelpModeDidDeactivateNotification Posted when the application exits context-sensitive help mode. This happens when the user clicks the mouse button while the cursor is anywhere on the screen after displaying a context-sensitive help topic.
   * @property {Symbol} textDidBeginEditingNotification Sent when a control with editable cells begins an edit session. 
   * @property {Symbol} textDidChangeNotification Sent when the text in the receiving control changes. 
   * @property {Symbol} textDidEndEditingNotification Sent when a control with editable cells ends an editing session. 
   * @property {Symbol} currentControlTintDidChangeNotification Sent after the user changes control tint preference.
   * @property {Symbol} didCloseNotification Posted whenever the drawer is closed. 
   * @property {Symbol} didOpenNotification Posted whenever the drawer is opened. 
   * @property {Symbol} willCloseNotification Posted whenever the drawer is about to close. 
   * @property {Symbol} willOpenNotification Posted whenever the drawer is about to open.
   * @property {Symbol} didChangeNotification Posted whenever a font collection is changed.
   * @property {Symbol} fontSetChangedNotification Posted after the the currently-set font changes.
   * @property {Symbol} registryDidChangeNotification Posted whenever the NSImageRep class registry changes.
   * @property {Symbol} didAddItemNotification Posted after a menu item is added to the menu.
   * @property {Symbol} didBeginTrackingNotification Posted when menu tracking begins.
   * @property {Symbol} didChangeItemNotification Posted after a menu item in the menu changes appearance.
   * @property {Symbol} didEndTrackingNotification Posted when menu tracking ends, even if no action is sent.
   * @property {Symbol} didRemoveItemNotification Posted after a menu item is removed from the menu.
   * @property {Symbol} didSendActionNotification Posted just after the application dispatches a menu item’s action method to the menu item’s target.
   * @property {Symbol} willSendActionNotification Posted just before the application dispatches a menu item’s action method to the menu item’s target.
   * @property {Symbol} columnDidMoveNotification Posted whenever a column is moved by user action in an NSOutlineView object.
   * @property {Symbol} columnDidResizeNotification Posted whenever a column is resized in an NSOutlineView object.
   * @property {Symbol} itemDidCollapseNotification Posted whenever an item is collapsed in an NSOutlineView object.
   * @property {Symbol} itemDidExpandNotification Posted whenever an item is expanded in an NSOutlineView object.
   * @property {Symbol} itemWillCollapseNotification Posted before an item is collapsed (after the user clicks the arrow but before the item is collapsed).
   * @property {Symbol} itemWillExpandNotification Posted before an item is expanded (after the user clicks the arrow but before the item is collapsed).
   * @property {Symbol} selectionDidChangeNotification Posted after the outline view's selection changes.
   * @property {Symbol} selectionIsChangingNotification Posted as the outline view’s selection changes (while the mouse button is still down).
   * @property {Symbol} NSPersistentStoreDidImportUbiquitousContentChanges Posted after records are imported from the ubiquitous content store.
   * @property {Symbol} willPopUpNotification This notification is posted just before an pop-up menu is attached to its window frame.
   * @property {Symbol} willPopUpNotification Posted when an NSPopUpButton object receives a mouse-down event—that is, when the user is about to select an item from the menu.
   * @property {Symbol} didCloseNotification Sent after the popover has finished animating offscreen.
   * @property {Symbol} didShowNotification Sent after the popover has finished animating onscreen.
   * @property {Symbol} willCloseNotification Sent before the popover is closed.
   * @property {Symbol} willShowNotification Sent before the popover is shown.
   * @property {Symbol} preferredScrollerStyleDidChangeNotification Posted if the preferred scroller style changes.
   * @property {Symbol} rowsDidChangeNotification This notification is posted to the default notification center whenever the view's rows change.
   * @property {Symbol} colorSpaceDidChangeNotification Posted when the color space of the screen has changed.
   * @property {Symbol} didEndLiveMagnifyNotification Posted at the end of a magnify gesture.
   * @property {Symbol} didEndLiveScrollNotification Posted on the main thread at the end of live scroll tracking.
   * @property {Symbol} didLiveScrollNotification Posted on the main thread after changing the clipview bounds origin due to a user-initiated event.
   * @property {Symbol} willStartLiveMagnifyNotification Posted at the beginning of a magnify gesture.
   * @property {Symbol} willStartLiveScrollNotification Posted on the main thread at the beginning of user-initiated live scroll tracking (gesture scroll or scroller tracking, for example, thumb dragging).
   * @property {Symbol} didChangeAutomaticCapitalizationNotification 
   * @property {Symbol} didChangeAutomaticDashSubstitutionNotification 
   * @property {Symbol} didChangeAutomaticPeriodSubstitutionNotification 
   * @property {Symbol} didChangeAutomaticQuoteSubstitutionNotification 
   * @property {Symbol} didChangeAutomaticSpellingCorrectionNotification This notification is posted when the spell checker did change text using automatic spell checking correction. The are posted to the application’s default notification center.
   * @property {Symbol} didChangeAutomaticTextReplacementNotification Posted when the spell checker changed text using automatic text replacement.  This notification is posted to the app’s default notification center. 
   * @property {Symbol} didResizeSubviewsNotification Posted after an NSSplitView changes the sizes of some or all of its subviews. 
   * @property {Symbol} willResizeSubviewsNotification Posted before an NSSplitView changes the sizes of some or all of its subviews.
   * @property {Symbol} systemColorsDidChangeNotification Sent when the system colors have been changed (such as through a system control panel interface).
   * @property {Symbol} columnDidMoveNotification Posted whenever a column is moved by user action in an NSTableView object.
   * @property {Symbol} columnDidResizeNotification Posted whenever a column is resized in an NSTableView object.
   * @property {Symbol} selectionDidChangeNotification Posted after an NSTableView object's selection changes.
   * @property {Symbol} selectionIsChangingNotification Posted as an NSTableView object's selection changes (while the mouse button is still down).
   * @property {Symbol} selectedAlternativeStringNotification Posted when the user selects an alternate string.
   * @property {Symbol} didBeginEditingNotification Posted when an NSText object begins any operation that changes characters or formatting attributes.
   * @property {Symbol} didChangeNotification Posted after an NSText object performs any operation that changes characters or formatting attributes.
   * @property {Symbol} didEndEditingNotification Posted when focus leaves an NSText object, whether or not any operation has changed characters or formatting attributes.
   * @property {Symbol} keyboardSelectionDidChangeNotification Posted after the selected text input source changes.
   * @property {Symbol} NSTextStorageDidProcessEditing Posted after a text storage finishes processing edits in processEditing().
   * @property {Symbol} NSTextStorageWillProcessEditing Posted before a text storage finishes processing edits in processEditing().
   * @property {Symbol} didChangeSelectionNotification Posted when the selected range of characters changes.
   * @property {Symbol} didChangeTypingAttributesNotification Posted when there is a change in the typing attributes within a text view.
   * @property {Symbol} willChangeNotifyingTextViewNotification Posted when a new text view is established as the text view that sends notifications.
   * @property {Symbol} didRemoveItemNotification Posted after an item is removed from a toolbar.
   * @property {Symbol} willAddItemNotification Posted before a new item is added to the toolbar.
   * @property {Symbol} boundsDidChangeNotification Posted whenever the NSView’s bounds rectangle changes to a new value independently of the frame rectangle, but only when the view’s postsBoundsChangedNotifications property is true.  
   * @property {Symbol} didUpdateTrackingAreasNotification Posted whenever an NSView object recalculates its tracking areas.
   * @property {Symbol} frameDidChangeNotification Posted whenever the view’s frame rectangle changes to a new value, but only when the view’s postsFrameChangedNotifications property is true.
   * @property {Symbol} globalFrameDidChangeNotification Posted whenever an NSView object that has attached surfaces (that is, NSOpenGLContext objects) moves to a different screen, or other cases where the NSOpenGLContext object needs to be updated. 
   * @property {Symbol} didBecomeKeyNotification Posted whenever an NSWindow object becomes the key window.
   * @property {Symbol} didBecomeMainNotification Posted whenever an NSWindow object becomes the main window.
   * @property {Symbol} didChangeBackingPropertiesNotification Posted when the window backing properties change.
   * @property {Symbol} didChangeOcclusionStateNotification Posted when the window’s occlusion state changes.
   * @property {Symbol} didChangeScreenNotification Posted whenever a portion of an NSWindow object’s frame moves onto or off of a screen.
   * @property {Symbol} didChangeScreenProfileNotification Posted whenever the display profile for the screen containing the window changes.
   * @property {Symbol} didDeminiaturizeNotification Posted whenever an NSWindow object is deminimized.
   * @property {Symbol} didEndLiveResizeNotification Posted after the user resizes a window.
   * @property {Symbol} didEndSheetNotification Posted whenever an NSWindow object closes an attached sheet.
   * @property {Symbol} didEnterFullScreenNotification Posted when the window entered full screen mode.
   * @property {Symbol} didEnterVersionBrowserNotification Posted when the window will enter version browser mode.
   * @property {Symbol} didExitFullScreenNotification Posted when the window did exit full screen mode.
   * @property {Symbol} didExitVersionBrowserNotification Posted when the window did exit version browser mode.
   * @property {Symbol} didExposeNotification Posted whenever a portion of a nonretained NSWindow object is exposed, whether by being ordered in front of other windows or by other windows being removed from in front of it.
   * @property {Symbol} didMiniaturizeNotification Posted whenever an NSWindow object is minimized.
   * @property {Symbol} didMoveNotification Posted whenever an NSWindow object is moved.
   * @property {Symbol} didResignKeyNotification Posted whenever an NSWindow object resigns its status as key window.
   * @property {Symbol} didResignMainNotification Posted whenever an NSWindow object resigns its status as main window.
   * @property {Symbol} didResizeNotification Posted whenever an NSWindow object’s size changes.
   * @property {Symbol} didUpdateNotification Posted whenever an NSWindow object receives an update() message.
   * @property {Symbol} willBeginSheetNotification Posted whenever an NSWindow object is about to open a sheet.
   * @property {Symbol} willCloseNotification Posted whenever an NSWindow object is about to close.
   * @property {Symbol} willEnterFullScreenNotification Posted when the window will enter full screen mode.
   * @property {Symbol} willEnterVersionBrowserNotification Posted when the window will enter version browser mode.
   * @property {Symbol} willExitFullScreenNotification Posted when the window will exit full screen mode.
   * @property {Symbol} willExitVersionBrowserNotification Posted when the window will exit version browser mode.
   * @property {Symbol} willMiniaturizeNotification Posted whenever an NSWindow object is about to be minimized.
   * @property {Symbol} willMoveNotification Posted whenever an NSWindow object is about to move.
   * @property {Symbol} willStartLiveResizeNotification Posted before the user resizes a window.
   * @property {Symbol} accessibilityDisplayOptionsDidChangeNotification Posted when any of the accessibility display options change.
   * @property {Symbol} activeSpaceDidChangeNotification Posted when a Spaces change has occurred.
   * @property {Symbol} didActivateApplicationNotification Posted when the Finder is about to activate an app.
   * @property {Symbol} didChangeFileLabelsNotification Posted when the Finder file labels or colors change.
   * @property {Symbol} didDeactivateApplicationNotification Posted when the Finder deactivated an app.
   * @property {Symbol} didHideApplicationNotification Posted when the Finder hid an app.
   * @property {Symbol} didLaunchApplicationNotification Posted when a new app has started up.
   * @property {Symbol} didMountNotification Posted when a new device has been mounted.
   * @property {Symbol} didPerformFileOperationNotification Posted when a file operation has been performed in the receiving app.
   * @property {Symbol} didRenameVolumeNotification Posted when a volume changes its name and/or mount path.  These typically change simultaneously, in which case only one notification is posted.
   * @property {Symbol} didTerminateApplicationNotification Posted when an app finishes executing.
   * @property {Symbol} didUnhideApplicationNotification Posted when the Finder unhid an app.
   * @property {Symbol} didUnmountNotification Posted when the Finder did unmount a device.
   * @property {Symbol} didWakeNotification Posted when the machine wakes from sleep.
   * @property {Symbol} screensDidSleepNotification Posted when the machine’s screen goes to sleep.
   * @property {Symbol} screensDidWakeNotification Posted when the machine’s screens wake.
   * @property {Symbol} sessionDidBecomeActiveNotification Posted after a user session is switched in.
   * @property {Symbol} sessionDidResignActiveNotification Posted before a user session is switched out.
   * @property {Symbol} willLaunchApplicationNotification Posted when the Finder is about to launch an app.
   * @property {Symbol} willPowerOffNotification Posted when the user has requested a logout or that the machine be powered off.
   * @property {Symbol} willSleepNotification Posted before the machine goes to sleep.
   * @property {Symbol} willUnmountNotification Posted when the Finder is about to unmount a device.
   * @property {Symbol} PDFDocumentDidBeginFind Posted when the beginFindString(_:withOptions:) or findString(_:withOptions:) method begins finding.
   * @property {Symbol} PDFDocumentDidBeginPageFind Posted each time a find operation begins working on a new page of a document.
   * @property {Symbol} PDFDocumentDidBeginPageWrite Posted each time a write operation begins working on a page in a document.
   * @property {Symbol} PDFDocumentDidBeginWrite Posted each time a write operation begins working on a document.
   * @property {Symbol} PDFDocumentDidEndFind Posted when the beginFindString(_:withOptions:) or findString(_:withOptions:) method returns.
   * @property {Symbol} PDFDocumentDidEndPageFind Posted each time a find operation finishes working on a page in a document.
   * @property {Symbol} PDFDocumentDidEndPageWrite Posted each time a write operation finishes working on a page in a document.
   * @property {Symbol} PDFDocumentDidEndWrite Posted each time a write operation finishes working on a document.
   * @property {Symbol} PDFDocumentDidFindMatch Posted each time a string match is found in a document.
   * @property {Symbol} PDFDocumentDidUnlock Posted when a document unlocks after a unlock(withPassword:) message.
   * @property {Symbol} PDFThumbnailViewDocumentEdited 
   * @property {Symbol} PDFViewAnnotationHit Posted when the user clicks on an annotation. 
   * @property {Symbol} PDFViewAnnotationWillHit Posted before the user clicks an annotation.
   * @property {Symbol} PDFViewChangedHistory Posted when the page history changes.
   * @property {Symbol} PDFViewCopyPermission Posted when the user attempts to copy to the pasteboard without the appropriate permissions. 
   * @property {Symbol} PDFViewDisplayBoxChanged Posted when the display box has changed.
   * @property {Symbol} PDFViewDisplayModeChanged Posted when the display mode has changed.
   * @property {Symbol} PDFViewDocumentChanged Posted when a new document is associated with the view.
   * @property {Symbol} PDFViewPageChanged Posted when a new page becomes the current page.
   * @property {Symbol} PDFViewPrintPermission Posted when the user attempts to print without the appropriate permissions. 
   * @property {Symbol} PDFViewScaleChanged Posted when the scale factor changes. 
   * @property {Symbol} PDFViewSelectionChanged Posted when the current selection has changed.
   * @property {Symbol} PDFViewVisiblePagesChanged 
   * @property {Symbol} QCCompositionPickerPanelDidSelectComposition Posted when the user chooses a composition.
   * @property {Symbol} QCCompositionPickerViewDidSelectComposition Posted when the user selects a composition in the picker view.
   * @property {Symbol} QCCompositionRepositoryDidUpdate Posted whenever the list of compositions in the composition repository is updated.
   * @property {Symbol} QCViewDidStartRendering Posted when the view starts rendering.
   * @property {Symbol} QCViewDidStopRendering Posted when the view stops rendering.
   * @property {Symbol} WebHistoryAllItemsRemoved Posted when all history items have been removed from the web history.
   * @property {Symbol} WebHistoryItemChanged Posted by a WebHistoryItem object when the value of the history item’s title, alternate title, URL strings, or last visited interval changes.
   * @property {Symbol} WebHistoryItemsAdded Posted when history items have been added to a web history.
   * @property {Symbol} WebHistoryItemsRemoved Posted when items have been removed from the web history.
   * @property {Symbol} WebHistoryLoaded Posted when web history items have been loaded from a URL.
   * @property {Symbol} WebHistorySaved Posted when web history items have been saved to a URL.
   * @property {Symbol} WebPreferencesChanged Posted when the web preference settings are changed. 
   * @property {Symbol} WebViewDidBeginEditing Posted when a web view begins any operation that changes its contents in response to user editing.
   * @property {Symbol} WebViewDidChange Posted when a web view performs any operation that changes its contents in response to user editing.
   * @property {Symbol} WebViewDidChangeSelection Posted when a web view changes its typing selection.
   * @property {Symbol} WebViewDidChangeTypingStyle Posted when a web view changes its typing style.
   * @property {Symbol} WebViewDidEndEditing Posted when a web view ends any operation that changes its contents in response to user editing.
   * @property {Symbol} WebViewProgressEstimateChanged Posted by a WebView object when the estimated progress value of a load changes.
   * @property {Symbol} WebViewProgressFinished Posted by a WebView object when the load has finished.
   * @property {Symbol} WebViewProgressStarted Posted by a WebView object when a load begins, including a load that is initiated in a subframe.
   * @property {Symbol} abDatabaseChanged Posted when this process has changed the Address Book database.
   * @property {Symbol} abDatabaseChangedExternally Posted when a process other than the current one has changed the Address Book database.
   * @property {Symbol} quartzFilterManagerDidAddFilter 
   * @property {Symbol} quartzFilterManagerDidModifyFilter 
   * @property {Symbol} quartzFilterManagerDidRemoveFilter 
   * @property {Symbol} quartzFilterManagerDidSelectFilter 
   * @property {Symbol} EAAccessoryDidConnect Posted when an accessory becomes connected and available for your application to use.
   * @property {Symbol} EAAccessoryDidDisconnect Posted when an accessory is disconnected and no longer available for your application to use.
   * @property {Symbol} MPMovieDurationAvailable Posted when the duration of a movie has been determined. There is no userInfo dictionary.
   * @property {Symbol} MPMovieMediaTypesAvailable Posted when the available media types in a movie are determined. There is no userInfo dictionary.
   * @property {Symbol} MPMovieNaturalSizeAvailable Posted when the natural frame size of a movie is first determined or subsequently changes. There is no userInfo dictionary.
   * @property {Symbol} MPMoviePlayerDidEnterFullscreen Posted when a movie player has entered full-screen mode. There is no userInfo dictionary.
   * @property {Symbol} MPMoviePlayerDidExitFullscreen Posted when a movie player has exited full-screen mode. There is no userInfo dictionary.  
   * @property {Symbol} MPMoviePlayerIsAirPlayVideoActiveDidChange Posted when a movie player has started or ended playing a movie via AirPlay. There is no userInfo dictionary.
   * @property {Symbol} MPMoviePlayerLoadStateDidChange Posted when a movie player’s network buffering state has changed. There is no userInfo dictionary.
   * @property {Symbol} MPMoviePlayerNowPlayingMovieDidChange Posted when the currently playing movie has changed. There is no userInfo dictionary.
   * @property {Symbol} MPMoviePlayerPlaybackDidFinish Posted when a movie has finished playing. The userInfo dictionary of this notification contains the MPMoviePlayerPlaybackDidFinishReasonUserInfoKey key, which indicates the reason that playback finished. This notification is also sent when playback fails because of an error.
   * @property {Symbol} MPMoviePlayerPlaybackStateDidChange Posted when a movie player’s playback state has changed. There is no userInfo dictionary.
   * @property {Symbol} MPMoviePlayerReadyForDisplayDidChange Posted when the ready for display state changes.
   * @property {Symbol} MPMoviePlayerScalingModeDidChange Posted when the scaling mode of a movie player has changed. There is no userInfo dictionary.
   * @property {Symbol} MPMoviePlayerThumbnailImageRequestDidFinish Posted when a request to capture a thumbnail from a movie has finished whether the request succeeded or failed. Upon successful capture of a thumbnail, the userInfo dictionary contains values for the following keys:
   * @property {Symbol} MPMoviePlayerTimedMetadataUpdated Posted when new timed metadata arrives.
   * @property {Symbol} MPMoviePlayerWillEnterFullscreen Posted when a movie player is about to enter full-screen mode. The userInfo dictionary contains keys whose values describe the transition animation used to enter full-screen mode. See Fullscreen Notification Keys.
   * @property {Symbol} MPMoviePlayerWillExitFullscreen Posted when a movie player is about to exit full-screen mode. The userInfo dictionary contains keys whose values describe the transition animation used to exit full-screen mode. See Fullscreen Notification Keys.
   * @property {Symbol} MPMovieSourceTypeAvailable Posted when the source type of a movie was previously unknown and is newly available. There is no userInfo dictionary.
   * @property {Symbol} SKCloudServiceCapabilitiesDidChange Called when the capabilities associated with the music library on the device change.
   * @property {Symbol} SKStorefrontIdentifierDidChange Called when the storefront identifier associated with the device changes.
   * @property {Symbol} TVTopShelfItemsDidChange A notification to post when your app’s Top Shelf content has changed.
   * @property {Symbol} UIAccessibilityAssistiveTouchStatusDidChange 
   * @property {Symbol} UIAccessibilityBoldTextStatusDidChange Posted by UIKit when the system’s Bold Text setting has changed. 
   * @property {Symbol} UIAccessibilityClosedCaptioningStatusDidChange Posted by UIKit when the setting for closed captioning has changed.
   * @property {Symbol} UIAccessibilityDarkerSystemColorsStatusDidChange Posted by UIKit when the system’s Darken Colors setting has changed.
   * @property {Symbol} UIAccessibilityGrayscaleStatusDidChange Posted by UIKit when the system’s Grayscale setting has changed.
   * @property {Symbol} UIAccessibilityGuidedAccessStatusDidChange Posted by UIKit when a Guided Access session starts or ends.  
   * @property {Symbol} UIAccessibilityHearingDevicePairedEarDidChange 
   * @property {Symbol} UIAccessibilityInvertColorsStatusDidChange Posted by UIKit when the setting for inverted colors has changed.  
   * @property {Symbol} UIAccessibilityMonoAudioStatusDidChange Posted by UIKit when system audio changes from stereo to mono.
   * @property {Symbol} UIAccessibilityReduceMotionStatusDidChange Posted by UIKit when the system’s Reduce Motion setting has changed.
   * @property {Symbol} UIAccessibilityReduceTransparencyStatusDidChange Posted by UIKit when the system’s Reduce Transparency system setting has changed.
   * @property {Symbol} UIAccessibilityShakeToUndoDidChange 
   * @property {Symbol} UIAccessibilitySpeakScreenStatusDidChange Posted by UIKit when the system’s Speak Screen setting has changed.
   * @property {Symbol} UIAccessibilitySpeakSelectionStatusDidChange Posted by UIKit when the system’s Speak Selection setting has changed.
   * @property {Symbol} UIAccessibilitySwitchControlStatusDidChange Posted by UIKit when the system’s Switch Control setting has changed.
   * @property {Symbol} UIApplicationDidBecomeActive Posted when the app becomes active. 
   * @property {Symbol} UIApplicationDidEnterBackground Posted when the app enters the background.
   * @property {Symbol} UIApplicationDidFinishLaunching Posted immediately after the app finishes launching.
   * @property {Symbol} UIApplicationDidReceiveMemoryWarning Posted when the app receives a warning from the operating system about low memory availability.
   * @property {Symbol} UIApplicationSignificantTimeChange Posted when there is a significant change in time, for example, change to a new day (midnight), carrier time update, and change to or from daylight savings time.
   * @property {Symbol} UIApplicationUserDidTakeScreenshot Posted when the user presses the Home and Lock buttons to take a screenshot. 
   * @property {Symbol} UIApplicationWillEnterForeground Posted shortly before an app leaves the background state on its way to becoming the active app.
   * @property {Symbol} UIApplicationWillResignActive Posted when the app is no longer active and loses focus.
   * @property {Symbol} UIApplicationWillTerminate Posted when the app is about to terminate.
   * @property {Symbol} UIContentSizeCategoryDidChange Posted when the user changes the preferred content size setting. 
   * @property {Symbol} UIDeviceProximityStateDidChange Posted when the state of the proximity sensor changes.
   * @property {Symbol} UIScreenBrightnessDidChange This notification is posted when the brightness of a screen changes. The object of the notification is the UIScreen object whose brightness property changed. There is no userInfo dictionary. 
   * @property {Symbol} UIScreenDidConnect This notification is posted when a new screen is connected to the device. The object of the notification is the UIScreen object representing the new screen. There is no userInfo dictionary. 
   * @property {Symbol} UIScreenDidDisconnect This notification is posted when a screen is disconnected from the device. The object of the notification is the UIScreen object that represented the now disconnected screen. There is no userInfo dictionary. 
   * @property {Symbol} UIScreenModeDidChange This notification is posted when the current mode of a screen changes. The object of the notification is the UIScreen object whose currentMode property changed. There is no userInfo dictionary. 
   * @property {Symbol} UITableViewSelectionDidChange Posted when the selected row in the posting table view changes.
   * @property {Symbol} UITextFieldTextDidBeginEditing Notifies observers that an editing session began in a text field. The affected text field is stored in the object parameter of the notification. The userInfo dictionary is not used.
   * @property {Symbol} UITextFieldTextDidChange Notifies observers that the text in a text field changed. The affected text field is stored in the object parameter of the notification. 
   * @property {Symbol} UITextFieldTextDidEndEditing Notifies observers that the editing session ended for a text field. The affected text field is stored in the object parameter of the notification. The userInfo dictionary is not used.
   * @property {Symbol} UITextInputCurrentInputModeDidChange Posted when the current input mode changes.
   * @property {Symbol} UITextViewTextDidBeginEditing Notifies observers that an editing session began in a text view. The affected view is stored in the object parameter of the notification. The userInfo dictionary is not used.
   * @property {Symbol} UITextViewTextDidChange Notifies observers that the text in a text view changed. The affected view is stored in the object parameter of the notification. The userInfo dictionary is not used.
   * @property {Symbol} UITextViewTextDidEndEditing Notifies observers that the editing session ended for a text view. The affected view is stored in the object parameter of the notification. The userInfo dictionary is not used.
   * @property {Symbol} UIViewControllerShowDetailTargetDidChange Posted when a split view controller is expanded or collapsed.
   * @property {Symbol} UIWindowDidBecomeHidden Posted when an UIWindow object becomes hidden.
   * @property {Symbol} UIWindowDidBecomeKey Posted whenever a UIWindow object becomes the key window.
   * @property {Symbol} UIWindowDidBecomeVisible Posted when an UIWindow object becomes visible.
   * @property {Symbol} UIWindowDidResignKey Posted whenever a UIWindow object resigns its status as main window.
   * @property {Symbol} ALAssetsLibraryChanged Sent when the contents of the assets library have changed from under the app that is using the data.
   * @property {Symbol} AVCaptureDeviceSubjectAreaDidChange Posted when the instance of AVCaptureDevice has detected a substantial change to the video subject area.
   * @property {Symbol} AVCaptureSessionInterruptionEnded Posted if an interruption to a capture session finishes.
   * @property {Symbol} AVCaptureSessionWasInterrupted Posted if a capture session is interrupted.
   * @property {Symbol} CTRadioAccessTechnologyDidChange 
   * @property {Symbol} MFMessageComposeViewControllerTextMessageAvailabilityDidChange Posted when the value returned by the canSendText() class method has changed.
   * @property {Symbol} MPMediaLibraryDidChange Indicates the media library has changed.
   * @property {Symbol} MPMediaPlaybackIsPreparedToPlayDidChange Indicates that the prepared to play status of the media player has changed.
   * @property {Symbol} MPMusicPlayerControllerNowPlayingItemDidChange Posted when the currently playing media item has changed.
   * @property {Symbol} MPMusicPlayerControllerPlaybackStateDidChange Posted when the playback state has been changed programmatically or by user action.
   * @property {Symbol} MPMusicPlayerControllerVolumeDidChange Posted when the audio playback volume for the music player has changed.
   * @property {Symbol} MPVolumeViewWirelessRouteActiveDidChange Indicates the active wireless route changed.
   * @property {Symbol} MPVolumeViewWirelessRoutesAvailableDidChange Indicates the available wireless routes changed.
   * @property {Symbol} NKIssueDownloadCompleted Posted when all assets of the issue have been downloaded.
   * @property {Symbol} UIApplicationBackgroundRefreshStatusDidChange Posted when the app’s status for downloading content in the background changes.
   * @property {Symbol} UIApplicationDidChangeStatusBarFrame Posted when the frame of the status bar changes.
   * @property {Symbol} UIApplicationDidChangeStatusBarOrientation Posted when the orientation of the app’s user interface changes.
   * @property {Symbol} UIApplicationWillChangeStatusBarFrame Posted when the app is about to change the frame of the status bar.
   * @property {Symbol} UIApplicationWillChangeStatusBarOrientation Posted when the app is about to change the orientation of its interface.
   * @property {Symbol} UIDeviceBatteryLevelDidChange Posted when the battery level changes.
   * @property {Symbol} UIDeviceBatteryStateDidChange Posted when battery state changes.
   * @property {Symbol} UIDeviceOrientationDidChange Posted when the orientation of the device changes.
   * @property {Symbol} UIDocumentStateChanged Posted by the document object when there is a change in the state of the document.
   * @property {Symbol} UIKeyboardDidChangeFrame Posted immediately after a change in the keyboard’s frame.
   * @property {Symbol} UIKeyboardDidHide Posted immediately after the dismissal of the keyboard.
   * @property {Symbol} UIKeyboardDidShow Posted immediately after the display of the keyboard.
   * @property {Symbol} UIKeyboardWillChangeFrame Posted immediately prior to a change in the keyboard’s frame.
   * @property {Symbol} UIKeyboardWillHide Posted immediately prior to the dismissal of the keyboard.
   * @property {Symbol} UIKeyboardWillShow Posted immediately prior to the display of the keyboard.
   * @property {Symbol} UIMenuControllerDidHideMenu Posted by the menu controller just after it hides the menu.
   * @property {Symbol} UIMenuControllerDidShowMenu Posted by the menu controller just after it shows the menu.
   * @property {Symbol} UIMenuControllerMenuFrameDidChange Posted when the frame of a visible menu changes.
   * @property {Symbol} UIMenuControllerWillHideMenu Posted by the menu controller just before it hides the menu.
   * @property {Symbol} UIMenuControllerWillShowMenu Posted by the menu controller just before it shows the menu.
   * @property {Symbol} UIPasteboardChanged Posted by a pasteboard object when its contents change.
   * @property {Symbol} UIPasteboardRemoved Posted by a pasteboard object just before an app removes it.
   * @property {Symbol} UIApplicationProtectedDataDidBecomeAvailable Posted when the protected files become available for your code to access.
   * @property {Symbol} UIApplicationProtectedDataWillBecomeUnavailable Posted shortly before protected files are locked down and become inaccessible.
   * @property {Symbol} didChangeAutomaticTextCompletionNotification 
   * @property {Symbol} MPMusicPlayerControllerQueueDidChange Indicates the music player's queue changed.
   * @property {Symbol} GKPlayerAuthenticationDidChangeNotificationName Posted after the isAuthenticated property of the shared local player object changes. The object property for this notification is a GKLocalPlayer object. Passing nil provides standard Notification Center behavior which is to receive the notification for any object.
   * @property {Symbol} GKPlayerDidChangeNotificationName Posted when a player object’s data changes.
   * @property {Symbol} NEDNSProxyConfigurationDidChange 
   * @property {Symbol} SKStorefrontCountryCodeDidChange 
   * @property {Symbol} UIAccessibilityVoiceOverStatusDidChange 
   * @property {Symbol} UIFocusDidUpdate 
   * @property {Symbol} UIFocusMovementDidFail 
   * @property {Symbol} init 
   * @property {Symbol} initrawValue 
   * @property {Symbol} initnameobjectuserInfo Initializes a new notification.
   * @property {Symbol} Notification.Name An alias for a type used to represent the name of a notification.
   * @see https://developer.apple.com/documentation/foundation/nsnotification.name
   */


  static get Name() {
    return _Name;
  }

}

/**
 * An input associated with a physical control, such as a button or thumbstick.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/gamecontroller/gccontrollerelement
 */

class GCControllerElement extends NSObject {
  /**
   * constructor
   * @access public
   */
  constructor() {
    super(); // Inspecting Element Properties

    this._isAnalog = false;
    this._collection = null;
  } // Inspecting Element Properties

  /**
   * Returns a Boolean value that indicates whether the element provides analog data.
   * @type {boolean}
   * @desc If the value is true, then the value properties defined by the element subclass can return a range (from minimum to maximum) of possible values. For example, this element might be a pressure-sensitive button or an axis of a thumb stick that allows for a range of physical movement. If the value is false, then the element’s value properties only provides discrete values, typically 0 if the element is off, and 1 if the element is on. 
   * @see https://developer.apple.com/documentation/gamecontroller/gccontrollerelement/1522581-isanalog
   */


  get isAnalog() {
    return this._isAnalog;
  }
  /**
   * Returns the element that this element is part of.
   * @type {?GCControllerElement}
   * @desc If the element is part of another element, this property holds the parent element. Otherwise, it holds nil.
   * @see https://developer.apple.com/documentation/gamecontroller/gccontrollerelement/1522575-collection
   */


  get collection() {
    return this._collection;
  }

}

/**
 * A control element measuring a button press. 
 * @access public
 * @extends {GCControllerElement}
 * @see https://developer.apple.com/documentation/gamecontroller/gccontrollerbuttoninput
 */

class GCControllerButtonInput extends GCControllerElement {
  /**
   * constructor
   * @access public
   * @returns {void}
   */
  constructor() {
    super(); // Reading the Button’s Value

    this._isPressed = false;
    this._value = 0; // Receiving Notifications When the Button’s Value Changes

    /**
     * A handler to be called when the button is pressed or released.
     * @type {?GCControllerButtonValueChangedHandler}
     * @see https://developer.apple.com/documentation/gamecontroller/gccontrollerbuttoninput/1522556-pressedchangedhandler
     */

    this.pressedChangedHandler = null;
    /**
     * A handler to be called when the pressure on a button changes.
     * @type {?GCControllerButtonValueChangedHandler}
     * @see https://developer.apple.com/documentation/gamecontroller/gccontrollerbuttoninput/1522491-valuechangedhandler
     */

    this.valueChangedHandler = null;
  } // Reading the Button’s Value

  /**
   * A Boolean value that indicates whether the button is pressed.
   * @type {boolean}
   * @desc 
   * @see https://developer.apple.com/documentation/gamecontroller/gccontrollerbuttoninput/1522539-ispressed
   */


  get isPressed() {
    return this._isPressed;
  }
  /**
   * The level of pressure being applied to the button.
   * @type {number}
   * @desc If pressure is being applied to the button, then the isPressed property is true and this property indicates the amount of pressure being applied to the button. The pressure value is normalized to a number between 0.0 (minimum pressure) and 1.0 (maximum pressure).If no pressure is being applied to the button, then the isPressed property is false and this property holds a value of 0.0.
   * @see https://developer.apple.com/documentation/gamecontroller/gccontrollerbuttoninput/1522580-value
   */


  get value() {
    return this._value;
  }

}

/**
 * A control element measuring movement along a particular axis.
 * @access public
 * @extends {GCControllerElement}
 * @see https://developer.apple.com/documentation/gamecontroller/gccontrolleraxisinput
 */

class GCControllerAxisInput extends GCControllerElement {
  /**
   * constructor
   * @access public
   */
  constructor() {
    super(); // Polling the Axis’ Value

    this._value = 0; // Receiving Notifications When the Axis’ Value Changes

    /**
     * A handler to be called when the axis changes value.
     * @type {?GCControllerAxisValueChangedHandler}
     * @see https://developer.apple.com/documentation/gamecontroller/gccontrolleraxisinput/1500221-valuechangedhandler
     */

    this.valueChangedHandler = null;
  } // Polling the Axis’ Value

  /**
   * The current value of the axis.
   * @type {number}
   * @desc On a physical controller, it is common for a portion of the physical control’s moment to be ignored near its neutral position. This part of the control is known as its deadzone. The GCControllerAxisInput element handles the deadzone and other physical constraints of the hardware control and computes a normalized value. The value is in a range from -1 to 1.   If the value is 0, then the movement is in the deadzone. A non-zero value indicates the moment is outside of the deadzone. The value is normalized so that no values are lost because of the deadzone.
   * @see https://developer.apple.com/documentation/gamecontroller/gccontrolleraxisinput/1500224-value
   */


  get value() {
    return this._value;
  }

}

/**
 * A control element associated with a directional pad or a thumbstick.
 * @access public
 * @extends {GCControllerElement}
 * @see https://developer.apple.com/documentation/gamecontroller/gccontrollerdirectionpad
 */

class GCControllerDirectionPad extends GCControllerElement {
  /**
   * constructor
   * @access public
   */
  constructor() {
    super(); // Reading the Directional Pad as a Pair of Axes

    this._xAxis = new GCControllerAxisInput();
    this._yAxis = new GCControllerAxisInput(); // Reading the Directional Pad as a Four Directional Buttons

    this._up = new GCControllerButtonInput();
    this._down = new GCControllerButtonInput();
    this._left = new GCControllerButtonInput();
    this._right = new GCControllerButtonInput(); // Receiving Notifications When the Directional Pad’s Values Change

    /**
     * A handler to be called when the directional pad element changes values.
     * @type {?GCControllerDirectionPadValueChangedHandler}
     * @see https://developer.apple.com/documentation/gamecontroller/gccontrollerdirectionpad/1462914-valuechangedhandler
     */

    this.valueChangedHandler = null;
  } // Reading the Directional Pad as a Pair of Axes

  /**
   * The value of the directional pad along the horizontal axis (left and right).
   * @type {GCControllerAxisInput}
   * @desc 
   * @see https://developer.apple.com/documentation/gamecontroller/gccontrollerdirectionpad/1462930-xaxis
   */


  get xAxis() {
    return this._xAxis;
  }
  /**
   * The value of the directional pad along the vertical axis (up and down).
   * @type {GCControllerAxisInput}
   * @desc 
   * @see https://developer.apple.com/documentation/gamecontroller/gccontrollerdirectionpad/1462926-yaxis
   */


  get yAxis() {
    return this._yAxis;
  } // Reading the Directional Pad as a Four Directional Buttons

  /**
   * A measurement of how far up the directional pad has been moved.
   * @type {GCControllerButtonInput}
   * @desc The value of the up property is mutually exclusive with the value of the down property. This means that whenever the value of the up property is non-zero, the value of the down property is 0.
   * @see https://developer.apple.com/documentation/gamecontroller/gccontrollerdirectionpad/1462918-up
   */


  get up() {
    return this._up;
  }
  /**
   * A measurement of how far down the directional pad has been moved.
   * @type {GCControllerButtonInput}
   * @desc The value of the down property is mutually exclusive with the value of the up property. This means that whenever the value of the down property is non-zero, the value of the up property is 0.
   * @see https://developer.apple.com/documentation/gamecontroller/gccontrollerdirectionpad/1462920-down
   */


  get down() {
    return this._down;
  }
  /**
   * A measurement of how far left the directional pad has been moved.
   * @type {GCControllerButtonInput}
   * @desc The value of the left property is mutually exclusive with the value of the right property. This means that whenever the value of the left property is non-zero, the value of the right property is 0.
   * @see https://developer.apple.com/documentation/gamecontroller/gccontrollerdirectionpad/1462924-left
   */


  get left() {
    return this._left;
  }
  /**
   * A measurement of how far right the directional pad has been moved.
   * @type {GCControllerButtonInput}
   * @desc The value of the right property is mutually exclusive with the value of the left property. This means that whenever the value of the right property is non-zero, the value of the left property is 0.
   * @see https://developer.apple.com/documentation/gamecontroller/gccontrollerdirectionpad/1462922-right
   */


  get right() {
    return this._right;
  }

}

const _defaultMapping = {
  A: 0,
  B: 1,
  X: 2,
  Y: 3,
  L1: 4,
  R1: 5,
  UP: 12,
  DOWN: 13,
  LEFT: 14,
  RIGHT: 15
};

if (typeof navigator !== 'undefined' && navigator.userAgent.indexOf('Firefox') !== -1) {
  // Is this a bug or something?
  _defaultMapping.A = 1;
  _defaultMapping.B = 2;
  _defaultMapping.X = 0;
  _defaultMapping.Y = 3;
  _defaultMapping.UP = 14;
  _defaultMapping.DOWN = 15;
  _defaultMapping.LEFT = 16;
  _defaultMapping.RIGHT = 17;
}
/**
 * The standard set of gamepad controls. 
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/gamecontroller/gcgamepad
 */


class GCGamepad extends NSObject {
  /**
   * constructor
   * @access public
   */
  constructor() {
    super(); // Determining the Controller That Owns This Profile

    this._controller = null; // Determining When Any Element in the Profile Changes

    /**
     * A block called when any element in the profile changes.
     * @type {?GCGamepadValueChangedHandler}
     * @see https://developer.apple.com/documentation/gamecontroller/gcgamepad/1497421-valuechangedhandler
     */

    this.valueChangedHandler = null; // Reading Shoulder Button Inputs

    this._leftShoulder = new GCControllerButtonInput();
    this._rightShoulder = new GCControllerButtonInput(); // Reading Directional Pad Inputs

    /**
     * @type {GCControllerDirectionPad}
     */

    this._dpad = new GCControllerDirectionPad(); // Reading Face Button Inputs

    this._buttonA = new GCControllerButtonInput();
    this._buttonB = new GCControllerButtonInput();
    this._buttonX = new GCControllerButtonInput();
    this._buttonY = new GCControllerButtonInput();
    this._buttonMapping = new Map([[this._leftShoulder, _defaultMapping.L1], [this._rightShoulder, _defaultMapping.R1], [this._buttonA, _defaultMapping.A], [this._buttonB, _defaultMapping.B], [this._buttonX, _defaultMapping.X], [this._buttonY, _defaultMapping.Y]]);
    this._dpadMapping = new Map([[this._dpad._up, _defaultMapping.UP], [this._dpad._down, _defaultMapping.DOWN], [this._dpad._left, _defaultMapping.LEFT], [this._dpad._right, _defaultMapping.RIGHT]]);
  }

  _update() {
    this._buttonMapping.forEach((index, c) => {
      c._value = this._controller._state.buttons[index];
      c._isPressed = this._controller._state.pressed[index];
    });

    this._dpadMapping.forEach((index, c) => {
      c._value = this._controller._state.buttons[index];
      c._isPressed = this._controller._state.pressed[index];
    });

    this._dpad._xAxis._value = this._dpad._right._value - this._dpad._left._value;
    this._dpad._yAxis._value = this._dpad._down._value - this._dpad._up._value;

    this._buttonMapping.forEach((index, c) => {
      if (c.pressedChangedHandler && this._controller._updated.pressed[index]) {
        c.pressedChangedHandler(c, c._value, c._isPressed);
      }

      if (this._controller._updated.buttons[index]) {
        if (c.valueChangedHandler) {
          c.valueChangedHandler(c, c._value, c._isPressed);
        }

        if (this.valueChangedHandler) {
          this.valueChangedHandler(this, c);
        }
      }
    });

    let dpadChanged = false;

    this._dpadMapping.forEach((index, c) => {
      if (this._controller._updated.pressed[index]) {
        dpadChanged = true;

        if (c.pressedChangedHandler) {
          c.pressedChangedHandler(c, c._value, c._isPressed);
        }
      }

      if (this._controller._updated.buttons[index]) {
        dpadChanged = true;

        if (c.valueChangedHandler) {
          c.valueChangedHandler(c, c._value, c._isPressed);
        }

        if (this.valueChangedHandler) {
          this.valueChangedHandler(this, c);
        }
      }
    });

    if (dpadChanged) {
      if (this._dpad.valueChangedHandler) {
        this._dpad.valueChangedHandler(this._dpad, this._dpad._xAxis.value, this._dpad._yAxis.value);
      }

      if (this.valueChangedHandler) {
        this.valueChangedHandler(this, this._dpad);
      }
    }
  }

  _getValue(button) {
    let index = this._buttonMapping.get(button);

    if (typeof index === 'undefined') {
      index = this._dpadMapping.get(button);
    }

    if (typeof index === 'undefined') {
      return null;
    }

    return this._controller._state.buttons[index];
  } // Determining the Controller That Owns This Profile

  /**
   * The controller this profile is associated with.
   * @type {?GCController}
   * @desc 
   * @see https://developer.apple.com/documentation/gamecontroller/gcgamepad/1497428-controller
   */


  get controller() {
    return this._controller;
  } // Reading Shoulder Button Inputs

  /**
   * The left shoulder button element.
   * @type {GCControllerButtonInput}
   * @desc The shoulder buttons in the gamepad profile are analog buttons.
   * @see https://developer.apple.com/documentation/gamecontroller/gcgamepad/1497423-leftshoulder
   */


  get leftShoulder() {
    return this._leftShoulder;
  }
  /**
   * The right shoulder button element.
   * @type {GCControllerButtonInput}
   * @desc The shoulder buttons in the gamepad profile are analog buttons.
   * @see https://developer.apple.com/documentation/gamecontroller/gcgamepad/1497429-rightshoulder
   */


  get rightShoulder() {
    return this._rightShoulder;
  } // Reading Directional Pad Inputs

  /**
   * The D-pad element.
   * @type {GCControllerDirectionPad}
   * @desc The directional pad in the gamepad profile is an analog control.
   * @see https://developer.apple.com/documentation/gamecontroller/gcgamepad/1497425-dpad
   */


  get dpad() {
    return this._dpad;
  } // Reading Face Button Inputs

  /**
   * The bottom face button.
   * @type {GCControllerButtonInput}
   * @desc The face buttons in the gamepad profile are analog buttons.
   * @see https://developer.apple.com/documentation/gamecontroller/gcgamepad/1497427-buttona
   */


  get buttonA() {
    return this._buttonA;
  }
  /**
   * The right face button.
   * @type {GCControllerButtonInput}
   * @desc The face buttons in the gamepad profile are analog buttons.
   * @see https://developer.apple.com/documentation/gamecontroller/gcgamepad/1497418-buttonb
   */


  get buttonB() {
    return this._buttonB;
  }
  /**
   * The left face button.
   * @type {GCControllerButtonInput}
   * @desc The face buttons in the gamepad profile are analog buttons.
   * @see https://developer.apple.com/documentation/gamecontroller/gcgamepad/1497417-buttonx
   */


  get buttonX() {
    return this._buttonX;
  }
  /**
   * The top face button.
   * @type {GCControllerButtonInput}
   * @desc The face buttons in the gamepad profile are analog buttons.
   * @see https://developer.apple.com/documentation/gamecontroller/gcgamepad/1497431-buttony
   */


  get buttonY() {
    return this._buttonY;
  } // Saving a Snapshot

  /**
   * Saves a snapshot of all of the profile’s elements.
   * @access public
   * @returns {GCGamepadSnapshot} - 
   * @see https://developer.apple.com/documentation/gamecontroller/gcgamepad/1497415-savesnapshot
   */


  saveSnapshot() {
    return null;
  }

}

/**
 * The extended set of gamepad controls.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/gamecontroller/gcextendedgamepad
 */

class GCExtendedGamepad extends NSObject {
  /**
   * constructor
   * @access public
   */
  constructor() {
    super(); // Determining the Controller That Owns This Profile

    this._controller = null; // Determining When Any Element in the Profile Changes

    /**
     * A block called when any element in the profile changes values.
     * @type {?GCExtendedGamepadValueChangedHandler}
     * @see https://developer.apple.com/documentation/gamecontroller/gcextendedgamepad/1522464-valuechangedhandler
     */

    this.valueChangedHandler = null; // Reading Shoulder Button Inputs

    this._leftShoulder = new GCControllerButtonInput();
    this._rightShoulder = new GCControllerButtonInput(); // Reading Directional Pad Inputs

    this._dpad = new GCControllerDirectionPad(); // Reading Face Button Inputs

    this._buttonA = new GCControllerButtonInput();
    this._buttonB = new GCControllerButtonInput();
    this._buttonX = new GCControllerButtonInput();
    this._buttonY = new GCControllerButtonInput(); // Reading Thumbstick Inputs

    this._leftThumbstick = new GCControllerDirectionPad();
    this._rightThumbstick = new GCControllerDirectionPad(); // Reading Trigger Inputs

    this._leftTrigger = new GCControllerButtonInput();
    this._rightTrigger = new GCControllerButtonInput();
  }

  _update() {} // Determining the Controller That Owns This Profile

  /**
   * The controller this profile is associated with.
   * @type {?GCController}
   * @desc 
   * @see https://developer.apple.com/documentation/gamecontroller/gcextendedgamepad/1522427-controller
   */


  get controller() {
    return this._controller;
  } // Reading Shoulder Button Inputs

  /**
   * The left shoulder button element.
   * @type {GCControllerButtonInput}
   * @desc The shoulder buttons in the extended gamepad profile are analog buttons.
   * @see https://developer.apple.com/documentation/gamecontroller/gcextendedgamepad/1522418-leftshoulder
   */


  get leftShoulder() {
    return this._leftShoulder;
  }
  /**
   * The right shoulder button element.
   * @type {GCControllerButtonInput}
   * @desc The shoulder buttons in the extended gamepad profile are analog buttons.
   * @see https://developer.apple.com/documentation/gamecontroller/gcextendedgamepad/1522484-rightshoulder
   */


  get rightShoulder() {
    return this._rightShoulder;
  } // Reading Directional Pad Inputs

  /**
   * The d-pad element.
   * @type {GCControllerDirectionPad}
   * @desc The directional pad in the extended gamepad profile is an analog control.
   * @see https://developer.apple.com/documentation/gamecontroller/gcextendedgamepad/1522422-dpad
   */


  get dpad() {
    return this._dpad;
  } // Reading Face Button Inputs

  /**
   * The bottom face button.
   * @type {GCControllerButtonInput}
   * @desc The face buttons in the extended gamepad profile are analog buttons.
   * @see https://developer.apple.com/documentation/gamecontroller/gcextendedgamepad/1522558-buttona
   */


  get buttonA() {
    return this._buttonA;
  }
  /**
   * The right face button.
   * @type {GCControllerButtonInput}
   * @desc The face buttons in the extended gamepad profile are analog buttons.
   * @see https://developer.apple.com/documentation/gamecontroller/gcextendedgamepad/1522396-buttonb
   */


  get buttonB() {
    return this._buttonB;
  }
  /**
   * The left face button.
   * @type {GCControllerButtonInput}
   * @desc The face buttons in the extended gamepad profile are analog buttons.
   * @see https://developer.apple.com/documentation/gamecontroller/gcextendedgamepad/1522567-buttonx
   */


  get buttonX() {
    return this._buttonX;
  }
  /**
   * The top face button.
   * @type {GCControllerButtonInput}
   * @desc The face buttons in the extended gamepad profile are analog buttons.
   * @see https://developer.apple.com/documentation/gamecontroller/gcextendedgamepad/1522473-buttony
   */


  get buttonY() {
    return this._buttonY;
  } // Reading Thumbstick Inputs

  /**
   * The left thumbstick element.
   * @type {GCControllerDirectionPad}
   * @desc The thumbsticks in the extended gamepad profile are analog buttons.
   * @see https://developer.apple.com/documentation/gamecontroller/gcextendedgamepad/1522564-leftthumbstick
   */


  get leftThumbstick() {
    return this._leftThumbstick;
  }
  /**
   * The right thumbstick element.
   * @type {GCControllerDirectionPad}
   * @desc The thumbsticks in the extended gamepad profile are analog buttons.
   * @see https://developer.apple.com/documentation/gamecontroller/gcextendedgamepad/1522437-rightthumbstick
   */


  get rightThumbstick() {
    return this._rightThumbstick;
  } // Reading Trigger Inputs

  /**
   * The left trigger element.
   * @type {GCControllerButtonInput}
   * @desc The triggers in the extended gamepad profile are analog buttons.
   * @see https://developer.apple.com/documentation/gamecontroller/gcextendedgamepad/1522569-lefttrigger
   */


  get leftTrigger() {
    return this._leftTrigger;
  }
  /**
   * The right trigger element.
   * @type {GCControllerButtonInput}
   * @desc The triggers in the extended gamepad profile are analog buttons.
   * @see https://developer.apple.com/documentation/gamecontroller/gcextendedgamepad/1522563-righttrigger
   */


  get rightTrigger() {
    return this._rightTrigger;
  } // Saving a Snapshot

  /**
   * Saves a snapshot of all of the profile’s elements.
   * @access public
   * @returns {GCExtendedGamepadSnapshot} - 
   * @see https://developer.apple.com/documentation/gamecontroller/gcextendedgamepad/1522447-savesnapshot
   */


  saveSnapshot() {
    return null;
  }

}

//import GCMicroGamepadValueChangedHandler from './GCMicroGamepadValueChangedHandler'
//import GCControllerDirectionPad from './GCControllerDirectionPad'
//import GCControllerButtonInput from './GCControllerButtonInput'
//import GCMicroGamepadSnapshot from './GCMicroGamepadSnapshot'

/**
 * The controls provided by the Siri Remote.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/gamecontroller/gcmicrogamepad
 */

class GCMicroGamepad extends NSObject {
  /**
   * constructor
   * @access public
   */
  constructor() {
    super(); // Determining the Controller That Owns This Profile

    this._controller = null; // Determining When Any Element in the Profile Changes

    /**
     * A block called when any element in the profile changes.
     * @type {?GCMicroGamepadValueChangedHandler}
     * @see https://developer.apple.com/documentation/gamecontroller/gcmicrogamepad/1627758-valuechangedhandler
     */

    this.valueChangedHandler = null; // Reading Directional Pad Inputs

    /**
     * A Boolean value that indicates whether the D-pad reports absolute or relative values.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/gamecontroller/gcmicrogamepad/1627757-reportsabsolutedpadvalues
     */

    this.reportsAbsoluteDpadValues = false;
    /**
     * A Boolean value that indicates whether the D-pad’s values are calculated relative to its current orientation.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/gamecontroller/gcmicrogamepad/1627755-allowsrotation
     */

    this.allowsRotation = false;
    this._dpad = null; // Reading Face Button Inputs

    this._buttonA = null;
    this._buttonX = null;
  } // Determining the Controller That Owns This Profile

  /**
   * The controller this profile is associated with.
   * @type {?GCController}
   * @desc 
   * @see https://developer.apple.com/documentation/gamecontroller/gcmicrogamepad/1627756-controller
   */


  get controller() {
    return this._controller;
  } // Reading Directional Pad Inputs

  /**
   * The D-pad element.
   * @type {GCControllerDirectionPad}
   * @desc The directional pad in the micro gamepad profile reports analog directional information.
   * @see https://developer.apple.com/documentation/gamecontroller/gcmicrogamepad/1627763-dpad
   */


  get dpad() {
    return this._dpad;
  } // Reading Face Button Inputs

  /**
   * The first button.
   * @type {GCControllerButtonInput}
   * @desc Button A is usually activated by a harder press on the touchpad. The button is always digital.
   * @see https://developer.apple.com/documentation/gamecontroller/gcmicrogamepad/1627762-buttona
   */


  get buttonA() {
    return this._buttonA;
  }
  /**
   * The secondary button.
   * @type {GCControllerButtonInput}
   * @desc The secondary button is always digital.
   * @see https://developer.apple.com/documentation/gamecontroller/gcmicrogamepad/1627759-buttonx
   */


  get buttonX() {
    return this._buttonX;
  } // Saving a Snapshot

  /**
   * Saves a snapshot of all of the profile’s elements.
   * @access public
   * @returns {GCMicroGamepadSnapshot} - 
   * @see https://developer.apple.com/documentation/gamecontroller/gcmicrogamepad/1627754-savesnapshot
   */


  saveSnapshot() {
    return null;
  }

}

//import GCControllerPlayerIndex from './GCControllerPlayerIndex'

let navigator$1 = {
  getGamepads: () => {
    return [];
  }
};

if (typeof window !== 'undefined' && typeof window.navigator !== 'undefined') {
  navigator$1 = window.navigator;
}
/**
 * @access private
 * @type {Map<number, GCController>}
 */


const _controllers = new Map();
/**
 * A representation of a physical game controller, connected to the device either physically or through a wireless connection.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/gamecontroller/gccontroller
 */


class GCController extends NSObject {
  static getController(gamepad) {
    let pad = gamepad;

    if (gamepad.id === '') {
      // needs to refresh gamepad info
      pad = GCController._gamepadObjByIndex(gamepad.index);

      if (pad === null) {
        return null;
      }
    }

    let controller = _controllers.get(pad.id);

    if (controller) {
      return controller;
    }

    controller = new GCController();

    if (!pad) {
      return controller;
    }

    _controllers.set(pad.id, controller);

    controller._gamepadIndex = pad.index;
    controller._gamepadId = pad.id;
    controller._gamepad = new GCGamepad();
    controller._gamepad._controller = controller;

    if (gamepad.mapping === 'standard') {
      controller._extendedGamepad = new GCExtendedGamepad();
      controller._extendedGamepad._controller = controller;
    }

    return controller;
  }
  /**
   * constructor
   * @access public
   */


  constructor() {
    super(); // Determining Which Profiles Are Supported by a Controller

    /**
     * @type {?GCGamepad}
     */

    this._gamepad = null;
    /**
     * @type {?GCExtendedGamepad}
     */

    this._extendedGamepad = null;
    /**
     * @type {?GCMicroGamepad}
     */

    this._microGamepad = null;
    /**
     * @type {?GCMotion}
     */

    this._motion = null; // Responding When a Controller Is Paused

    /**
     * A block called when the controller’s pause button is pressed.
     * @type {?function(arg1: GCController): void}
     * @see https://developer.apple.com/documentation/gamecontroller/gccontroller/1458852-controllerpausedhandler
     */

    this.controllerPausedHandler = null; // Inspecting a Controller

    this._isAttachedToDevice = false;
    this._vendorName = null; // Assigning a Player Index

    /**
     * The player index assigned to the controller.
     * @type {GCControllerPlayerIndex}
     * @see https://developer.apple.com/documentation/gamecontroller/gccontroller/1458885-playerindex
     */

    this.playerIndex = null; // Determining Which Dispatch Queue Notifications are Dispatched On

    /**
     * The dispatch queue to be used when the values of a game controller’s input values change.
     * @type {DispatchQueue}
     * @see https://developer.apple.com/documentation/gamecontroller/gccontroller/1458869-handlerqueue
     */

    this.handlerQueue = null;
    this._gamepadIndex = -1;
    this._gamepadId = -1;
    this._state = {
      buttons: [],
      pressed: [],
      axes: []
    };
    this._updated = {
      buttons: [],
      pressed: [],
      axes: []
    };
  }

  static _update() {
    _controllers.forEach((c, gamepadId) => {
      const gamepad = GCController._gamepadObjById(gamepadId);

      if (!gamepad) {
        _controllers.delete(gamepadId);

        return;
      }

      const bLen = gamepad.buttons.length;

      for (let i = 0; i < bLen; i++) {
        const b = gamepad.buttons[i];
        c._updated.buttons[i] = false;

        if (c._state.buttons[i] !== b.value) {
          c._state.buttons[i] = b.value;
          c._updated.buttons[i] = true;
        }

        c._updated.pressed[i] = false;

        if (c._state.pressed[i] !== b.pressed) {
          c._state.pressed[i] = b.pressed;
          c._updated.pressed[i] = true;
        }
      }

      const aLen = gamepad.axes.length;

      for (let i = 0; i < aLen; i++) {
        const value = gamepad.axes[i];
        c._updated.axes[i] = false;

        if (c._state.axes[i] !== value) {
          c._state.axes[i] = value;
          c._updated.axes[i] = true;
        }
      }
    });

    _controllers.forEach((c, gamepadId) => {
      if (c._gamepad) {
        c._gamepad._update();
      }

      if (c._extendedGamepad) {
        c._extendedGamepad._update();
      }

      if (c._microGamepad) {
        c._microGamepad._update();
      }
    });
  } // Discovering Controllers

  /**
   * Starts browsing for nearby controllers.
   * @access public
   * @param {?function(): void} [completionHandler = null] - A block to be called when browsing ends.
   * @returns {void}
   * @desc You should include a user interface in your game to allow the player to determine when controllers are discovered. When the user chooses to search for controllers, call this method. The device searches asynchronously for discoverable wireless controllers as well as controllers that are connected to iOS devices that have been placed in controller-forwarding mode. Whenever a new controller is connected, a GCControllerDidConnect notification is posted. When no more devices can be found or the discovery process times out, the completion handler is called.If this method is called multiple times, only the block associated with the last invocation is called when discovery times out.
   * @see https://developer.apple.com/documentation/gamecontroller/gccontroller/1458879-startwirelesscontrollerdiscovery
   */


  static startWirelessControllerDiscovery(completionHandler = null) {}
  /**
   * Stops browsing for nearby controllers.
   * @access public
   * @returns {void}
   * @desc This method may be called at any time. If a search for new wireless controllers in progress, that search ends and its completion handler is called. 
   * @see https://developer.apple.com/documentation/gamecontroller/gccontroller/1458854-stopwirelesscontrollerdiscovery
   */


  static stopWirelessControllerDiscovery() {}
  /**
   * The controllers connected to the device.
   * @access public
   * @returns {GCController[]} - 
   * @desc Whenever a controller is connected to or disconnected from the device, the array of controllers is updated and a notification is posted.
   * @see https://developer.apple.com/documentation/gamecontroller/gccontroller/1458871-controllers
   */


  static controllers() {
    return Array.from(_controllers.values());
  } // Determining Which Profiles Are Supported by a Controller

  /**
   * The gamepad profile.
   * @type {?GCGamepad}
   * @desc If the controller supports the gamepad profile, then this property holds a GCGamepad object. You use this object to access the input elements of the controller. If the controller does not support the gamepad profile, this property holds nil.
   * @see https://developer.apple.com/documentation/gamecontroller/gccontroller/1458860-gamepad
   */


  get gamepad() {
    return this._gamepad;
  }
  /**
   * The extended gamepad profile.
   * @type {?GCExtendedGamepad}
   * @desc If the controller supports the extended gamepad profile, then this property holds a GCExtendedGamepad object. You use this object to access the input elements of the controller. If the controller does not support the extended gamepad profile, this property holds nil.
   * @see https://developer.apple.com/documentation/gamecontroller/gccontroller/1458883-extendedgamepad
   */


  get extendedGamepad() {
    return this._extendedGamepad;
  }
  /**
   * The micro gamepad profile.
   * @type {?GCMicroGamepad}
   * @desc If the controller supports the micro gamepad profile, then this property holds a GCMicroGamepad object. You use this object to access the input elements of the controller. If the controller does not support the micro gamepad profile, this property holds nil.
   * @see https://developer.apple.com/documentation/gamecontroller/gccontroller/1627772-microgamepad
   */


  get microGamepad() {
    return this._microGamepad;
  }
  /**
   * The motion input profile.
   * @type {?GCMotion}
   * @desc If the controller supports the motion profile, then this property holds a GCMotion object. This profile is typically available when the controller is attached to a device that supports motion. You use this object to access the motion data of the controller. If the controller does not support the motion input profile, this property holds nil.
   * @see https://developer.apple.com/documentation/gamecontroller/gccontroller/1458884-motion
   */


  get motion() {
    return this._motion;
  } // Inspecting a Controller

  /**
   * A Boolean property that indicates whether the controller is closely integrated with the device.
   * @type {boolean}
   * @desc If true, then the controller is attached to the device or is close enough to it for the player to interact simultaneously with the controller and the device. If false, then the controller is not guaranteed to be near the device.
   * @see https://developer.apple.com/documentation/gamecontroller/gccontroller/1458868-isattachedtodevice
   */


  get isAttachedToDevice() {
    return this._isAttachedToDevice;
  }
  /**
   * The name of the vendor that manufactured the controller.
   * @type {?string}
   * @desc The value of this property may be nil and is not guaranteed to be unique.
   * @see https://developer.apple.com/documentation/gamecontroller/gccontroller/1458877-vendorname
   */


  get vendorName() {
    return this._vendorName;
  }

  get gamepadObj() {
    return GCController._gamepadObjById(this._gamepadId);
  }

  static _gamepadObjByIndexId(index, id) {
    const pad = GCController._gamepadObjByIndex(index);

    if (pad && pad.id === id) {
      return pad;
    }

    return null;
  }

  static _gamepadObjByIndex(index) {
    return navigator$1.getGamepads()[index];
  }

  static _gamepadObjById(id) {
    const pads = navigator$1.getGamepads();

    for (const pad of pads) {
      if (pad && pad.id === id) {
        return pad;
      }
    }

    return null;
  }

}

let _default = null;
/**
 * A notification dispatch mechanism that enables the broadcast of information to registered observers.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/foundation/notificationcenter
 */

class NotificationCenter extends NSObject {
  /**
   * constructor
   * @access public
   * @constructor
   */
  //constructor() {
  //  super()
  //}
  // Getting the Notification Center

  /**
   * Returns the process’s default notification center.
   * @type {NotificationCenter}
   * @desc 
   * @see https://developer.apple.com/documentation/foundation/notificationcenter/1414169-default
   */
  static get default() {
    if (_default === null) {
      _default = new NotificationCenter();
    }

    return _default;
  } // Managing Notification Observers

  /**
   * Adds an entry to the receiver’s dispatch table with a notification queue and a block to add to the queue, and optional criteria: notification name and sender.
   * @access public
   * @param {?NSNotification.Name} name - The name of the notification for which to register the observer; that is, only notifications with this name are used to add the block to the operation queue.If you pass nil, the notification center doesn’t use a notification’s name to decide whether to add the block to the operation queue.
   * @param {?Object} obj - The object whose notifications the observer wants to receive; that is, only notifications sent by this sender are delivered to the observer.If you pass nil, the notification center doesn’t use a notification’s sender to decide whether to deliver it to the observer.
   * @param {?OperationQueue} queue - The operation queue to which block should be added.If you pass nil, the block is run synchronously on the posting thread.
   * @param {function(arg1: Notification): void} block - The block to be executed when the notification is received.The block is copied by the notification center and (the copy) held until the observer registration is removed. The block takes one argument:notificationThe notification.
   * @returns {NSObjectProtocol} - 
   * @desc If a given notification triggers more than one observer block, the blocks may all be executed concurrently with respect to one another (but on their given queue or on the current thread).The following example shows how you can register to receive locale change notifications.let center = NSNotificationCenter.defaultCenter()
  let mainQueue = NSOperationQueue.mainQueue()
  self.localeChangeObserver = center.addObserverForName(NSCurrentLocaleDidChangeNotification, object: nil, queue: mainQueue) { (note) in
    print("The user's locale changed to: \(NSLocale.currentLocale().localeIdentifier)")
  }
  To unregister observations, you pass the object returned by this method to removeObserver(_:). You must invoke removeObserver(_:) or removeObserver(_:name:object:) before any object specified by addObserverForName:object:queue:usingBlock: is deallocated.let center = NSNotificationCenter.defaultCenter()
  center.removeObserver(self.localeChangeObserver)
  Another common pattern is to create a one-time notification by removing the observer from within the observation block, as in the following example.let center = NSNotificationCenter.defaultCenter()
  let mainQueue = NSOperationQueue.mainQueue()
  var token: NSObjectProtocol?
  token = center.addObserverForName("OneTimeNotification", object: nil, queue: mainQueue) { (note) in
    print("Received the notification!")
    center.removeObserver(token!)
  }
  let center = NSNotificationCenter.defaultCenter()
  let mainQueue = NSOperationQueue.mainQueue()
  self.localeChangeObserver = center.addObserverForName(NSCurrentLocaleDidChangeNotification, object: nil, queue: mainQueue) { (note) in
    print("The user's locale changed to: \(NSLocale.currentLocale().localeIdentifier)")
  }
  let center = NSNotificationCenter.defaultCenter()
  center.removeObserver(self.localeChangeObserver)
  let center = NSNotificationCenter.defaultCenter()
  let mainQueue = NSOperationQueue.mainQueue()
  var token: NSObjectProtocol?
  token = center.addObserverForName("OneTimeNotification", object: nil, queue: mainQueue) { (note) in
    print("Received the notification!")
    center.removeObserver(token!)
  }
    * @see https://developer.apple.com/documentation/foundation/notificationcenter/1411723-addobserver
   */


  addObserverForNameObjectUsing(name, obj, queue, block) {
    return null;
  }
  /**
   * Adds an entry to the receiver’s dispatch table with an observer, a notification selector and optional criteria: notification name and sender.
   * @access public
   * @param {Object} observer - Object registering as an observer. This value must not be nil.
   * @param {function} aSelector - Selector that specifies the message the receiver sends observer to notify it of the notification posting. The method specified by aSelector must have one and only one argument (an instance of NSNotification).
   * @param {?NSNotification.Name} aName - The name of the notification for which to register the observer; that is, only notifications with this name are delivered to the observer.If you pass nil, the notification center doesn’t use a notification’s name to decide whether to deliver it to the observer.
   * @param {?Object} anObject - The object whose notifications the observer wants to receive; that is, only notifications sent by this sender are delivered to the observer.If you pass nil, the notification center doesn’t use a notification’s sender to decide whether to deliver it to the observer.
   * @returns {void}
   * @desc If your app targets iOS 9.0 and later or macOS 10.11 and later, you don't need to unregister an observer in its deallocation method. If your app targets earlier releases, be sure to invoke removeObserver(_:name:object:) before observer or any object specified in addObserver:selector:name:object: is deallocated.
   * @see https://developer.apple.com/documentation/foundation/notificationcenter/1415360-addobserver
   */


  addObserverSelectorNameObject(observer, aSelector, aName, anObject) {
    const f = aSelector.bind(observer);

    if (aName === NSNotification.Name.GCControllerDidConnect) {
      window.addEventListener('gamepadconnected', e => {
        const controller = GCController.getController(e.gamepad);

        if (controller) {
          f(new NSNotification(aName, controller, anObject));
        }
      });
      window.addEventListener('gamepaddisconnected', e => {
        const controller = GCController.getController(e.gamepad);

        if (controller) {
          f(new NSNotification(aName, controller, anObject));
        }
      });
    }
  }
  /**
   * Removes all the entries specifying a given observer from the receiver’s dispatch table.
   * @access public
   * @param {Object} observer - The observer to remove. Must not be nil.
   * @returns {void}
   * @desc Be sure to invoke this method (or removeObserver(_:name:object:)) before observer or any object specified in addObserver(_:selector:name:object:) is deallocated.You should not use this method to remove all observers from an object that is going to be long-lived, because your code may not be the only code adding observers that involve the object. The following example illustrates how to unregister someObserver for all notifications for which it had previously registered. This is safe to do in the dealloc method, but should not otherwise be used—use removeObserver(_:name:object:) instead.[[NSNotificationCenter defaultCenter] removeObserver:someObserver];
  [[NSNotificationCenter defaultCenter] removeObserver:someObserver];
    * @see https://developer.apple.com/documentation/foundation/notificationcenter/1413994-removeobserver
   */


  removeObserver(observer) {}
  /**
   * Removes matching entries from the receiver’s dispatch table.
   * @access public
   * @param {Object} observer - Observer to remove from the dispatch table. Specify an observer to remove only entries for this observer. Must not be nil, or message will have no effect.
   * @param {?NSNotification.Name} aName - Name of the notification to remove from dispatch table. Specify a notification name to remove only entries that specify this notification name. When nil, the receiver does not use notification names as criteria for removal.
   * @param {?Object} anObject - Sender to remove from the dispatch table. Specify a notification sender to remove only entries that specify this sender. When nil, the receiver does not use notification senders as criteria for removal.
   * @returns {void}
   * @desc Be sure to invoke this method (or removeObserver(_:)) before the observer object or any object specified in addObserver(_:selector:name:object:) is deallocated.
   * @see https://developer.apple.com/documentation/foundation/notificationcenter/1407263-removeobserver
   */


  removeObserverNameObject(observer, aName, anObject) {} // Posting Notifications

  /**
   * Posts a given notification to the receiver.
   * @access public
   * @param {Notification} notification - The notification to post. This value must not be nil.
   * @returns {void}
   * @desc You can create a notification with the NSNotification class method init(name:object:) or notificationWithName:object:userInfo:. An exception is raised if notification is nil.
   * @see https://developer.apple.com/documentation/foundation/notificationcenter/1410472-post
   */


  post(notification) {}
  /**
   * Creates a notification with a given name and sender and posts it to the receiver.
   * @access public
   * @param {NSNotification.Name} aName - The name of the notification.
   * @param {?Object} anObject - The object posting the notification.
   * @returns {void}
   * @desc This method invokes post(name:object:userInfo:) with an aUserInfo argument of nil.
   * @see https://developer.apple.com/documentation/foundation/notificationcenter/1415812-post
   */


  postNameObject(aName, anObject) {}
  /**
   * Creates a notification with a given name, sender, and information and posts it to the receiver.
   * @access public
   * @param {NSNotification.Name} aName - The name of the notification.
   * @param {?Object} anObject - The object posting the notification.
   * @param {?Map<AnyHashable, Object>} [aUserInfo = null] - Information about the the notification. May be nil.
   * @returns {void}
   * @desc This method is the preferred method for posting notifications.
   * @see https://developer.apple.com/documentation/foundation/notificationcenter/1410608-post
   */


  postNameObjectUserInfo(aName, anObject, aUserInfo = null) {}

}

/**
 * dummy class for NSKeyedArchiver/Unarchiver
 * @access public
 * @extends {NSObject}
 */

class NSArray extends NSObject {
  /**
   * @access public
   * @param {NSCoder} coder -
   * @returns {Object[]} -
   */
  static initWithCoder(coder) {
    const arr = [];

    if (typeof coder._refObj['NS.objects'] !== 'undefined') {
      const objects = coder._refObj['NS.objects'];

      if (!Array.isArray(objects)) {
        throw new Error('NS.objects must be Array');
      }

      const objCoder = coder.copy();
      objCoder._refObj = objects;

      for (let i = 0; i < objects.length; i++) {
        const obj = objCoder.decodeObjectForKey(i);
        arr.push(obj);
      }
    } else {
      for (let i = 0;; i++) {
        const key = `NS.object.${i}`;

        if (typeof coder._refObj[key] === 'undefined') {
          break;
        }

        const obj = coder.decodeObjectForKey(key);
        arr.push(obj);
      }
    }

    return arr;
  }

}

const _DecodingFailurePolicy = {
  raiseException: Symbol('raiseException'),
  setErrorAndReturn: Symbol('setErrorAndReturn')
  /**
   * The NSCoder abstract class declares the interface used by concrete subclasses to transfer objects and other values between memory and some other format. This capability provides the basis for archiving (where objects and data items are stored on disk) and distribution (where objects and data items are copied between different processes or threads). The concrete subclasses provided by Foundation for these purposes are NSArchiver, NSUnarchiver, NSKeyedArchiver, NSKeyedUnarchiver, and NSPortCoder. Concrete subclasses of NSCoder are referred to in general as coder classes, and instances of these classes as coder objects (or simply coders). A coder object that can only encode values is referred to as an encoder object, and one that can only decode values as a decoder object.
   * @access public
   * @extends {NSObject}
   * @see https://developer.apple.com/documentation/foundation/nscoder
   */

};
class NSCoder extends NSObject {
  /**
   * constructor
   * @access public
   * @constructor
   */
  constructor() {
    super(); // Inspecting a Coder

    this._allowsKeyedCoding = false; // Secure Coding

    this._requiresSecureCoding = false;
    this._allowedClasses = null; // Getting Version Information

    this._systemVersion = 0; // Instance Properties

    this._decodingFailurePolicy = null;
    this._error = null;
  }

  static get DecodingFailurePolicy() {
    return _DecodingFailurePolicy;
  } // Inspecting a Coder

  /**
   * Returns a Boolean value that indicates whether an encoded value is available for a string.
   * @access public
   * @param {string} key - 
   * @returns {boolean} - 
   * @desc Subclasses must override this method if they perform keyed coding. The string is passed as key.
   * @see https://developer.apple.com/documentation/foundation/nscoder/1416125-containsvalue
   */


  containsValueForKey(key) {
    return false;
  }
  /**
   * A Boolean value that indicates whether the receiver supports keyed coding of objects.
   * @type {boolean}
   * @desc false by default. Concrete subclasses that support keyed coding, such as NSKeyedArchiver, need to override this property to return true.
   * @see https://developer.apple.com/documentation/foundation/nscoder/1417541-allowskeyedcoding
   */


  get allowsKeyedCoding() {
    return this._allowsKeyedCoding;
  } // Encoding General Data

  /**
   * Encodes an array of count items, whose Objective-C type is given by itemType.
   * @access public
   * @param {UnsafePointer<Int8>} type - 
   * @param {number} count - 
   * @param {UnsafeRawPointer} array - 
   * @returns {void}
   * @desc The values are encoded from the buffer beginning at address. itemType must contain exactly one type code. NSCoder’s implementation invokes encodeValue(ofObjCType:at:) to encode the entire array of items. Subclasses that implement the encodeValue(ofObjCType:at:) method do not need to override this method.This method must be matched by a subsequent decodeArray(ofObjCType:count:at:) message.For information on creating an Objective-C type code suitable for itemType, see Type Encodings.Special ConsiderationsYou should not use this method to encode C arrays of Objective-C objects. See decodeArray(ofObjCType:count:at:) for more details.
   * @see https://developer.apple.com/documentation/foundation/nscoder/1417865-encodearray
   */


  encodeArrayOfObjCTypeAt(type, count, array) {}
  /**
   * Encodes the object objv and associates it with the string key.
   * @access public
   * @param {?Object} objv - 
   * @param {string} key - 
   * @returns {void}
   * @desc Subclasses must override this method to identify multiple encodings of objv and encode a reference to objv instead. For example, NSKeyedArchiver detects duplicate objects and encodes a reference to the original object rather than encode the same object twice.
   * @see https://developer.apple.com/documentation/foundation/nscoder/1411568-encode
   */


  encodeForKey(objv, key) {}
  /**
   * Can be overridden by subclasses to encode object so that a copy, rather than a proxy, is created upon decoding.
   * @access public
   * @param {?Object} anObject - 
   * @returns {void}
   * @desc NSCoder’s implementation simply invokes encode(_:).This method must be matched by a corresponding decodeObject() message.
   * @see https://developer.apple.com/documentation/foundation/nscoder/1418225-encodebycopyobject
   */


  encodeBycopyObject(anObject) {}
  /**
   * Can be overridden by subclasses to encode object so that a proxy, rather than a copy, is created upon decoding.
   * @access public
   * @param {?Object} anObject - 
   * @returns {void}
   * @desc NSCoder’s implementation simply invokes encode(_:).This method must be matched by a corresponding decodeObject() message.
   * @see https://developer.apple.com/documentation/foundation/nscoder/1416279-encodebyrefobject
   */


  encodeByrefObject(anObject) {}
  /**
   * Encodes a buffer of data whose types are unspecified.
   * @access public
   * @param {?UnsafeRawPointer} byteaddr - 
   * @param {number} length - 
   * @returns {void}
   * @desc The buffer to be encoded begins at address, and its length in bytes is given by numBytes.This method must be matched by a corresponding decodeBytes(withReturnedLength:) message.
   * @see https://developer.apple.com/documentation/foundation/nscoder/1411664-encodebytes
   */


  encodeBytes(byteaddr, length) {}
  /**
   * Encodes a buffer of data, bytesp, whose length is specified by lenv, and associates it with the string key.
   * @access public
   * @param {?UnsafePointer<UInt8>} bytesp - 
   * @param {number} lenv - 
   * @param {string} key - 
   * @returns {void}
   * @desc Subclasses must override this method if they perform keyed coding.
   * @see https://developer.apple.com/documentation/foundation/nscoder/1413078-encodebytes
   */


  encodeBytesLengthForKey(bytesp, lenv, key) {}
  /**
   * Can be overridden by subclasses to conditionally encode object, preserving common references to that object.
   * @access public
   * @param {?Object} object - 
   * @returns {void}
   * @desc In the overriding method, object should be encoded only if it’s unconditionally encoded elsewhere (with any other encode...Object: method).This method must be matched by a subsequent decodeObject() message. Upon decoding, if object was never encoded unconditionally, decodeObject returns nil in place of object. However, if object was encoded unconditionally, all references to object must be resolved.NSCoder’s implementation simply invokes encode(_:). 
   * @see https://developer.apple.com/documentation/foundation/nscoder/1415196-encodeconditionalobject
   */


  encodeConditionalObject(object) {}
  /**
   * Conditionally encodes a reference to objv and associates it with the string key only if objv has been unconditionally encoded with encode(_:forKey:).
   * @access public
   * @param {?Object} objv - 
   * @param {string} key - 
   * @returns {void}
   * @desc Subclasses must override this method if they support keyed coding.The encoded object is decoded with the decodeObject(forKey:) method. If objv was never encoded unconditionally, decodeObject(forKey:) returns nil in place of objv.
   * @see https://developer.apple.com/documentation/foundation/nscoder/1413918-encodeconditionalobject
   */


  encodeConditionalObjectForKey(objv, key) {}
  /**
   * Encodes size.
   * @access public
   * @param {CGSize} size - 
   * @returns {void}
   * @desc NSCoder’s implementation invokes encodeValue(ofObjCType:at:) to encode size.This method must be matched by a subsequent decodeSize() message.
   * @see https://developer.apple.com/documentation/foundation/nscoder/1391291-encode
   */


  encode(size) {}
  /**
   * Encodes intv and associates it with the string key.
   * @access public
   * @param {number} intv - 
   * @param {string} key - 
   * @returns {void}
   * @desc Subclasses must override this method if they perform keyed coding.
   * @see https://developer.apple.com/documentation/foundation/nscoder/1413906-encodecint
   */


  encodeCIntForKey(intv, key) {}
  /**
   * Encodes the property list aPropertyList.
   * @access public
   * @param {Object} aPropertyList - 
   * @returns {void}
   * @desc NSCoder’s implementation invokes encodeValue(ofObjCType:at:) to encode aPropertyList.This method must be matched by a subsequent decodePropertyList() message.
   * @see https://developer.apple.com/documentation/foundation/nscoder/1410643-encodepropertylist
   */


  encodePropertyList(aPropertyList) {}
  /**
   * Can be overridden by subclasses to encode an interconnected group of Objective-C objects, starting with rootObject.
   * @access public
   * @param {Object} rootObject - 
   * @returns {void}
   * @desc NSCoder’s implementation simply invokes encode(_:).This method must be matched by a subsequent decodeObject() message.
   * @see https://developer.apple.com/documentation/foundation/nscoder/1409439-encoderootobject
   */


  encodeRootObject(rootObject) {}
  /**
   * Must be overridden by subclasses to encode a single value residing at address, whose Objective-C type is given by valueType.
   * @access public
   * @param {UnsafePointer<Int8>} type - 
   * @param {UnsafeRawPointer} addr - 
   * @returns {void}
   * @desc  valueType must contain exactly one type code.This method must be matched by a subsequent decodeValue(ofObjCType:at:) message.For information on creating an Objective-C type code suitable for valueType, see Type Encodings.Special ConsiderationsYou should not use this method to encode of Objective-C objects. See decodeArray(ofObjCType:count:at:) for more details.
   * @see https://developer.apple.com/documentation/foundation/nscoder/1414648-encodevalue
   */


  encodeValueOfObjCTypeAt(type, addr) {} // Decoding General Data

  /**
   * Decodes an array of count items, whose Objective-C type is given by itemType.
   * @access public
   * @param {UnsafePointer<Int8>} itemType - 
   * @param {number} count - 
   * @param {Object} array - 
   * @returns {void}
   * @desc The items are decoded into the buffer beginning at address, which must be large enough to contain them all. itemType must contain exactly one type code. NSCoder’s implementation invokes decodeValue(ofObjCType:at:) to decode the entire array of items.This method matches an encodeArray(ofObjCType:count:at:) message used during encoding.For information on creating an Objective-C type code suitable for itemType, see Type Encodings.Special ConsiderationsYou should not use this method to decode C arrays of Objective-C objects. For historical reasons, returned objects will have an additional ownership reference which you can only relinquish using CFRelease.
   * @see https://developer.apple.com/documentation/foundation/nscoder/1408354-decodearray
   */


  decodeArrayOfObjCTypeAt(itemType, count, array) {}
  /**
   * Decodes and returns a boolean value that was previously encoded with encode(_:forKey:) and associated with the string key.
   * @access public
   * @param {string} key - 
   * @returns {boolean} - 
   * @desc Subclasses must override this method if they perform keyed coding.
   * @see https://developer.apple.com/documentation/foundation/nscoder/1409293-decodebool
   */


  decodeBoolForKey(key) {
    return false;
  }
  /**
   * Decodes a buffer of data that was previously encoded with encodeBytes(_:length:forKey:) and associated with the string key.
   * @access public
   * @param {string} key - 
   * @param {?UnsafeMutablePointer<Int>} lengthp - 
   * @returns {?UnsafePointer<UInt8>} - 
   * @desc  The buffer’s length is returned by reference in lengthp. The returned bytes are immutable. Subclasses must override this method if they perform keyed coding.
   * @see https://developer.apple.com/documentation/foundation/nscoder/1411987-decodebytes
   */


  decodeBytesForKeyReturnedLength(key, lengthp) {
    return null;
  }
  /**
   * Decodes a buffer of data whose types are unspecified.
   * @access public
   * @param {UnsafeMutablePointer<Int>} lengthp - 
   * @returns {?Object} - 
   * @desc NSCoder’s implementation invokes decodeValue(ofObjCType:at:) to decode the data as a series of bytes, which this method then places into a buffer and returns. The buffer’s length is returned by reference in numBytes. If you need the bytes beyond the scope of the current @autoreleasepool block, you must copy them.This method matches an encodeBytes(_:length:) message used during encoding.
   * @see https://developer.apple.com/documentation/foundation/nscoder/1415441-decodebytes
   */


  decodeBytesWithReturnedLength(lengthp) {
    return null;
  }
  /**
   * Decodes and returns an NSData object that was previously encoded with encode(_:). Subclasses must override this method.
   * @access public
   * @returns {?Data} - 
   * @desc The implementation of your overriding method must match the implementation of your encode(_:) method. For example, a typical encode(_:) method encodes the number of bytes of data followed by the bytes themselves. Your override of this method must read the number of bytes, create an NSData object of the appropriate size, and decode the bytes into the new NSData object. 
   * @see https://developer.apple.com/documentation/foundation/nscoder/1409876-decodedata
   */


  decodeData() {
    return null;
  }
  /**
   * Decodes and returns a double value that was previously encoded with either encode(_:forKey:) or encode(_:forKey:) and associated with the string key.
   * @access public
   * @param {string} key - 
   * @returns {number} - 
   * @desc Subclasses must override this method if they perform keyed coding.
   * @see https://developer.apple.com/documentation/foundation/nscoder/1409374-decodedouble
   */


  decodeDoubleForKey(key) {
    return 0;
  }
  /**
   * Decodes and returns a float value that was previously encoded with encode(_:forKey:) or encode(_:forKey:) and associated with the string key.
   * @access public
   * @param {string} key - 
   * @returns {number} - 
   * @desc If the value was encoded as a double, the extra precision is lost. If the encoded real value does not fit into a float, the method raises an NSRangeException. Subclasses must override this method if they perform keyed coding.
   * @see https://developer.apple.com/documentation/foundation/nscoder/1408104-decodefloat
   */


  decodeFloatForKey(key) {
    return 0;
  }
  /**
   * Decodes and returns an int value that was previously encoded with encodeCInt(_:forKey:), encode(_:forKey:), encode(_:forKey:), or encode(_:forKey:) and associated with the string key.
   * @access public
   * @param {string} key - 
   * @returns {number} - 
   * @desc If the encoded integer does not fit into the default integer size, the method raises an NSRangeException. Subclasses must override this method if they perform keyed coding.
   * @see https://developer.apple.com/documentation/foundation/nscoder/1411168-decodecint
   */


  decodeCIntForKey(key) {
    return 0;
  }
  /**
   * Decodes and returns an NSInteger value that was previously encoded with encodeCInt(_:forKey:), encode(_:forKey:), encode(_:forKey:), or encode(_:forKey:) and associated with the string key.
   * @access public
   * @param {string} key - 
   * @returns {number} - 
   * @desc If the encoded integer does not fit into the NSInteger size, the method raises an NSRangeException. Subclasses must override this method if they perform keyed coding.
   * @see https://developer.apple.com/documentation/foundation/nscoder/1409246-decodeinteger
   */


  decodeIntegerForKey(key) {
    return 0;
  }
  /**
   * Decodes and returns a 32-bit integer value that was previously encoded with encodeCInt(_:forKey:), encode(_:forKey:), encode(_:forKey:), or encode(_:forKey:) and associated with the string key.
   * @access public
   * @param {string} key - 
   * @returns {number} - 
   * @desc If the encoded integer does not fit into a 32-bit integer, the method raises an NSRangeException. Subclasses must override this method if they perform keyed coding.
   * @see https://developer.apple.com/documentation/foundation/nscoder/1408918-decodeint32
   */


  decodeInt32ForKey(key) {
    return 0;
  }
  /**
   * Decodes and returns a 64-bit integer value that was previously encoded with encodeCInt(_:forKey:), encode(_:forKey:), encode(_:forKey:), or encode(_:forKey:) and associated with the string key.
   * @access public
   * @param {string} key - 
   * @returns {Int64} - 
   * @desc Subclasses must override this method if they perform keyed coding.
   * @see https://developer.apple.com/documentation/foundation/nscoder/1407878-decodeint64
   */


  decodeInt64ForKey(key) {
    return null;
  }
  /**
   * Decodes an Objective-C object that was previously encoded with any of the encode...Object: methods.
   * @access public
   * @returns {?Object} - 
   * @desc NSCoder’s implementation invokes decodeValue(ofObjCType:at:) to decode the object data.Subclasses may need to override this method if they override any of the corresponding encode...Object: methods. For example, if an object was encoded conditionally using the encodeConditionalObject(_:) method, this method needs to check whether the object had actually been encoded.
   * @see https://developer.apple.com/documentation/foundation/nscoder/1414478-decodeobject
   */


  decodeObject() {
    return null;
  }
  /**
   * Decodes and returns an Objective-C object that was previously encoded with encode(_:forKey:) or encodeConditionalObject(_:forKey:) and associated with the string key.
   * @access public
   * @param {string} key - 
   * @returns {?Object} - 
   * @desc Subclasses must override this method if they perform keyed coding.
   * @see https://developer.apple.com/documentation/foundation/nscoder/1418185-decodeobject
   */


  decodeObjectForKey(key) {
    return null;
  }
  /**
   * Decodes and returns an NSPoint structure that was previously encoded with encode(_:).
   * @access public
   * @returns {CGPoint} - 
   * @see https://developer.apple.com/documentation/foundation/nscoder/1391189-decodepoint
   */


  decodePoint() {
    return null;
  }
  /**
   * Decodes and returns an NSPoint structure that was previously encoded with encode(_:forKey:).
   * @access public
   * @param {string} key - 
   * @returns {CGPoint} - 
   * @see https://developer.apple.com/documentation/foundation/nscoder/1391214-decodepoint
   */


  decodePointForKey(key) {
    return null;
  }
  /**
   * Decodes a property list that was previously encoded with encodePropertyList(_:).
   * @access public
   * @returns {?Object} - 
   * @see https://developer.apple.com/documentation/foundation/nscoder/1411916-decodepropertylist
   */


  decodePropertyList() {
    return null;
  }
  /**
   * Decodes and returns an NSRect structure that was previously encoded with encode(_:).
   * @access public
   * @returns {CGRect} - 
   * @see https://developer.apple.com/documentation/foundation/nscoder/1391269-decoderect
   */


  decodeRect() {
    return null;
  }
  /**
   * Decodes and returns an NSRect structure that was previously encoded with encode(_:forKey:).
   * @access public
   * @param {string} key - 
   * @returns {CGRect} - 
   * @see https://developer.apple.com/documentation/foundation/nscoder/1391116-decoderect
   */


  decodeRectForKey(key) {
    return null;
  }
  /**
   * Decodes and returns an NSSize structure that was previously encoded with encode(_:).
   * @access public
   * @returns {CGSize} - 
   * @see https://developer.apple.com/documentation/foundation/nscoder/1391144-decodesize
   */


  decodeSize() {
    return null;
  }
  /**
   * Decodes and returns an NSSize structure that was previously encoded with encode(_:forKey:).
   * @access public
   * @param {string} key - 
   * @returns {CGSize} - 
   * @see https://developer.apple.com/documentation/foundation/nscoder/1391253-decodesize
   */


  decodeSizeForKey(key) {
    return null;
  }
  /**
   * Decodes a single value, whose Objective-C type is given by valueType.
   * @access public
   * @param {UnsafePointer<Int8>} type - 
   * @param {Object} data - 
   * @returns {void}
   * @desc  valueType must contain exactly one type code, and the buffer specified by data must be large enough to hold the value corresponding to that type code. For information on creating an Objective-C type code suitable for valueType, see Type Encodings.Subclasses must override this method and provide an implementation to decode the value. In your overriding implementation, decode the value into the buffer beginning at data.This method matches an encodeValue(ofObjCType:at:) message used during encoding.
   * @see https://developer.apple.com/documentation/foundation/nscoder/1417159-decodevalue
   */


  decodeValueOfObjCTypeAt(type, data) {}
  /**
   * Returns a decoded property list for the specified key.
   * @access public
   * @param {string} key - The coder key.
   * @returns {?Object} - 
   * @desc This method calls decodeObjectOfClasses:forKey: with a set allowing only property list types.
   * @see https://developer.apple.com/documentation/foundation/nscoder/1416284-decodepropertylist
   */


  decodePropertyListForKey(key) {
    return null;
  } // Decoding Geometry-Based Data

  /**
   * Decodes and returns the CGPoint structure associated with the specified key in the receiver’s archive. 
   * @access public
   * @param {string} key - The key that identifies the point.
   * @returns {CGPoint} - 
   * @desc Use this method to decode a point that was previously encoded using the encode(_:forKey:) method.
   * @see https://developer.apple.com/documentation/foundation/nscoder/1624523-decodecgpoint
   */


  decodeCGPointForKey(key) {
    return null;
  }
  /**
   * Decodes and returns the CGRect structure associated with the specified key in the receiver’s archive. 
   * @access public
   * @param {string} key - The key that identifies the rectangle.
   * @returns {CGRect} - 
   * @desc Use this method to decode a rectangle that was previously encoded using the encode(_:forKey:) method.
   * @see https://developer.apple.com/documentation/foundation/nscoder/1624522-decodecgrect
   */


  decodeCGRectForKey(key) {
    return null;
  }
  /**
   * Decodes and returns the CGSize structure associated with the specified key in the receiver’s archive. 
   * @access public
   * @param {string} key - The key that identifies the size information.
   * @returns {CGSize} - 
   * @desc Use this method to decode size information that was previously encoded using the encode(_:forKey:) method.
   * @see https://developer.apple.com/documentation/foundation/nscoder/1624519-decodecgsize
   */


  decodeCGSizeForKey(key) {
    return null;
  }
  /**
   * Decodes and returns the CGAffineTransform structure associated with the specified key in the receiver’s archive. 
   * @access public
   * @param {string} key - The key that identifies the affine transform.
   * @returns {CGAffineTransform} - 
   * @desc Use this method to decode size information that was previously encoded using the encode(_:forKey:) method.
   * @see https://developer.apple.com/documentation/foundation/nscoder/1624478-decodecgaffinetransform
   */


  decodeCGAffineTransformForKey(key) {
    return null;
  }
  /**
   * Decodes and returns the UIEdgeInsets structure associated with the specified key in the receiver’s archive. 
   * @access public
   * @param {string} key - The key that identifies the edge insets.
   * @returns {UIEdgeInsets} - 
   * @desc Use this method to decode size information that was previously encoded using the encode(_:forKey:) method.
   * @see https://developer.apple.com/documentation/foundation/nscoder/1624492-decodeuiedgeinsets
   */


  decodeUIEdgeInsetsForKey(key) {
    return null;
  }
  /**
   * Decodes and returns the UIOffset structure associated with the specified key in the receiver’s archive. 
   * @access public
   * @param {string} key - The key that identifies the offset.
   * @returns {UIOffset} - 
   * @desc Use this method to decode offset information that was previously encoded using the encode(_:forKey:) method.
   * @see https://developer.apple.com/documentation/foundation/nscoder/1624507-decodeuioffset
   */


  decodeUIOffsetForKey(key) {
    return null;
  }
  /**
   * Decodes and returns the CGVector data associated with the specified key in the coder’s archive.
   * @access public
   * @param {string} key - The key that identifies the vector.
   * @returns {CGVector} - 
   * @desc Use this method to decode vector information that was previously encoded using the encode(_:forKey:) method.
   * @see https://developer.apple.com/documentation/foundation/nscoder/1624488-decodecgvector
   */


  decodeCGVectorForKey(key) {
    return null;
  } // Decoding Core Media Time Structures

  /**
   * Returns the CMTime structure associated with a given key.
   * @access public
   * @param {string} key - The key for a CMTime structure encoded in the receiver.
   * @returns {CMTime} - 
   * @see https://developer.apple.com/documentation/foundation/nscoder/1389544-decodetime
   */


  decodeTimeForKey(key) {
    return null;
  }
  /**
   * Returns the CMTimeRange structure associated with a given key.
   * @access public
   * @param {string} key - The key for a CMTimeRange structure encoded in the receiver.
   * @returns {CMTimeRange} - 
   * @see https://developer.apple.com/documentation/foundation/nscoder/1385718-decodetimerange
   */


  decodeTimeRangeForKey(key) {
    return null;
  }
  /**
   * Returns the CMTimeMapping structure associated with a given key.
   * @access public
   * @param {string} key - The key for a CMTimeMapping structure encoded in the receiver.
   * @returns {CMTimeMapping} - 
   * @see https://developer.apple.com/documentation/foundation/nscoder/1389860-decodetimemapping
   */


  decodeTimeMappingForKey(key) {
    return null;
  } // Secure Coding

  /**
   * Boolean value that indicates whether the coder requires secure coding.
   * @type {boolean}
   * @desc true if this coder requires secure coding; false otherwise.Secure coders check a set of allowed classes before decoding objects, and all objects must implement the NSSecureCoding protocol.
   * @see https://developer.apple.com/documentation/foundation/nscoder/1409845-requiressecurecoding
   */


  get requiresSecureCoding() {
    return this._requiresSecureCoding;
  }
  /**
   * The set of coded classes allowed for secure coding.
   * @type {?Set<AnyHashable>}
   * @desc Secure coders check this set of allowed classes before decoding objects, and all objects must implement the NSSecureCoding protocol.
   * @see https://developer.apple.com/documentation/foundation/nscoder/1412486-allowedclasses
   */


  get allowedClasses() {
    return this._allowedClasses;
  } // Getting Version Information

  /**
   * This method is present for historical reasons and is not used with keyed archivers.
   * @access public
   * @param {string} className - 
   * @returns {number} - 
   * @desc The version number does apply not to NSKeyedArchiver/NSKeyedUnarchiver.  A keyed archiver does not encode class version numbers.
   * @see https://developer.apple.com/documentation/foundation/nscoder/1417703-version
   */


  versionForClassName(className) {
    return 0;
  }
  /**
   * The system version in effect for the archive.
   * @type {number}
   * @desc During encoding, the current version. During decoding, the version that was in effect when the data was encoded.Subclasses that implement decoding must override this property to return the system version of the data being decoded.
   * @see https://developer.apple.com/documentation/foundation/nscoder/1413205-systemversion
   */


  get systemVersion() {
    return this._systemVersion;
  } // Instance Properties

  /**
   * 
   * @type {NSCoder.DecodingFailurePolicy}
   * @desc 
   * @see https://developer.apple.com/documentation/foundation/nscoder/1642984-decodingfailurepolicy
   */


  get decodingFailurePolicy() {
    return this._decodingFailurePolicy;
  }
  /**
   * 
   * @type {?Error}
   * @desc 
   * @see https://developer.apple.com/documentation/foundation/nscoder/1643263-error
   */


  get error() {
    return this._error;
  } // Instance Methods

  /**
   * 
   * @access public
   * @param {DecodedObjectType.Type} cls - 
   * @param {string} key - 
   * @returns {NSCoding} - 
   * @see https://developer.apple.com/documentation/foundation/nscoder/2292924-decodeobject
   */


  decodeObjectOfClassForKey(cls, key) {
    return null;
  }
  /**
   * 
   * @access public
   * @returns {void}
   * @throws {Error}
   * @see https://developer.apple.com/documentation/foundation/nscoder/1407699-decodetoplevelobject
   */


  decodeTopLevelObject() {}
  /**
   * 
   * @access public
   * @param {string} key - 
   * @returns {void}
   * @throws {Error}
   * @see https://developer.apple.com/documentation/foundation/nscoder/2293311-decodetoplevelobject
   */


  decodeTopLevelObjectForKey(key) {}
  /**
   * 
   * @access public
   * @param {?Object[]} classes - 
   * @param {string} key - 
   * @returns {void}
   * @throws {Error}
   * @see https://developer.apple.com/documentation/foundation/nscoder/2293221-decodetoplevelobject
   */


  decodeTopLevelObjectOfForKey(classes, key) {}
  /**
   * 
   * @access public
   * @param {Error} error - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/foundation/nscoder/1411455-failwitherror
   */


  failWithError(error) {}

}

/**
 * dummy class for NSColorSpace
 * @access public
 * @extends {NSObject}
 */

class NSColorSpace extends NSObject {
  static get _propTypes() {
    return {
      NSICC: ['NSMutableData', '_icc'],
      NSSpaceID: ['integer', '_spaceID'],
      NSID: ['integer', '_id']
    };
  }

  constructor() {
    super();
    this._icc = null;
    this._spaceID = null;
    this._id = null;
  }

}

/**
 * dummy class for NSKeyedArchiver/Unarchiver
 * @access public
 * @extends {NSObject}
 */

class NSData extends NSObject {
  /**
   * @access public
   * @param {NSCoder} coder -
   * @returns {_Buffer} -
   */
  static initWithCoder(coder) {
    const data = coder.decodeBytesForKeyReturnedLength('NS.data', null);

    if (typeof data !== 'undefined') {
      return data;
    }

    const bytes = coder.decodeBytesForKeyReturnedLength('NS.bytes', null);

    if (typeof bytes !== 'undefined') {
      return bytes;
    }

    return null;
  }

}

/**
 * dummy class for NSKeyedArchiver/Unarchiver
 * @access public
 * @extends {NSObject}
 */

class NSDictionary extends NSObject {
  /**
   * @access public
   * @param {NSCoder} coder -
   * @returns {Object} -
   */
  static initWithCoder(coder) {
    const dict = {};

    if (typeof coder._refObj['NS.objects'] !== 'undefined') {
      const keys = coder._refObj['NS.keys'];
      const objects = coder._refObj['NS.objects'];

      if (!Array.isArray(keys)) {
        throw new Error('NS.keys must be Array');
      }

      if (!Array.isArray(objects)) {
        throw new Error('NS.objects must be Array');
      }

      if (keys.length !== objects.length) {
        throw new Error('NS.keys.length !== NS.objects.length');
      }

      const keyCoder = coder.copy();
      keyCoder._refObj = keys;
      const objCoder = coder.copy();
      objCoder._refObj = objects;

      for (let i = 0; i < keys.length; i++) {
        const key = keyCoder.decodeObjectForKey(i);
        const obj = objCoder.decodeObjectForKey(i);
        dict[key] = obj;
      }
    } else {
      for (let i = 0;; i++) {
        const objKey = `NS.object.${i}`;
        const keyKey = `NS.key.${i}`;

        if (typeof coder._refObj[objKey] === 'undefined') {
          break;
        }

        const key = coder.decodeObjectForKey(keyKey);
        const obj = coder.decodeObjectForKey(objKey);
        dict[key] = obj;
      }
    }

    return dict;
  }

}

//import NSKeyedArchiverDelegate from '../undefined/NSKeyedArchiverDelegate'

/**
 * NSKeyedArchiver, a concrete subclass of NSCoder, provides a way to encode objects (and scalar values) into an architecture-independent format that can be stored in a file. When you archive a set of objects, the class information and instance variables for each object are written to the archive. NSKeyedArchiver’s companion class, NSKeyedUnarchiver, decodes the data in an archive and creates a set of objects equivalent to the original set.
 * @access public
 * @extends {NSCoder}
 * @see https://developer.apple.com/documentation/foundation/nskeyedarchiver
 */

class NSKeyedArchiver extends NSCoder {
  // Initializers

  /**
   * 
   * @access public
   * @constructor
   * @see https://developer.apple.com/documentation/foundation/nskeyedarchiver/1642790-init
   */
  constructor() {
    super(); // Archiving Data

    /**
     * The format in which the receiver encodes its data.
     * @type {PropertyListSerialization.PropertyListFormat}
     * @see https://developer.apple.com/documentation/foundation/nskeyedarchiver/1417520-outputformat
     */

    this.outputFormat = null;
    /**
     * Indicates whether the receiver requires all archived classes to conform to NSSecureCoding.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/foundation/nskeyedarchiver/1417084-requiressecurecoding
     */

    this.requiresSecureCoding = false; // Managing the Delegate

    /**
     * The archiver’s delegate.
     * @type {?NSKeyedArchiverDelegate}
     * @see https://developer.apple.com/documentation/foundation/nskeyedarchiver/1412809-delegate
     */

    this.delegate = null; // Instance Properties

    this._encodedData = null;
  } // Initializing an NSKeyedArchiver Object

  /**
   * Returns the receiver, initialized for encoding an archive into a given a mutable-data object.
   * @access public
   * @param {NSMutableData} data - The mutable-data object into which the archive is written.
   * @returns {NSKeyedArchiver}
   * @desc When you finish encoding data, you must invoke finishEncoding() at which point data is filled. The format of the receiver is NSPropertyListBinaryFormat_v1_0.
   * @see https://developer.apple.com/documentation/foundation/nskeyedarchiver/1409579-init
   */
  //initForWritingWith(data) {


  static archiverForWritingWithData(data) {
    const instance = new NSKeyedArchiver(); // TODO: implement

    return instance;
  } // Archiving Data

  /**
   * Returns an NSData object containing the encoded form of the object graph whose root object is given.
   * @access public
   * @param {Object} rootObject - 
   * @returns {Data} - 
   * @see https://developer.apple.com/documentation/foundation/nskeyedarchiver/1413189-archiveddata
   */


  static archivedDataWithRootObject(rootObject) {
    return null;
  }
  /**
   * Archives an object graph rooted at a given object by encoding it into a data object then atomically writes the resulting data object to a file at a given path, and returns a Boolean value that indicates whether the operation was successful.
   * @access public
   * @param {Object} rootObject - 
   * @param {string} path - The path of the file in which to write the archive.
   * @returns {boolean} - 
   * @desc The format of the archive is NSPropertyListBinaryFormat_v1_0.
   * @see https://developer.apple.com/documentation/foundation/nskeyedarchiver/1410621-archiverootobject
   */


  static archiveRootObjectToFile(rootObject, path) {
    return false;
  }
  /**
   * Instructs the receiver to construct the final data stream.
   * @access public
   * @returns {void}
   * @desc No more values can be encoded after this method is called. You must call this method when finished.
   * @see https://developer.apple.com/documentation/foundation/nskeyedarchiver/1413904-finishencoding
   */


  finishEncoding() {} // Encoding Data and Objects

  /**
   * Encodes a given float value and associates it with a given key.
   * @access public
   * @param {number} realv - The value to encode.
   * @param {string} key - The key with which to associate realv. This value must not be nil.
   * @returns {void}
   * @see https://developer.apple.com/documentation/foundation/nskeyedarchiver/1416972-encode
   */


  encodeForKey(realv, key) {}
  /**
   * Encodes a given number of bytes from a given C array of bytes and associates them with the a given key.
   * @access public
   * @param {?UnsafePointer<UInt8>} bytesp - A C array of bytes to encode.
   * @param {number} lenv - The number of bytes from bytesp to encode.
   * @param {string} key - The key with which to associate the encoded value. This value must not be nil.
   * @returns {void}
   * @see https://developer.apple.com/documentation/foundation/nskeyedarchiver/1417696-encodebytes
   */


  encodeBytesLengthForKey(bytesp, lenv, key) {}
  /**
   * Encodes a reference to a given object and associates it with a given key only if it has been unconditionally encoded elsewhere in the archive with encode(_:forKey:).
   * @access public
   * @param {?Object} objv - The object to encode. 
   * @param {string} key - The key with which to associate the encoded value. This value must not be nil.
   * @returns {void}
   * @see https://developer.apple.com/documentation/foundation/nskeyedarchiver/1413677-encodeconditionalobject
   */


  encodeConditionalObjectForKey(objv, key) {} // Managing Classes and Class Names

  /**
   * Adds a class translation mapping to the receiver whereby instances of of a given class are encoded with a given class name instead of their real class names.
   * @access public
   * @param {?string} codedName - 
   * @param {Object} cls - The class for which to set up a translation mapping.
   * @returns {void}
   * @desc When encoding, the receiver’s translation map overrides any translation that may also be present in the class’s map.
   * @see https://developer.apple.com/documentation/foundation/nskeyedarchiver/1414746-setclassname
   */


  static setClassNameFor(codedName, cls) {}
  /**
   * Returns the class name with which the receiver encodes instances of a given class.
   * @access public
   * @param {Object} cls - The class for which to determine the translation mapping.
   * @returns {?string} - 
   * @see https://developer.apple.com/documentation/foundation/nskeyedarchiver/1407245-classname
   */


  static classNameFor(cls) {
    return null;
  } // Instance Properties

  /**
   * Returns the encoded data for the archiver.
   * @type {Data}
   * @desc If encoding has not yet finished, invoking this property calls finishEncoding() and returns the data. If you initialized the keyed archiver with a specific mutable data instance, then that data is returned by the property after finishEncoding() is called.
   * @see https://developer.apple.com/documentation/foundation/nskeyedarchiver/1643042-encodeddata
   */


  get encodedData() {
    return this._encodedData;
  }

}

class File {
  /**
   * @access public
   * @constructor
   * @param {array} fileBits -
   * @param {string} fileName -
   * @param {Object} options -
   */
  constructor(fileBits, fileName, options) {
    this._lastModified = null;
    this._lastModifiedDate = null;
    this._name = fileName;
    this._size = null;
    this._webkitRelativePath = null;
    this._type = null;
  }

  get lastModified() {
    return this._lastModified;
  }

  get lastModifiedDate() {
    return this._lastModifiedDate;
  }

  get name() {
    return this._name;
  }

  get size() {
    return this._size;
  }

  get webkitRelativePath() {
    return this._webkitRelativePath;
  }

  get type() {
    return this._type;
  }

}

var fs = {};

const EMPTY = 0;
const LOADING = 1;
const DONE = 2;
class FileReader {
  /**
   * @access public
   * @constructor
   */
  constructor() {
    this.onabort = null;
    this.onerror = null;
    this.onload = null;
    this.onloadstart = null;
    /**
     * @type {function}
     */

    this.onloadend = null;
    this.onprogress = null;
    this._error = null;
    this._readyState = EMPTY;
    this._result = null;
  }

  get error() {
    return this._error;
  }

  get readyState() {
    return this._readyState;
  }
  /**
   * @type {Blob|string}
   */


  get result() {
    return this._result;
  }

  abort() {}
  /**
   * @access public
   * @param {Blob|File} blob -
   * @returns {void}
   */


  readAsArrayBuffer(blob) {
    this._read(blob, 'ArrayBuffer');
  }
  /**
   * @access public
   * @param {Blob|File} blob -
   * @returns {void}
   */


  readAsBinaryString(blob) {
    this._read(blob, 'BinaryString');
  }
  /**
   * @access public
   * @param {Blob|File} blob -
   * @param {string} [encoding = 'utf8'] -
   * @returns {void}
   */


  readAsText(blob, encoding = 'utf8') {
    this._read(blob, 'Text', encoding);
  }
  /**
   * @access public
   * @param {Blob|File} blob -
   * @returns {void}
   */


  readAsDataURL(blob) {
    this._read(blob, 'DataURL');
  }

  _read(blob, type, encoding = null) {
    if (this._readyState === LOADING) {
      throw new Error('InvalidStateError');
    }

    this._readyState = LOADING;

    if (blob instanceof File) {
      fs.readFile(blob.name, encoding, (err, data) => {
        if (err) {
          this._error = err;

          if (this.onerror !== null) {
            this.onerror();
          }

          if (this.onloadend !== null) {
            this.onloadend();
          }

          return;
        }

        this._readyState = DONE;

        switch (type) {
          case 'ArrayBuffer':
            this._result = data;
            break;

          case 'BinaryString':
            this._result = data;
            break;

          case 'Text':
            this._result = data;
            break;

          case 'DataURL':
            this._result = data;
            break;

          default:
            throw new Error('unknown return type');
        }

        if (this._readyState !== LOADING) {
          if (this.onload !== null) {
            this.onload();
          }

          if (this.onloadend !== null) {
            this.onloadend();
          }
        }
      });
    }
  }

}

//

const UnescapeSJIS = function (str) {
  return str.replace(/%(8[1-9A-F]|[9E][0-9A-F]|F[0-9A-C])(%[4-689A-F][0-9A-F]|%7[0-9A-E]|[@-~])|%([0-7][0-9A-F]|A[1-9A-F]|[B-D][0-9A-F])/ig, function (s) {
    var c = parseInt(s.substring(1, 3), 16),
        l = s.length;
    return 3 == l ? String.fromCharCode(c < 160 ? c : c + 65216) : JCT11280.charAt((c < 160 ? c - 129 : c - 193) * 188 + (4 == l ? s.charCodeAt(3) - 64 : (c = parseInt(s.substring(4), 16)) < 127 ? c - 64 : c - 65));
  });
};

const UnescapeEUCJP = function (str) {
  return str.replace(/(%A[1-9A-F]|%[B-E][0-9A-F]|%F[0-9A-E]){2}|%8E%(A[1-9A-F]|[B-D][0-9A-F])|%[0-7][0-9A-F]/ig, function (s) {
    var c = parseInt(s.substring(1), 16);
    return c < 161 ? String.fromCharCode(c < 128 ? c : parseInt(s.substring(4), 16) + 65216) : JCT8836.charAt((c - 161) * 94 + parseInt(s.substring(4), 16) - 161);
  });
};

const UnescapeJIS7 = function (str) {
  var i = 0,
      p,
      q,
      s = "",
      u = String.fromCharCode,
      P = ("%28B" + str.replace(/%49/g, "I").replace(/%1B%24%4[02]|%1B%24@/ig, "%1B%24B")).split(/%1B/i),
      I = function (s) {
    return u(parseInt(s.substring(1), 16));
  },
      J = function (s) {
    return u((3 == s.length ? parseInt(s.substring(1), 16) : s.charCodeAt(0)) + 65344);
  },
      K = function (s) {
    var l = s.length;
    return JCT8836.charAt(4 < l ? (parseInt(s.substring(1), 16) - 33) * 94 + parseInt(s.substring(4), 16) - 33 : 2 < l ? (37 == (l = s.charCodeAt(0)) ? (parseInt(s.substring(1, 3), 16) - 33) * 94 + s.charCodeAt(3) : (l - 33) * 94 + parseInt(s.substring(2), 16)) - 33 : (s.charCodeAt(0) - 33) * 94 + s.charCodeAt(1) - 33);
  },
      rI = new RegExp(),
      rJ = new RegExp(),
      rK = new RegExp();

  rI.compile("%[0-7][0-9A-F]", "ig");
  rJ.compile("(%2[1-9A-F]|%[3-5][0-9A-F])|[!-_]", "ig");
  rK.compile("(%2[1-9A-F]|%[3-6][0-9A-F]|%7[0-9A-E]){2}|(%2[1-9A-F]|%[3-6][0-9A-F]|%7[0-9A-E])[!-~]|[!-~](%2[1-9A-F]|%[3-6][0-9A-F]|%7[0-9A-E])|[!-~]{2}", "ig");

  while (p = P[i++]) s += "%24B" == (q = p.substring(0, 4)) ? p.substring(4).replace(rK, K) : "%28I" == q ? p.substring(4).replace(rJ, J) : p.replace(rI, I).substring(2);

  return s;
};

const UnescapeJIS8 = function (str) {
  var i = 0,
      p,
      s = "",
      P = ("%28B" + str.replace(/%1B%24%4[02]|%1B%24@/ig, "%1B%24B")).split(/%1B/i),
      I = function (s) {
    var c = parseInt(s.substring(1), 16);
    return String.fromCharCode(c < 128 ? c : c + 65216);
  },
      K = function (s) {
    var l = s.length;
    return JCT8836.charAt(4 < l ? (parseInt(s.substring(1), 16) - 33) * 94 + parseInt(s.substring(4), 16) - 33 : 2 < l ? (37 == (l = s.charCodeAt(0)) ? (parseInt(s.substring(1, 3), 16) - 33) * 94 + s.charCodeAt(3) : (l - 33) * 94 + parseInt(s.substring(2), 16)) - 33 : (s.charCodeAt(0) - 33) * 94 + s.charCodeAt(1) - 33);
  },
      rI = new RegExp(),
      rK = new RegExp();

  rI.compile("%([0-7][0-9A-F]|A[1-9A-F]|[B-D][0-9A-F])", "ig");
  rK.compile("(%2[1-9A-F]|%[3-6][0-9A-F]|%7[0-9A-E]){2}|(%2[1-9A-F]|%[3-6][0-9A-F]|%7[0-9A-E])[!-~]|[!-~](%2[1-9A-F]|%[3-6][0-9A-F]|%7[0-9A-E])|[!-~]{2}", "ig");

  while (p = P[i++]) s += "%24B" == p.substring(0, 4) ? p.substring(4).replace(rK, K) : p.replace(rI, I).substring(2);

  return s;
};

const UnescapeUnicode = function (str) {
  return str.replace(/%u[0-9A-F]{4}|%[0-9A-F]{2}/ig, function (s) {
    return String.fromCharCode("0x" + s.substring(s.length / 3));
  });
};

const UnescapeUTF7 = function (str) {
  var i = 0,
      B = {};

  while (i < 64) B["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(i)] = i++;

  return str.replace(RegExp("[+][+/-9A-Za-z]*-?", "g"), function (s) {
    if ("+-" == s) return "+";
    var b = B[s.charAt(1)],
        c,
        i = 1,
        t = "";

    while (0 <= b) {
      if ((c = i & 7) < 6) c = c < 3 ? b << 10 | B[s.charAt(++i)] << 4 | (b = B[s.charAt(++i)]) >> 2 : (b & 3) << 14 | B[s.charAt(++i)] << 8 | B[s.charAt(++i)] << 2 | (b = B[s.charAt(++i)]) >> 4;else {
        c = (b & 15) << 12 | B[s.charAt(++i)] << 6 | B[s.charAt(++i)];
        b = B[s.charAt(++i)];
      }
      if (c) t += String.fromCharCode(c);
    }

    return t;
  });
};

const UnescapeUTF8 = function (str) {
  return str.replace(/%(E(0%[AB]|[1-CEF]%[89AB]|D%[89])[0-9A-F]|C[2-9A-F]|D[0-9A-F])%[89AB][0-9A-F]|%[0-7][0-9A-F]/ig, function (s) {
    var c = parseInt(s.substring(1), 16);
    return String.fromCharCode(c < 128 ? c : c < 224 ? (c & 31) << 6 | parseInt(s.substring(4), 16) & 63 : ((c & 15) << 6 | parseInt(s.substring(4), 16) & 63) << 6 | parseInt(s.substring(7), 16) & 63);
  });
};

const UnescapeUTF16LE = function (str) {
  var u = String.fromCharCode,
      b = u(92, 120, 48, 48, 45, 92, 120, 70, 70);
  return str.replace(/^%FF%FE/i, "").replace(RegExp("%[0-9A-F]{2}%[0-9A-F]{2}|%[0-9A-F]{2}[" + b + "]|[" + b + "]%[0-9A-F]{2}|[" + b + "]{2}", "ig"), function (s) {
    var l = s.length;
    return u(4 < l ? "0x" + s.substring(4, 6) + s.substring(1, 3) : 2 < l ? 37 == (l = s.charCodeAt(0)) ? parseInt(s.substring(1, 3), 16) | s.charCodeAt(3) << 8 : l | parseInt(s.substring(2), 16) << 8 : s.charCodeAt(0) | s.charCodeAt(1) << 8);
  });
};

const JCT11280 = Function('var a="zKV33~jZ4zN=~ji36XazM93y!{~k2y!o~k0ZlW6zN?3Wz3W?{EKzK[33[`y|;-~j^YOTz$!~kNy|L1$353~jV3zKk3~k-4P4zK_2+~jY4y!xYHR~jlz$_~jk4z$e3X5He<0y!wy|X3[:~l|VU[F3VZ056Hy!nz/m1XD61+1XY1E1=1y|bzKiz!H034zKj~mEz#c5ZA3-3X$1~mBz$$3~lyz#,4YN5~mEz#{ZKZ3V%7Y}!J3X-YEX_J(3~mAz =V;kE0/y|F3y!}~m>z/U~mI~j_2+~mA~jp2;~m@~k32;~m>V}2u~mEX#2x~mBy+x2242(~mBy,;2242(~may->2&XkG2;~mIy-_2&NXd2;~mGz,{4<6:.:B*B:XC4>6:.>B*BBXSA+A:X]E&E<~r#z+625z s2+zN=`HXI@YMXIAXZYUM8X4K/:Q!Z&33 3YWX[~mB`{zKt4z (zV/z 3zRw2%Wd39]S11z$PAXH5Xb;ZQWU1ZgWP%3~o@{Dgl#gd}T){Uo{y5_d{e@}C(} WU9|cB{w}bzvV|)[} H|zT}d||0~{]Q|(l{|x{iv{dw}(5}[Z|kuZ }cq{{y|ij}.I{idbof%cu^d}Rj^y|-M{ESYGYfYsZslS`?ZdYO__gLYRZ&fvb4oKfhSf^d<Yeasc1f&a=hnYG{QY{D`Bsa|u,}Dl|_Q{C%xK|Aq}C>|c#ryW=}eY{L+`)][YF_Ub^h4}[X|?r|u_ex}TL@YR]j{SrXgo*|Gv|rK}B#mu{R1}hs|dP{C7|^Qt3|@P{YVV |8&}#D}ef{e/{Rl|>Hni}R1{Z#{D[}CQlQ||E}[s{SG_+i8eplY[=[|ec[$YXn#`hcm}YR|{Ci(_[ql|?8p3]-}^t{wy}4la&pc|3e{Rp{LqiJ],] `kc(]@chYnrM`O^,ZLYhZB]ywyfGY~aex!_Qww{a!|)*lHrM{N+n&YYj~Z b c#e_[hZSon|rOt`}hBXa^i{lh|<0||r{KJ{kni)|x,|0auY{D!^Sce{w;|@S|cA}Xn{C1h${E]Z-XgZ*XPbp]^_qbH^e[`YM|a||+=]!Lc}]vdBc=j-YSZD]YmyYLYKZ9Z>Xcczc2{Yh}9Fc#Z.l{}(D{G{{mRhC|L3b#|xK[Bepj#ut`H[,{E9Yr}1b{[e]{ZFk7[ZYbZ0XL]}Ye[(`d}c!|*y`Dg=b;gR]Hm=hJho}R-[n}9;{N![7k_{UbmN]rf#pTe[x8}!Qcs_rs[m`|>N}^V})7{^r|/E}),}HH{OYe2{Skx)e<_.cj.cjoMhc^d}0uYZd!^J_@g,[[[?{i@][|3S}Yl3|!1|eZ|5IYw|1D}e7|Cv{OHbnx-`wvb[6[4} =g+k:{C:}ed{S]|2M]-}WZ|/q{LF|dYu^}Gs^c{Z=}h>|/i|{W]:|ip{N:|zt|S<{DH[p_tvD{N<[8Axo{X4a.^o^X>Yfa59`#ZBYgY~_t^9`jZHZn`>G[oajZ;X,i)Z.^~YJe ZiZF^{][[#Zt^|]Fjx]&_5dddW]P0C[-]}]d|y {C_jUql] |OpaA[Z{lp|rz}:Mu#]_Yf6{Ep?f5`$[6^D][^u[$[6^.Z8]]ePc2U/=]K^_+^M{q*|9tYuZ,s(dS{i=|bNbB{uG}0jZOa:[-]dYtu3]:]<{DJ_SZIqr_`l=Yt`gkTnXb3d@kiq0a`Z{|!B|}e}Ww{Sp,^Z|0>_Z}36|]A|-t}lt{R6pi|v8hPu#{C>YOZHYmg/Z4nicK[}hF_Bg|YRZ7c|crkzYZY}_iXcZ.|)U|L5{R~qi^Uga@Y[xb}&qdbd6h5|Btw[}c<{Ds53[Y7]?Z<|e0{L[ZK]mXKZ#Z2^tavf0`PE[OSOaP`4gi`qjdYMgys/?[nc,}EEb,eL]g[n{E_b/vcvgb.{kcwi`~v%|0:|iK{Jh_vf5lb}KL|(oi=LrzhhY_^@`zgf[~g)[J_0fk_V{T)}I_{D&_/d9W/|MU[)f$xW}?$xr4<{Lb{y4}&u{XJ|cm{Iu{jQ}CMkD{CX|7A}G~{kt)nB|d5|<-}WJ}@||d@|Iy}Ts|iL|/^|no|0;}L6{Pm]7}$zf:|r2}?C_k{R(}-w|`G{Gy[g]bVje=_0|PT{^Y^yjtT[[[l!Ye_`ZN]@[n_)j3nEgMa]YtYpZy].d-Y_cjb~Y~[nc~sCi3|zg}B0}do{O^{|$`_|D{}U&|0+{J3|8*]iayx{a{xJ_9|,c{Ee]QXlYb]$[%YMc*]w[aafe]aVYi[fZEii[xq2YQZHg]Y~h#|Y:thre^@^|_F^CbTbG_1^qf7{L-`VFx Zr|@EZ;gkZ@slgko`[e}T:{Cu^pddZ_`yav^Ea+[#ZBbSbO`elQfLui}.F|txYcbQ`XehcGe~fc^RlV{D_0ZAej[l&jShxG[ipB_=u:eU}3e8[=j|{D(}dO{Do[BYUZ0/]AYE]ALYhZcYlYP/^-^{Yt_1_-;YT`P4BZG=IOZ&]H[e]YYd[9^F[1YdZxZ?Z{Z<]Ba2[5Yb[0Z4l?]d_;_)a?YGEYiYv`_XmZs4ZjY^Zb]6gqGaX^9Y}dXZr[g|]Y}K aFZp^k^F]M`^{O1Ys]ZCgCv4|E>}8eb7}l`{L5[Z_faQ|c2}Fj}hw^#|Ng|B||w2|Sh{v+[G}aB|MY}A{|8o}X~{E8paZ:]i^Njq]new)`-Z>haounWhN}c#{DfZ|fK]KqGZ=:u|fqoqcv}2ssm}.r{]{nIfV{JW)[K|,Z{Uxc|]l_KdCb%]cfobya3`p}G^|LZiSC]U|(X|kBlVg[kNo({O:g:|-N|qT}9?{MBiL}Sq{`P|3a|u.{Uaq:{_o|^S}jX{Fob0`;|#y_@[V[K|cw[<_ }KU|0F}d3|et{Q7{LuZttsmf^kYZ`Af`}$x}U`|Ww}d]| >}K,r&|XI|*e{C/a-bmr1fId4[;b>tQ_:]hk{b-pMge]gfpo.|(w[jgV{EC1Z,YhaY^q,_G[c_g[J0YX]`[h^hYK^_Yib,` {i6vf@YM^hdOKZZn(jgZ>bzSDc^Z%[[o9[2=/YHZ(_/Gu_`*|8z{DUZxYt^vuvZjhi^lc&gUd4|<UiA`z]$b/Z?l}YI^jaHxe|;F}l${sQ}5g}hA|e4}?o{ih}Uz{C)jPe4]H^J[Eg[|AMZMlc}:,{iz}#*|gc{Iq|/:|zK{l&}#u|myd{{M&v~nV};L|(g|I]ogddb0xsd7^V})$uQ{HzazsgxtsO^l}F>ZB]r|{7{j@cU^{{CbiYoHlng]f+nQ[bkTn/}<-d9q {KXadZYo+n|l[|lc}V2{[a{S4Zam~Za^`{HH{xx_SvF|ak=c^[v^7_rYT`ld@]:_ub%[$[m](Shu}G2{E.ZU_L_R{tz`vj(f?^}hswz}GdZ}{S:h`aD|?W|`dgG|if{a8|J1{N,}-Ao3{H#{mfsP|[ bzn+}_Q{MT{u4kHcj_q`eZj[8o0jy{p7}C|[}l){MuYY{|Ff!Ykn3{rT|m,^R|,R}$~Ykgx{P!]>iXh6[l[/}Jgcg{JYZ.^qYfYIZl[gZ#Xj[Pc7YyZD^+Yt;4;`e8YyZVbQ7YzZxXja.7SYl[s]2^/Ha$[6ZGYrb%XiYdf2]H]kZkZ*ZQ[ZYS^HZXcCc%Z|[(bVZ]]:OJQ_DZCg<[,]%Zaa [g{C00HY[c%[ChyZ,Z_`PbXa+eh`^&jPi0a[ggvhlekL]w{Yp^v}[e{~;k%a&k^|nR_z_Qng}[E}*Wq:{k^{FJZpXRhmh3^p>de^=_7`|ZbaAZtdhZ?n4ZL]u`9ZNc3g%[6b=e.ZVfC[ZZ^^^hD{E(9c(kyZ=bb|Sq{k`|vmr>izlH[u|e`}49}Y%}FT{[z{Rk}Bz{TCc/lMiAqkf(m$hDc;qooi[}^o:c^|Qm}a_{mrZ(pA`,}<2sY| adf_%|}`}Y5U;}/4|D>|$X{jw{C<|F.hK|*A{MRZ8Zsm?imZm_?brYWZrYx`yVZc3a@f?aK^ojEd {bN}/3ZH]/$YZhm^&j 9|(S|b]mF}UI{q&aM]LcrZ5^.|[j`T_V_Gak}9J[ ZCZD|^h{N9{~&[6Zd{}B}2O|cv]K}3s}Uy|l,fihW{EG`j_QOp~Z$F^zexS`dcISfhZBXP|.vn|_HYQ|)9|cr]<`&Z6]m_(ZhPcSg>`Z]5`~1`0Xcb4k1{O!bz|CN_T{LR|a/gFcD|j<{Z._[f)mPc:1`WtIaT1cgYkZOaVZOYFrEe[}T$}Ch}mk{K-^@]fH{Hdi`c*Z&|Kt{if[C{Q;{xYB`dYIX:ZB[}]*[{{p9|4GYRh2ao{DS|V+[zd$`F[ZXKadb*A] Ys]Maif~a/Z2bmclb8{Jro_rz|x9cHojbZ{GzZx_)]:{wAayeDlx}<=`g{H1{l#}9i|)=|lP{Qq}.({La|!Y{i2EZfp=c*}Cc{EDvVB|;g}2t{W4av^Bn=]ri,|y?|3+}T*ckZ*{Ffr5e%|sB{lx^0]eZb]9[SgAjS_D|uHZx]dive[c.YPkcq/}db{EQh&hQ|eg}G!ljil|BO]X{Qr_GkGl~YiYWu=c3eb}29v3|D|}4i||.{Mv})V{SP1{FX}CZW6{cm|vO{pS|e#}A~|1i}81|Mw}es|5[}3w{C`h9aL]o{}p[G`>i%a1Z@`Ln2bD[$_h`}ZOjhdTrH{[j_:k~kv[Sdu]CtL}41{I |[[{]Zp$]XjxjHt_eThoa#h>sSt8|gK|TVi[Y{t=}Bs|b7Zpr%{gt|Yo{CS[/{iteva|cf^hgn}($_c^wmb^Wm+|55jrbF|{9^ q6{C&c+ZKdJkq_xOYqZYSYXYl`8]-cxZAq/b%b*_Vsa[/Ybjac/OaGZ4fza|a)gY{P?| I|Y |,pi1n7}9bm9ad|=d{aV|2@[(}B`d&|Uz}B}{`q|/H|!JkM{FU|CB|.{}Az}#P|lk}K{|2rk7{^8^?`/|k>|Ka{Sq}Gz}io{DxZh[yK_#}9<{TRdgc]`~Z>JYmYJ]|`!ZKZ]gUcx|^E[rZCd`f9oQ[NcD_$ZlZ;Zr}mX|=!|$6ZPZYtIo%fj}CpcN|B,{VDw~gb}@hZg`Q{LcmA[(bo`<|@$|o1|Ss}9Z_}tC|G`{F/|9nd}i=}V-{L8aaeST]daRbujh^xlpq8|}zs4bj[S`J|]?G{P#{rD{]I`OlH{Hm]VYuSYUbRc*6[j`8]pZ[bt_/^Jc*[<Z?YE|Xb|?_Z^Vcas]h{t9|Uwd)_(=0^6Zb{Nc} E[qZAeX[a]P^|_J>e8`W^j_Y}R{{Jp__]Ee#e:iWb9q_wKbujrbR}CY`,{mJ}gz{Q^{t~N|? gSga`V_||:#mi}3t|/I`X{N*|ct|2g{km}gi|{={jC}F;|E}{ZZjYf*frmu}8Tdroi{T[|+~}HG{cJ}DM{Lp{Ctd&}$hi3|FZ| m}Kr|38}^c|m_|Tr{Qv|36}?Up>|;S{DV{k_as}BK{P}}9p|t`jR{sAm4{D=b4pWa[}Xi{EjwEkI}3S|E?u=X0{jf} S|NM|JC{qo^3cm]-|JUx/{Cj{s>{Crt[UXuv|D~|j|d{YXZR}Aq}0r}(_{pJfi_z}0b|-vi)Z mFe,{f4|q`b{}^Z{HM{rbeHZ|^x_o|XM|L%|uFXm}@C_{{Hhp%a7|0p[Xp+^K}9U{bP}: tT}B|}+$|b2|[^|~h{FAby[`{}xgygrt~h1[li`c4vz|,7p~b(|mviN}^pg[{N/|g3|^0c,gE|f%|7N{q[|tc|TKA{LU}I@|AZp(}G-sz{F |qZ{}F|f-}RGn6{Z]_5})B}UJ{FFb2]4ZI@v=k,]t_Dg5Bj]Z-]L]vrpdvdGlk|gF}G]|IW}Y0[G| /bo|Te^,_B}#n^^{QHYI[?hxg{[`]D^IYRYTb&kJ[cri[g_9]Ud~^_]<p@_e_XdNm-^/|5)|h_{J;{kacVopf!q;asqd}n)|.m|bf{QW|U)}b+{tL|w``N|to{t ZO|T]jF}CB|0Q{e5Zw|k |We}5:{HO{tPwf_uajjBfX}-V_C_{{r~gg|Ude;s+}KNXH}! `K}eW{Upwbk%ogaW}9EYN}YY|&v|SL{C3[5s.]Y]I]u{M6{pYZ`^,`ZbCYR[1mNg>rsk0Ym[jrE]RYiZTr*YJ{Ge|%-lf|y(`=[t}E6{k!|3)}Zk} ][G{E~cF{u3U.rJ|a9p#o#ZE|?|{sYc#vv{E=|LC}cu{N8`/`3`9rt[4|He{cq|iSYxY`}V |(Q|t4{C?]k_Vlvk)BZ^r<{CL}#h}R+[<|i=}X|{KAo]|W<`K{NW|Zx}#;|fe{IMr<|K~tJ_x}AyLZ?{GvbLnRgN}X&{H7|x~}Jm{]-| GpNu0}.ok>|c4{PYisrDZ|fwh9|hfo@{H~XSbO]Odv]%`N]b1Y]]|eIZ}_-ZA]aj,>eFn+j[aQ_+]h[J_m_g]%_wf.`%k1e#Z?{CvYu_B^|gk`Xfh^M3`afGZ-Z|[m{L}|k3cp[it ^>YUi~d>{T*}YJ{Q5{Jxa$hg|%4`}|LAgvb }G}{P=|<;Ux{_skR{cV|-*|s-{Mp|XP|$G|_J}c6cM{_=_D|*9^$ec{V;|4S{qO|w_|.7}d0|/D}e}|0G{Dq]Kdp{}dfDi>}B%{Gd|nl}lf{C-{y}|ANZr}#={T~|-(}c&{pI|ft{lsVP}){|@u}!W|bcmB{d?|iW|:dxj{PSkO|Hl]Li:}VYk@|2={fnWt{M3`cZ6|)}|Xj}BYa?vo{e4|L7|B7{L7|1W|lvYO}W8nJ|$Vih|{T{d*_1|:-n2dblk``fT{Ky|-%}m!|Xy|-a{Pz}[l{kFjz|iH}9N{WE{x,|jz}R {P|{D)c=nX|Kq|si}Ge{sh|[X{RF{t`|jsr*fYf,rK|/9}$}}Nf{y!1|<Std}4Wez{W${Fd_/^O[ooqaw_z[L`Nbv[;l7V[ii3_PeM}.h^viqYjZ*j1}+3{bt{DR[;UG}3Og,rS{JO{qw{d<_zbAh<R[1_r`iZTbv^^a}c{iEgQZ<exZFg.^Rb+`Uj{a+{z<[~r!]`[[|rZYR|?F|qppp]L|-d|}K}YZUM|=Y|ktm*}F]{D;g{uI|7kg^}%?Z%ca{N[_<q4xC]i|PqZC]n}.bDrnh0Wq{tr|OMn6tM|!6|T`{O`|>!]ji+]_bTeU}Tq|ds}n|{Gm{z,f)}&s{DPYJ`%{CGd5v4tvb*hUh~bf]z`jajiFqAii]bfy^U{Or|m+{I)cS|.9k:e3`^|xN}@Dnlis`B|Qo{`W|>||kA}Y}{ERYuYx`%[exd`]|OyiHtb}HofUYbFo![5|+]gD{NIZR|Go}.T{rh^4]S|C9_}xO^i`vfQ}C)bK{TL}cQ|79iu}9a];sj{P.o!f[Y]pM``Jda^Wc9ZarteBZClxtM{LW}l9|a.mU}KX}4@{I+f1}37|8u}9c|v${xGlz}jP{Dd1}e:}31}%3X$|22i<v+r@~mf{sN{C67G97855F4YL5}8f{DT|xy{sO{DXB334@55J1)4.G9A#JDYtXTYM4, YQD9;XbXm9SX]IB^4UN=Xn<5(;(F3YW@XkH-X_VM[DYM:5XP!T&Y`6|,^{IS-*D.H>:LXjYQ0I3XhAF:9:(==.F*3F1189K/7163D,:@|e2{LS36D4hq{Lw/84443@4.933:0307::6D7}&l{Mx657;89;,K5678H&93D(H<&<>0B90X^I;}Ag1{P%3A+>><975}[S{PZE453?4|T2{Q+5187;>447:81{C=hL6{Me^:=7ii{R=.=F<81;48?|h8}Uh{SE|,VxL{ST,7?9Y_5Xk3A#:$%YSYdXeKXOD8+TXh7(@>(YdXYHXl9J6X_5IXaL0N?3YK7Xh!1?XgYz9YEXhXaYPXhC3X`-YLY_XfVf[EGXZ5L8BXL9YHX]SYTXjLXdJ: YcXbQXg1PX]Yx4|Jr{Ys4.8YU+XIY`0N,<H%-H;:0@,74/:8546I=9177154870UC]d<C3HXl7ALYzXFXWP<<?E!88E5@03YYXJ?YJ@6YxX-YdXhYG|9o{`iXjY_>YVXe>AYFX[/(I@0841?):-B=14337:8=|14{c&93788|di{cW-0>0<097/A;N{FqYpugAFT%X/Yo3Yn,#=XlCYHYNX[Xk3YN:YRT4?)-YH%A5XlYF3C1=NWyY}>:74-C673<69545v {iT85YED=64=.F4..9878/D4378?48B3:7:7/1VX[f4{D,{l<5E75{dAbRB-8-@+;DBF/$ZfW8S<4YhXA.(5@*11YV8./S95C/0R-A4AXQYI7?68167B95HA1*<M3?1/@;/=54XbYP36}lc{qzSS38:19?,/39193574/66878Yw1X-87E6=;964X`T734:>86>1/=0;(I-1::7ALYGXhF+Xk[@W%TYbX7)KXdYEXi,H-XhYMRXfYK?XgXj.9HX_SX]YL1XmYJ>Y}WwIXiI-3-GXcYyXUYJ$X`Vs[7;XnYEZ;XF! 3;%8;PXX(N3Y[)Xi1YE&/ :;74YQ6X`33C;-(>Xm0(TYF/!YGXg8 9L5P01YPXO-5%C|qd{{/K/E6,=0144:361:955;6443@?B7*7:F89&F35YaX-CYf,XiFYRXE_e{}sF 0*7XRYPYfXa5YXXY8Xf8Y~XmA[9VjYj*#YMXIYOXk,HHX40YxYMXU8OXe;YFXLYuPXP?EB[QV0CXfY{:9XV[FWE0D6X^YVP*$4%OXiYQ(|xp|%c3{}V`1>Y`XH00:8/M6XhQ1:;3414|TE|&o@1*=81G8<3}6<|(f6>>>5-5:8;093B^3U*+*^*UT30XgYU&7*O1953)5@E78--F7YF*B&0:%P68W9Zn5974J9::3}Vk|-,C)=)1AJ4+<3YGXfY[XQXmT1M-XcYTYZXCYZXEYXXMYN,17>XIG*SaS|/eYJXbI?XdNZ+WRYP<F:R PXf;0Xg`$|1GX9YdXjLYxWX!ZIXGYaXNYm6X9YMX?9EXmZ&XZ#XQ>YeXRXfAY[4 ;0X!Zz0XdN$XhYL XIY^XGNXUYS/1YFXhYk.TXn4DXjB{jg|4DEX]:XcZMW=A.+QYL<LKXc[vV$+&PX*Z3XMYIXUQ:ZvW< YSXFZ,XBYeXMM)?Xa XiZ4/EXcP3%}&-|6~:1(-+YT$@XIYRBC<}&,|7aJ6}bp|8)K1|Xg|8C}[T|8Q.89;-964I38361<=/;883651467<7:>?1:.}le|:Z=39;1Y^)?:J=?XfLXbXi=Q0YVYOXaXiLXmJXO5?.SFXiCYW}-;|=u&D-X`N0X^,YzYRXO(QX_YW9`I|>hZ:N&X)DQXP@YH#XmNXi$YWX^=!G6YbYdX>XjY|XlX^XdYkX>YnXUXPYF)FXT[EVTMYmYJXmYSXmNXi#GXmT3X8HOX[ZiXN]IU2>8YdX1YbX<YfWuZ8XSXcZU%0;1XnXkZ_WTG,XZYX5YSX Yp 05G?XcYW(IXg6K/XlYP4XnI @XnO1W4Zp-9C@%QDYX+OYeX9>--YSXkD.YR%Q/Yo YUX].Xi<HYEZ2WdCE6YMXa7F)=,D>-@9/8@5=?7164;35387?N<618=6>7D+C50<6B03J0{Hj|N9$D,9I-,.KB3}m |NzE0::/81YqXjMXl7YG; [.W=Z0X4XQY]:MXiR,XgM?9$9>:?E;YE77VS[Y564760391?14941:0=:8B:;/1DXjFA-564=0B3XlH1+D85:0Q!B#:-6&N/:9<-R3/7Xn<*3J4.H:+334B.=>30H.;3833/76464665755:/83H6633:=;.>5645}&E|Y)?1/YG-,93&N3AE@5 <L1-G/8A0D858/30>8<549=@B8] V0[uVQYlXeD(P#ID&7T&7;Xi0;7T-$YE)E=1:E1GR):--0YI7=E<}n9|aT6783A>D7&4YG7=391W;Zx<5+>F#J39}o/|cc;6=A050EQXg8A1-}D-|d^5548083563695D?-.YOXd37I$@LYLWeYlX<Yd+YR A$;3-4YQ-9XmA0!9/XLY_YT(=5XdDI>YJ5XP1ZAW{9>X_6R(XhYO65&J%DA)C-!B:97#A9;@?F;&;(9=11/=657/H,<8}bz|j^5446>.L+&Y^8Xb6?(CYOXb*YF(8X`FYR(XPYVXmPQ%&DD(XmZXW??YOXZXfCYJ79,O)XnYF7K0!QXmXi4IYFRXS,6<%-:YO(+:-3Q!1E1:W,Zo}Am|n~;3580534*?3Zc4=9334361693:30C<6/717:<1/;>59&:4}6!|rS36=1?75<8}[B|s809983579I.A.>84758=108564741H*9E{L{|u%YQ<%6XfH.YUXe4YL@,>N}Tv|ve*G0X)Z;/)3@A74(4P&A1X:YVH97;,754*A66:1 D739E3553545558E4?-?K17/770843XAYf838A7K%N!YW4.$T19Z`WJ*0XdYJXTYOXNZ 1XaN1A+I&Xi.Xk3Z3GB&5%WhZ1+5#Y[X<4YMXhQYoQXVXbYQ8XSYUX4YXBXWDMG0WxZA[8V+Z8X;D],Va$%YeX?FXfX[XeYf<X:Z[WsYz8X_Y]%XmQ(!7BXIZFX]&YE3F$(1XgYgYE& +[+W!<YMYFXc;+PXCYI9YrWxGXY9DY[!GXiI7::)OC;*$.>N*HA@{C|}&k=:<TB83X`3YL+G4XiK]i}(fYK<=5$.FYE%4*5*H*6XkCYL=*6Xi6!Yi1KXR4YHXbC8Xj,B9ZbWx/XbYON#5B}Ue}+QKXnF1&YV5XmYQ0!*3IXBYb71?1B75XmF;0B976;H/RXU:YZX;BG-NXj;XjI>A#D3B636N;,*%<D:0;YRXY973H5)-4FXOYf0:0;/7759774;7;:/855:543L43<?6=E,.A4:C=L)%4YV!1(YE/4YF+ F3%;S;&JC:%/?YEXJ4GXf/YS-EXEYW,9;E}X$}547EXiK=51-?71C%?57;5>463553Zg90;6447?<>4:9.7538XgN{|!}9K/E&3-:D+YE1)YE/3;37/:05}n<}:UX8Yj4Yt864@JYK..G=.(A Q3%6K>3(P3#AYE$-6H/456*C=.XHY[#S.<780191;057C)=6HXj?955B:K1 E>-B/9,;5.!L?:0>/.@//:;7833YZ56<4:YE=/:7Z_WGC%3I6>XkC*&NA16X=Yz2$X:Y^&J48<99k8}CyB-61<18K946YO4{|N}E)YIB9K0L>4=46<1K0+R;6-=1883:478;4,S+3YJX`GJXh.Yp+Xm6MXcYpX(>7Yo,/:X=Z;Xi0YTYHXjYmXiXj;*;I-8S6N#XgY}.3XfYGO3C/$XjL$*NYX,1 6;YH&<XkK9C#I74.>}Hd`A748X[T450[n75<4439:18A107>|ET}Rf<1;14876/Yb983E<5.YNXd4149>,S=/4E/<306443G/06}0&}UkYSXFYF=44=-5095=88;63844,9E6644{PL}WA8:>)7+>763>>0/B3A545CCnT}Xm|dv}Xq1L/YNXk/H8;;.R63351YY747@15YE4J8;46;.38.>4A369.=-83,;Ye3?:3@YE.4-+N353;/;@(X[YYD>@/05-I*@.:551741Yf5>6A443<3535;.58/86=D4753442$635D1>0359NQ @73:3:>><Xn?;43C14 ?Y|X611YG1&<+,4<*,YLXl<1/AIXjF*N89A4Z576K1XbJ5YF.ZOWN.YGXO/YQ01:4G38Xl1;KI0YFXB=R<7;D/,/4>;$I,YGXm94@O35Yz66695385.>:6A#5}W7n^4336:4157597434433<3|XA}m`>=D>:4A.337370?-6Q96{`E|4A}C`|Qs{Mk|J+~r>|o,wHv>Vw}!c{H!|Gb|*Ca5}J||,U{t+{CN[!M65YXOY_*B,Y[Z9XaX[QYJYLXPYuZ%XcZ8LY[SYPYKZM<LMYG9OYqSQYM~[e{UJXmQYyZM_)>YjN1~[f3{aXFY|Yk:48YdH^NZ0|T){jVFYTZNFY^YTYN~[h{nPYMYn3I]`EYUYsYIZEYJ7Yw)YnXPQYH+Z.ZAZY]^Z1Y`YSZFZyGYHXLYG 8Yd#4~[i|+)YH9D?Y^F~Y7|-eYxZ^WHYdYfZQ~[j|3>~[k|3oYmYqY^XYYO=Z*4[]Z/OYLXhZ1YLZIXgYIHYEYK,<Y`YEXIGZI[3YOYcB4SZ!YHZ*&Y{Xi3~[l|JSY`Zz?Z,~[m|O=Yi>??XnYWXmYS617YVYIHZ(Z4[~L4/=~[n|Yu{P)|];YOHHZ}~[o33|a>~[r|aE]DH~[s|e$Zz~[t|kZFY~XhYXZB[`Y}~[u|{SZ&OYkYQYuZ2Zf8D~[v}% ~[w3},Q[X]+YGYeYPIS~[y}4aZ!YN^!6PZ*~[z}?E~[{3}CnZ=~[}}EdDZz/9A3(3S<,YR8.D=*XgYPYcXN3Z5 4)~[~}JW=$Yu.XX~] }KDX`PXdZ4XfYpTJLY[F5]X~[2Yp}U+DZJ::<446[m@~]#3}]1~]%}^LZwZQ5Z`/OT<Yh^ -~]&}jx[ ~m<z!%2+~ly4VY-~o>}p62yz!%2+Xf2+~ly4VY-zQ`z (=] 2z~o2",C={" ":0,"!":1},c=34,i=2,p,s="",u=String.fromCharCode,t=u(12539);while(++c<127)C[u(c)]=c^39&&c^92?i++:0;i=0;while(0<=(c=C[a.charAt(i++)]))if(16==c)if((c=C[a.charAt(i++)])<87){if(86==c)c=1879;while(c--)s+=u(++p)}else s+=s.substr(8272,360);else if(c<86)s+=u(p+=c<51?c-16:(c-55)*92+C[a.charAt(i++)]);else if((c=((c-86)*92+C[a.charAt(i++)])*92+C[a.charAt(i++)])<49152)s+=u(p=c<40960?c:c|57344);else{c&=511;while(c--)s+=t;p=12539}return s')();
const JCT8836 = JCT11280.substring(0, 8836);

/*global Buffer*/

/**
 * BinaryReader class
 * @access public
 */

class _BinaryReader {
  /**
   * constructor
   * @param {Buffer|ArrayBuffer} data - 
   * @param {boolean} bigEndian -
   * @param {string} encoding -
   * @constructor
   */
  constructor(data, bigEndian = false, encoding = '') {
    /**
     * @access private
     * @type {number}
     */
    this._pos = 0;
    /**
     * @access private
     * @type {boolean}
     */

    this._eof = true;
    /**
     *
     * @access public
     * @type {Buffer}
     */

    this.buffer = null;

    if (data instanceof Buffer) {
      this.buffer = data;
    } else if (typeof data === 'string') {
      this.buffer = Buffer.from(data, 'binary');
    } else {
      this.buffer = Buffer.from(data);
    }
    /**
     *
     * @access public
     * @type {boolean}
     */


    this.bigEndian = bigEndian;
    /**
     *
     * @access public
     * @type {string}
     */

    this.encoding = encoding;
  }
  /**
   * @access public
   * @param {number} length - length of data to skip
   * @param {boolean} noAssert -
   * @returns {void}
   */


  skip(length, noAssert = false) {
    this._pos += length;

    if (!noAssert) {
      this._check();
    }
  }
  /**
   * @access public
   * @param {number} pos -
   * @returns {void}
   */


  seek(pos) {
    if (pos < 0) {
      this._pos = this.buffer.length + pos;
    } else {
      this._pos = pos;
    }

    if (this._pos < 0) {
      this._pos = 0;
    } else if (this._pos > this.buffer.length) {
      this._pos = this.buffer.length;
    }
  }
  /**
   *
   * @access public
   * @param {number} length - length of data to read
   * @param {?string} [encoding = null] -
   * @returns {string} -
   */


  readString(length, encoding = null) {
    const start = this._pos;
    this._pos += length;

    const _encoding = encoding || this.encoding || 'sjis'; //if(_Buffer.isEncoding(_encoding)){


    if (Buffer.isEncoding(_encoding)) {
      return this.buffer.toString(_encoding, start, this._pos);
    }

    const data = this.buffer.toString('binary', start, this._pos);
    return this._convert(data, _encoding);
  }
  /**
   *
   * @access public
   * @param {number} length - 
   * @param {boolean} signed -
   * @returns {number} -
   */


  readInteger(length, signed) {
    const start = this._pos;
    this._pos += length; // big endian

    if (this.bigEndian) {
      if (signed) {
        return this.buffer.readIntBE(start, length);
      }

      return this.buffer.readUIntBE(start, length);
    } // little endian


    if (signed) {
      return this.buffer.readIntLE(start, length);
    }

    return this.buffer.readUIntLE(start, length);
  }
  /**
   *
   * @access public
   * @returns {number} -
   */


  readUnsignedByte() {
    return this.readInteger(1, false);
  }
  /**
   *
   * @access public
   * @returns {number} -
   */


  readUnsignedShort() {
    return this.readInteger(2, false);
  }
  /**
   *
   * @access public
   * @returns {number} -
   */


  readUnsignedInt() {
    return this.readInteger(4, false);
  }
  /**
   *
   * @access public
   * @returns {number} -
   */


  readUnsignedLongLong() {
    return this.readInteger(8, false);
  }
  /**
   *
   * @access public
   * @returns {number} -
   */


  readByte() {
    return this.readInteger(1, true);
  }
  /**
   *
   * @access public
   * @returns {number} -
   */


  readShort() {
    return this.readInteger(2, true);
  }
  /**
   *
   * @access public
   * @returns {number} -
   */


  readInt() {
    return this.readInteger(4, true);
  }
  /**
   *
   * @access public
   * @returns {number} -
   */


  readLongLong() {
    return this.readInteger(8, true);
  }
  /**
   *
   * @access public
   * @returns {number} -
   */


  readFloat() {
    const start = this._pos;
    this._pos += 4;

    if (this.bigEndian) {
      return this.buffer.readFloatBE(start);
    }

    return this.buffer.readFloatLE(start);
  }
  /**
   *
   * @access public
   * @returns {number} -
   */


  readDouble() {
    const start = this._pos;
    this._pos += 8;

    if (this.bigEndian) {
      return this.buffer.readDoubleBE(start);
    }

    return this.buffer.readDoubleLE(start);
  }
  /**
   *
   * @access public
   * @param {number} length -
   * @returns {Buffer} -
   */


  readData(length) {
    const start = this._pos;
    this._pos += length;
    return this.buffer.slice(start, this._pos);
  }
  /**
   *
   * @access private
   * @returns {void}
   */


  _check() {
    if (this._pos >= this.buffer.length) {
      throw new Error(`_BinaryReader: buffer out of range (${this._pos} >= ${this.buffer.length})`);
    }
  }
  /**
   * 
   * @access private
   * @param {number[]} data - data to escape
   * @param {?string} [encoding = null] -
   * @returns {string} - escaped string
   */


  _escapeLE(data, encoding) {
    const length = data.length;
    let escapeString = '';

    for (let i = 0; i < length; i++) {
      const charCode = data.charCodeAt(i);

      if (charCode === 0) {
        break;
      } else if (charCode < 16) {
        escapeString += '%0' + charCode.toString(16);
      } else {
        escapeString += '%' + charCode.toString(16);
      }
    }

    return escapeString;
  }
  /**
   * 
   * @access private
   * @param {number[]} data - data to escape
   * @param {?string} [encoding = null] -
   * @returns {string} - escaped string
   */


  _escapeBE(data, encoding) {
    const length = data.length;
    let escapeString = '';

    for (let i = 0; i < length; i++) {
      const charCode1 = data.charCodeAt(i);

      if (charCode1 === 0) {
        break;
      }

      let str1 = '';

      if (charCode1 < 16) {
        str1 = '%0' + charCode1.toString(16);
      } else {
        str1 = '%' + charCode1.toString(16);
      }

      i++;
      const charCode2 = data.charCodeAt(i);

      if (charCode2 === 0) {
        break;
      }

      let str2 = '';

      if (charCode2 < 16) {
        str2 = '%0' + charCode2.toString(16);
      } else {
        str2 = '%' + charCode2.toString(16);
      }

      escapeString += str1 + str2;
    }

    return escapeString;
  }
  /**
   *
   * @access private
   * @param {number[]} data - length of data to convert
   * @param {?string} [encoding = null] -
   * @returns {string} -
   */


  _convert(data, encoding) {
    let escapeString = '';

    if (encoding === 'utf16be') {
      escapeString = this._escapeBE(data);
    } else {
      escapeString = this._escapeLE(data);
    }

    if (encoding === 'sjis') {
      return UnescapeSJIS(escapeString);
    } else if (encoding === 'euc-jp') {
      return UnescapeEUCJP(escapeString);
    } else if (encoding === 'jis-7') {
      return UnescapeJIS7(escapeString);
    } else if (encoding === 'jis-8') {
      return UnescapeJIS8(escapeString);
    } else if (encoding === 'unicode') {
      return UnescapeUnicode(escapeString);
    } else if (encoding === 'utf7') {
      return UnescapeUTF7(escapeString);
    } else if (encoding === 'utf-8') {
      return UnescapeUTF8(escapeString);
    } else if (encoding === 'utf-16') {
      return UnescapeUTF16LE(escapeString);
    } else if (encoding === 'utf16be') {
      return UnescapeUTF16LE(escapeString);
    }

    throw new Error(`unsupported encoding: ${encoding}`);
  }

  getAvailableDataLength() {
    return this.buffer.length - this._pos;
  }

  get length() {
    return this.buffer.length;
  }

}

/*global Buffer*/

const _classForKey = new Map();

const _loadingSymbol = Symbol('loading');

class _UID {
  constructor(unarchiver, value) {
    this._unarchiver = unarchiver;
    this._value = value;
  }

  get value() {
    return this._value;
  }

  get obj() {
    return this._unarchiver._parsedObj.$objects[this._value];
  }

}
/**
 * NSKeyedUnarchiver, a concrete subclass of NSCoder, defines methods for decoding a set of named objects (and scalar values) from a keyed archive. Such archives are produced by instances of the NSKeyedArchiver class.
 * @access public
 * @extends {NSCoder}
 * @see https://developer.apple.com/documentation/foundation/nskeyedunarchiver
 */


class NSKeyedUnarchiver extends NSCoder {
  // Initializing a Keyed Unarchiver

  /**
   * Initializes the receiver for decoding an archive previously encoded by NSKeyedArchiver.
   * @access public
   * @constructor
   * @param {Data} data - An archive previously encoded by NSKeyedArchiver.
   * @desc When you finish decoding data, you should invoke finishDecoding(). This method throws an exception if data is not a valid archive.
   * @see https://developer.apple.com/documentation/foundation/nskeyedunarchiver/1410862-init
   */
  constructor(data = null, options = new Map()) {
    super(); // Unarchiving Data

    /**
     * Indicates whether the receiver requires all unarchived classes to conform to NSSecureCoding.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/foundation/nskeyedunarchiver/1410824-requiressecurecoding
     */

    this._requiresSecureCoding = false; // Managing the Delegate

    /**
     * The receiver’s delegate.
     * @type {?NSKeyedUnarchiverDelegate}
     * @see https://developer.apple.com/documentation/foundation/nskeyedunarchiver/1415688-delegate
     */

    this.delegate = null; // Instance Properties

    /**
     * 
     * @type {NSCoder.DecodingFailurePolicy}
     * @see https://developer.apple.com/documentation/foundation/nskeyedunarchiver/1643164-decodingfailurepolicy
     */

    this._decodingFailurePolicy = null;
    /**
     * @access private
     * @type {?_BinaryReader}
     */

    this._reader = null;
    /**
     * @access private
     * @type {number}
     */

    this._offsetSize = 0;
    /**
     * @access private
     * @type {number}
     */

    this._objCount = 0;
    /**
     * @access private
     * @type {Object[]}
     */

    this._offsetArray = [];
    /**
     * @access private
     * @type {Object}
     */

    this._parsedObj = {};
    /**
     * @access private
     * @type {Object[]}
     */

    this._dataObj = [];
    this._resolveFunctions = [];
    /**
     * @access private
     * @type {string}
     */

    this._filePath = null;
    /**
     * @access private
     * @type {?Object}
     */

    this._refObj = null;
    /**
     * @access private
     * @type {boolean}
     */

    this._decodingFinished = false;
    this._options = options;
    this._promises = [];

    if (data !== null) {
      this._reader = new _BinaryReader(data, true, 'utf8');

      this._checkHeader();

      this._parsedObj = this._parseBPlist();
    }
  }

  copy() {
    const coder = new NSKeyedUnarchiver();
    coder._requiresSecureCoding = this._requiresSecureCoding;
    coder.delegate = this.delegate;
    coder._decodingFailurePolicy = this._decodingFailurePolicy;
    coder._reader = this._reader;
    coder._offsetSize = this._offsetSize;
    coder._objCount = this._objCount;
    coder._offsetArray = this._offsetArray;
    coder._parsedObj = this._parsedObj;
    coder._dataObj = this._dataObj;
    coder._resolveFunctions = this._resolveFunctions;
    coder._filePath = this._filePath;
    coder._refObj = this._refObj;
    coder._decodingFinished = this._decodingFinished;
    return coder;
  } // Unarchiving Data

  /**
   * Decodes and returns the object graph previously encoded by NSKeyedArchiver and stored in a given NSData object.
   * @access public
   * @param {Buffer} data - An object graph previously encoded by NSKeyedArchiver.
   * @param {?string} path - 
   * @returns {?Object} - 
   * @desc This method raises an invalidArchiveOperationException if data is not a valid archive.
   * @see https://developer.apple.com/documentation/foundation/nskeyedunarchiver/1413894-unarchiveobject
   */


  static unarchiveObjectWithData(data, path = null, options = new Map()) {
    const unarchiver = new NSKeyedUnarchiver(data, options);
    unarchiver._filePath = path;
    const topObjIndex = unarchiver._parsedObj.$top.root.value;
    return unarchiver._parseClassAt(topObjIndex);
  }

  _checkHeader() {
    this._reader.seek(0);

    const header = this._reader.readString(8);

    if (header !== 'bplist00') {
      throw new Error(`unsupported file format: ${header}`);
    }
  }

  static _getBufferOfFile(path, options) {
    // TODO: use 'await' to return Buffer instead of Promise
    const promise = new Promise((resolve, reject) => {
      const file = new File([], path);
      const reader = new FileReader();

      reader.onload = () => {
        const data = reader.result;
        resolve(data);
      };

      reader.onerror = () => {
        reject(reader.error);
      };

      reader.readAsBinaryString(file);
    });
    return promise;
  }

  _parseBPlist() {
    const reader = this._reader; // read basic info

    reader.seek(-26);
    const dataLen = reader.length;
    const intSize = reader.readUnsignedByte();
    this._offsetSize = reader.readUnsignedByte();
    this._objCount = reader.readUnsignedLongLong();
    const topIndex = reader.readUnsignedLongLong();
    const tablePos = reader.readUnsignedLongLong(); //console.log(`dataLen: ${dataLen}`)
    //console.log(`intSize: ${intSize}`)
    //console.log(`offsetSize: ${this._offsetSize}`)
    //console.log(`objCount: ${this._objCount}`)
    //console.log(`topIndex: ${topIndex}`)
    //console.log(`tablePos: ${tablePos}`)

    this._offsetArray = [];
    let pos = tablePos;
    reader.seek(pos);
    const objCount = this._objCount;

    for (let i = 0; i < objCount; i++) {
      const offset = reader.readInteger(intSize);

      this._offsetArray.push(offset);
    }

    return this._parseObjAtIndex(topIndex);
  }

  _parseObjAtIndex(index) {
    return this._parseObj(this._offsetArray[index]);
  }

  _parseObj(offset = null, signed = false) {
    const reader = this._reader;

    if (offset !== null) {
      reader.seek(offset);
    }

    const type = reader.readUnsignedByte();
    const type1 = type & 0xF0;
    const type2 = type & 0x0F; //console.log(`parseObj: type: ${type1} ${type2}`)

    if (type1 === 0x00) {
      // null, boolean
      if (type2 === 0) {
        //console.log('   type: null')
        return null;
      } else if (type2 === 8) {
        //console.log('   type: boolean')
        return false;
      } else if (type2 === 9) {
        //console.log('   type: boolean')
        return true;
      }
    } else if (type1 === 0x10) {
      // Int
      const len = Math.pow(2, type2); //console.log('   type: integer ' + len)

      return reader.readInteger(len, signed);
    } else if (type1 === 0x20) {
      // Float
      const len = Math.pow(2, type2);

      if (len === 4) {
        //console.log('   type: float')
        return reader.readFloat();
      } else if (len === 8) {
        //console.log('   type: double')
        return reader.readDouble();
      }

      throw new Error(`unsupported float size: ${len}`);
    } else if (type1 === 0x30) ; else if (type1 === 0x40) {
      // Data
      const count = this._getDataSize(type2); //console.log(`   type: Data: length: ${count}`)


      return reader.readData(count);
    } else if (type1 === 0x50) {
      // ASCII
      const count = this._getDataSize(type2); //console.log('   type: ascii ' + count)


      return reader.readString(count, 'ascii');
    } else if (type1 === 0x60) {
      // UTF-16
      const count = this._getDataSize(type2); //console.log('   type: UTF-16 ' + count)


      return reader.readString(count, 'utf16be'); // Big Endian might not be supported...
    } else if (type1 === 0x80) {
      // UID
      const uid = reader.readInteger(type2 + 1, false); //console.log('   type: UID: ' + uid)

      return new _UID(this, uid);
    } else if (type1 === 0xA0) {
      // Array
      const count = this._getDataSize(type2); //console.log('   type: array: ' + count)


      const arrIndex = [];

      for (let i = 0; i < count; i++) {
        arrIndex.push(reader.readInteger(this._offsetSize, false));
      }

      const arr = arrIndex.map(index => this._parseObjAtIndex(index)); //console.log(`***arr.length: ${arr.length}`)

      return arr;
    } else if (type1 === 0xC0) {
      // Set
      const count = this._getDataSize(type2);

      const setIndex = [];

      for (let i = 0; i < count; i++) {
        setIndex.push(reader.readInteger(this._offsetSize, false));
      }

      const arr = setIndex.map(index => this._parseObjAtIndex(index));
      return new Set(arr);
    } else if (type1 === 0xD0) {
      // Dictionary
      //console.log('   type: dictionary')
      const count = this._getDataSize(type2);

      const keyIndex = [];
      const valueIndex = [];

      for (let i = 0; i < count; i++) {
        keyIndex.push(reader.readInteger(this._offsetSize, false));
      }

      for (let i = 0; i < count; i++) {
        valueIndex.push(reader.readInteger(this._offsetSize, false));
      }

      const result = {};

      for (let i = 0; i < count; i++) {
        const key = this._parseObjAtIndex(keyIndex[i]); //console.log('key: ' + key)


        const val = this._parseObjAtIndex(valueIndex[i]); //console.log('val: ' + val)


        result[key] = val;
      }

      return result;
    }

    throw new Error(`unknown data type: ${type}`);
  }

  _getDataSize(type2) {
    let count = 0;

    if (type2 !== 0x0F) {
      count = type2;
    } else {
      count = this._parseObj(null, false);

      if (typeof count !== 'number') {
        throw new Error('data size must be int type');
      }
    }

    return count;
  }

  _parseClassAt(index) {
    const obj = this._parsedObj.$objects[index];

    if (this._dataObj[index] === _loadingSymbol) {
      // it seems to be a reference loop; return Promise
      return new Promise((resolve, reject) => {
        if (typeof this._resolveFunctions[index] === 'undefined') {
          this._resolveFunctions[index] = [];
        }

        this._resolveFunctions[index].push(resolve);
      });
    } else if (typeof this._dataObj[index] !== 'undefined') {
      return this._dataObj[index];
    }

    this._dataObj[index] = _loadingSymbol;

    const data = this._parseClass(obj);

    this._dataObj[index] = data;

    if (Array.isArray(this._resolveFunctions[index])) {
      this._resolveFunctions[index].forEach(resolve => {
        resolve(data);
      });

      delete this._resolveFunctions[index];
    }

    return data;
  }

  _parseClass(obj) {
    const className = obj.$class.obj.$classname; //console.log(`parseClass ${className}`)

    const classObj = NSKeyedUnarchiver.classForClassName(className);

    if (classObj) {
      const unarchiver = this.copy();
      unarchiver._refObj = obj;
      return classObj.initWithCoder(unarchiver);
    }

    return null;
  }
  /**
   * @access private
   * @param {Object} obj -
   * @param {Object} classObj -
   * @returns {Object} -
   */


  _parseStruct(obj, classObj) {
    if (typeof classObj._initWithData !== 'function') {
      throw new Error(`${classObj.prototype.constructor.name} class doesn't have _initWithData function`);
    }

    return classObj._initWithData(obj);
  }
  /**
   * Decodes and returns the object graph previously encoded by NSKeyedArchiver written to the file at a given path.
   * @access public
   * @param {string} path - A path to a file that contains an object graph previously encoded by NSKeyedArchiver.
   * @returns {Promise} - 
   * @desc This method raises an invalidArgumentException if the file at path does not contain a valid archive.
   * @see https://developer.apple.com/documentation/foundation/nskeyedunarchiver/1417153-unarchiveobject
   */


  static unarchiveObjectWithFile(path, options = new Map()) {
    const promise = NSKeyedUnarchiver._getBufferOfFile(path, options).then(data => {
      return NSKeyedUnarchiver.unarchiveObjectWithData(data, path, options);
    });

    return promise;
  } // Decoding Data

  /**
   * Returns a Boolean value that indicates whether the archive contains a value for a given key within the current decoding scope.
   * @access public
   * @param {string} key - A key in the archive within the current decoding scope. key must not be nil.
   * @returns {boolean} - 
   * @see https://developer.apple.com/documentation/foundation/nskeyedunarchiver/1413564-containsvalue
   */


  containsValueForKey(key) {
    return typeof this._refObj[key] !== 'undefined';
  }
  /**
   * Decodes a Boolean value associated with a given key.
   * @access public
   * @param {string} key - A key in the archive within the current decoding scope. key must not be nil.
   * @returns {boolean} - 
   * @see https://developer.apple.com/documentation/foundation/nskeyedunarchiver/1413260-decodebool
   */


  decodeBoolForKey(key) {
    if (this._decodingFinished) {
      throw new Error(`can't decode '${key}' after finishDecoding() is called`);
    }

    const value = this._getValueForKey(key);

    return Boolean(value);
  }
  /**
   * Decodes a stream of bytes associated with a given key.
   * @access public
   * @param {string} key - A key in the archive within the current decoding scope. key must not be nil.
   * @param {?UnsafeMutablePointer<Int>} lengthp - Upon return, contains the number of bytes returned.
   * @returns {?UnsafePointer<UInt8>} - 
   * @desc The returned value is a pointer to a temporary buffer owned by the receiver. The buffer goes away with the unarchiver, not the containing autorelease pool block. You must copy the bytes into your own buffer if you need the data to persist beyond the life of the receiver.
   * @see https://developer.apple.com/documentation/foundation/nskeyedunarchiver/1418091-decodebytes
   */


  decodeBytesForKeyReturnedLength(key, lengthp) {
    if (this._decodingFinished) {
      throw new Error(`can't decode '${key}' after finishDecoding() is called`);
    }

    return this._getValueForKey(key);
  }
  /**
   * Decodes a double-precision floating-point value associated with a given key.
   * @access public
   * @param {string} key - A key in the archive within the current decoding scope. key must not be nil.
   * @returns {number} - 
   * @desc If the archived value was encoded as single-precision, the type is coerced. 
   * @see https://developer.apple.com/documentation/foundation/nskeyedunarchiver/1414963-decodedouble
   */


  decodeDoubleForKey(key) {
    if (this._decodingFinished) {
      throw new Error(`can't decode '${key}' after finishDecoding() is called`);
    }

    return this._getValueForKey(key);
  }
  /**
   * Decodes a single-precision floating-point value associated with a given key.
   * @access public
   * @param {string} key - A key in the archive within the current decoding scope. key must not be nil.
   * @returns {number} - 
   * @desc If the archived value was encoded as double precision, the type is coerced, loosing precision. If the archived value is too large for single precision, the method raises an NSRangeException. 
   * @see https://developer.apple.com/documentation/foundation/nskeyedunarchiver/1412252-decodefloat
   */


  decodeFloatForKey(key) {
    if (this._decodingFinished) {
      throw new Error(`can't decode '${key}' after finishDecoding() is called`);
    }

    return this._getValueForKey(key);
  }
  /**
   * Decodes and returns an int value that was previously encoded with encodeCInt(_:forKey:), encode(_:forKey:), encode(_:forKey:), or encode(_:forKey:) and associated with the string key.
   * @access public
   * @param {string} key - 
   * @returns {number} - 
   * @desc If the encoded integer does not fit into the default integer size, the method raises an NSRangeException. Subclasses must override this method if they perform keyed coding.
   * @see https://developer.apple.com/documentation/foundation/nscoder/1411168-decodecint
   */


  decodeCIntForKey(key) {
    if (this._decodingFinished) {
      throw new Error(`can't decode '${key}' after finishDecoding() is called`);
    }

    return this._getValueForKey(key);
  }
  /**
   * Decodes a 32-bit integer value associated with a given key.
   * @access public
   * @param {string} key - A key in the archive within the current decoding scope. key must not be nil.
   * @returns {number} - 
   * @desc If the archived value was encoded with a different size but is still an integer, the type is coerced. If the archived value is too large to fit into a 32-bit integer, the method raises an NSRangeException. 
   * @see https://developer.apple.com/documentation/foundation/nskeyedunarchiver/1416327-decodeint32
   */


  decodeInt32ForKey(key) {
    if (this._decodingFinished) {
      throw new Error(`can't decode '${key}' after finishDecoding() is called`);
    }

    return this._getValueForKey(key);
  }
  /**
   * Decodes a 64-bit integer value associated with a given key.
   * @access public
   * @param {string} key - A key in the archive within the current decoding scope. key must not be nil.
   * @returns {Int64} - 
   * @desc If the archived value was encoded with a different size but is still an integer, the type is coerced. 
   * @see https://developer.apple.com/documentation/foundation/nskeyedunarchiver/1413288-decodeint64
   */


  decodeInt64ForKey(key) {
    if (this._decodingFinished) {
      throw new Error(`can't decode '${key}' after finishDecoding() is called`);
    }

    return this._getValueForKey(key);
  }
  /**
   * Decodes and returns an object associated with a given key.
   * @access public
   * @param {string} key - A key in the archive within the current decoding scope. key must not be nil.
   * @returns {?Object} - 
   * @see https://developer.apple.com/documentation/foundation/nskeyedunarchiver/1409082-decodeobject
   */


  decodeObjectForKey(key, options) {
    if (this._decodingFinished) {
      throw new Error(`can't decode '${key}' after finishDecoding() is called`);
    }

    const parsedObj = this._refObj[key];

    if (typeof parsedObj === 'string') {
      return parsedObj;
    } else if (parsedObj instanceof _UID) {
      const obj = parsedObj.obj;

      if (typeof obj.$class !== 'undefined') {
        return this._parseClassAt(parsedObj.value, options);
      }

      return obj;
    }

    throw new Error(`unknown data type for key ${key}: ${parsedObj}`);
  }
  /**
   * Returns a decoded property list for the specified key.
   * @access public
   * @param {string} key - The coder key.
   * @returns {?Object} - 
   * @desc This method calls decodeObjectOfClasses:forKey: with a set allowing only property list types.
   * @see https://developer.apple.com/documentation/foundation/nscoder/1416284-decodepropertylist
   */


  decodePropertyListForKey(key, options) {
    if (this._decodingFinished) {
      throw new Error(`can't decode '${key}' after finishDecoding() is called`);
    }

    const parsedObj = this.decodeObjectForKey(key, options); //console.log(`${key}: ${parsedObj.constructor.name}`)

    if (!(parsedObj instanceof Buffer)) {
      throw new Error(`propertylist of key ${key} is not Buffer data`);
    } //console.log(`***header: ${parsedObj.toString('ascii', 0, 8)}`)
    //console.log(`length: ${parsedObj.length}`)
    //for(let i=0; i<8; i++){
    //  console.log(`${i}: ${parsedObj.readUIntBE(i, 1)}`)
    //}


    return NSKeyedUnarchiver.unarchiveObjectWithData(parsedObj, this._filePath, options);
  }

  decodeObjectOfTypeForKey(type, key) {
    if (this._decodingFinished) {
      throw new Error(`can't decode '${key}' after finishDecoding() is called`);
    }

    const parsedObj = this._refObj[key];

    if (!(parsedObj instanceof Buffer)) {
      throw new Error(`value is not Buffer data for key: ${key}`);
    }

    return this._parseStruct(parsedObj, type);
  }

  get _fileName() {
    if (this._filePath === null) {
      return null;
    }

    const paths = this._filePath.split('/');

    const fileName = paths.pop();
    return fileName;
  }

  get _directoryPath() {
    if (this._filePath === null) {
      return null;
    }

    const paths = this._filePath.split('/');

    const fileName = paths.pop();
    const directoryPath = paths.join('/') + '/';
    return directoryPath;
  }
  /**
   * Tells the receiver that you are finished decoding objects.
   * @access public
   * @returns {void}
   * @desc Invoking this method allows the receiver to notify its delegate and to perform any final operations on the archive. Once this method is invoked, the receiver cannot decode any further values.
   * @see https://developer.apple.com/documentation/foundation/nskeyedunarchiver/1418233-finishdecoding
   */


  finishDecoding() {
    this._decodingFinished = true;
  } // Managing Class Names

  /**
   * Adds a class translation mapping to the receiver whereby objects encoded with a given class name are decoded as instances of a given class instead.
   * @access public
   * @param {?Object} cls - The class with which to replace instances of the class named codedName.
   * @param {string} codedName - 
   * @returns {void}
   * @desc When decoding, the receiver’s translation map overrides any translation that may also be present in the class’s map (see setClass(_:forClassName:)).
   * @see https://developer.apple.com/documentation/foundation/nskeyedunarchiver/1414659-setclass
   */


  static setClassForClassName(cls, codedName) {
    _classForKey.set(codedName, cls);
  }
  /**
   * Returns the class from which the receiver instantiates an encoded object with a given class name.
   * @access public
   * @param {string} codedName - 
   * @returns {?Object} - 
   * @desc The class’s separate translation map is not searched.
   * @see https://developer.apple.com/documentation/foundation/nskeyedunarchiver/1412476-class
   */


  static classForClassName(codedName) {
    const classObj = _classForKey.get(codedName);

    if (classObj) {
      return classObj;
    }

    return _ClassList.get(codedName);
  } // Type Methods

  /**
   * 
   * @access public
   * @param {NSData} data - 
   * @param {string} path -
   * @returns {void}
   * @throws {Error}
   * @see https://developer.apple.com/documentation/foundation/nskeyedunarchiver/1413622-unarchivetoplevelobjectwithdata
   */


  static unarchiveTopLevelObjectWithData(data, path = null, options = new Map()) {
    // what's different from unarchiveObjectWithData???
    return NSKeyedUnarchiver.unarchiveObjectWithData(data, path, options);
  }

  _getValueForKey(key) {
    const value = this._refObj[key];

    if (value instanceof _UID) {
      return value.obj;
    }

    return value;
  }

}

/**
 * dummy class for NSKeyedArchiver/Unarchiver
 * @access public
 * @extends {NSArray}
 */

class NSMutableArray extends NSArray {}

/**
 * dummy class for NSKeyedArchiver/Unarchiver
 * @access public
 * @extends {NSData}
 */

class NSMutableData extends NSData {}

/**
 * dummy class for NSKeyedArchiver/Unarchiver
 * @access public
 * @extends {NSDictionary}
 */

class NSMutableDictionary extends NSDictionary {}

/**
 * dummy class for NSURL
 * @access public
 * @extends {NSObject}
 */

class NSURL extends NSObject {
  /**
   * @access public
   * @param {NSCoder} coder -
   * @returns {string} -
   */
  static initWithCoder(coder) {
    const base = coder._refObj['NS.base'].obj;
    const relative = coder._refObj['NS.relative'].obj;
    let url = relative; // Should I add the base url?

    if (url.indexOf(':') < 0) {
      url = coder._directoryPath + url;
    }

    return url;
  }

}

//import SCNVector3 from '../SceneKit/SCNVector3'
//import SCNVector4 from '../SceneKit/SCNVector4'
//import SCNMatrix4 from '../SceneKit/SCNMatrix4'

const rectPattern = new RegExp(/^\{\{([-.0-9]+),\s*([-.0-9]+)\},\s*\{([-.0-9]+),\s*([-.0-9]+)\}\}$/);
/**
 * An NSValue object is a simple container for a single C or Objective-C data item. It can hold any of the scalar types such as int, float, and char, as well as pointers, structures, and object id references. Use this class to work with such data types in collections (such as NSArray and NSSet), Key-value coding, and other APIs that require Objective-C objects. NSValue objects are always immutable.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/foundation/nsvalue
 */

class NSValue extends NSObject {
  /**
   * @access public
   * @param {NSCoder} coder -
   * @returns {Object} -
   */
  static initWithCoder(coder) {
    //console.log('NSValue: ' + Object.keys(coder._refObj))
    const special = coder._refObj['NS.special'];
    const size = coder._refObj['NS.sizeval'];

    if (size) {
      const obj = size.obj;

      if (obj.charAt(0) !== '{' || obj.charAt(size.length - 1) !== '}') {
        throw new Error(`unknown NSValue size format: ${obj}`);
      }

      const values = obj.slice(1, -1).split(',').map(parseFloat);
      return new CGSize(values[0], values[1]);
    }

    const rect = coder._refObj['NS.rectval'];

    if (rect) {
      const obj = rect.obj;
      const value = obj.match(rectPattern);

      if (!value) {
        throw new Error(`unknown NSValue rect format: ${obj}`);
      }

      const values = value.slice(1, 5).map(parseFloat);
      const point = new CGPoint(values[0], values[1]);

      const _size = new CGSize(values[2], values[3]);

      return new CGRect(point, _size);
    }

    throw new Error('unknown NSValue type');
  } // Working with Raw Values

  /**
   * Initializes a value object to contain the specified value, interpreted with the specified Objective-C type.
   * @access public
   * @param {UnsafeRawPointer} value - A pointer to data to be stored in the new value object.
   * @param {UnsafePointer<Int8>} type - The Objective-C type of value, as provided by the @encode() compiler directive. Do not hard-code this parameter as a C string. 
   * @returns {void}
   * @desc See Number and Value Programming Topics for other considerations in creating a value object.This is the designated initializer for the NSValue class.
   * @see https://developer.apple.com/documentation/foundation/nsvalue/1411621-init
   */


  initBytesObjCType(value, type) {}
  /**
   * Creates a value object containing the specified value, interpreted with the specified Objective-C type.
   * @access public
   * @param {UnsafeRawPointer} value - A pointer to data to be stored in the new value object.
   * @param {UnsafePointer<Int8>} type - The Objective-C type of value, as provided by the @encode() compiler directive. Do not hard-code this parameter as a C string. 
   * @returns {void}
   * @desc This method has the same effect as valueWithBytes:objCType: and may be deprecated in a future release. You should use valueWithBytes:objCType: instead.
   * @see https://developer.apple.com/documentation/foundation/nsvalue/1417400-init
   */


  initWithObjCType(value, type) {}
  /**
   * Copies the value into the specified buffer.
   * @access public
   * @param {Object} value - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/foundation/nsvalue/1415141-getvalue
   */


  getValue(value) {}
  /**
   * A C string containing the Objective-C type of the data contained in the value object.
   * @type {UnsafePointer<Int8>}
   * @desc This property provides the same string produced by the @encode() compiler directive.
   * @see https://developer.apple.com/documentation/foundation/nsvalue/1412365-objctype
   */


  get objCType() {
    return this._objCType;
  } // Working with Pointer and Object Values

  /**
   * Creates a value object containing the specified pointer.
   * @access public
   * @constructor
   * @param {?UnsafeRawPointer} pointer - 
   * @desc This method is equivalent to invoking init(_:withObjCType:) in this manner:NSValue *theValue = [NSValue value:&aPointer withObjCType:@encode(void *)];
  This method does not copy the contents of aPointer, so you must not to free the memory at the pointer destination while the NSValue object exists. NSData objects may be more suited for arbitrary pointers than NSValue objects.NSValue *theValue = [NSValue value:&aPointer withObjCType:@encode(void *)];
    * @see https://developer.apple.com/documentation/foundation/nsvalue/1415975-init
   */


  constructor(pointer) {
    super(); // Working with Raw Values

    this._objCType = null; // Working with Pointer and Object Values

    this._pointerValue = null;
    this._nonretainedObjectValue = null; // Working with Range Values

    this._rangeValue = null; // Working with Foundation Geometry Values

    this._pointValue = null;
    this._sizeValue = null;
    this._rectValue = null; // Working with CoreGraphics Geometry Values

    this._cgPointValue = null;
    this._cgVectorValue = null;
    this._cgSizeValue = null;
    this._cgRectValue = null;
    this._cgAffineTransformValue = null; // Working with UIKit Geometry Values

    this._uiEdgeInsetsValue = null;
    this._uiOffsetValue = null; // Working with CoreAnimation Transform Values

    this._caTransform3DValue = null; // Working with Media Time Values

    this._timeValue = null;
    this._timeRangeValue = null;
    this._timeMappingValue = null; // Working with Geographic Coordinate Values

    this._mkCoordinateValue = null;
    this._mkCoordinateSpanValue = null; // Working with SceneKit Vector and Matrix Values

    this._scnVector3Value = null;
    this._scnVector4Value = null;
    this._scnMatrix4Value = null; // Instance Properties

    this._edgeInsetsValue = null;
  }
  /**
   * Creates a value object containing the specified object.
   * @access public
   * @param {?Object} anObject - The value for the new object.
   * @returns {void}
   * @desc  This method is equivalent to invoking init(_:withObjCType:) in this manner:NSValue *theValue = [NSValue value:&anObject withObjCType:@encode(void *)];
  This method is useful if you want to add an object to a Collection but don’t want the collection to create a strong reference to it.NSValue *theValue = [NSValue value:&anObject withObjCType:@encode(void *)];
    * @see https://developer.apple.com/documentation/foundation/nsvalue/1408098-init
   */


  initNonretainedObject(anObject) {}
  /**
   * Returns the value as an untyped pointer.
   * @type {?Object}
   * @desc 
   * @see https://developer.apple.com/documentation/foundation/nsvalue/1410668-pointervalue
   */


  get pointerValue() {
    return this._pointerValue;
  }
  /**
   * The value as a non-retained pointer to an object.
   * @type {?Object}
   * @desc If the value was not created to hold a pointer-sized data item, the result is undefined.
   * @see https://developer.apple.com/documentation/foundation/nsvalue/1412287-nonretainedobjectvalue
   */


  get nonretainedObjectValue() {
    return this._nonretainedObjectValue;
  } // Working with Range Values

  /**
   * The Foundation range structure representation of the value.
   * @type {NSRange}
   * @desc 
   * @see https://developer.apple.com/documentation/foundation/nsvalue/1413902-rangevalue
   */


  get rangeValue() {
    return this._rangeValue;
  } // Working with Foundation Geometry Values

  /**
   * The Foundation point structure representation of the value.
   * @type {CGPoint}
   * @desc 
   * @see https://developer.apple.com/documentation/foundation/nsvalue/1391255-pointvalue
   */


  get pointValue() {
    return this._pointValue;
  }
  /**
   * The Foundation size structure representation of the value.
   * @type {CGSize}
   * @desc 
   * @see https://developer.apple.com/documentation/foundation/nsvalue/1391301-sizevalue
   */


  get sizeValue() {
    return this._sizeValue;
  }
  /**
   * The Foundation rectangle structure representation of the value.
   * @type {CGRect}
   * @desc 
   * @see https://developer.apple.com/documentation/foundation/nsvalue/1391171-rectvalue
   */


  get rectValue() {
    return this._rectValue;
  } // Working with CoreGraphics Geometry Values

  /**
   * Creates a new value object containing the specified CoreGraphics point structure.
   * @access public
   * @param {CGPoint} point - The value for the new object.
   * @returns {void}
   * @see https://developer.apple.com/documentation/foundation/nsvalue/1624531-init
   */


  initCgPoint(point) {}
  /**
   * Creates a new value object containing the specified CoreGraphics vector structure.
   * @access public
   * @param {CGVector} vector - The value for the new object.
   * @returns {void}
   * @see https://developer.apple.com/documentation/foundation/nsvalue/1624493-init
   */


  initCgVector(vector) {}
  /**
   * Creates a new value object containing the specified CoreGraphics size structure.
   * @access public
   * @param {CGSize} size - The value for the new object.
   * @returns {void}
   * @see https://developer.apple.com/documentation/foundation/nsvalue/1624511-init
   */


  initCgSize(size) {}
  /**
   * Creates a new value object containing the specified CoreGraphics rectangle structure.
   * @access public
   * @param {CGRect} rect - The value for the new object.
   * @returns {void}
   * @see https://developer.apple.com/documentation/foundation/nsvalue/1624529-init
   */


  initCgRect(rect) {}
  /**
   * Creates a new value object containing the specified CoreGraphics affine transform structure.
   * @access public
   * @param {CGAffineTransform} transform - The value for the new object.
   * @returns {void}
   * @see https://developer.apple.com/documentation/foundation/nsvalue/1624503-init
   */


  initCgAffineTransform(transform) {}
  /**
   * Returns the CoreGraphics point structure representation of the value.
   * @type {CGPoint}
   * @desc 
   * @see https://developer.apple.com/documentation/foundation/nsvalue/1624534-cgpointvalue
   */


  get cgPointValue() {
    return this._cgPointValue;
  }
  /**
   * Returns the CoreGraphics vector structure representation of the value.
   * @type {CGVector}
   * @desc 
   * @see https://developer.apple.com/documentation/foundation/nsvalue/1624486-cgvectorvalue
   */


  get cgVectorValue() {
    return this._cgVectorValue;
  }
  /**
   * Returns the CoreGraphics size structure representation of the value.
   * @type {CGSize}
   * @desc 
   * @see https://developer.apple.com/documentation/foundation/nsvalue/1624489-cgsizevalue
   */


  get cgSizeValue() {
    return this._cgSizeValue;
  }
  /**
   * Returns the CoreGraphics rectangle structure representation of the value.
   * @type {CGRect}
   * @desc 
   * @see https://developer.apple.com/documentation/foundation/nsvalue/1624506-cgrectvalue
   */


  get cgRectValue() {
    return this._cgRectValue;
  }
  /**
   * Returns the CoreGraphics affine transform representation of the value.
   * @type {CGAffineTransform}
   * @desc 
   * @see https://developer.apple.com/documentation/foundation/nsvalue/1624512-cgaffinetransformvalue
   */


  get cgAffineTransformValue() {
    return this._cgAffineTransformValue;
  } // Working with UIKit Geometry Values

  /**
   * Creates a new value object containing the specified UIKit edge insets structure.
   * @access public
   * @param {UIEdgeInsets} insets - The value for the new object.
   * @returns {void}
   * @see https://developer.apple.com/documentation/foundation/nsvalue/1624485-init
   */


  initUiEdgeInsets(insets) {}
  /**
   * Creates a new value object containing the specified UIKit offset structure.
   * @access public
   * @param {UIOffset} insets - The value for the new object.
   * @returns {void}
   * @see https://developer.apple.com/documentation/foundation/nsvalue/1624530-init
   */


  initUiOffset(insets) {}
  /**
   * Returns the UIKit edge insets structure representation of the value.
   * @type {UIEdgeInsets}
   * @desc 
   * @see https://developer.apple.com/documentation/foundation/nsvalue/1624517-uiedgeinsetsvalue
   */


  get uiEdgeInsetsValue() {
    return this._uiEdgeInsetsValue;
  }
  /**
   * Returns the UIKit offset structure representation of the value.
   * @type {UIOffset}
   * @desc 
   * @see https://developer.apple.com/documentation/foundation/nsvalue/1624526-uioffsetvalue
   */


  get uiOffsetValue() {
    return this._uiOffsetValue;
  } // Working with CoreAnimation Transform Values

  /**
   * Creates a new value object containing the specified CoreAnimation transform structure.
   * @access public
   * @param {CATransform3D} t - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/foundation/nsvalue/1436556-init
   */


  initCaTransform3D(t) {}
  /**
   * The CoreAnimation transform structure representation of the value.
   * @type {CATransform3D}
   * @desc 
   * @see https://developer.apple.com/documentation/foundation/nsvalue/1436572-catransform3dvalue
   */


  get caTransform3DValue() {
    return this._caTransform3DValue;
  } // Working with Media Time Values

  /**
   * The CoreMedia time structure representation of the value.
   * @type {CMTime}
   * @desc 
   * @see https://developer.apple.com/documentation/foundation/nsvalue/1388151-timevalue
   */


  get timeValue() {
    return this._timeValue;
  }
  /**
   * The CoreMedia time range structure representation of the value.
   * @type {CMTimeRange}
   * @desc 
   * @see https://developer.apple.com/documentation/foundation/nsvalue/1385930-timerangevalue
   */


  get timeRangeValue() {
    return this._timeRangeValue;
  }
  /**
   * The CoreMedia time mapping structure representation of the value.
   * @type {CMTimeMapping}
   * @desc 
   * @see https://developer.apple.com/documentation/foundation/nsvalue/1387277-timemappingvalue
   */


  get timeMappingValue() {
    return this._timeMappingValue;
  } // Working with Geographic Coordinate Values

  /**
   * Creates a new value object containing the specified CoreLocation geographic coordinate structure.
   * @access public
   * @param {CLLocationCoordinate2D} coordinate - The value for the new object.
   * @returns {void}
   * @see https://developer.apple.com/documentation/foundation/nsvalue/1452193-init
   */


  initMkCoordinate(coordinate) {}
  /**
   * Creates a new value object containing the specified MapKit coordinate span structure.
   * @access public
   * @param {MKCoordinateSpan} span - The value for the new object.
   * @returns {void}
   * @see https://developer.apple.com/documentation/foundation/nsvalue/1452333-init
   */


  initMkCoordinateSpan(span) {}
  /**
   * The CoreLocation geographic coordinate structure representation of the value.
   * @type {CLLocationCoordinate2D}
   * @desc 
   * @see https://developer.apple.com/documentation/foundation/nsvalue/1452495-mkcoordinatevalue
   */


  get mkCoordinateValue() {
    return this._mkCoordinateValue;
  }
  /**
   * The MapKit coordinate span structure representation of the value.
   * @type {MKCoordinateSpan}
   * @desc 
   * @see https://developer.apple.com/documentation/foundation/nsvalue/1452516-mkcoordinatespanvalue
   */


  get mkCoordinateSpanValue() {
    return this._mkCoordinateSpanValue;
  } // Working with SceneKit Vector and Matrix Values

  /**
   * Creates a value object that contains the specified three-element SceneKit vector.
   * @access public
   * @param {SCNVector3} v - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/foundation/nsvalue/1409671-init
   */


  initScnVector3(v) {}
  /**
   * Creates a value object that contains the specified four-element SceneKit vector.
   * @access public
   * @param {SCNVector4} v - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/foundation/nsvalue/1409688-init
   */


  initScnVector4(v) {}
  /**
   * Creates a value object that contains the specified SceneKit 4 x 4 matrix.
   * @access public
   * @param {SCNMatrix4} v - The value for the new object.
   * @returns {void}
   * @see https://developer.apple.com/documentation/foundation/nsvalue/1409680-init
   */


  initScnMatrix4(v) {}
  /**
   * The three-element Scene Kit vector representation of the value.
   * @type {SCNVector3}
   * @desc 
   * @see https://developer.apple.com/documentation/foundation/nsvalue/1409669-scnvector3value
   */


  get scnVector3Value() {
    return this._scnVector3Value;
  }
  /**
   * The four-element Scene Kit vector representation of the value.
   * @type {SCNVector4}
   * @desc 
   * @see https://developer.apple.com/documentation/foundation/nsvalue/1409725-scnvector4value
   */


  get scnVector4Value() {
    return this._scnVector4Value;
  }
  /**
   * The Scene Kit 4 x 4 matrix representation of the value.
   * @type {SCNMatrix4}
   * @desc 
   * @see https://developer.apple.com/documentation/foundation/nsvalue/1409684-scnmatrix4value
   */


  get scnMatrix4Value() {
    return this._scnMatrix4Value;
  } // Comparing Value Objects

  /**
   * Returns a Boolean value that indicates whether the value object and another value object are equal.
   * @access public
   * @param {NSValue} value - 
   * @returns {boolean} - 
   * @desc The NSValue class compares the type and contents of each value object to determine equality.
   * @see https://developer.apple.com/documentation/foundation/nsvalue/1409038-isequal
   */


  isEqualTo(value) {
    return false;
  } // Initializers

  /**
   * 
   * @access public
   * @param {NSCoder} aDecoder - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/foundation/nsvalue/1417896-init
   */


  initCoder(aDecoder) {}
  /**
   * 
   * @access public
   * @param {EdgeInsets} insets - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/foundation/nsvalue/1391181-init
   */


  initEdgeInsets(insets) {} // Instance Properties

  /**
   * 
   * @type {EdgeInsets}
   * @desc 
   * @see https://developer.apple.com/documentation/foundation/nsvalue/1391123-edgeinsetsvalue
   */


  get edgeInsetsValue() {
    return this._edgeInsetsValue;
  }

}

const _InstanceOf = function (instance, aClass) {
  return instance && instance.isInstanceOf && instance.isInstanceOf(aClass);
};

/**
 * An object relevant to gameplay, with functionality entirely provided by a collection of component objects. 
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/gameplaykit/gkentity
 */

class GKEntity extends NSObject {
  // Creating an Entity

  /**
   * Initializes a new entity object.
   * @access public
   * @constructor
   * @desc If you create a GKEntity subclass and define any additional initializers, you must delegate to this initializer. You do not need to subclass GKEntity to use Entity-Component architecture—generally, you should create a custom entity class only when you need a place to store state or resources that are shared by multiple components.
   * @see https://developer.apple.com/documentation/gameplaykit/gkentity/1501143-init
   */
  constructor() {
    super(); // Managing an Entity’s List of Components

    this._components = [];
  } // Managing an Entity’s List of Components

  /**
   * Adds a component to the entity.
   * @access public
   * @param {GKComponent} component - An instance of a GKComponent subclass.
   * @returns {void}
   * @desc You create components by subclassing GKEntity to implement reusable behavior. Then, use this method to incorporate the behavior of a component class into that entity. An entity’s components list never has more than one instance of any component class—if the entity already contains a component of the same class as the component parameter, calling this method will replace that component.
   * @see https://developer.apple.com/documentation/gameplaykit/gkentity/1501312-addcomponent
   */


  addComponent(component) {
    if (this._components.indexOf(component) < 0) {
      this._components.push(component);

      component._entity = this;
      component.didAddToEntity();
    }
  }
  /**
   * The entity’s list of components.
   * @type {GKComponent[]}
   * @desc 
   * @see https://developer.apple.com/documentation/gameplaykit/gkentity/1501182-components
   */


  get components() {
    return this._components.slice();
  } // Performing Periodic Updates

  /**
   * Performs periodic updates for each of the entity’s components.
   * @access public
   * @param {number} seconds - The time step to use for any time-dependent actions performed by this method (typically, the elapsed time since the previous call to this method).
   * @returns {void}
   * @desc At runtime, an entity/component-based game needs to dispatch periodic logic—from an update/render loop method such as update(_:) (SpriteKit) or renderer(_:updateAtTime:) (SceneKit), or a CADisplayLink (iOS) or CVDisplayLink (macOS) timer in a custom rendering engine—to each of its components, so that each can perform component-specific update logic.The GKEntity update(deltaTime:) method is one of the two options GameplayKit provides for dispatching updates—this option is easy to implement in games with small numbers of entities and components. Call this method for each entity in your game, and each entity will in turn call the update(deltaTime:) method for each of its components.The other option is to dispatch updates per-component, rather than per-entity, using a GKComponentSystem object. Using a component system allows you to update all components of a specific component class in a deterministic order, without needing to traverse your game’s object graph and update each entity.NoteIf a component owned by an entity is a member of a component system, calling the entity’s update(deltaTime:) method will not update that component.
   * @see https://developer.apple.com/documentation/gameplaykit/gkentity/1501228-update
   */


  updateDeltaTime(seconds) {} // Instance Methods

  /**
   * 
   * @access public
   * @param {ComponentType.Type} componentClass - 
   * @returns {GKComponent} - 
   * @see https://developer.apple.com/documentation/gameplaykit/gkentity/2300466-component
   */


  componentOfType(componentClass) {
    return this._components.find(component => _InstanceOf(component, componentClass));
  }
  /**
   * 
   * @access public
   * @param {ComponentType.Type} componentClass - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/gameplaykit/gkentity/2300467-removecomponent
   */


  removeComponentOfType(componentClass) {
    for (const component of this._components) {
      if (_InstanceOf(component, componentClass)) {
        component.willRemoveFromEntity();

        const index = this._components.indexOf(component);

        if (index >= 0) {
          this._components.splice(index);

          component._entity = null;
        }
      }
    }
  }

}

/**
 * The abstract superclass for creating objects that add specific gameplay functionality to an entity.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/gameplaykit/gkcomponent
 */

class GKComponent extends NSObject {
  /**
   * constructor
   * @access public
   * @constructor
   */
  constructor() {
    super(); // Working with Entities

    /**
     * @access private
     * @type {GKEntity}
     */

    this._entity = null;
  } // Performing Periodic Updates

  /**
   * Performs any custom periodic actions defined by the component subclass.
   * @access public
   * @param {number} seconds - The time step to use for any time-dependent actions performed by this method (typically, the elapsed time since the previous call to this method).
   * @returns {void}
   * @desc Override this method to implement per-frame logic specific to your component class. GameplayKit calls this method when you call the update(deltaTime:) method of the entity owning a component, or when you call the update(deltaTime:) method of a GKComponentSystem object that manages all components of a specific GKComponent subclass. Typically, you call one of those methods in response to a per-frame game loop method such as update(_:) (SpriteKit) or renderer(_:updateAtTime:) (SceneKit).
   * @see https://developer.apple.com/documentation/gameplaykit/gkcomponent/1501218-update
   */


  updateDeltaTime(seconds) {} // Working with Entities

  /**
   * Notifies the component that it has been assigned to an entity.
   * @access public
   * @returns {void}
   * @desc Override this method in a component subclass if you need to perform game logic when the component is added to an entity. For example, if one component’s behavior depends on the presence of other components in the same entity, you can examine the entity’s components array in this method and take action accordingly.
   * @see https://developer.apple.com/documentation/gameplaykit/gkcomponent/1687601-didaddtoentity
   */


  didAddToEntity() {}
  /**
   * Notifies the component that it has been removed from an entity.
   * @access public
   * @returns {void}
   * @desc Override this method in a component subclass if you need to perform game logic when the component is removed from to an entity. For example, if one component’s behavior depends on the presence of other components in the same entity, you can examine the entity’s components array in this method and take action accordingly.
   * @see https://developer.apple.com/documentation/gameplaykit/gkcomponent/1640914-willremovefromentity
   */


  willRemoveFromEntity() {}
  /**
   * The entity that owns this component.
   * @type {?GKEntity}
   * @desc Use this property in a component subclass to refer back to the owning entity and its attributes. An entity may be an instance either of the GKEntity class or of a custom subclass. In the latter case, a custom entity class can provide storage for state or resources accessed by multiple components.
   * @see https://developer.apple.com/documentation/gameplaykit/gkcomponent/1501250-entity
   */


  get entity() {
    return this._entity;
  }

}

//import GKObstacle from './GKObstacle'
//import GKPath from './GKPath'
// TODO: check values from NSKeyedArchiver output.

const _GKGoalType = {
  none: 0,
  seek: 1,
  flee: 2,
  reach: 3,
  wander: 4,
  avoid: 5,
  intercept: 6,
  separate: 7,
  align: 8,
  cohere: 9,
  stay: 10,
  follow: 11
  /**
   * An influence that motivates the movement of one or more agents.
   * @access public
   * @extends {NSObject}
   * @see https://developer.apple.com/documentation/gameplaykit/gkgoal
   */

};
class GKGoal extends NSObject {
  /**
   * constructor
   * @access public
   * @constructor
   */
  constructor() {
    super();
    /**
     * @access private
     * @type {_GKGoalType}
     */

    this._type = 0;
    /**
     * @access private
     * @type {GKPath}
     */

    this._path = null;
    /**
     * @access private
     * @type {GKObstacle[]}
     */

    this._obstacles = [];
    /**
     * @access private
     * @type {GKAgent[]}
     */

    this._agents = [];
    /**
     * @access pricate
     * @type {number}
     */

    this._time = 0;
    /**
     * @access pricate
     * @type {number}
     */

    this._angle = 0;
    /**
     * @access pricate
     * @type {number}
     */

    this._distance = 0;
    /**
     * @access pricate
     * @type {number}
     */

    this._speed = 0;
    /**
     * @access pricate
     * @type {boolean}
     */

    this._forward = true;
  } // Creating Goals for General Movement Behavior

  /**
   * Creates a goal whose effect is to move an agent toward the current position of the specified other agent.
   * @access public
   * @param {GKAgent} agent - An agent whose position affected agents will attempt to move toward.
   * @returns {GKGoal} -
   * @desc This goal is similar to one produced by the init(toInterceptAgent:maxPredictionTime:) method with a maxPredictionTime parameter of zero. Affected agents will attempt to move toward the target agent, but without taking the target’s movement into account.You can also use this goal when you want an agent to move toward a target point, such as the current mouse or touch location. Create another agent that remains stationary at the target point (that is, has no velocity and no goals), and use that agent as the parameter when creating a goal with this method.
   * @see https://developer.apple.com/documentation/gameplaykit/gkgoal/1501217-init
   */


  static goalToSeekAgent(agent) {
    const goal = new GKGoal();
    goal._type = _GKGoalType.seek;

    goal._agents.push(agent);

    return goal;
  }
  /**
   * Creates a goal whose effect is to move an agent away from the current position of the specified other agent.
   * @access public
   * @param {GKAgent} agent - An agent whose position affected agents will attempt to move away from.
   * @returns {GKGoal} -
   * @desc This goal is similar to one produced by the init(toAvoid:maxPredictionTime:) method with a single agent and a maxPredictionTime parameter of zero. Affected agents will attempt to move away from the target agent, but without taking the target’s movement into account.You can also use this goal when you want an agent to move away from a target point, such as the current mouse or touch location. Create another agent that remains stationary at the target point (that is, has no velocity and no goals), and use that agent as the parameter when creating a goal with this method.
   * @see https://developer.apple.com/documentation/gameplaykit/gkgoal/1501248-init
   */


  static goalToFleeAgent(agent) {
    const goal = new GKGoal();
    goal._type = _GKGoalType.flee;

    goal._agents.push(agent);

    return goal;
  }
  /**
   * Creates a goal whose effect is to accelerate or decelerate an agent until it reaches the specified speed.
   * @access public
   * @param {number} targetSpeed - The speed for affected agents to reach.
   * @returns {GKGoal} -
   * @see https://developer.apple.com/documentation/gameplaykit/gkgoal/1501070-init
   */


  static goalToReachTargetSpeed(targetSpeed) {
    const goal = new GKGoal();
    goal._type = _GKGoalType.reach;
    goal._speed = targetSpeed;
    return goal;
  }
  /**
   * Creates a goal whose effect is to make an agent wander aimlessly, moving forward and turning at random.
   * @access public
   * @param {number} speed - The forward speed for affected agents to maintain while turning at random.
   * @returns {GKGoal} -
   * @see https://developer.apple.com/documentation/gameplaykit/gkgoal/1501052-init
   */


  static goalToWander(speed) {
    const goal = new GKGoal();
    goal._type = _GKGoalType.wander;
    goal._speed = speed;
    return goal;
  } // Creating Goals for Avoidance and Interception Behavior

  /**
   * Creates a goal whose effect is to make an agent avoid colliding with the specified static obstacles.
   * @access public
   * @param {GKObstacle[]} obstacles - The static obstacles with which to avoid collisions.
   * @param {number} maxPredictionTime - The amount of time during which to predict collisions.
   * @returns {GKGoal} -
   * @desc The maxPredictionTime parameter controls how far in the future a predicted collision must be in order for the agent to take action to avoid it. For example, if this parameter has a low value, an agents speeding toward an obstacle will not swerve or slow until a collision is imminent (and depending on the properties of that agent, it might not be able to move quickly enough to avoid colliding). If this parameter has a high value, the agent will change course leisurely, well before colliding.
   * @see https://developer.apple.com/documentation/gameplaykit/gkgoal/1501098-init
   */


  static goalToAvoid(obstacles, maxPredictionTime) {
    const goal = new GKGoal();
    goal._type = _GKGoalType.avoid;

    goal._obstacles.push(...obstacles);

    goal._time = maxPredictionTime;
    return goal;
  }
  /**
   * Creates a goal whose effect is to make an agent pursue the specified other agent, taking into account the target’s movement.
   * @access public
   * @param {GKAgent} target - An agent whose position affected agents will attempt to move toward.
   * @param {number} maxPredictionTime - The amount of time for which to predict the target agent’s movement.
   * @returns {GKGoal} -
   * @desc The maxPredictionTime parameter controls how far in the future the agent will plan to intercept its target. A larger value causes an affected agent to pursue its quarry more efficently, catching up with the target’s motion using fewer course corrections. A smaller value causes an affected agent to more closely follow the target’s current position despite the target’s current speed (and depending on the properties of the affected agent, it might not be able to move quickly enough to catch its target).
   * @see https://developer.apple.com/documentation/gameplaykit/gkgoal/1501219-init
   */


  static goalToInterceptAgent(target, maxPredictionTime) {
    const goal = new GKGoal();
    goal._type = _GKGoalType.intercept;

    goal._agents.push(...target);

    goal._time = maxPredictionTime;
    return goal;
  } // Creating Goals for Flocking Behavior

  /**
   * Creates a goal whose effect is to make an agent maintain the specified distance from other agents in a specified group.
   * @access public
   * @param {GKAgent[]} agents - The agents from whom to maintain distance.
   * @param {number} maxDistance - The maximum distance from other agents required for this goal to take effect.
   * @param {number} maxAngle - The maximum angle, in radians, between an affected agent’s velocity and the direction toward the other agents required for this goal to take effect.
   * @returns {GKGoal} -
   * @desc The agents array can safely include the agent(s) affected by the goal—an agent pursuing this goal will ignore itself in the array. Therefore, you can use a single goal created with this method to cause an entire group of agents to mutually avoid one another.Changing the maxDistance parameter determines the minimum distance between agents in the group. Changing the maxAngle parameter determines how tightly an agent will turn to maintain separation from the group.You can combine separation, alignment, and cohesion goals to produce “flocking” behaviors in which a group of agents move together.
   * @see https://developer.apple.com/documentation/gameplaykit/gkgoal/1501049-init
   */


  static goalToSeparateFrom(agents, maxDistance, maxAngle) {
    const goal = new GKGoal();
    goal._type = _GKGoalType.separate;

    goal._agents.push(...agents);

    goal._distance = maxDistance;
    goal._angle = maxAngle;
    return goal;
  }
  /**
   * Creates a goal whose effect is to make an agent align its orientation with that of other agents in a specified group.
   * @access public
   * @param {GKAgent[]} agents - The agents with whom to maintain alignment.
   * @param {number} maxDistance - The maximum distance from other agents required for this goal to take effect.
   * @param {number} maxAngle - The maximum angle, in radians, between an affected agent’s velocity and the direction toward the other agents required for this goal to take effect.
   * @returns {GKGoal} -
   * @desc The agents array can safely include the agent(s) affected by the goal—an agent pursuing this goal will ignore itself in the array. Therefore, you can use a single goal created with this method to cause an entire group of agents to mutually align with one another.Changing the maxDistance parameter determines the minimum distance between agents in the group. Changing the maxAngle parameter determines how tightly an agent will turn to maintain alignment with the group.You can combine separation, alignment, and cohesion goals to produce “flocking” behaviors in which a group of agents move together.
   * @see https://developer.apple.com/documentation/gameplaykit/gkgoal/1501134-init
   */


  static goalToAlignWith(agents, maxDistance, maxAngle) {
    const goal = new GKGoal();
    goal._type = _GKGoalType.align;

    goal._agents.push(...agents);

    goal._distance = maxDistance;
    goal._angle = maxAngle;
    return goal;
  }
  /**
   * Creates a goal whose effect is to make an agent stay near the other agents in a specified group.
   * @access public
   * @param {GKAgent[]} agents - The agents with whom to stay close.
   * @param {number} maxDistance - The maximum distance from other agents required for this goal to take effect.
   * @param {number} maxAngle - The maximum angle, in radians, between an affected agent’s velocity and the direction toward the other agents required for this goal to take effect.
   * @returns {GKGoal} -
   * @desc The agents array can safely include the agent(s) affected by the goal—an agent pursuing this goal will ignore itself in the array. Therefore, you can use a single goal created with this method to cause an entire group of agents to mutually stay near one another.Changing the maxDistance parameter determines how close to one another agents need to be in order for them to form a group. Changing the maxAngle parameter determines how tightly an agent will turn to maintain cohesion in the group.You can combine separation, alignment, and cohesion goals to produce “flocking” behaviors in which a group of agents move together.
   * @see https://developer.apple.com/documentation/gameplaykit/gkgoal/1501170-init
   */


  static goalToCohereWith(agents, maxDistance, maxAngle) {
    const goal = new GKGoal();
    goal._type = _GKGoalType.cohere;

    goal._agents.push(...agents);

    goal._distance = maxDistance;
    goal._angle = maxAngle;
    return goal;
  } // Creating Goals for Path-Following Behavior

  /**
   * Creates a goal whose effect is to maintain an agent’s position within the specified path.
   * @access public
   * @param {GKPath} path - A path object.
   * @param {number} maxPredictionTime - The amount of time for which to predict an affected agent’s movement.
   * @returns {GKGoal} -
   * @desc This goal uses the shape and the radius property of the specified path to define the boundaries of an area for the agent to stay in. If an affected agent is outside that area, the agent will move into that area; if the agent is already in that area, this goal will not motivate the agent to move further.The maxPredictionTime parameter determines how far ahead of time the agent will predict its own movement to fulfill this goal. For example, with a larger value, an agent moving toward the path will begin to slow gradually so as to stop gently within the path’s radius. With a smaller value, the agent will attempt to stop more abruptly as it reaches the path (and depending on its properties, it might not be able to stop quickly enough to avoid overshooting).
   * @see https://developer.apple.com/documentation/gameplaykit/gkgoal/1501166-init
   */


  static goalToStayOn(path, maxPredictionTime) {
    const goal = new GKGoal();
    goal._type = _GKGoalType.stay;
    goal._path = path;
    goal._time = maxPredictionTime;
    return goal;
  }
  /**
   * Creates a goal whose effect is to both maintain position on and traverse the specified path.
   * @access public
   * @param {GKPath} path - A path object.
   * @param {number} maxPredictionTime - The amount of time for which to predict an affected agent’s movement.
   * @param {boolean} forward - true to traverse in the order the path’s verties are defined; false to traverse the path in the opposite order.
   * @returns {GKGoal} -
   * @desc This goal uses the shape and the radius property of the specified path to define the agent’s desired movement. The agent first attempts to reach a location near the path’s start point (or end point if the forward parameter is false), to a tolerance determined by the path’s radius. Then, the agent attemps to move toward the next point in the path, again with a tolerance determined by the path’s radius. This sequence continues until the path terminates, or repeats indefinitely if the path’s isCyclical property is true.The maxPredictionTime parameter determines how far ahead of time the agent will predict its own movement to fulfill this goal. For example, with a larger value, an agent moving toward the path will begin to slow gradually so as to stop gently within the path’s radius. With a smaller value, the agent will attempt to stop more abruptly as it reaches the path (and depending on its properties, it might not be able to stop quickly enough to avoid overshooting).
   * @see https://developer.apple.com/documentation/gameplaykit/gkgoal/1501095-init
   */


  static goalToFollow(path, maxPredictionTime, forward) {
    const goal = new GKGoal();
    goal._type = _GKGoalType.follow;
    goal._path = path;
    goal._time = maxPredictionTime;
    goal._foward = forward;
    return goal;
  }

}

/**
 * A set of goals that together influence the movement of an agent.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/gameplaykit/gkbehavior
 */

class GKBehavior extends NSObject {
  /**
   * constructor
   * @access public
   * @constructor
   */
  constructor() {
    super(); // Managing a Behavior’s Set of Goals

    /**
     * @access private
     * @type {GKGoal[]}
     */

    this._goals = [];
    /**
     * @access private
     * @type {number[]}
     */

    this._weights = [];
  } // Creating a Behavior

  /**
   * Creates a behavior with a single goal.
   * @access public
   * @param {GKGoal} goal - A goal object.
   * @param {number} weight - A weight to be applied to the goal’s influence on an agent’s speed and direction.
   * @returns {GKBehavior}
   * @see https://developer.apple.com/documentation/gameplaykit/gkbehavior/1388733-init
   */


  static behaviorWithGoalWeight(goal, weight) {
    const behavior = new GKBehavior();

    behavior._goals.push(goal);

    behavior._weights.push(weight);

    return behavior;
  }
  /**
   * Creates a behavior with the specified goals.
   * @access public
   * @param {GKGoal[]} goals - An array of goal objects.
   * @returns {GKBehavior} - A new behavior object. To assign a set of goals to an agent, use its behavior property.
   * @see https://developer.apple.com/documentation/gameplaykit/gkbehavior/1388725-init
   */


  static behaviorWithGoals(goals) {
    const behavior = new GKBehavior();

    behavior._goals.push(...goals);

    for (let i = 0; i < goals.length; i++) {
      behavior._weights.push(1);
    }

    return behavior;
  }
  /**
   * Creates a behavior with the specified goals and weights.
   * @access public
   * @param {GKGoal[]} goals - An array of goal objects.
   * @param {number[]} weights - An array of numbers, each the weight to be applied to the goal at the corresponding index in the goals array.
   * @returns {GKBehavior} -
   * @see https://developer.apple.com/documentation/gameplaykit/gkbehavior/1388727-init
   */


  static behaviorWithGoalsAndWeights(goals, weights) {
    const behavior = new GKBehavior();

    behavior._goals.push(...goals);

    behavior._weights.push(...weights);

    return behavior;
  } // Managing a Behavior’s Set of Goals

  /**
   * Sets the weight for the specified goal’s influence on agents, adding that goal to the behavior if not already present.
   * @access public
   * @param {number} weight - A weight to be applied to the goal’s influence on an agent’s speed and direction.
   * @param {GKGoal} goal - A goal object.
   * @returns {void}
   * @desc When an agent evaluates its behavior, it examines each goal and calculates the change in direction and speed necessary to move toward fulfilling that goal (within the limits of the current time step and the agent’s maximum speed and turn rate). The agent then combines these influences to determine the total change in direction and speed for the current time step. To modulate the effects of multiple goals in a behavior, use this method to increase or decrease the relative influence of each.You can use this method to vary the behaviors in your game in response to player actions or other events. For example, an enemy agent’s behavior may combine pursuing the player (init(toInterceptAgent:maxPredictionTime:)) with a bit of wandering (init(toWander:)) to make its movement appear natural. When the enemy has not yet sighted the player, you might reduce the weight of the pursue goal to zero; when the player attacks the enemy, you might increase the weight of the wander goal for a short time to make the enemy act dazed.
   * @see https://developer.apple.com/documentation/gameplaykit/gkbehavior/1388731-setweight
   */


  setWeightFor(weight, goal) {
    const index = this._goals.indexOf(goal);

    if (index >= 0) {
      this._weights[index] = weight;
    }
  }
  /**
   * Returns the weight for the specified goal’s influence on agents.
   * @access public
   * @param {GKGoal} goal - A goal already included in the behavior’s set of goals.
   * @returns {number} - 
   * @desc When an agent evaluates its behavior, it examines each goal and calculates the change in direction and speed necessary to move toward fulfilling that goal (within the limits of the current time step and the agent’s maximum speed and turn rate). The agent then combines these influences to determine the total change in direction and speed for the current time step. Weights modulate the effects of multiple goals in a behavior.
   * @see https://developer.apple.com/documentation/gameplaykit/gkbehavior/1388729-weight
   */


  weightFor(goal) {
    const index = this._goals.indexOf(goal);

    if (index >= 0) {
      return this._weights[index];
    }

    return 0;
  }
  /**
   * Removes the specified goal from the behavior.
   * @access public
   * @param {GKGoal} goal - A goal object.
   * @returns {void}
   * @see https://developer.apple.com/documentation/gameplaykit/gkbehavior/1388714-remove
   */


  remove(goal) {
    const index = this._goals.indexOf(goal);

    if (index >= 0) {
      this._goals.splice(index, 1);

      this._weights.splice(index, 1);
    }
  }
  /**
   * Removes all goals from the behavior.
   * @access public
   * @returns {void}
   * @see https://developer.apple.com/documentation/gameplaykit/gkbehavior/1388716-removeallgoals
   */


  removeAllGoals() {
    this._goals = [];
    this._weights = [];
  }
  /**
   * The number of goals in the behavior.
   * @type {number}
   * @desc 
   * @see https://developer.apple.com/documentation/gameplaykit/gkbehavior/1388721-goalcount
   */


  get goalCount() {
    return this._goals.length;
  } // Working with Goals Using Subscript Syntax

  /**
   * Returns the weight associated with the goal specified by subscript syntax.
   * @access public
   * @param {GKGoal} goal - A goal already included in the behavior’s set of goals.
   * @returns {NSNumber! { get set }} - 
   * @desc This method is equivalent to the weight(for:) method, but allows access using subscript syntax.
   * @see https://developer.apple.com/documentation/gameplaykit/gkbehavior/1388723-subscript
   */


  subscript(goal) {
    return null;
  }

}

/**
 * Implement this protocol to synchronize the state of an agent with its visual representation in your game.
 * @interface
 * @see https://developer.apple.com/documentation/gameplaykit/gkagentdelegate
 */

class GKAgentDelegate {
  /**
   * constructor
   * @access public
   * @constructor
   */
  //constructor() {
  //}
  // Synchronizing with Agents

  /**
   * Tells the delegate that an agent is about to perform its next simulation step.
   * @access public
   * @param {GKAgent} agent - The agent object that will perform its next simulation step.
   * @returns {void}
   * @desc Implement this method when you want to update the agent simulation with data from an external source, such as node position and orientation information updated by the SceneKit or SpriteKit physics engine. Set the position and rotation properties of the agent (as a GKAgent2D or GKAgent3D object) so that the next simulation step will take your changes to those properties into account.
   * @see https://developer.apple.com/documentation/gameplaykit/gkagentdelegate/1501232-agentwillupdate
   */
  agentWillUpdate(agent) {}
  /**
   * Tells the delegate that an agent has just performed a simulation step.
   * @access public
   * @param {GKAgent} agent - The agent object that has just performed a simulation step.
   * @returns {void}
   * @desc Implement this method when you want to update a display based on the latest data from the agent simulation. Read the position and rotation properties of the agent (as a GKAgent2D or GKAgent3D object), then set the corresponding attributes of the object that provides the agent’s visual representation.
   * @see https://developer.apple.com/documentation/gameplaykit/gkagentdelegate/1501131-agentdidupdate
   */


  agentDidUpdate(agent) {}

}

/**
 * A component that moves a game entity according to a set of goals and realistic constraints.
 * @access public
 * @extends {GKComponent}
 * @see https://developer.apple.com/documentation/gameplaykit/gkagent
 */

class GKAgent extends GKComponent {
  /**
   * constructor
   * @access public
   * @constructor
   */
  constructor() {
    super(); // Defining an Agent’s Behavior

    /**
     * A weighted collection of goals that influence the agent’s movement.
     * @type {?GKBehavior}
     * @see https://developer.apple.com/documentation/gameplaykit/gkagent/1501272-behavior
     */

    this.behavior = null; // Constraining an Agent’s Movement

    /**
     * The resistance of the agent to changes in speed or direction.
     * @type {number}
     * @see https://developer.apple.com/documentation/gameplaykit/gkagent/1501080-mass
     */

    this.mass = 0;
    /**
     * The upper limit to changes in the agent’s speed or direction.
     * @type {number}
     * @see https://developer.apple.com/documentation/gameplaykit/gkagent/1501224-maxacceleration
     */

    this.maxAcceleration = 0;
    /**
     * The agent’s maximum forward speed, in units per second.
     * @type {number}
     * @see https://developer.apple.com/documentation/gameplaykit/gkagent/1501323-maxspeed
     */

    this.maxSpeed = 0;
    /**
     * The agent’s radius.
     * @type {number}
     * @see https://developer.apple.com/documentation/gameplaykit/gkagent/1501066-radius
     */

    this.radius = 0; // Synchronizing an Agent’s Visual Representation

    /**
     * An object that prepares for or responds to updates in the agent simulation.
     * @type {?GKAgentDelegate}
     * @see https://developer.apple.com/documentation/gameplaykit/gkagent/1501215-delegate
     */

    this.delegate = null; // Managing an Agent’s Attributes

    /**
     * The agent’s current forward speed, in units per second.
     * @type {number}
     * @see https://developer.apple.com/documentation/gameplaykit/gkagent/1501038-speed
     */

    this.speed = 0;
  } // GKAgentDelegate

  /**
   * Tells the delegate that an agent is about to perform its next simulation step.
   * @access public
   * @param {GKAgent} agent - The agent object that will perform its next simulation step.
   * @returns {void}
   * @desc Implement this method when you want to update the agent simulation with data from an external source, such as node position and orientation information updated by the SceneKit or SpriteKit physics engine. Set the position and rotation properties of the agent (as a GKAgent2D or GKAgent3D object) so that the next simulation step will take your changes to those properties into account.
   * @see https://developer.apple.com/documentation/gameplaykit/gkagentdelegate/1501232-agentwillupdate
   */


  agentWillUpdate(agent) {}
  /**
   * Tells the delegate that an agent has just performed a simulation step.
   * @access public
   * @param {GKAgent} agent - The agent object that has just performed a simulation step.
   * @returns {void}
   * @desc Implement this method when you want to update a display based on the latest data from the agent simulation. Read the position and rotation properties of the agent (as a GKAgent2D or GKAgent3D object), then set the corresponding attributes of the object that provides the agent’s visual representation.
   * @see https://developer.apple.com/documentation/gameplaykit/gkagentdelegate/1501131-agentdidupdate
   */


  agentDidUpdate(agent) {}

}

/**
 * An agent that operates in a two-dimensional space. 
 * @access public
 * @extends {GKAgent}
 * @see https://developer.apple.com/documentation/gameplaykit/gkagent2d
 */

class GKAgent2D extends GKAgent {
  /**
   * constructor
   * @access public
   * @constructor
   */
  constructor() {
    super(); // Managing an Agent’s Position and Orientation

    /**
     * The current position of the agent in 2D space.
     * @type {CGPoint}
     * @see https://developer.apple.com/documentation/gameplaykit/gkagent2d/1501043-position
     */

    this.position = new CGPoint(0, 0);
    /**
     * The rotation of the agent around the z-axis.
     * @type {number}
     * @see https://developer.apple.com/documentation/gameplaykit/gkagent2d/1501045-rotation
     */

    this.rotation = 0; // Running the Agent Simulation

    /**
     * @access private
     * @type {CGPoint}
     */

    this._velocity = new CGPoint();
  } // Running the Agent Simulation

  /**
   * Causes the agent to evaluate its goals and update its position, rotation, and velocity accordingly.
   * @access public
   * @param {number} seconds - 
   * @returns {void}
   * @desc You call this method directly on an individual agent, or on all the agents in your game through a GKComponentSystem object, whenever you want to run a step of the agent simulation. Typically, a game updates its agent simulation whenever it prepares to draw a new frame—for example, in the update(_:) method of a SpriteKit SKScene object.
   * @see https://developer.apple.com/documentation/gameplaykit/gkagent2d/1501242-update
   */


  updateDeltaTime(seconds) {}
  /**
   * The current velocity of the agent in 2D space.
   * @type {CGPoint}
   * @desc An agent’s velocity is a calculated property—the velocity vector is determined by an agent’s facing direction (its rotation property) and its speed property.
   * @see https://developer.apple.com/documentation/gameplaykit/gkagent2d/1501186-velocity
   */


  get velocity() {
    return this._velocity;
  }

}

const _epsilon = 0.0000001;
/**
 * A representation of a 4 x 4 matrix.
 * @access public
 * @see https://developer.apple.com/documentation/scenekit/scnmatrix4
 */

class SCNMatrix4 {
  // Initializers

  /**
   * 
   * @access public
   * @construtor
   * @param {number[][]} [m = null] - 
   * @see https://developer.apple.com/documentation/quartzcore/catransform3d/1524036-init
   */
  constructor(m = null) {
    // Instance Properties

    /** @type {number} */
    this.m11 = 0;
    /** @type {number} */

    this.m12 = 0;
    /** @type {number} */

    this.m13 = 0;
    /** @type {number} */

    this.m14 = 0;
    /** @type {number} */

    this.m21 = 0;
    /** @type {number} */

    this.m22 = 0;
    /** @type {number} */

    this.m23 = 0;
    /** @type {number} */

    this.m24 = 0;
    /** @type {number} */

    this.m31 = 0;
    /** @type {number} */

    this.m32 = 0;
    /** @type {number} */

    this.m33 = 0;
    /** @type {number} */

    this.m34 = 0;
    /** @type {number} */

    this.m41 = 0;
    /** @type {number} */

    this.m42 = 0;
    /** @type {number} */

    this.m43 = 0;
    /** @type {number} */

    this.m44 = 0;

    if (_InstanceOf(m, SCNMatrix4)) {
      this.m11 = m.m11;
      this.m12 = m.m12;
      this.m13 = m.m13;
      this.m14 = m.m14;
      this.m21 = m.m21;
      this.m22 = m.m22;
      this.m23 = m.m23;
      this.m24 = m.m24;
      this.m31 = m.m31;
      this.m32 = m.m32;
      this.m33 = m.m33;
      this.m34 = m.m34;
      this.m41 = m.m41;
      this.m42 = m.m42;
      this.m43 = m.m43;
      this.m44 = m.m44;
    } else if (arguments.length >= 16) {
      this.m11 = arguments[0];
      this.m12 = arguments[1];
      this.m13 = arguments[2];
      this.m14 = arguments[3];
      this.m21 = arguments[4];
      this.m22 = arguments[5];
      this.m23 = arguments[6];
      this.m24 = arguments[7];
      this.m31 = arguments[8];
      this.m32 = arguments[9];
      this.m33 = arguments[10];
      this.m34 = arguments[11];
      this.m41 = arguments[12];
      this.m42 = arguments[13];
      this.m43 = arguments[14];
      this.m44 = arguments[15];
    } else if (m !== null) {
      // TODO: type check
      this.m11 = m[0][0];
      this.m12 = m[0][1];
      this.m13 = m[0][2];
      this.m14 = m[0][3];
      this.m21 = m[1][0];
      this.m22 = m[1][1];
      this.m23 = m[1][2];
      this.m24 = m[1][3];
      this.m31 = m[2][0];
      this.m32 = m[2][1];
      this.m33 = m[2][2];
      this.m34 = m[2][3];
      this.m41 = m[3][0];
      this.m42 = m[3][1];
      this.m43 = m[3][2];
      this.m44 = m[3][3];
    }
  }
  /**
   * @access private
   * @param {Buffer} data -
   * @param {number} [offset = 0] -
   * @param {boolean} [bigEndian = false] -
   * @returns {SCNMatrix4} -
   */


  static _initWithData(data, offset = 0, bigEndian = false) {
    const instance = new SCNMatrix4();

    if (bigEndian) {
      instance.m11 = data.readFloatBE(offset + 0);
      instance.m12 = data.readFloatBE(offset + 4);
      instance.m13 = data.readFloatBE(offset + 8);
      instance.m14 = data.readFloatBE(offset + 12);
      instance.m21 = data.readFloatBE(offset + 16);
      instance.m22 = data.readFloatBE(offset + 20);
      instance.m23 = data.readFloatBE(offset + 24);
      instance.m24 = data.readFloatBE(offset + 28);
      instance.m31 = data.readFloatBE(offset + 32);
      instance.m32 = data.readFloatBE(offset + 36);
      instance.m33 = data.readFloatBE(offset + 40);
      instance.m34 = data.readFloatBE(offset + 44);
      instance.m41 = data.readFloatBE(offset + 48);
      instance.m42 = data.readFloatBE(offset + 52);
      instance.m43 = data.readFloatBE(offset + 56);
      instance.m44 = data.readFloatBE(offset + 60);
    } else {
      instance.m11 = data.readFloatLE(offset + 0);
      instance.m12 = data.readFloatLE(offset + 4);
      instance.m13 = data.readFloatLE(offset + 8);
      instance.m14 = data.readFloatLE(offset + 12);
      instance.m21 = data.readFloatLE(offset + 16);
      instance.m22 = data.readFloatLE(offset + 20);
      instance.m23 = data.readFloatLE(offset + 24);
      instance.m24 = data.readFloatLE(offset + 28);
      instance.m31 = data.readFloatLE(offset + 32);
      instance.m32 = data.readFloatLE(offset + 36);
      instance.m33 = data.readFloatLE(offset + 40);
      instance.m34 = data.readFloatLE(offset + 44);
      instance.m41 = data.readFloatLE(offset + 48);
      instance.m42 = data.readFloatLE(offset + 52);
      instance.m43 = data.readFloatLE(offset + 56);
      instance.m44 = data.readFloatLE(offset + 60);
    }

    return instance;
  }

  _copy() {
    return new SCNMatrix4(this);
  } // extensions

  /**
   * @access public
   * @param {SCNMatrix4} m -
   * @returns {SCNMatrix4} - 
   */


  add(m) {
    const r = new SCNMatrix4();
    r.m11 = this.m11 + m.m11;
    r.m12 = this.m12 + m.m12;
    r.m13 = this.m13 + m.m13;
    r.m14 = this.m14 + m.m14;
    r.m21 = this.m21 + m.m21;
    r.m22 = this.m22 + m.m22;
    r.m23 = this.m23 + m.m23;
    r.m24 = this.m24 + m.m24;
    r.m31 = this.m31 + m.m31;
    r.m32 = this.m32 + m.m32;
    r.m33 = this.m33 + m.m33;
    r.m34 = this.m34 + m.m34;
    r.m41 = this.m41 + m.m41;
    r.m42 = this.m42 + m.m42;
    r.m43 = this.m43 + m.m43;
    r.m44 = this.m44 + m.m44;
    return r;
  }
  /**
   * @access public
   * @param {number} t -
   * @returns {SCNMatrix4} - 
   */


  mul(t) {
    const r = new SCNMatrix4();
    r.m11 = this.m11 * t;
    r.m12 = this.mj2 * t;
    r.m13 = this.m13 * t;
    r.m14 = this.m14 * t;
    r.m21 = this.m21 * t;
    r.m22 = this.m22 * t;
    r.m23 = this.m23 * t;
    r.m24 = this.m24 * t;
    r.m31 = this.m31 * t;
    r.m32 = this.m32 * t;
    r.m33 = this.m33 * t;
    r.m34 = this.m34 * t;
    r.m41 = this.m41 * t;
    r.m42 = this.m42 * t;
    r.m43 = this.m43 * t;
    r.m44 = this.m44 * t;
    return r;
  }
  /**
   * @access public
   * @param {SCNMatrix4} m -
   * @returns {SCNMatrix4} - 
   */


  mult(m) {
    const r = new SCNMatrix4();
    r.m11 = this.m11 * m.m11 + this.m12 * m.m21 + this.m13 * m.m31 + this.m14 * m.m41;
    r.m12 = this.m11 * m.m12 + this.m12 * m.m22 + this.m13 * m.m32 + this.m14 * m.m42;
    r.m13 = this.m11 * m.m13 + this.m12 * m.m23 + this.m13 * m.m33 + this.m14 * m.m43;
    r.m14 = this.m11 * m.m14 + this.m12 * m.m24 + this.m13 * m.m34 + this.m14 * m.m44;
    r.m21 = this.m21 * m.m11 + this.m22 * m.m21 + this.m23 * m.m31 + this.m24 * m.m41;
    r.m22 = this.m21 * m.m12 + this.m22 * m.m22 + this.m23 * m.m32 + this.m24 * m.m42;
    r.m23 = this.m21 * m.m13 + this.m22 * m.m23 + this.m23 * m.m33 + this.m24 * m.m43;
    r.m24 = this.m21 * m.m14 + this.m22 * m.m24 + this.m23 * m.m34 + this.m24 * m.m44;
    r.m31 = this.m31 * m.m11 + this.m32 * m.m21 + this.m33 * m.m31 + this.m34 * m.m41;
    r.m32 = this.m31 * m.m12 + this.m32 * m.m22 + this.m33 * m.m32 + this.m34 * m.m42;
    r.m33 = this.m31 * m.m13 + this.m32 * m.m23 + this.m33 * m.m33 + this.m34 * m.m43;
    r.m34 = this.m31 * m.m14 + this.m32 * m.m24 + this.m33 * m.m34 + this.m34 * m.m44;
    r.m41 = this.m41 * m.m11 + this.m42 * m.m21 + this.m43 * m.m31 + this.m44 * m.m41;
    r.m42 = this.m41 * m.m12 + this.m42 * m.m22 + this.m43 * m.m32 + this.m44 * m.m42;
    r.m43 = this.m41 * m.m13 + this.m42 * m.m23 + this.m43 * m.m33 + this.m44 * m.m43;
    r.m44 = this.m41 * m.m14 + this.m42 * m.m24 + this.m43 * m.m34 + this.m44 * m.m44;
    return r;
  }
  /**
   * @access public
   * @param {SCNMatrix4} m -
   * @param {number} rate -
   * @returns {SCNMatrix4} - 
   */


  lerp(m, rate) {
    const r = new SCNMatrix4();
    r.m11 = this.m11 + rate * (this.m11 - m.m11);
    r.m12 = this.m12 + rate * (this.m12 - m.m12);
    r.m13 = this.m13 + rate * (this.m13 - m.m13);
    r.m14 = this.m14 + rate * (this.m14 - m.m14);
    r.m21 = this.m21 + rate * (this.m21 - m.m21);
    r.m22 = this.m22 + rate * (this.m22 - m.m22);
    r.m23 = this.m23 + rate * (this.m23 - m.m23);
    r.m24 = this.m24 + rate * (this.m24 - m.m24);
    r.m31 = this.m31 + rate * (this.m31 - m.m31);
    r.m32 = this.m32 + rate * (this.m32 - m.m32);
    r.m33 = this.m33 + rate * (this.m33 - m.m33);
    r.m34 = this.m34 + rate * (this.m34 - m.m34);
    r.m41 = this.m41 + rate * (this.m41 - m.m41);
    r.m42 = this.m42 + rate * (this.m42 - m.m42);
    r.m43 = this.m43 + rate * (this.m43 - m.m43);
    r.m44 = this.m44 + rate * (this.m44 - m.m44);
    return r;
  }
  /**
   * @access public
   * @returns {SCNVector4} -
   */


  quaternion() {
    const r = new SCNVector4();
    r.x = this.m32 - this.m23;
    r.y = this.m13 - this.m31;
    r.z = this.m21 - this.m12;
    r.w = Math.acos((this.m11 + this.m22 + this.m33 - 1) * 0.5);
    return r;
  }
  /**
   * @access public
   * @returns {SCNMatrix4} -
   */


  invert() {
    const mat = SCNMatrix4._identity();

    const tmp = new SCNMatrix4(this);
    let buf = 0;
    let w1 = Math.abs(tmp.m11);
    let w2 = Math.abs(tmp.m21);
    let w3 = Math.abs(tmp.m31);
    let w4 = Math.abs(tmp.m41);
    let max = w1 > w2 ? w1 : w2;
    if (max < w3) max = w3; // 1

    if (max < w4) {
      buf = 1.0 / tmp.m41;
      w1 = tmp.m11;
      w2 = tmp.m12;
      w3 = tmp.m13;
      w4 = tmp.m14;
      tmp.m12 = tmp.m42 * buf;
      tmp.m13 = tmp.m43 * buf;
      tmp.m14 = tmp.m44 * buf;
      tmp.m41 = w1;
      tmp.m42 = w2;
      tmp.m43 = w3;
      tmp.m44 = w4;
      mat.m11 = 0.0;
      mat.m14 = buf;
      mat.m41 = 1.0;
      mat.m44 = 0.0;
    } else if (max === w1) {
      buf = 1.0 / tmp.m11;
      tmp.m12 *= buf;
      tmp.m13 *= buf;
      tmp.m14 *= buf;
      mat.m11 = buf;
    } else if (max === w2) {
      buf = 1.0 / tmp.m21;
      w1 = tmp.m11;
      w2 = tmp.m12;
      w3 = tmp.m13;
      w4 = tmp.m14;
      tmp.m12 = tmp.m22 * buf;
      tmp.m13 = tmp.m23 * buf;
      tmp.m14 = tmp.m24 * buf;
      tmp.m21 = w1;
      tmp.m22 = w2;
      tmp.m23 = w3;
      tmp.m24 = w4;
      mat.m11 = 0.0;
      mat.m12 = buf;
      mat.m21 = 1.0;
      mat.m22 = 0.0;
    } else {
      buf = 1.0 / tmp.m31;
      w1 = tmp.m11;
      w2 = tmp.m12;
      w3 = tmp.m13;
      w4 = tmp.m14;
      tmp.m12 = tmp.m32 * buf;
      tmp.m13 = tmp.m33 * buf;
      tmp.m14 = tmp.m34 * buf;
      tmp.m31 = w1;
      tmp.m32 = w2;
      tmp.m33 = w3;
      tmp.m34 = w4;
      mat.m11 = 0.0;
      mat.m13 = buf;
      mat.m31 = 1.0;
      mat.m33 = 0.0;
    }

    buf = tmp.m21;
    tmp.m22 -= tmp.m12 * buf;
    tmp.m23 -= tmp.m13 * buf;
    tmp.m24 -= tmp.m14 * buf;
    mat.m21 -= mat.m11 * buf;
    mat.m22 -= mat.m12 * buf;
    mat.m23 -= mat.m13 * buf;
    mat.m24 -= mat.m14 * buf;
    buf = tmp.m31;
    tmp.m32 -= tmp.m12 * buf;
    tmp.m33 -= tmp.m13 * buf;
    tmp.m34 -= tmp.m14 * buf;
    mat.m31 -= mat.m11 * buf;
    mat.m32 -= mat.m12 * buf;
    mat.m33 -= mat.m13 * buf;
    mat.m34 -= mat.m14 * buf;
    buf = tmp.m41;
    tmp.m42 -= tmp.m12 * buf;
    tmp.m43 -= tmp.m13 * buf;
    tmp.m44 -= tmp.m14 * buf;
    mat.m41 -= mat.m11 * buf;
    mat.m42 -= mat.m12 * buf;
    mat.m43 -= mat.m13 * buf;
    mat.m44 -= mat.m14 * buf; // 2

    w2 = Math.abs(tmp.m22);
    w3 = Math.abs(tmp.m32);
    w4 = Math.abs(tmp.m42);
    max = w2 > w3 ? w2 : w3;

    if (max < w4) {
      buf = 1.0 / tmp.m42;
      w2 = tmp.m22;
      w3 = tmp.m23;
      w4 = tmp.m24;
      tmp.m23 = tmp.m43 * buf;
      tmp.m24 = tmp.m44 * buf;
      tmp.m42 = w2;
      tmp.m43 = w3;
      tmp.m44 = w4;
      w1 = mat.m21;
      w2 = mat.m22;
      w3 = mat.m23;
      w4 = mat.m24;
      mat.m21 = mat.m41 * buf;
      mat.m22 = mat.m42 * buf;
      mat.m23 = mat.m43 * buf;
      mat.m24 = mat.m44 * buf;
      mat.m41 = w1;
      mat.m42 = w2;
      mat.m43 = w3;
      mat.m44 = w4;
    } else if (w2 > w3) {
      buf = 1.0 / tmp.m22;
      tmp.m23 *= buf;
      tmp.m24 *= buf;
      mat.m21 *= buf;
      mat.m22 *= buf;
      mat.m23 *= buf;
      mat.m24 *= buf;
    } else {
      buf = 1.0 / tmp.m32;
      w2 = tmp.m22;
      w3 = tmp.m23;
      w4 = tmp.m24;
      tmp.m23 = tmp.m33 * buf;
      tmp.m24 = tmp.m34 * buf;
      tmp.m32 = w2;
      tmp.m33 = w3;
      tmp.m34 = w4;
      w1 = mat.m21;
      w2 = mat.m22;
      w3 = mat.m23;
      w4 = mat.m24;
      mat.m21 = mat.m31 * buf;
      mat.m22 = mat.m32 * buf;
      mat.m23 = mat.m33 * buf;
      mat.m24 = mat.m34 * buf;
      mat.m31 = w1;
      mat.m32 = w2;
      mat.m33 = w3;
      mat.m34 = w4;
    }

    buf = tmp.m12;
    tmp.m13 -= tmp.m23 * buf;
    tmp.m14 -= tmp.m24 * buf;
    mat.m11 -= mat.m21 * buf;
    mat.m12 -= mat.m22 * buf;
    mat.m13 -= mat.m23 * buf;
    mat.m14 -= mat.m24 * buf;
    buf = tmp.m32;
    tmp.m33 -= tmp.m23 * buf;
    tmp.m34 -= tmp.m24 * buf;
    mat.m31 -= mat.m21 * buf;
    mat.m32 -= mat.m22 * buf;
    mat.m33 -= mat.m23 * buf;
    mat.m34 -= mat.m24 * buf;
    buf = tmp.m42;
    tmp.m43 -= tmp.m23 * buf;
    tmp.m44 -= tmp.m24 * buf;
    mat.m41 -= mat.m21 * buf;
    mat.m42 -= mat.m22 * buf;
    mat.m43 -= mat.m23 * buf;
    mat.m44 -= mat.m24 * buf; // 3

    if (Math.abs(tmp.m33) > Math.abs(tmp.m43)) {
      buf = 1.0 / tmp.m33;
      tmp.m34 *= buf;
      mat.m31 *= buf;
      mat.m32 *= buf;
      mat.m33 *= buf;
      mat.m34 *= buf;
    } else {
      buf = 1.0 / tmp.m43;
      w3 = tmp.m33;
      w4 = tmp.m34;
      tmp.m34 = tmp.m44 * buf;
      tmp.m43 = w3;
      tmp.m44 = w4;
      w1 = mat.m31;
      w2 = mat.m32;
      w3 = mat.m33;
      w4 = mat.m34;
      mat.m31 = mat.m41 * buf;
      mat.m32 = mat.m42 * buf;
      mat.m33 = mat.m43 * buf;
      mat.m34 = mat.m44 * buf;
      mat.m41 = w1;
      mat.m42 = w2;
      mat.m43 = w3;
      mat.m44 = w4;
    }

    buf = tmp.m13;
    tmp.m14 -= tmp.m34 * buf;
    mat.m11 -= mat.m31 * buf;
    mat.m12 -= mat.m32 * buf;
    mat.m13 -= mat.m33 * buf;
    mat.m14 -= mat.m34 * buf;
    buf = tmp.m23;
    tmp.m24 -= tmp.m34 * buf;
    mat.m21 -= mat.m31 * buf;
    mat.m22 -= mat.m32 * buf;
    mat.m23 -= mat.m33 * buf;
    mat.m24 -= mat.m34 * buf;
    buf = tmp.m43;
    tmp.m44 -= tmp.m34 * buf;
    mat.m41 -= mat.m31 * buf;
    mat.m42 -= mat.m32 * buf;
    mat.m43 -= mat.m33 * buf;
    mat.m44 -= mat.m34 * buf; // 4

    buf = 1.0 / tmp.m44;
    mat.m41 *= buf;
    mat.m42 *= buf;
    mat.m43 *= buf;
    mat.m44 *= buf;
    buf = tmp.m14;
    mat.m11 -= mat.m41 * buf;
    mat.m12 -= mat.m42 * buf;
    mat.m13 -= mat.m43 * buf;
    mat.m14 -= mat.m44 * buf;
    buf = tmp.m24;
    mat.m21 -= mat.m41 * buf;
    mat.m22 -= mat.m42 * buf;
    mat.m23 -= mat.m43 * buf;
    mat.m24 -= mat.m44 * buf;
    buf = tmp.m34;
    mat.m31 -= mat.m41 * buf;
    mat.m32 -= mat.m42 * buf;
    mat.m33 -= mat.m43 * buf;
    mat.m34 -= mat.m44 * buf;
    return mat;
  }
  /**
   * @access public
   * @returns {SCNMatrix4} -
   */


  transpose() {
    const r = new SCNMatrix4();
    r.m11 = this.m11;
    r.m12 = this.m21;
    r.m13 = this.m31;
    r.m14 = this.m41;
    r.m21 = this.m12;
    r.m22 = this.m22;
    r.m23 = this.m32;
    r.m24 = this.m42;
    r.m31 = this.m13;
    r.m32 = this.m23;
    r.m33 = this.m33;
    r.m34 = this.m43;
    r.m41 = this.m14;
    r.m42 = this.m24;
    r.m43 = this.m34;
    r.m44 = this.m44;
    return r;
  }
  /**
   * @access public
   * @param {number} x -
   * @param {number} y -
   * @param {number} z -
   * @returns {SCNMatrix4} -
   */


  scale(x, y, z) {
    const m = SCNMatrix4.matrixWithScale(x, y, z);
    return this.mult(m);
  }
  /**
   * @access public
   * @param {number} x -
   * @param {number} y -
   * @param {number} z -
   * @returns {SCNMatrix4} -
   */


  static matrixWithScale(x, y, z) {
    let _x = x;
    let _y = y;
    let _z = z;

    if (_InstanceOf(x, SCNVector3)) {
      const v = x;
      _x = v.x;
      _y = v.y;
      _z = v.z;
    } //const m = new SCNMatrix4()


    const m = SCNMatrix4._identity();

    m.m11 = _x;
    m.m22 = _y;
    m.m33 = _z;
    return m;
  }
  /**
   * @access public
   * @param {number} x -
   * @param {number} y -
   * @param {number} z -
   * @param {number} w -
   * @returns {SCNMatrix4} -
   */


  rotation(x, y, z, w) {
    if (_InstanceOf(x, SCNVector4)) {
      const v = x;
      x = v.x;
      y = v.y;
      z = v.z;
      w = v.w;
    }

    const m = SCNMatrix4.matrixWithRotation(x, y, z, w);
    return this.mult(m);
  }
  /**
   * @access public
   * @param {number} x -
   * @param {number} y -
   * @param {number} z -
   * @param {number} w -
   * @returns {SCNMatrix4} -
   */


  static matrixWithRotation(x, y, z, w) {
    if (_InstanceOf(x, SCNVector4)) {
      const v = x;
      x = v.x;
      y = v.y;
      z = v.z;
      w = v.w;
    }

    const c = Math.cos(w);
    const s = Math.sin(w);
    const v = new SCNVector3(x, y, z).normalize();

    const m = SCNMatrix4._identity();

    const nx = v.x;
    const ny = v.y;
    const nz = v.z;
    m.m11 = nx * nx * (1.0 - c) + c;
    m.m12 = ny * nx * (1.0 - c) + nz * s;
    m.m13 = nz * nx * (1.0 - c) - ny * s;
    m.m14 = 0.0;
    m.m21 = nx * ny * (1.0 - c) - nz * s;
    m.m22 = ny * ny * (1.0 - c) + c;
    m.m23 = nz * ny * (1.0 - c) + nx * s;
    m.m24 = 0.0;
    m.m31 = nx * nz * (1.0 - c) + ny * s;
    m.m32 = ny * nz * (1.0 - c) - nx * s;
    m.m33 = nz * nz * (1.0 - c) + c;
    m.m34 = 0.0;
    m.m41 = 0.0;
    m.m42 = 0.0;
    m.m43 = 0.0;
    m.m44 = 1.0;
    return m;
  }

  static matrixWithOrientation(orientation) {
    return SCNMatrix4.matrixWithRotation(orientation.quatToRotation());
  }
  /**
   * @access public
   * @param {number} x -
   * @param {number} y -
   * @param {number} z -
   * @returns {SCNMatrix4} -
   */


  translation(x, y, z) {
    const m = SCNMatrix4.matrixWithTranslation(x, y, z);
    return this.mult(m);
  }
  /**
   * @access public
   * @param {number} x -
   * @param {number} y -
   * @param {number} z -
   * @returns {SCNMatrix4} -
   */


  static matrixWithTranslation(x, y, z) {
    let _x = x;
    let _y = y;
    let _z = z;

    if (_InstanceOf(x, SCNVector3)) {
      const v = x;
      _x = v.x;
      _y = v.y;
      _z = v.z;
    } //const m = new SCNMatrix4()


    const m = SCNMatrix4._identity();

    m.m41 = _x;
    m.m42 = _y;
    m.m43 = _z;
    return m;
  }
  /**
   * Returns a Boolean value that indicates whether the corresponding elements of two matrices are equal.
   * @access public
   * @param {SCNMatrix4} m -
   * @returns {boolean} -
   * @desc This function performs a numeric (not bitwise) comparison of each pair of elements.
   * @see https://developer.apple.com/documentation/scenekit/1409665-scnmatrix4equaltomatrix4
   */


  equalTo(m) {
    if (!_InstanceOf(m, SCNMatrix4)) {
      return false;
    }

    return Math.abs(this.m11 - m.m11) < _epsilon && Math.abs(this.m12 - m.m12) < _epsilon && Math.abs(this.m13 - m.m13) < _epsilon && Math.abs(this.m14 - m.m14) < _epsilon && Math.abs(this.m21 - m.m21) < _epsilon && Math.abs(this.m22 - m.m22) < _epsilon && Math.abs(this.m23 - m.m23) < _epsilon && Math.abs(this.m24 - m.m24) < _epsilon && Math.abs(this.m31 - m.m31) < _epsilon && Math.abs(this.m32 - m.m32) < _epsilon && Math.abs(this.m33 - m.m33) < _epsilon && Math.abs(this.m34 - m.m34) < _epsilon && Math.abs(this.m41 - m.m41) < _epsilon && Math.abs(this.m42 - m.m42) < _epsilon && Math.abs(this.m43 - m.m43) < _epsilon && Math.abs(this.m44 - m.m44) < _epsilon;
  }
  /**
   * Returns a Boolean value that indicates whether the matrix is equal to the identity matrix.
   * @access public
   * @returns {boolean} - 
   * @see https://developer.apple.com/documentation/scenekit/1409715-scnmatrix4isidentity
   */


  isIdentity() {
    return this.equalTo(SCNMatrix4._identity());
  }
  /**
   * @access public
   * @returns {SCNVector3} -
   */


  getScale() {
    const det = this.m11 * this.m22 * this.m33 + this.m12 * this.m23 * this.m31 + this.m13 * this.m21 * this.m32 - this.m11 * this.m23 * this.m32 - this.m12 * this.m21 * this.m33 - this.m13 * this.m22 * this.m31;
    const sign = det > 0 ? 1 : -1;
    const r = sign / this.m44;
    const sx = new SCNVector3(this.m11, this.m12, this.m13);
    const sy = new SCNVector3(this.m21, this.m22, this.m23);
    const sz = new SCNVector3(this.m31, this.m32, this.m33);
    return new SCNVector3(sx.length() * r, sy.length() * r, sz.length() * r);
  }
  /**
   * @access public
   * @returns {SCNVector3} -
   */


  getTranslation() {
    return new SCNVector3(this.m41 / this.m44, this.m42 / this.m44, this.m43 / this.m44);
  }
  /**
   * @access public
   * @returns {SCNVector4} -
   */


  getRotation() {
    const e = [];
    const scale = this.getScale().mul(this.m44);
    const v = new SCNVector4();
    const n1 = new SCNVector3(this.m11, this.m12, this.m13).mul(1.0 / scale.x);
    const n2 = new SCNVector3(this.m21, this.m22, this.m23).mul(1.0 / scale.y);
    const n3 = new SCNVector3(this.m31, this.m32, this.m33).mul(1.0 / scale.z);
    e[0] = n1.x - n2.y - n3.z + 1.0;
    e[1] = -n1.x + n2.y - n3.z + 1.0;
    e[2] = -n1.x - n2.y + n3.z + 1.0;
    e[3] = n1.x + n2.y + n3.z + 1.0;
    let maxIndex = 0;

    for (let i = 1; i < 4; i++) {
      if (e[i] > e[maxIndex]) {
        maxIndex = i;
      }
    }

    if (e[maxIndex] < 0) {
      throw new Error('something is wrong...');
    }

    const d = Math.sqrt(e[maxIndex]) * 0.5;
    const r = 0.25 / d; //console.log(`n1: ${n1.x}, ${n1.y}, ${n1.z}`)
    //console.log(`n2: ${n2.x}, ${n2.y}, ${n2.z}`)
    //console.log(`n3: ${n3.x}, ${n3.y}, ${n3.z}`)
    //console.log(`d: ${d}, r: ${r}`)

    switch (maxIndex) {
      case 0:
        v.x = d;
        v.y = (n1.y + n2.x) * r;
        v.z = (n3.x + n1.z) * r;
        v.w = (n2.z - n3.y) * r;
        break;

      case 1:
        v.x = (n1.y + n2.x) * r;
        v.y = d;
        v.z = (n2.z + n3.y) * r;
        v.w = (n3.x - n1.z) * r;
        break;

      case 2:
        v.x = (n3.x + n1.z) * r;
        v.y = (n2.z + n3.y) * r;
        v.z = d;
        v.w = (n1.y - n2.x) * r;
        break;

      case 3:
        v.x = (n2.z - n3.y) * r;
        v.y = (n3.x - n1.z) * r;
        v.z = (n1.y - n2.x) * r;
        v.w = d;
        break;
    }

    if (v.x === 0 && v.y === 0 && v.z === 0) {
      v.w = 0;
    } else {
      const w = Math.acos(v.w);

      if (isNaN(w)) {
        v.w = 0;
      } else {
        v.w = w * 2.0;
      }
    }

    return v;
  }
  /**
   * @access public
   * @returns {SCNVector4} -
   */


  getOrientation() {
    return this.getRotation().rotationToQuat();
    /*
    const e = []
    const scale = this.getScale().mul(this.m44)
    const v = new SCNVector4()
    const n1 = (new SCNVector3(this.m11, this.m12, this.m13)).mul(1.0 / scale.x)
    const n2 = (new SCNVector3(this.m21, this.m22, this.m23)).mul(1.0 / scale.y)
    const n3 = (new SCNVector3(this.m31, this.m32, this.m33)).mul(1.0 / scale.z)
    e[0] = n1.x - n2.y - n3.z + 1.0
    e[1] = -n1.x + n2.y - n3.z + 1.0
    e[2] = -n1.x - n2.y + n3.z + 1.0
    e[3] = n1.x + n2.y + n3.z + 1.0
    let maxIndex = 0
    for(let i=1; i<4; i++){
      if(e[i] > e[maxIndex]){
        maxIndex = i
      }
    }
    console.log(`maxIndex: ${maxIndex} => ${e[maxIndex]}`)
    if(e[maxIndex] < 0){
      throw new Error('something is wrong...')
    }
    const d = Math.sqrt(e[maxIndex]) * 0.5
    const r = 0.25 / d
     //console.log(`n1: ${n1.x}, ${n1.y}, ${n1.z}`)
    //console.log(`n2: ${n2.x}, ${n2.y}, ${n2.z}`)
    //console.log(`n3: ${n3.x}, ${n3.y}, ${n3.z}`)
    //console.log(`d: ${d}, r: ${r}`)
    switch(maxIndex){
      case 0:
        v.x = d
        v.y = (n1.y + n2.x) * r
        v.z = (n3.x + n1.z) * r
        v.w = (n2.z - n3.y) * r
        break
      case 1:
        v.x = (n1.y + n2.x) * r
        v.y = d
        v.z = (n2.z + n3.y) * r
        v.w = (n3.x - n1.z) * r
        break
      case 2:
        v.x = (n3.x + n1.z) * r
        v.y = (n2.z + n3.y) * r
        v.z = d
        v.w = (n1.y - n2.x) * r
        break
      case 3:
        v.x = (n2.z - n3.y) * r
        v.y = (n3.x - n1.z) * r
        v.z = (n1.y - n2.x) * r
        v.w = d
        break
    }
    const len = 1.0 / Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z)
    v.x *= len
    v.y *= len
    v.z *= len
     return v
    */
  }
  /**
   * @access public
   * @returns {number[]} -
   */


  floatArray() {
    return [this.m11, this.m12, this.m13, this.m14, this.m21, this.m22, this.m23, this.m24, this.m31, this.m32, this.m33, this.m34, this.m41, this.m42, this.m43, this.m44];
  }
  /**
   * @access public
   * @returns {Float32Array} -
   */


  float32Array() {
    return new Float32Array([this.m11, this.m12, this.m13, this.m14, this.m21, this.m22, this.m23, this.m24, this.m31, this.m32, this.m33, this.m34, this.m41, this.m42, this.m43, this.m44]);
  }
  /**
   * @access public
   * @returns {number[]} -
   */


  floatArray3x4f() {
    return [this.m11, this.m21, this.m31, this.m41, this.m12, this.m22, this.m32, this.m42, this.m13, this.m23, this.m33, this.m43];
  }
  /**
   * @access public
   * @returns {Float32Array} -
   */


  float32Array3x4f() {
    return new Float32Array([this.m11, this.m21, this.m31, this.m41, this.m12, this.m22, this.m32, this.m42, this.m13, this.m23, this.m33, this.m43]);
  }

  static _identity() {
    return new SCNMatrix4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
  }

}

/**
 * A representation of a four-component vector.
 * @access public
 * @see https://developer.apple.com/documentation/scenekit/scnvector4
 */

class SCNVector4 {
  // Initializers

  /**
   * 
   * @access public
   * @constructor
   * @param {number} x - 
   * @param {number} y - 
   * @param {number} z - 
   * @param {number} w - 
   * @see https://developer.apple.com/documentation/scenekit/scnvector4/1523931-init
   */
  constructor(x = 0, y = 0, z = 0, w = 0) {
    // Instance Properties

    /** @type {number} */
    this.x = x;
    /** @type {number} */

    this.y = y;
    /** @type {number} */

    this.z = z;
    /** @type {number} */

    this.w = w; //if(x instanceof Ammo.btVector4){
    //  this.x = x.x()
    //  this.y = x.y()
    //  this.z = x.z()
    //  this.w = x.w()
    //}
  }
  /**
   * @access private
   * @param {Buffer} data -
   * @param {number} [offset = 0] -
   * @param {boolean} [bigEndian = false] -
   * @returns {SCNVector4} -
   */


  static _initWithData(data, offset = 0, bigEndian = false) {
    const instance = new SCNVector4();

    if (bigEndian) {
      instance.x = data.readFloatBE(offset + 0);
      instance.y = data.readFloatBE(offset + 4);
      instance.z = data.readFloatBE(offset + 8);
      instance.w = data.readFloatBE(offset + 12);
    } else {
      instance.x = data.readFloatLE(offset + 0);
      instance.y = data.readFloatLE(offset + 4);
      instance.z = data.readFloatLE(offset + 8);
      instance.w = data.readFloatLE(offset + 12);
    }

    return instance;
  }

  _copy() {
    return new SCNVector4(this.x, this.y, this.z, this.w);
  }

  _copyFrom(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    this.w = v.z;
  } // extensions


  zero() {
    return new SCNVector4();
  }
  /**
   * @access public
   * @param {SCNVector4} v -
   * @returns {SCNVector4} -
   */


  add(v) {
    const r = new SCNVector4();
    r.x = this.x + v.x;
    r.y = this.y + v.y;
    r.z = this.z + v.z;
    r.w = this.w + v.w;
    return r;
  }
  /**
   * @access public
   * @param {SCNVector4} v -
   * @returns {SCNVector4} -
   */


  sub(v) {
    const r = new SCNVector4();
    r.x = this.x - v.x;
    r.y = this.y - v.y;
    r.z = this.z - v.z;
    r.w = this.w - v.w;
    return r;
  }
  /**
   * @access public
   * @param {number} n -
   * @returns {SCNVector4} -
   */


  mul(n) {
    const r = new SCNVector4();
    r.x = this.x * n;
    r.y = this.y * n;
    r.z = this.z * n;
    r.w = this.w * n;
    return r;
  }
  /**
   * @access public
   * @param {SCNVector4} v -
   * @returns {SCNVector4}
   */


  mulv(v) {
    const r = new SCNVector4();
    r.x = this.x * v.x;
    r.y = this.y * v.y;
    r.z = this.z * v.z;
    r.z = this.w * v.w;
    return r;
  }
  /**
   * @access public
   * @param {SCNVector4} v -
   * @returns {number} -
   */


  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
  }
  /**
   * @access public
   * @param {SCNVecor4} v -
   * @returns {SCNVector4} -
   */


  cross(v) {
    const r = new SCNVector4();
    r.x = this.w * v.x + this.x * v.w + this.y * v.z - this.z * v.y;
    r.y = this.w * v.y - this.x * v.z + this.y * v.w + this.z * v.x;
    r.z = this.w * v.z + this.x * v.y - this.y * v.x + this.z * v.w;
    r.w = this.w * v.w - this.x * v.x - this.y * v.y - this.z * v.z;
    return r;
  }
  /**
   * @access public
   * @param {SCNVector4} v -
   * @param {number} rate -
   * @returns {SCNVector4} -
   */


  lerp(v, rate) {
    const r = new SCNVector4();
    r.x = this.x + rate * (v.x - this.x);
    r.y = this.y + rate * (v.y - this.y);
    r.z = this.z + rate * (v.z - this.z);
    r.w = this.w + rate * (v.w - this.w);
    return r;
  }
  /**
   * @access public
   * @param {SCNVector4} v -
   * @param {number} rate -
   * @returns {SCNVector4} -
   */


  slerp(v, rate) {
    const r = new SCNVector4();
    const qr = this.dot(v);

    if (qr < 0) {
      r.x = this.x - (this.x + v.x) * rate;
      r.y = this.y - (this.y + v.y) * rate;
      r.z = this.z - (this.z + v.z) * rate;
      r.w = this.w - (this.w + v.w) * rate;
    } else {
      r.x = this.x + (v.x - this.x) * rate;
      r.y = this.y + (v.y - this.y) * rate;
      r.z = this.z + (v.z - this.z) * rate;
      r.w = this.w + (v.w - this.w) * rate;
    }

    return r.normalize();
  }
  /**
   * @access public
   * @returns {SCNVector4} -
   */


  normalize() {
    const r = new SCNVector4();
    const sqr = 1.0 / this.length();
    r.x = this.x * sqr;
    r.y = this.y * sqr;
    r.z = this.z * sqr;
    r.w = this.w * sqr;
    return r;
  }
  /**
   * @access public
   * @returns {number} -
   */


  length2() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  /**
   * @access public
   * @returns {number} -
   */


  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }

  transform(m) {
    const r = new SCNVector4();
    r.x = this.x * m.m11 + this.y * m.m21 + this.z * m.m31 + this.w * m.m41;
    r.y = this.x * m.m12 + this.y * m.m22 + this.z * m.m32 + this.w * m.m42;
    r.z = this.x * m.m13 + this.y * m.m23 + this.z * m.m33 + this.w * m.m43;
    r.w = this.x * m.m14 + this.y * m.m24 + this.z * m.m34 + this.w * m.m44;
    return r;
  }
  /**
   * @access public
   * @returns {SCNVector4} -
   */


  ln() {
    const r = new SCNVector4();
    const v = this.normalize();
    const n = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);

    if (n === 0) {
      r.x = 0;
      r.y = 0;
      r.z = 0;
      r.w = 0;
      return r;
    }

    const theta = Math.atan2(n, v.w) / n;
    r.x = theta * v.x;
    r.y = theta * v.y;
    r.z = theta * v.z;
    r.w = 0;
    return r;
  }
  /**
   * @access public
   * @returns {SCNVector4} -
   */


  exp() {
    const r = new SCNVector4();
    const n = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);

    if (n > 0.0) {
      const sinn = Math.sin(n);
      r.x = sinn * this.x / n;
      r.y = sinn * this.y / n;
      r.z = sinn * this.z / n;
      r.w = Math.cos(n);
    } else {
      r.x = 0.0;
      r.y = 0.0;
      r.z = 0.0;
      r.w = 1.0;
    }

    return r;
  }
  /**
   * @access public
   * @returns {SCNMatrix4} -
   */


  rotMatrix() {
    const r = new SCNMatrix4();
    const x2 = this.x * this.x * 2.0;
    const y2 = this.y * this.y * 2.0;
    const z2 = this.z * this.z * 2.0;
    const xy = this.x * this.y * 2.0;
    const yz = this.y * this.z * 2.0;
    const zx = this.z * this.x * 2.0;
    const xw = this.x * this.w * 2.0;
    const yw = this.y * this.w * 2.0;
    const zw = this.z * this.w * 2.0;
    r.m11 = 1.0 - y2 - z2;
    r.m12 = xy + zw;
    r.m13 = zx - yw;
    r.m14 = 0.0;
    r.m21 = xy - zw;
    r.m22 = 1.0 - z2 - x2;
    r.m23 = yz + xw;
    r.m24 = 0.0;
    r.m31 = zx + yw;
    r.m32 = yz - xw;
    r.m33 = 1.0 - x2 - y2;
    r.m34 = 0.0;
    r.m41 = 0.0;
    r.m42 = 0.0;
    r.m43 = 0.0;
    r.m44 = 1.0;
    return r;
  }
  /**
   * @access public
   * @returns {SCNVector4} -
   */


  rotationToQuat() {
    const quat = new SCNVector4();

    if (this.x === 0 && this.y === 0 && this.z === 0) {
      quat.x = 0;
      quat.y = 0;
      quat.z = 0;
      quat.w = 1.0;
    } else {
      const r = 1.0 / Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      const cosW = Math.cos(this.w * 0.5);
      const sinW = Math.sin(this.w * 0.5) * r;
      quat.x = this.x * sinW;
      quat.y = this.y * sinW;
      quat.z = this.z * sinW;
      quat.w = cosW;
    }

    return quat;
  }
  /**
   * @access public
   * @returns {SCNVector4} -
   */


  quatToRotation() {
    const rot = new SCNVector4();

    if (this.x === 0 && this.y === 0 && this.z === 0) {
      rot.x = 0;
      rot.y = 0;
      rot.z = 0;

      if (Math.abs(this.w) > 1) {
        // actually, if this.w < -1, rotation will be NaN...
        rot.w = 0;
      } else {
        // I don't know why it needs to be double but I make it the same as SceneKit
        rot.w = Math.acos(this.w) * 2.0;
      }
    } else {
      const quat = this.normalize();
      const r = 1.0 / Math.sqrt(quat.x * quat.x + quat.y * quat.y + quat.z * quat.z);
      rot.x = quat.x * r;
      rot.y = quat.y * r;
      rot.z = quat.z * r;
      const w = Math.acos(quat.w);

      if (isNaN(w)) {
        rot.w = 0;
      } else {
        // I don't know why it needs to be double but I make it the same as SceneKit
        rot.w = w * 2.0;
      }
    }

    return rot;
  }
  /**
   * @access public
   * @returns {SCNVector3} -
   */


  rotationToEulerAngles() {
    const euler = new SCNVector3();
    const sinW = Math.sin(this.w);
    const cosW = Math.cos(this.w);
    const cosWR = 1.0 - cosW;
    const len2 = this.x * this.x + this.y * this.y + this.z * this.z;

    if (len2 === 0) {
      return euler;
    }

    const r = 1.0 / Math.sqrt(len2);
    const x = this.x * r;
    const y = this.y * r;
    const z = this.z * r;
    const s = y * sinW - x * z * cosWR; //console.log(`s: ${s}`)
    //const threshold = 0.998

    const threshold = 0.999999;

    if (s > threshold) {
      // TODO: check SceneKit implementation
      euler.x = 0;
      euler.y = -Math.PI * 0.5;
      euler.z = -2.0 * Math.atan2(z * Math.sin(this.w * 0.5), Math.cos(this.w * 0.5));
    } else if (s < -threshold) {
      // TODO: check SceneKit implementation
      euler.x = 0;
      euler.y = Math.PI * 0.5;
      euler.z = 2.0 * Math.atan2(z * Math.sin(this.w * 0.5), Math.cos(this.w * 0.5));
    } else {
      const m23 = x * sinW + y * z * cosWR; //const m33 = 1 - (y * y + x * x) * cosWR

      const m33 = cosW + z * z * cosWR;
      const m12 = z * sinW + x * y * cosWR; //const m11 = 1 - (z * z + y * y) * cosWR

      const m11 = cosW + x * x * cosWR;
      euler.x = Math.atan2(m23, m33);
      euler.y = Math.asin(s); // How can I get euler.y > pi/2 ?

      euler.z = Math.atan2(m12, m11);
    }

    return euler;
  }
  /**
   * @access public
   * @returns {SCNVector3} -
   */


  quatToEulerAngles() {
    return this.quatToRotation().rotationToEulerAngles();
  }

  get angle() {
    return this.quatToRotation().w;
  }
  /**
   * @access public
   * @returns {number[]} -
   */


  floatArray() {
    return [this.x, this.y, this.z, this.w];
  }
  /**
   * @access public
   * @returns {Float32Array} -
   */


  float32Array() {
    return new Float32Array([this.x, this.y, this.z, this.w]);
  }
  /**
   * @access private
   * @returns {Ammo.btVector4} -
   * @desc call Ammo.destroy(vec) after using it.
   */


  _createBtVector4() {} //return new Ammo.btVector4(this.x, this.y, this.z, this.w)

  /**
   * @access private
   * @returns {Ammo.btQuaternion} -
   * @desc call Ammo.destroy(quat) after using it.
   */


  _createBtQuaternion() {//return new Ammo.btQuaternion(this.x, this.y, this.z, this.w)
  }

}

/**
 * A representation of a three-component vector.
 * @access public
 * @see https://developer.apple.com/documentation/scenekit/scnvector3
 */

class SCNVector3 {
  // Initializers

  /**
   * 
   * @access public
   * @constructor
   * @param {number} x - 
   * @param {number} y - 
   * @param {number} z - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnvector3/1522904-init
   */
  constructor(x = 0, y = 0, z = 0) {
    // Instance Properties

    /** @type {number} */
    this.x = x;
    /** @type {number} */

    this.y = y;
    /** @type {number} */

    this.z = z; //if(x instanceof Ammo.btVector3){
    //  this.x = x.x()
    //  this.y = x.y()
    //  this.z = x.z()
    //}
  }
  /**
   * @access private
   * @param {Buffer} data -
   * @param {number} [offset = 0] -
   * @param {boolean} [bigEndian = false] -
   * @returns {SCNVector3} -
   */


  static _initWithData(data, offset = 0, bigEndian = false) {
    const instance = new SCNVector3();

    if (bigEndian) {
      instance.x = data.readFloatBE(offset + 0);
      instance.y = data.readFloatBE(offset + 4);
      instance.z = data.readFloatBE(offset + 8);
    } else {
      instance.x = data.readFloatLE(offset + 0);
      instance.y = data.readFloatLE(offset + 4);
      instance.z = data.readFloatLE(offset + 8);
    }

    return instance;
  }

  _copy() {
    return new SCNVector3(this.x, this.y, this.z);
  }

  _copyFrom(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
  } // extensions


  zero() {
    return new SCNVector3();
  }
  /**
   * @access public
   * @param {SCNVector3} v -
   * @returns {SCNVector3} -
   */


  add(v) {
    const r = new SCNVector3();
    r.x = this.x + v.x;
    r.y = this.y + v.y;
    r.z = this.z + v.z;
    return r;
  }
  /**
   * @access public
   * @param {SCNVector3} v -
   * @returns {SCNVector3} -
   */


  sub(v) {
    const r = new SCNVector3();
    r.x = this.x - v.x;
    r.y = this.y - v.y;
    r.z = this.z - v.z;
    return r;
  }
  /**
   * @access public
   * @param {number} n -
   * @returns {SCNVector3} -
   */


  mul(n) {
    const r = new SCNVector3();
    r.x = this.x * n;
    r.y = this.y * n;
    r.z = this.z * n;
    return r;
  }
  /**
   * @access public
   * @param {SCNVector3} v -
   * @returns {SCNVector3}
   */


  mulv(v) {
    const r = new SCNVector3();
    r.x = this.x * v.x;
    r.y = this.y * v.y;
    r.z = this.z * v.z;
    return r;
  }
  /**
   * @access public
   * @param {SCNVector3} v -
   * @returns {number} -
   */


  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  }
  /**
   * @access public
   * @param {SCNVecor3} v -
   * @returns {SCNVector3} -
   */


  cross(v) {
    const r = new SCNVector3();
    r.x = this.y * v.z - this.z * v.y;
    r.y = this.z * v.x - this.x * v.z;
    r.z = this.x * v.y - this.y * v.x;
    return r;
  }
  /**
   * @access public
   * @param {SCNVector3} v -
   * @param {number} rate -
   * @returns {SCNVector3} -
   */


  lerp(v, rate) {
    const r = new SCNVector3();
    r.x = this.x + rate * (v.x - this.x);
    r.y = this.y + rate * (v.y - this.y);
    r.z = this.z + rate * (v.z - this.z);
    return r;
  }
  /**
   * @access public
   * @returns {SCNVector3} -
   */


  normalize() {
    const len = this.length();
    const r = new SCNVector3();

    if (len === 0) {
      return r;
    }

    const sqr = 1.0 / len;
    r.x = this.x * sqr;
    r.y = this.y * sqr;
    r.z = this.z * sqr;
    return r;
  }
  /**
   * @access public
   * @returns {number} -
   */


  length2() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  /**
   * @access public
   * @returns {number} -
   */


  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  /**
   * @access public
   * @param {SCNMatrix4} m -
   * @returns {SCNVector3} -
   */


  transform(m) {
    const r = new SCNVector3();
    const w = this.x * m.m14 + this.y * m.m24 + this.z * m.m34 + m.m44;

    if (w === 0) {
      return r;
    }

    const iw = 1.0 / w;
    r.x = (this.x * m.m11 + this.y * m.m21 + this.z * m.m31 + m.m41) * iw;
    r.y = (this.x * m.m12 + this.y * m.m22 + this.z * m.m32 + m.m42) * iw;
    r.z = (this.x * m.m13 + this.y * m.m23 + this.z * m.m33 + m.m43) * iw;
    return r;
  }
  /**
   * @access public
   * @param {SCNMatrix4} m -
   * @returns {SCNVector3} -
   */


  rotate(m) {
    const r = new SCNVector3();
    r.x = this.x * m.m11 + this.y * m.m21 + this.z * m.m31;
    r.y = this.x * m.m12 + this.y * m.m22 + this.z * m.m32;
    r.z = this.x * m.m13 + this.y * m.m23 + this.z * m.m33;
    return r;
  }
  /**
   * @access public
   * @param {SCNVector4} q -
   * @returns {SCNVector3} -
   */


  rotateWithQuaternion(q) {
    return this.rotate(q.rotMatrix());
  }
  /**
   * @access public
   * @returns {SCNVector4} -
   */


  eulerAnglesToRotation() {
    const rot = new SCNVector4();
    const halfX = this.x * 0.5;
    const halfY = this.y * 0.5;
    const halfZ = this.z * 0.5;
    const cosX = Math.cos(halfX);
    const sinX = Math.sin(halfX);
    const cosY = Math.cos(halfY);
    const sinY = Math.sin(halfY);
    const cosZ = Math.cos(halfZ);
    const sinZ = Math.sin(halfZ);
    const x = sinX * cosY * cosZ - cosX * sinY * sinZ;
    const y = cosX * sinY * cosZ + sinX * cosY * sinZ;
    const z = cosX * cosY * sinZ - sinX * sinY * cosZ;
    const d = x * x + y * y + z * z;

    if (d === 0) {
      rot.x = 0;
      rot.y = 0;
      rot.z = 0;
      rot.w = 0;
    } else {
      const r = 1.0 / Math.sqrt(d);
      rot.x = x * r;
      rot.y = y * r;
      rot.z = z * r;
      rot.w = 2 * Math.acos(cosX * cosY * cosZ + sinX * sinY * sinZ);
    }

    return rot;
  }
  /**
   * @access public
   * @returns {SCNVector4} -
   */


  eulerAnglesToQuat() {
    return this.eulerAnglesToRotation().rotationToQuat();
  }
  /**
   * @access public
   * @returns {number[]} -
   */


  floatArray() {
    return [this.x, this.y, this.z];
  }
  /**
   * @access public
   * @returns {Float32Array} -
   */


  float32Array() {
    return new Float32Array([this.x, this.y, this.z]);
  }
  /**
   * @access private
   * @returns {Ammo.btVector3} -
   * @desc call Ammo.destroy(vec) after using it.
   */


  _createBtVector3() {//return new Ammo.btVector3(this.x, this.y, this.z)
  }

}

/**
 * A polygonal path that can be followed by an agent.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/gameplaykit/gkpath
 */

class GKPath extends NSObject {
  /**
   * @access public
   * @constructor
   */
  constructor() {
    super(); // Managing a Path’s Attributes

    /**
     * The radius of the path.
     * @type {number}
     * @see https://developer.apple.com/documentation/gameplaykit/gkpath/1501281-radius
     */

    this.radius = 0;
    /**
     * A Boolean value that determines whether the path loops around on itself (that is, the path’s end point connects to its start point).
     * @type {boolean}
     * @see https://developer.apple.com/documentation/gameplaykit/gkpath/1501244-iscyclical
     */

    this.isCyclical = false; // Inspecting a Path’s Shape

    this._points = [];
  } // Creating a Path

  /**
   * Initializes a path with the specified array of 2D points.
   * @access public
   * @param {UnsafeMutablePointer<vector_float2>} points - An array of 2D points representing the vertices in the path. The order of points in this array determines the order in which an agent follows the path.
   * @param {number} count - The number of elements in the pointsarray.
   * @param {number} radius - The radius of the path.
   * @param {boolean} cyclical - true if the path’s end point should connect to its start point; otherwise false.
   * @return {GKPath}
   * @desc The radius parameter defines the space occupied by the path—think of this space as the area created by sweeping a circle of the specified radius along the path from vertex to vertex. Agents with path-related goals will attempt to move to or stay within this area.The cyclical parameter determines whether the path loops around on itself. If the path is cyclical, an agent with a follow-path goal will proceed around the path indefinitely. If the path is not cyclical, an agent following the path will stop at the last point in the path.To use the newly created path to constrain an agent’s behavior, create a goal with the init(toStayOn:maxPredictionTime:) or init(toFollow:maxPredictionTime:forward:) method.
   * @see https://developer.apple.com/documentation/gameplaykit/gkpath/1501048-init
   */


  static pathWithPointsCountRadiusCyclical(points, count, radius, cyclical) {
    const path = new GKPath();

    path._points.push(...points.slice(0, count));

    path.radius = radius;
    path.isCyclical = cyclical;
    return path;
  }
  /**
   * Initializes a path with the specified array of 3D points.
   * @access public
   * @param {UnsafeMutablePointer<vector_float3>} points - An array of points representing the vertices in the path. The order of points in this array determines the order in which an agent follows the path.
   * @param {number} count - The number of elements in the pointsarray.
   * @param {number} radius - The radius of the path.
   * @param {boolean} cyclical - true if the path’s end point (the last element of the points array) should connect to its start point (the first element in the points array); otherwise false.
   * @returns {GKPath}
   * @desc The radius parameter defines the space occupied by the path—think of this space as the volume created by sweeping a sphere of the specified radius along the path from vertex to vertex. Agents with path-related goals will attempt to move to or stay within this volume.The cyclical parameter determines whether the path loops around on itself. If the path is cyclical, an agent with a follow-path goal will proceed around the path indefinitely. If the path is not cyclical, an agent following the path will stop at the last point in the path.To use the newly created path to constrain an agent’s behavior, create a goal with the init(toStayOn:maxPredictionTime:) or init(toFollow:maxPredictionTime:forward:) method.
   * @see https://developer.apple.com/documentation/gameplaykit/gkpath/1778297-init
   */


  static pathWithFloat3PointsCountRadiusCyclical(points, count, radius, cyclical) {
    const path = new GKPath();

    path._points.push(...points.slice(0, count));

    path.radius = radius;
    path.isCyclical = cyclical;
    return path;
  }
  /**
   * Initializes a path using the positions of the specified graph nodes.
   * @access public
   * @param {GKGraphNode[]} graphNodes - An array of graph node objects containing 2D points.
   * @param {number} radius - The radius of the path.
   * @returns {GKPath}
   * @desc Use this initializer to turn a list of nodes from a navigation graph (as returned by the GKGraphfindPath(from:to:) method) into a path-following goal for an agent. If the nodes are GKGraphNode2D objects, this initializer creates a 2D path; if the nodes are GKGraphNode3D objects, this initializer creates a 3D path.The radius parameter defines the space occupied by the path—think of this space as the area created by sweeping a circle (or sphere, for 3D paths) of the specified radius along the path from vertex to vertex. Agents with path-related goals will attempt to move to or stay within this area.To use the newly created path to constrain an agent’s behavior, create a goal with the init(toStayOn:maxPredictionTime:) or init(toFollow:maxPredictionTime:forward:) method.
   * @see https://developer.apple.com/documentation/gameplaykit/gkpath/1501138-init
   */


  static pathWithGraphNodesRadius(graphNodes, radius) {
    const path = new GKPath(); // TODO: implement

    path.radius = radius;
    return path;
  }
  /**
   *
   * @access public
   * @param {float2[]|float3[]} points -
   * @param {number} radius -
   * @param {boolean} cyclical -
   * @returns {GKPath}
   */


  static pathWithPointsRadiusCyclical(points, radius, cyclical) {
    const path = new GKPath();

    path._points.push(...points);

    path.radius = radius;
    path.isCyclical = cyclical;
    return path;
  } // Inspecting a Path’s Shape

  /**
   * Returns the 2D point at the specified index in the path’s list of vertices.
   * @access public
   * @param {number} index - The index of the vertex to return, between 0 and the numPoints value.
   * @returns {number[]} - 
   * @desc You define a path’s vertices when creating it, either directly with the init(__float3Points:count:radius:cyclical:) initializer or indirectly with the init(graphNodes:radius:) initializer.If the path is a 3D path, this method is still functional but returns only 2D vectors, ignoring the z-component of each point on the path.
   * @see https://developer.apple.com/documentation/gameplaykit/gkpath/1778285-float2
   */


  float2At(index) {
    return this.pointAt(index);
  }
  /**
   * Returns the 3D point at the specified index in the path’s list of vertices.
   * @access public
   * @param {number} index - The index of the vertex to return, between 0 and the numPoints value.
   * @returns {number[]} - 
   * @desc You define a path’s vertices when creating it, either directly with the init(__float3Points:count:radius:cyclical:) initializer or indirectly with the init(graphNodes:radius:) initializer.If the path is a 2D path, this method is still functional, but returns 3D vectors whose z-component is always zero.
   * @see https://developer.apple.com/documentation/gameplaykit/gkpath/1778310-float3
   */


  float3At(index) {
    const point = this._points[index];

    if (point) {
      return new SCNVector3(point.x, point.y, point.z);
    }

    return null;
  }
  /**
   * Returns the 2D point at the specified index in the path’s list of vertices.
   * @access public
   * @param {number} index - The index of the vertex to return, between 0 and the numPoints value.
   * @returns {number[]} - 
   * @see https://developer.apple.com/documentation/gameplaykit/gkpath/1501172-point
   */


  pointAt(index) {
    const point = this._points[index];

    if (point) {
      return new CGPoint(point.x, point.y);
    }

    return null;
  }
  /**
   * The number of vertices in the path.
   * @type {number}
   * @desc You define a path’s vertices when creating it, either directly with the init(__points:count:radius:cyclical:) initializer or indirectly with the init(graphNodes:radius:) initializer.
   * @see https://developer.apple.com/documentation/gameplaykit/gkpath/1501071-numpoints
   */


  get numPoints() {
    return this._points.length();
  }

}

//import GKEntity from './GKEntity'
//import GKGraph from './GKGraph'

/**
 * A container for associating GameplayKit objects with a SpriteKit scene.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/gameplaykit/gkscene
 */

class GKScene extends NSObject {
  /**
   * constructor
   * @access public
   * @constructor
   */
  constructor() {
    super(); // Accessing the SpriteKit Scene

    /**
     * The SpriteKit scene managed by this GKScene object.
     * @type {?GKSceneRootNodeType}
     * @see https://developer.apple.com/documentation/gameplaykit/gkscene/1640947-rootnode
     */

    this.rootNode = null; // Managing Entities and Components

    this._entities = []; // Managing Pathfinding Graphs

    this._graphs = {};
  } // Loading a Scene File

  /**
   * Loads the specified SpriteKit scene file, creating a GKScene object containing the SpriteKit scene and associated GameplayKit objects.
   * @access public
   * @param {string} filename - The name of a scene file in your app’s main bundle.
   * @returns {void}
   * @desc Use this initializer to load SpriteKit scenes (.sks files) created in the Xcode SpriteKit scene editor that contain associated GameplayKit entities, components, and pathfinding graphs.
   * @see https://developer.apple.com/documentation/gameplaykit/gkscene/1640935-init
   */


  static sceneWithFileNamed(filename) {
    const scene = new GKScene(); // TODO: implement

    return scene;
  } // Managing Entities and Components

  /**
   * Adds a GameplayKit entity to the list of entities managed by the scene.
   * @access public
   * @param {GKEntity} entity - The entity to be added to the scene.
   * @returns {void}
   * @see https://developer.apple.com/documentation/gameplaykit/gkscene/1640954-addentity
   */


  addEntity(entity) {
    if (this._entities.indexOf(entity) < 0) {
      this._entities.push(entity);
    }
  }
  /**
   * Removes a GameplayKit entity from the list of entities managed by the scene.
   * @access public
   * @param {GKEntity} entity - The entity to be removed from the scene.
   * @returns {void}
   * @see https://developer.apple.com/documentation/gameplaykit/gkscene/1640686-removeentity
   */


  removeEntity(entity) {
    const index = this._entities.indexOf(entity);

    this._entities.splice(index, 1);
  }
  /**
   * The list of GameplayKit entities managed by the scene.
   * @type {GKEntity[]}
   * @desc When you add entities (and their components) to a scene in the Xcode SpriteKit scene editor, Xcode automatically adds them to this array.
   * @see https://developer.apple.com/documentation/gameplaykit/gkscene/1640795-entities
   */


  get entities() {
    return this._entities.slice();
  } // Managing Pathfinding Graphs

  /**
   * Removes a pathfinding graph from the list of graphs managed by the scene.
   * @access public
   * @param {string} name - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/gameplaykit/gkscene/1640663-removegraph
   */


  removeGraph(name) {
    if (this._graphs[name]) {
      delete this._graphs[name];
    }
  }
  /**
   * The list of pathfinding graph objects managed by the scene.
   * @type {Map<string, GKGraph>}
   * @desc When you define pathfinding graphs in the Xcode SpriteKit scene editor, Xcode automatically adds them to this array.
   * @see https://developer.apple.com/documentation/gameplaykit/gkscene/1640940-graphs
   */


  get graphs() {
    return this._graphs;
  } // Instance Methods

  /**
   * 
   * @access public
   * @param {GKGraph} graph - 
   * @param {string} name - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/gameplaykit/gkscene/2143063-addgraph
   */


  addGraph(graph, name) {
    this._graphs[name] = graph;
  }

}

/**
 * 
 * @access public
 * @extends {GKComponent}
 * @see https://developer.apple.com/documentation/gameplaykit/gkscnnodecomponent
 */

class GKSCNNodeComponent extends GKComponent {
  // Initializers

  /**
   * 
   * @access public
   * @constructor
   * @param {SCNNode} node - 
   * @see https://developer.apple.com/documentation/gameplaykit/gkscnnodecomponent/2873248-init
   */
  constructor(node) {
    super(); // Instance Properties

    this._node = node;
  } // Instance Properties

  /**
   * 
   * @type {SCNNode}
   * @desc 
   * @see https://developer.apple.com/documentation/gameplaykit/gkscnnodecomponent/2873245-node
   */


  get node() {
    return this._node;
  }

}

/**
 * The partitioning mode used by the tessellator to derive the number and spacing of segments used to subdivide a corresponding edge.
 * @typedef {Object} MTLTessellationPartitionMode
 * @property {number} pow2 - 
 * @property {number} integer - 
 * @property {number} fractionalOdd - 
 * @property {number} fractionalEven - 
 * @see https://developer.apple.com/documentation/metal/mtltessellationpartitionmode
 */

const MTLTessellationPartitionMode = {
  pow2: 0,
  integer: 1,
  fractionalOdd: 2,
  fractionalEven: 3
};

/**
 * An interface that allows objects to respond to actions triggered by a CALayer.
 * @interface
 * @see https://developer.apple.com/documentation/quartzcore/caaction
 */

class CAAction {
  /**
   * constructor
   * @access public
   * @constructor
   */
  //constructor() {
  //}
  // Responding to an action

  /**
   * Required. Called to trigger the action specified by the identifier.
   * @access public
   * @param {string} event - 
   * @param {Object} anObject - The layer on which the action should occur.
   * @param {?Map<AnyHashable, Object>} dict - A dictionary containing parameters associated with this event. May be nil.
   * @returns {void}
   * @see https://developer.apple.com/documentation/quartzcore/caaction/1410806-run
   */
  runForKeyObjectArguments(event, anObject, dict) {}

}

/*global exports*/
// 
const kCAFillModeRemoved = 'removed';
const kCAFillModeForwards = 'forwards';
const kCAFillModeBackwards = 'backwards';
const kCAFillModeBoth = 'both'; // 

const kCAMediaTimingFunctionLinear = 'linear';
const kCAMediaTimingFunctionEaseIn = 'easeIn';
const kCAMediaTimingFunctionEaseOut = 'easeOut';
const kCAMediaTimingFunctionEaseInEaseOut = 'easeInEaseOut';
const kCAMediaTimingFunctionDefault = 'default'; // Value calculation modes

const kCAAnimationLinear = 'linear';
const kCAAnimationDiscrete = 'discrete';
const kCAAnimationPaced = 'paced';
const kCAAnimationCubic = 'cubic';
const kCAAnimationCubicPaced = 'cubicPaced'; // Rotation Mode Values

//import CAMediaTiming from './CAMediaTiming'
//import CAMediaTimingFunction from './CAMediaTimingFunction'
//import CAAnimationDelegate from './CAAnimationDelegate'
//import SCNAnimationEvent from '../SceneKit/SCNAnimationEvent'

/**
 * The abstract superclass for Core Animation animations. 
 * @access public
 * @extends {NSObject}
 * @implements {CAAction}
 * @implements {CAMediaTiming}
 * @see https://developer.apple.com/documentation/quartzcore/caanimation
 */

class CAAnimation extends NSObject {
  /**
   * constructor
   * @access public
   * @constructor
   */
  constructor() {
    super(); // Animation attributes

    /**
     * Determines if the animation is removed from the target layer’s animations upon completion.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/quartzcore/caanimation/1412458-isremovedoncompletion
     */

    this.isRemovedOnCompletion = true;
    /**
     * An optional timing function defining the pacing of the animation.
     * @type {?CAMediaTimingFunction}
     * @see https://developer.apple.com/documentation/quartzcore/caanimation/1412456-timingfunction
     */

    this.timingFunction = null; // Getting and setting the delegate

    /**
     * Specifies the receiver’s delegate object.
     * @type {?CAAnimationDelegate}
     * @see https://developer.apple.com/documentation/quartzcore/caanimation/1412490-delegate
     */

    this.delegate = null; // Controlling SceneKit Animation Timing

    /**
     * For animations attached to SceneKit objects, a Boolean value that determines whether the animation is evaluated using the scene time or the system time.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/quartzcore/caanimation/1523819-usesscenetimebase
     */

    this.usesSceneTimeBase = false; // Fading Between SceneKit Animations

    /**
     * For animations attached to SceneKit objects, the duration for transitioning into the animation’s effect as it beins.
     * @type {number}
     * @see https://developer.apple.com/documentation/quartzcore/caanimation/1523370-fadeinduration
     */

    this.fadeInDuration = 0;
    /**
     * For animations attached to SceneKit objects, the duration for transitioning out of the animation’s effect as it ends.
     * @type {number}
     * @see https://developer.apple.com/documentation/quartzcore/caanimation/1522959-fadeoutduration
     */

    this.fadeOutDuration = 0; // Attaching SceneKit Animation Events

    /**
     * For animations attached to SceneKit objects, a list of events attached to an animation.
     * @type {?SCNAnimationEvent[]}
     * @see https://developer.apple.com/documentation/quartzcore/caanimation/1523940-animationevents
     */

    this.animationEvents = null; ///////////////////
    // CAMediaTiming //
    ///////////////////
    // Animation Start Time

    /**
     * Required. Specifies the begin time of the receiver in relation to its parent object, if applicable.
     * @type {number}
     * @see https://developer.apple.com/documentation/quartzcore/camediatiming/1427654-begintime
     */

    this.beginTime = 0;
    /**
     * Required. Specifies an additional time offset in active local time.
     * @type {number}
     * @see https://developer.apple.com/documentation/quartzcore/camediatiming/1427650-timeoffset
     */

    this.timeOffset = 0; // Repeating Animations

    /**
     * Required. Determines the number of times the animation will repeat.
     * @type {number}
     * @see https://developer.apple.com/documentation/quartzcore/camediatiming/1427666-repeatcount
     */

    this.repeatCount = 0;
    /**
     * Required. Determines how many seconds the animation will repeat for.
     * @type {number}
     * @see https://developer.apple.com/documentation/quartzcore/camediatiming/1427643-repeatduration
     */

    this.repeatDuration = 0; // Duration and Speed

    /**
     * Required. Specifies the basic duration of the animation, in seconds.
     * @type {number}
     * @see https://developer.apple.com/documentation/quartzcore/camediatiming/1427652-duration
     */

    this.duration = 0;
    /**
     * Required. Specifies how time is mapped to receiver’s time space from the parent time space. 
     * @type {number}
     * @see https://developer.apple.com/documentation/quartzcore/camediatiming/1427647-speed
     */

    this.speed = 1; // Playback Modes

    /**
     * Required. Determines if the receiver plays in the reverse upon completion.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/quartzcore/camediatiming/1427645-autoreverses
     */

    this.autoreverses = false;
    /**
     * Required. Determines if the receiver’s presentation is frozen or removed once its active duration has completed.
     * @type {string}
     * @see https://developer.apple.com/documentation/quartzcore/camediatiming/1427656-fillmode
     */

    this.fillMode = kCAFillModeRemoved;
    this._isFinished = false;
    this._prevTime = null;
    this._animationStartTime = null;
  } // Archiving properties

  /**
   * Specifies whether the value of the property for a given key is archived.
   * @access public
   * @param {string} key - The name of one of the receiver’s properties.
   * @returns {boolean} - 
   * @desc Called by the object's implementation of encodeWithCoder:. The object must implement keyed archiving. The default implementation returns true. 
   * @see https://developer.apple.com/documentation/quartzcore/caanimation/1412525-shouldarchivevalue
   */


  shouldArchiveValueForKey(key) {
    return false;
  } // Providing default values for properties

  /**
   * Specifies the default value of the property with the specified key. 
   * @access public
   * @param {string} key - The name of one of the receiver’s properties.
   * @returns {?Object} - 
   * @desc If this method returns nil a suitable “zero” default value for the property is provided, based on the declared type of the key. For example, if key is a CGSize object, a size of (0.0,0.0) is returned. For a CGRect an empty rectangle is returned. For CGAffineTransform and CATransform3D, the appropriate identity matrix is returned. Special ConsiderationsIf key is not a known for property of the class, the result of the method is undefined.
   * @see https://developer.apple.com/documentation/quartzcore/caanimation/1412530-defaultvalue
   */


  static defaultValueForKey(key) {
    return null;
  }
  /**
   * @access public
   * @returns {CAAnimation} -
   */


  copy() {
    const anim = super.copy();
    anim.isRemovedOnCompletion = this.isRemovedOnCompletion;
    anim.timingFunction = this.timingFunction;
    anim.delegate = this.delegate;
    anim.usesSceneTimeBase = this.usesSceneTimeBase;
    anim.fadeInDuration = this.fadeInDuration;
    anim.fadeOutDuration = this.fadeOutDuration;
    anim.animationEvents = this.animationEvents ? this.animationEvents.slice(0) : null;
    anim.beginTime = this.beginTime;
    anim.timeOffset = this.timeOffset;
    anim.repeatCount = this.repeatCount;
    anim.repeatDuration = this.repeatDuration;
    anim.duration = this.duration;
    anim.speed = this.speed;
    anim.autoreverses = this.autoreverses;
    anim.fillMode = this.fillMode;
    return anim;
  }
  /*
  _copyValue(src) {
    console.log('CAAnimation._copyValue')
    this.isRemovedOnCompletion = src.isRemovedOnCompletion
    this.timingFunction = src.timingFunction
    this.delegate = src.delegate
    this.usesSceneTimeBase = src.usesSceneTimeBase
    this.fadeInDuration = src.fadeInDuration
    this.fadeOutDuration = src.fadeOutDuration
    this.animationEvents = src.animationEvents
    this.beginTime = src.beginTime
    this.timeOffset = src.timeOffset
    this.repeatCount = src.repeatCount
    this.repeatDuration = src.repeatDuration
    this.duration = src.duration
    this.speed = src.speed
    this.autoreverses = src.autoreverses
    this.fillMode = src.fillMode
  }
  */

  /**
   * apply animation to the given node.
   * @access private
   * @param {Object} obj - target object to apply this animation.
   * @param {number} time - active time
   * @param {boolean} [needTimeConversion = true] -
   * @returns {void}
   */


  _applyAnimation(obj, time, needTimeConversion = true) {
    let t = time;

    if (needTimeConversion) {
      const baseTime = this._basetimeFromTime(time);

      t = baseTime;

      if (this.timingFunction !== null) {
        t = this.timingFunction._getValueAtTime(baseTime);
      }
    }

    this._handleEvents(obj, t);
  }

  _handleEvents(obj, time) {
    if (this.animationEvents === null) {
      return;
    }

    let prevTime = this._prevTime;

    if (prevTime === null) {
      if (this.delegate && this.delegate.animationDidStart) {
        this.delegate.animationDidStart(this);
      }

      prevTime = time - 0.0000001;
    }

    this.animationEvents.forEach(event => {
      if (prevTime < event._time && event._time <= time) {
        if (event._eventBlock) {
          // FIXME: set playingBackward
          // SCNAnimationEventBlock(animation, animatedObject, playingBackward)
          event._eventBlock(this, obj, false);
        }
      }
    });
    this._prevTime = time;
  }
  /**
   * convert parent time to base time
   * @access private
   * @param {number} time - parent time
   * @returns {number} - animation base time for the current frame (0-1 or null).
   */


  _basetimeFromTime(time) {
    const activeTime = time - this._animationStartTime;
    return this._basetimeFromActivetime(activeTime);
  }
  /**
   * convert active time to base time
   * @access private
   * @param {number} time - active time
   * @returns {number} - animation base time for the current frame (0-1 or null).
   */


  _basetimeFromActivetime(time) {
    let beginTime = 0;

    if (this.beginTime > 0) {
      // FIXME: check usesSceneTimeBase value
      beginTime = this.beginTime - this._animationStartTime;
    }

    let dt = time - beginTime;

    if (dt < 0) {
      if (this.fillMode === kCAFillModeBackwards || this.fillMode === kCAFillModeBoth) {
        dt = 0;
      } else {
        // the animation hasn't started yet.
        return null;
      }
    }

    if (this.speed === 0) {
      return 0;
    }

    let oneLoopDuration = this.duration / Math.abs(this.speed);
    let duration = oneLoopDuration;

    if (duration === 0) {
      duration = 0.25;
    }

    let repeatCount = this.repeatCount;

    if (this.usesSceneTimeBase) {
      // FIXME: I don't know why, but if you set usesSceneTimeBase = true, it will animate repeatedly...
      repeatCount = Infinity;
    }

    if (this.repeatDuration > 0) {
      duration = this.repeatDuration;
    } else {
      if (repeatCount > 0) {
        duration *= repeatCount;
      }

      if (this.autoreverses) {
        oneLoopDuration *= 2.0;
        duration *= 2.0;
      }
    }

    if (dt > duration) {
      // the animation is over.
      if (!this._isFinished) {
        this._isFinished = true;

        if (this.delegate && this.delegate.animationDidStop) {
          this.delegate.animationDidStop(this, true);
        }
      }

      if (this.fillMode === kCAFillModeForwards || this.fillMode === kCAFillModeBoth) {
        dt = duration;
      } else {
        return null;
      }
    }

    let t = (dt + this.timeOffset) / oneLoopDuration;

    if (Math.abs(t) > 1) {
      t = t - Math.floor(t);
    }

    if (t < 0) {
      t = 1 + t;
    }

    if (this.autoreverses) {
      if (t <= 0.5) {
        return t * 2.0;
      }

      return (1 - t) * 2.0;
    }

    return t;
  }

}

/**
 * Methods your app can implement to respond when animations start and stop.
 * @interface
 * @see https://developer.apple.com/documentation/quartzcore/caanimationdelegate
 */

class CAAnimationDelegate {
  /**
   * constructor
   * @access public
   * @constructor
   */
  //constructor() {
  //}
  // Instance Methods

  /**
   * Tells the delegate the animation has started. 
   * @access public
   * @param {CAAnimation} anim - The CAAnimation object that has started.
   * @returns {void}
   * @see https://developer.apple.com/documentation/quartzcore/caanimationdelegate/2097265-animationdidstart
   */
  animationDidStart(anim) {}
  /**
   * Tells the delegate the animation has ended. 
   * @access public
   * @param {CAAnimation} anim - The CAAnimation object that has ended.
   * @param {boolean} flag - A flag indicating whether the animation has completed by reaching the end of its duration.
   * @returns {void}
   * @desc The animation may have ended because it has completed its active duration or because it has been removed from the layer it is attached to. flag is true if the animation reached the end of its duration without being removed.
   * @see https://developer.apple.com/documentation/quartzcore/caanimationdelegate/2097259-animationdidstop
   */


  animationDidStopFinished(anim, flag) {}

}

/**
 * An object that allows multiple animations to be grouped and run concurrently. 
 * @access public
 * @extends {CAAnimation}
 * @see https://developer.apple.com/documentation/quartzcore/caanimationgroup
 */

class CAAnimationGroup extends CAAnimation {
  static get _propTypes() {
    return {
      animations: 'LKNSArrayCodingProxy',
      duration: 'integer',
      fillMode: 'string',
      removedOnCompletion: ['boolean', 'isRemovedOnCompletion'],
      __CACodingContents: 'NSArray'
    };
  }
  /**
   * constructor
   * @access public
   * @constructor
   */


  constructor() {
    super(); // Grouped animations

    /**
     * An array of CAAnimation objects to be evaluated in the time space of the receiver.
     * @type {?CAAnimation[]}
     * @see https://developer.apple.com/documentation/quartzcore/caanimationgroup/1412516-animations
     */

    this.animations = [];
  }
  /**
   * apply animation to the given node.
   * @access private
   * @param {Object} obj - target object to apply this animation.
   * @param {number} time - active time
   * @param {boolean} [needTimeConversion = true] -
   * @returns {void}
   */


  _applyAnimation(obj, time, needTimeConversion = true) {
    let t = time;

    if (needTimeConversion) {
      const baseTime = this._basetimeFromTime(time);

      t = baseTime;

      if (this.timingFunction !== null) {
        t = this.timingFunction._getValueAtTime(baseTime);
      } //console.log(`time ${time} activeTime ${time - this._animationStartTime} baseTime ${baseTime}`)

    }

    this.animations.forEach(animation => {
      animation._applyAnimation(obj, t, false);
    });

    this._handleEvents(obj, t);
  }
  /**
   * @access public
   * @returns {CAAnimationGroup} -
   */


  copy() {
    //console.log('CAAnimationGroup.copy')
    const anim = super.copy();
    anim.animations = this.animations.slice();
    return anim;
  }
  /*
  _copyValue(src) {
    console.log('CAAnimationGroup._copyValue')
    //super._copyValue(src)
    this.animations = src.animations.slice()
  }
  */


}

/**
 * An abstract subclass of CAAnimation for creating animations that manipulate the value of layer properties. 
 * @access public
 * @extends {CAAnimation}
 * @see https://developer.apple.com/documentation/quartzcore/capropertyanimation
 */

class CAPropertyAnimation extends CAAnimation {
  // Creating an Animation

  /**
   * Creates and returns an CAPropertyAnimation instance for the specified key path.
   * @access public
   * @constructor
   * @param {?string} path - 
   * @see https://developer.apple.com/documentation/quartzcore/capropertyanimation/1412534-init
   */
  constructor(path) {
    super(); // Animated Key Path

    /**
     * Specifies the key path the receiver animates.
     * @type {?string}
     * @see https://developer.apple.com/documentation/quartzcore/capropertyanimation/1412496-keypath
     */

    this.keyPath = path; // Property Value Calculation Behavior

    /**
     * Determines if the value of the property is the value at the end of the previous repeat cycle, plus the value of the current repeat cycle.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/quartzcore/capropertyanimation/1412538-iscumulative
     */

    this.isCumulative = false;
    /**
     * Determines if the value specified by the animation is added to the current render tree value to produce the new render tree value.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/quartzcore/capropertyanimation/1412493-isadditive
     */

    this.isAdditive = false;
    /**
     * An optional value function that is applied to interpolated values.
     * @type {?CAValueFunction}
     * @see https://developer.apple.com/documentation/quartzcore/capropertyanimation/1412447-valuefunction
     */

    this.valueFunction = null;
    this._isMultiplicative = false;
  }
  /**
   * @access public
   * @returns {CAPropertyAnimation} -
   */


  copy() {
    const anim = super.copy(); //anim._copyValue(this)

    anim.keyPath = this.keyPath;
    anim.isCumulative = this.isCumulative;
    anim.isAdditive = this.isAdditive;
    anim.valueFunction = this.valueFunction;
    anim._isMultiplicative = this._isMultiplicative;
    return anim;
  }
  /*
  _copyValue(src) {
    console.log('CAPropertyAnimation._copyValue: ' + src.keyPath)
    this.keyPath = src.keyPath
    this.isCumulative = src.isCumulative
    this.isAdditive = src.isAdditive
    this.valueFunction = src.valueFunction
  }
  */

  /**
   * apply animation to the given node.
   * @access private
   * @param {Object} obj - target object to apply this animation.
   * @param {number} time - active time
   * @param {boolean} [needTimeConversion = true] -
   * @returns {void}
   */


  _applyAnimation(obj, time, needTimeConversion = true) {
    let t = time;

    if (needTimeConversion) {
      const baseTime = this._basetimeFromTime(time);

      t = baseTime;

      if (this.timingFunction !== null) {
        t = this.timingFunction._getValueAtTime(baseTime);
      }
    }

    let value = t;

    if (this.valueFunction !== null) {
      value = this.valueFunction._getValueAtTime(t);
    }

    value = this._calculateWithBaseValue(obj, value); //console.log(`CAPropertyAnimation: obj: ${obj.name}, time: ${time}, keyPath: ${this.keyPath}, value: ${value}`)

    this._applyValue(obj, value);

    this._handleEvents(obj, t);
  }

  _calculateWithBaseValue(obj, value) {
    if (this.isAdditive) {
      const baseValue = obj.valueForKeyPath(this.keyPath);
      return this._addValues(baseValue, value);
    } else if (this._isMultiplicative) {
      const baseValue = obj.valueForKeyPath(this.keyPath);
      return this._mulValues(baseValue, value);
    }

    return value;
  }

  _applyValue(obj, value) {
    obj.setValueForKeyPath(value, this.keyPath);
  }

  _addValues(v1, v2) {
    if (v1 instanceof Object) {
      return v1.add(v2);
    }

    return v1 + v2;
  }

  _mulValues(v1, v2) {
    if (v1 instanceof Object) {
      return v1.mul(v2);
    }

    return v1 * v2;
  }

  _lerp(from, to, t) {
    if (t === null) {
      // the animation is over.
      return to;
    }

    if (_InstanceOf(from, SCNVector4)) {
      // TODO: slerp for Quaternion
      return from.lerp(to, t);
    } else if (_InstanceOf(from, SCNVector3)) {
      return from.lerp(to, t);
    } else if (_InstanceOf(from, SCNMatrix4)) {
      return from.lerp(to, t);
    } else if (_InstanceOf(from, CGSize)) ; else if (_InstanceOf(from, CGPoint)) ; else if (_InstanceOf(from, CGRect)) ; else if (_InstanceOf(from, SKColor)) {
      return from._lerp(to, t);
    }

    return from + (to - from) * t;
  }

  _slerp(from, to, t) {
    if (!_InstanceOf(from, SCNVector4)) {
      throw new Error('CABasicAnimation._slerp: object is not SCNVector4');
    }

    return from.slerp(to, t);
  }

}

/**
 * An object that provides basic, single-keyframe animation capabilities for a layer property. 
 * @access public
 * @extends {CAPropertyAnimation}
 * @see https://developer.apple.com/documentation/quartzcore/cabasicanimation
 */

class CABasicAnimation extends CAPropertyAnimation {
  /**
   * constructor
   * @access public
   * @param {?string} path -
   * @constructor
   */
  constructor(path) {
    super(path); // Interpolation values

    /**
     * Defines the value the receiver uses to start interpolation.
     * @type {?Object}
     * @see https://developer.apple.com/documentation/quartzcore/cabasicanimation/1412519-fromvalue
     */

    this.fromValue = null;
    /**
     * Defines the value the receiver uses to end interpolation.
     * @type {?Object}
     * @see https://developer.apple.com/documentation/quartzcore/cabasicanimation/1412523-tovalue
     */

    this.toValue = null;
    /**
     * Defines the value the receiver uses to perform relative interpolation.
     * @type {?Object}
     * @see https://developer.apple.com/documentation/quartzcore/cabasicanimation/1412445-byvalue
     */

    this.byValue = null;
    this._baseValue = null;
  }
  /**
   * @access public
   * @returns {CABasicAnimation} -
   */


  copy() {
    const anim = super.copy(); //anim._copyValue(this)

    anim.fromValue = this.fromValue;
    anim.toValue = this.toValue;
    anim.byValue = this.byValue;
    return anim;
  }
  /*
  _copyValue(src) {
    this.fromValue = src.fromValue
    this.toValue = src.toValue
    this.byValue = src.byValue
  }
  */

  /**
   * apply animation to the given node.
   * @access private
   * @param {Object} obj - target object to apply this animation.
   * @param {number} time - active time
   * @param {boolean} [needTimeConversion = true] -
   * @returns {void}
   */


  _applyAnimation(obj, time, needTimeConversion = true) {
    let t = time;

    if (needTimeConversion) {
      const baseTime = this._basetimeFromTime(time);

      if (baseTime === null) {
        return;
      }

      t = baseTime;

      if (this.timingFunction !== null) {
        t = this.timingFunction._getValueAtTime(baseTime);
      }

      if (t < 0) {
        t = 0;
      }

      if (t > 1) {
        t = 1;
      } //if(this.keyPath === 'rotation.w'){
      //  console.log(`time: ${time}, activeTime: ${time - this._animationStartTime}, baseTime: ${baseTime}, t: ${t}`)
      //}

    }

    let isObject = false;

    if (this._baseValue === null || this.isAdditive) {
      this._baseValue = obj.valueForKeyPath(this.keyPath, false);
    }

    if (typeof this._baseValue !== 'number' && this._baseValue !== null) {
      isObject = true;
    }

    let fromValue = 0;
    let toValue = 0;

    if (this.fromValue !== null && this.toValue !== null) {
      fromValue = this.fromValue;
      toValue = this.toValue;
    } else if (this.fromValue !== null && this.byValue !== null) {
      fromValue = this.fromValue;

      if (isObject) {
        toValue = this.fromValue.add(this.byValue);
      } else {
        toValue = this.fromValue + this.byValue;
      }
    } else if (this.byValue !== null && this.toValue !== null) {
      if (isObject) {
        fromValue = this.toValue.sub(this.byValue);
      } else {
        fromValue = this.toValue - this.byValue;
      }

      toValue = toValue;
    } else if (this.fromValue !== null) {
      fromValue = this.fromValue;

      if (this.isAdditive) {
        if (isObject) {
          toValue = this._baseValue.zero();
        } else {
          toValue = 0;
        }
      } else {
        toValue = this._baseValue;
      }
    } else if (this.toValue !== null) {
      if (this.isAdditive) {
        if (isObject) {
          fromValue = this._baseValue.zero();
        } else {
          fromValue = 0;
        }
      } else {
        fromValue = this._baseValue;
      }

      toValue = this.toValue;
    } else if (this.byValue !== null) {
      if (this.isAdditive) {
        if (isObject) {
          fromValue = this._baseValue.zero();
        } else {
          fromValue = 0;
        }

        toValue = this.byValue;
      } else {
        fromValue = this._baseValue;

        if (isObject) {
          toValue = this._baseValue.add(this.byValue);
        } else {
          toValue = this._baseValue + this.byValue;
        }
      }
    }

    let value = this._lerp(fromValue, toValue, t); //if(this.keyPath === 'rotation.w'){
    //  console.log(`from: ${fromValue}, to: ${toValue}, t: ${t}, value: ${value}`)
    //}


    if (this.isAdditive) {
      if (isObject) {
        //value = value.add(obj.valueForKeyPath(this.keyPath))
        value = value.add(this._baseValue);
      } else {
        value += this._baseValue;
      }
    } //if(this.keyPath === 'rotation.w'){
    //  console.log(`value after: ${value}`)
    //}
    //console.log(`CABasicAnimation._applyAnimation: keyPath: ${this.keyPath}, time: ${time}, baseTime: ${baseTime}, t: ${t}, value: ${value}`)


    this._applyValue(obj, value);

    this._handleEvents(obj, t);
  }

}

/**
 * 
 * @access public
 * @extends {NSObject}
 * 
 */

class CACodingProxy extends NSObject {
  static get _propTypes() {
    return {};
  }
  /**
   * constructor
   * @access public
   * @constructor
   */


  constructor() {
    super();
  }

}

/**
 * Returns the current absolute time, in seconds.
 * @access public
 * @returns {number} - 
 * @see https://developer.apple.com/documentation/quartzcore/1395996-cacurrentmediatime
 */

const CACurrentMediaTime = function () {
  return Date.now() * 0.001;
};

/**
 * An object that provides keyframe animation capabilities for a layer object. 
 * @access public
 * @extends {CAPropertyAnimation}
 * @see https://developer.apple.com/documentation/quartzcore/cakeyframeanimation
 */

class CAKeyframeAnimation extends CAPropertyAnimation {
  static get _propTypes() {
    return {
      duration: 'integer',
      fillMode: 'string',
      keyPath: 'string',
      keyTimes: 'LKNSArrayCodingProxy',
      removedOnCompletion: ['boolean', 'isRemovedOnCompletion'],
      timingFunctions: 'LKNSArrayCodingProxy',
      values: 'LKNSArrayCodingProxy',
      __CACodingContents: 'NSArray'
    };
  } // Creating an Animation

  /**
   * Creates and returns an CAKeyframeAnimation instance for the specified key path.
   * @access public
   * @constructor
   * @param {?string} path - 
   */


  constructor(path) {
    super(path); // Providing keyframe values

    /**
     * An array of objects that specify the keyframe values to use for the animation.
     * @type {?Object[]}
     * @see https://developer.apple.com/documentation/quartzcore/cakeyframeanimation/1412498-values
     */

    this.values = null;
    /**
     * The path for a point-based property to follow.
     * @type {?CGPath}
     * @see https://developer.apple.com/documentation/quartzcore/cakeyframeanimation/1412474-path
     */

    this.path = null; // Keyframe timing

    /**
     * An optional array of NSNumber objects that define the time at which to apply a given keyframe segment.
     * @type {?number[]}
     * @see https://developer.apple.com/documentation/quartzcore/cakeyframeanimation/1412522-keytimes
     */

    this.keyTimes = null;
    /**
     * An optional array of CAMediaTimingFunction objects that define the pacing for each keyframe segment.
     * @type {?CAMediaTimingFunction[]}
     * @see https://developer.apple.com/documentation/quartzcore/cakeyframeanimation/1412465-timingfunctions
     */

    this.timingFunctions = null;
    /**
     * Specifies how intermediate keyframe values are calculated by the receiver.
     * @type {string}
     * @see https://developer.apple.com/documentation/quartzcore/cakeyframeanimation/1412500-calculationmode
     */

    this.calculationMode = kCAAnimationLinear; // Rotation Mode Attribute

    /**
     * Determines whether objects animating along the path rotate to match the path tangent.
     * @type {?string}
     * @see https://developer.apple.com/documentation/quartzcore/cakeyframeanimation/1412454-rotationmode
     */

    this.rotationMode = null; // Cubic Mode Attributes

    /**
     * An array of NSNumber objects that define the tightness of the curve. 
     * @type {?number[]}
     * @see https://developer.apple.com/documentation/quartzcore/cakeyframeanimation/1412475-tensionvalues
     */

    this.tensionValues = null;
    /**
     * An array of NSNumber objects that define the sharpness of the timing curve’s corners.
     * @type {?number[]}
     * @see https://developer.apple.com/documentation/quartzcore/cakeyframeanimation/1412491-continuityvalues
     */

    this.continuityValues = null;
    /**
     * An array of NSNumber objects that define the position of the curve relative to a control point.
     * @type {?number[]}
     * @see https://developer.apple.com/documentation/quartzcore/cakeyframeanimation/1412485-biasvalues
     */

    this.biasValues = null;
    /**
     * @access private
     * @type {number}
     */

    this._indexCache = 0;
  }
  /**
   * @access public
   * @returns {CAKeyframeAnimation} -
   */


  copy() {
    const anim = super.copy();
    anim.values = this.values ? this.values.slice() : null;
    anim.path = this.path;
    anim.keyTimes = this.keyTimes ? this.keyTimes.slice() : null;
    anim.timingFunctions = this.timingFunctions ? this.timingFunctions.slice() : null;
    anim.calculationMode = this.calculationMode;
    anim.rotationMode = this.rotationMode;
    anim.tensionValues = this.tensionValues ? this.tensionValues.slice() : null;
    anim.continuityValues = this.continuityValues ? this.continuityValues.slice() : null;
    anim.biasValues = this.biasValues ? this.biasValues.slice() : null;
    return anim;
  }
  /**
   * apply animation to the given node.
   * @access private
   * @param {Object} obj - target object to apply this animation.
   * @param {number} time - active time
   * @param {boolean} [needTimeConversion = true] -
   * @returns {void}
   */


  _applyAnimation(obj, time, needTimeConversion = true) {
    let t = time;

    if (needTimeConversion) {
      const baseTime = this._basetimeFromTime(time);

      t = baseTime;
    }

    let index = this._indexCache;
    let key0 = 0;
    let key1 = 0;

    if (t > 1) {
      throw new Error(`CAKeyframeAnimation._applyAnimation: t ${t} > 1`);
    }

    const len = this.keyTimes.length;

    if (index >= len) {
      console.log(`CAKeyframeAnimation index >= len  ${index} >= ${len}`);
      index = len - 1;
    } // search keyTime linearly


    if (this.keyTimes[index] < t) {
      for (; index < len; index++) {
        if (this.keyTimes[index] >= t) break;
      }

      key0 = index - 1;
      key1 = index;
    } else {
      for (; index >= 0; index--) {
        if (this.keyTimes[index] < t) break;
      }

      key0 = index;
      key1 = index + 1;
    }

    if (key0 <= 0) {
      key0 = 0;
    }

    if (key1 >= len) {
      key1 = len - 1;
    }

    this._indexCache = key0;
    const time0 = this.keyTimes[key0];
    const time1 = this.keyTimes[key1];
    const val0 = this.values[key0];
    const val1 = this.values[key1];
    let value = val0;

    if (time0 !== time1) {
      const dt = (t - time0) / (time1 - time0);
      let r = dt;

      if (this.timingFunctions !== null) {
        r = this.timingFunctions[key0]._getValueAtTime(dt);
      }

      switch (this.calculationMode) {
        case kCAAnimationLinear:
          value = this._lerp(val0, val1, r);
          break;

        case kCAAnimationDiscrete:
          // TODO: implement
          throw new Error('kCAAnimationDiscrete not implemented');

        case kCAAnimationPaced:
          // TODO: implement
          throw new Error('kCAAnimationPaced not implemented');

        case kCAAnimationCubic:
          // TODO: implement
          throw new Error('kCAAnimationCubic not implemented');

        case kCAAnimationCubicPaced:
          // TODO: impelement
          throw new Error('kCAAnimationCubicPaced not implemented');

        default:
          throw new Error(`unknown calculation mode: ${this.calculationMode}`);
      } //console.log(`t: ${t}, time0: ${time0}, time1: ${time1}, dt: ${dt}, r: ${r}, value: ${value}`)

    }

    value = this._calculateWithBaseValue(obj, value);

    this._applyValue(obj, value);

    this._handleEvents(obj, t);
  }

}

/**
 * Methods that model a hierarchical timing system, allowing objects to map time between their parent and local time. 
 * @interface
 * @see https://developer.apple.com/documentation/quartzcore/camediatiming
 */

class CAMediaTiming {
  /**
   * constructor
   * @access public
   * @constructor
   */
  constructor() {
    // Animation Start Time

    /**
     * Required. Specifies the begin time of the receiver in relation to its parent object, if applicable.
     * @type {number}
     * @see https://developer.apple.com/documentation/quartzcore/camediatiming/1427654-begintime
     */
    this.beginTime = 0;
    /**
     * Required. Specifies an additional time offset in active local time.
     * @type {number}
     * @see https://developer.apple.com/documentation/quartzcore/camediatiming/1427650-timeoffset
     */

    this.timeOffset = 0; // Repeating Animations

    /**
     * Required. Determines the number of times the animation will repeat.
     * @type {number}
     * @see https://developer.apple.com/documentation/quartzcore/camediatiming/1427666-repeatcount
     */

    this.repeatCount = 0;
    /**
     * Required. Determines how many seconds the animation will repeat for.
     * @type {number}
     * @see https://developer.apple.com/documentation/quartzcore/camediatiming/1427643-repeatduration
     */

    this.repeatDuration = 0; // Duration and Speed

    /**
     * Required. Specifies the basic duration of the animation, in seconds.
     * @type {number}
     * @see https://developer.apple.com/documentation/quartzcore/camediatiming/1427652-duration
     */

    this.duration = 0;
    /**
     * Required. Specifies how time is mapped to receiver’s time space from the parent time space. 
     * @type {number}
     * @see https://developer.apple.com/documentation/quartzcore/camediatiming/1427647-speed
     */

    this.speed = 0; // Playback Modes

    /**
     * Required. Determines if the receiver plays in the reverse upon completion.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/quartzcore/camediatiming/1427645-autoreverses
     */

    this.autoreverses = false;
    /**
     * Required. Determines if the receiver’s presentation is frozen or removed once its active duration has completed.
     * @type {string}
     * @see https://developer.apple.com/documentation/quartzcore/camediatiming/1427656-fillmode
     */

    this.fillMode = '';
  }

}

/**
 * A function that defines the pacing of an animation as a timing curve. 
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/quartzcore/camediatimingfunction
 */

class CAMediaTimingFunction extends NSObject {
  static get _propTypes() {
    return {
      c1x: ['float', '_c1x'],
      c1y: ['float', '_c1y'],
      c2x: ['float', '_c2x'],
      c2y: ['float', '_c2y']
    };
  } // Creating Timing Functions

  /**
   * Returns an initialized timing function modeled as a cubic Bézier curve using the specified control points.
   * @access public
   * @constructor
   * @param {number} c1x - A floating point number representing the x position of the c1 control point.
   * @param {number} c1y - A floating point number representing the y position of the c1 control point.
   * @param {number} c2x - A floating point number representing the x position of the c2 control point.
   * @param {number} c2y - A floating point number representing the y position of the c2 control point.
   * @desc The end points of the Bézier curve are automatically set to (0.0,0.0) and (1.0,1.0). The control points defining the Bézier curve are: [(0.0,0.0), (c1x,c1y), (c2x,c2y), (1.0,1.0)].
   * @see https://developer.apple.com/documentation/quartzcore/camediatimingfunction/1522235-init
   */


  constructor(c1x, c1y, c2x, c2y) {
    super();
    this._c1x = c1x;
    this._c1y = c1y;
    this._c2x = c2x;
    this._c2y = c2y;
  }
  /**
   * Creates and returns a new instance of CAMediaTimingFunction configured with the predefined timing function specified by name.
   * @access public
   * @param {string} name - The timing function to use as specified in Predefined Timing Functions. 
   * @returns {CAMediaTimingFunction} -
   * @see https://developer.apple.com/documentation/quartzcore/camediatimingfunction/1521979-init
   */


  static functionWithName(name) {
    switch (name) {
      case kCAMediaTimingFunctionLinear:
        return new CAMediaTimingFunction(0.0, 0.0, 1.0, 1.0);

      case kCAMediaTimingFunctionEaseIn:
        return new CAMediaTimingFunction(0.42, 0.0, 1.0, 1.0);

      case kCAMediaTimingFunctionEaseOut:
        return new CAMediaTimingFunction(0.0, 0.0, 0.58, 1.0);

      case kCAMediaTimingFunctionEaseInEaseOut:
        return new CAMediaTimingFunction(0.42, 0.0, 0.58, 1.0);

      case kCAMediaTimingFunctionDefault:
        return new CAMediaTimingFunction(0.25, 0.1, 0.25, 1.0);

      default:
        throw new Error(`CAMediaTimingFunction: unknown name: ${name}`);
    }
  }
  /**
   * Returns an initialized timing function modeled as a cubic Bézier curve using the specified control points.
   * @access public
   * @param {number} c1x - A floating point number representing the x position of the c1 control point.
   * @param {number} c1y - A floating point number representing the y position of the c1 control point.
   * @param {number} c2x - A floating point number representing the x position of the c2 control point.
   * @param {number} c2y - A floating point number representing the y position of the c2 control point.
   * @returns {CAMediaTimingFunction} -
   * @desc The end points of the Bézier curve are automatically set to (0.0,0.0) and (1.0,1.0). The control points defining the Bézier curve are: [(0.0,0.0), (c1x,c1y), (c2x,c2y), (1.0,1.0)].
   * @see https://developer.apple.com/documentation/quartzcore/camediatimingfunction/1522235-init
   */


  static functionWithControlPoints(c1x, c1y, c2x, c2y) {
    return new CAMediaTimingFunction(c1x, c1y, c2x, c2y);
  } // Accessing the Control Points

  /**
   * Returns the control point for the specified index.
   * @access public
   * @param {number} idx - 
   * @param {!UnsafeMutablePointer<Float>} ptr - A pointer to an array that, upon return, will contain the x and y values of the specified point.
   * @returns {void}
   * @desc The value of index must be between 0 and 3.
   * @see https://developer.apple.com/documentation/quartzcore/camediatimingfunction/1522057-getcontrolpoint
   */


  getControlPointAtValues(idx, ptr) {}

  _getValueAtTime(time) {
    let t0 = 0;
    let t1 = 1;
    let t = 0.5;
    let r = 0;

    if (time <= 0) {
      return 0;
    } else if (time >= 1) {
      return 1;
    }

    for (let i = 0; i < 8; i++) {
      r = 1 - t;
      const tval = 3 * t * r * (this._c1x * r + this._c2x * t) + t * t * t;

      if (time > tval) {
        t0 = t;
      } else {
        t1 = t;
      }

      t = (t0 + t1) * 0.5;
    }

    r = 1 - t;
    const val = 3 * t * r * (this._c1y * r + this._c2y * t) + t * t * t;
    return val;
  }

}

/**
 * Defines the standard transform matrix used throughout Core Animation.
 * @access public
 * @see https://developer.apple.com/documentation/quartzcore/catransform3d
 */

class CATransform3D {
  // Initializers

  /**
   * 
   * @access public
   * @constructor
   * @param {number[][]} m - 
   * @see https://developer.apple.com/documentation/quartzcore/catransform3d/1523734-init
   */
  constructor(m) {
    // Instance Properties
    this._m11 = 1;
    this._m12 = 0;
    this._m13 = 0;
    this._m14 = 0;
    this._m21 = 0;
    this._m22 = 1;
    this._m23 = 0;
    this._m24 = 0;
    this._m31 = 0;
    this._m32 = 0;
    this._m33 = 1;
    this._m34 = 0;
    this._m41 = 0;
    this._m42 = 0;
    this._m43 = 0;
    this._m44 = 1;
  } // Instance Properties


}

/**
 * 
 * @access public
 * @extends {CACodingProxy}
 * 
 */

class LKNSArrayCodingProxy extends CACodingProxy {
  static get _propTypes() {
    return {
      array: ['NSArray', '_array']
    };
  }
  /**
   * constructor
   * @access public
   * @constructor
   */


  constructor() {
    super();
    this._array = [];
  }

}

/**
 * 
 * @access public
 * @extends {CACodingProxy}
 * 
 */

class LKNSValueCodingProxy extends CACodingProxy {
  /**
   *
   */
  static initWithCoder(coder) {
    //console.log('LKNSValueCodingProxy: ' + JSON.stringify(Object.keys(coder._refObj), null, 2))
    const obj = coder._refObj;
    const kind = obj.kind;

    switch (kind) {
      case 0:
        {
          // CGPoint (x, y)
          return new CGPoint(obj.x, obj.y);
        }

      case 1:
        {
          // CGSize (width, height)
          return new CGSize(obj.width, obj.height);
        }

      case 2:
        {
          // CGRect (x, y, width, height)
          const point = new CGPoint(obj.x, obj.y);
          const size = new CGSize(obj.width, obj.height);
          return new CGRect(point, size);
        }

      case 3:
        {
          // CATransform3D (m11, m12, ..., m44)
          break;
        }

      case 4:
        {
          // CAPoint3D (x, y, z)
          return new CGPoint(obj.x, obj.y);
        }

      case 5:
        {
          // CADoublePoint (x, y)
          return new CGPoint(obj.x, obj.y);
        }

      case 6:
        {
          // CADoubleSize (width, height)
          return new CGSize(obj.width, obj.height);
        }

      case 7:
        {
          // CADoubleRect (x, y, width, height)
          const point = new CGPoint(obj.x, obj.y);
          const size = new CGSize(obj.width, obj.height);
          return new CGRect(point, size);
        }

      case 8:
        {
          // CAColorMatrix (m11, ..., m15, m21, ..., m45)
          break;
        }
    }

    throw new Error('LKNSValueCodingProxy unsupported type: ' + kind);
  }
  /**
   * constructor
   * @access public
   * @constructor
   */


  constructor() {
    super();
  }

}

/**
 * @type {string}
 */

const _SCNDefaultFragmentShader = `#version 300 es
  precision mediump float;
  precision highp sampler2DShadow;

  uniform bool[12] textureFlags;
  #define TEXTURE_EMISSION_INDEX 0
  #define TEXTURE_AMBIENT_INDEX 1
  #define TEXTURE_DIFFUSE_INDEX 2
  #define TEXTURE_SPECULAR_INDEX 3
  #define TEXTURE_REFLECTIVE_INDEX 4
  #define TEXTURE_TRANSPARENT_INDEX 5
  #define TEXTURE_MULTIPLY_INDEX 6
  #define TEXTURE_NORMAL_INDEX 7
  #define TEXTURE_AMBIENT_OCCLUSION_INDEX 8
  #define TEXTURE_SELF_ILLUMINATION_INDEX 9
  #define TEXTURE_METALNESS_INDEX 10
  #define TEXTURE_ROUGHNESS_INDEX 11

  uniform bool selfIllumination;

  uniform sampler2D u_emissionTexture;
  uniform sampler2D u_ambientTexture;
  uniform sampler2D u_diffuseTexture;
  uniform sampler2D u_specularTexture;
  uniform samplerCube u_reflectiveTexture;
  uniform sampler2D u_transparentTexture;
  uniform sampler2D u_multiplyTexture;
  uniform sampler2D u_normalTexture;
  uniform sampler2D u_ambientOcclusionTexture;
  uniform sampler2D u_selfIlluminationTexture;
  uniform sampler2D u_metalnessTexture;
  uniform sampler2D u_roughnessTexture;

  #define NUM_AMBIENT_LIGHTS __NUM_AMBIENT_LIGHTS__
  #define NUM_DIRECTIONAL_LIGHTS __NUM_DIRECTIONAL_LIGHTS__
  #define NUM_DIRECTIONAL_SHADOW_LIGHTS __NUM_DIRECTIONAL_SHADOW_LIGHTS__
  #define NUM_OMNI_LIGHTS __NUM_OMNI_LIGHTS__
  #define NUM_SPOT_LIGHTS __NUM_SPOT_LIGHTS__
  #define NUM_IES_LIGHTS __NUM_IES_LIGHTS__
  #define NUM_PROBE_LIGHTS __NUM_PROBE_LIGHTS__

  #define NUM_SHADOW_LIGHTS (NUM_DIRECTIONAL_LIGHTS + NUM_DIRECTIONAL_SHADOW_LIGHTS + NUM_OMNI_LIGHTS + NUM_SPOT_LIGHTS)
  #define NUM_LIGHTS (NUM_AMBIENT_LIGHTS + NUM_DIRECTIONAL_LIGHTS + NUM_DIRECTIONAL_SHADOW_LIGHTS + NUM_OMNI_LIGHTS + NUM_SPOT_LIGHTS + NUM_IES_LIGHTS + NUM_PROBE_LIGHTS)

  #define USE_SHADER_MODIFIER_SURFACE __USE_SHADER_MODIFIER_SURFACE__
  #define USE_SHADER_MODIFIER_FRAGMENT __USE_SHADER_MODIFIER_FRAGMENT__

  layout (std140) uniform cameraUniform {
    vec4 position;
    mat4 viewTransform;
    mat4 inverseViewTransform;
    mat4 viewProjectionTransform;
  } camera;

  layout (std140) uniform materialUniform {
    vec4 ambient;
    vec4 diffuse;
    vec4 specular;
    vec4 normal;
    vec4 reflective;
    vec4 emission;
    vec4 transparent;
    vec4 multiply;
    vec4 ambientOcclusion;
    vec4 selfIllumination;
    vec4 metalness;
    vec4 roughness;
    float shininess;
    float fresnelExponent;
  } material;

  struct AmbientLight {
    vec4 color;
  };

  struct SCNShaderLightingContribution {
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
  } _lightingContribution;

  struct DirectionalLight {
    vec4 color;
    vec4 direction; // should use vec4; vec3 might cause problem for the layout
  };

  struct DirectionalShadowLight {
    vec4 color;
    vec4 direction; // should use vec4; vec3 might cause problem for the layout
    vec4 shadowColor;
    mat4 viewProjectionTransform;
    mat4 shadowProjectionTransform;
  };

  struct OmniLight {
    vec4 color;
    vec4 position; // should use vec4; vec3 might cause problem for the layout
  };

  struct ProbeLight {
    // TODO: implement
    vec4 color;
  };

  struct SpotLight {
    // TODO: implement
    vec4 color;
  };

  layout (std140) uniform lightUniform {
    #if NUM_AMBIENT_LIGHTS > 0
      AmbientLight ambient[NUM_AMBIENT_LIGHTS];
    #endif
    #if NUM_DIRECTIONAL_LIGHTS > 0
      DirectionalLight directional[NUM_DIRECTIONAL_LIGHTS];
    #endif
    #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 0
      DirectionalShadowLight directionalShadow[NUM_DIRECTIONAL_SHADOW_LIGHTS];
    #endif
    #if NUM_OMNI_LIGHTS > 0
      OmniLight omni[NUM_OMNI_LIGHTS];
    #endif
    #if NUM_SPOT_LIGHTS > 0
      SpotLight spot[NUM_SPOT_LIGHTS];
    #endif
    #if NUM_IES_LIGHTS > 0
      IESLight ies[NUM_IES_LIGHTS];
    #endif
    #if NUM_PROBE_LIGHTS > 0
      ProbeLight probe[NUM_PROBE_LIGHTS];
    #endif
    #if NUM_LIGHTS == 0
      vec4 dummy;
    #endif
  } light;
  #if NUM_SHADOW_LIGHTS > 0
    in vec3 v_light[NUM_SHADOW_LIGHTS];
  #endif
  #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 0
    in vec4 v_directionalShadowDepth[NUM_DIRECTIONAL_SHADOW_LIGHTS];
    in vec4 v_directionalShadowTexcoord[NUM_DIRECTIONAL_SHADOW_LIGHTS];
    uniform sampler2D u_shadowTexture0;
    #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 1
      uniform sampler2D u_shadowTexture1;
    #endif
    #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 2
      uniform sampler2D u_shadowTexture2;
    #endif
    #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 3
      uniform sampler2D u_shadowTexture3;
    #endif
  #endif

  layout (std140) uniform SCNLightsUniform {
    vec4 direction0;
    mat4 shadowMatrix0;
  } scn_lights;

  layout (std140) uniform fogUniform {
    vec4 color;
    float startDistance;
    float endDistance;
    float densityExponent;
  } fog;

  struct SCNShaderSurface {
    vec3 view;
    vec3 position;
    vec3 normal;
    vec2 normalTexcoord;
    vec3 geometryNormal;
    vec3 tangent;
    vec3 bitangent;
    vec4 ambient;
    vec2 ambientTexcoord;
    vec4 diffuse;
    vec2 diffuseTexcoord;
    vec4 specular;
    vec2 specularTexcoord;
    vec4 emission;
    vec2 emissionTexcoord;
    vec4 multiply;
    vec2 multiplyTexcoord;
    vec4 transparent;
    vec2 transparentTexcoord;
    vec4 reflective;
    float ambientOcclusion;
    float shininess;
    float fresnel;
    __USER_CUSTOM_SURFACE__
  } _surface;

  struct SCNShaderOutput {
    vec4 color;
  } _output;

  vec2 poissonDisk[4] = vec2[](
    vec2( -0.94201624, -0.39906216 ),
    vec2( 0.94558609, -0.76890725 ),
    vec2( -0.094184101, -0.92938870 ),
    vec2( 0.34495938, 0.29387760 )
  );

  //#define kSCNTexcoordCount 2
  //struct SCNShaderGeometry {
  //  vec3 position;
  //  vec3 normal;
  //  vec4 tangent;
  //  vec4 color;
  //  vec2 texcoords[kSCNTexcoordCount];
  //};

  uniform float u_time;

  in vec3 v_position;
  in vec3 v_normal;
  in vec2 v_texcoord0;
  in vec2 v_texcoord1;
  //in vec4 v_color;
  in vec3 v_eye;
  in vec3 v_tangent;
  in vec3 v_bitangent;
  in float v_fogFactor;

  //in SCNShaderGeometry _geometry;

  out vec4 outColor;

  __USER_CUSTOM_UNIFORM__

  float saturate(float value) {
    return clamp(value, 0.0, 1.0);
  }

  float convDepth(vec4 color) {
    const float rMask = 1.0;
    const float gMask = 1.0 / 255.0;
    const float bMask = 1.0 / (255.0 * 255.0);
    const float aMask = 1.0 / (255.0 * 255.0 * 255.0);
    float depth = dot(color, vec4(rMask, gMask, bMask, aMask));
    return depth * 2.0 - 1.0;
  }

  #if USE_SHADER_MODIFIER_SURFACE
  void shaderModifierSurface() {
    __SHADER_MODIFIER_SURFACE__
  }
  #endif

  #if USE_SHADER_MODIFIER_FRAGMENT
  void shaderModifierFragment() {
    __SHADER_MODIFIER_FRAGMENT__
  }
  #endif

    
  void main() {
    //_output.color = v_color;
    //_output.color = vec4(0, 0, 0, 1);

    //vec3 viewVec = normalize(v_eye);
    //vec3 nom = normalize(v_normal);
    _surface.view = normalize(v_eye);
    _surface.position = v_position;
    _surface.normal = normalize(v_normal);
    _surface.tangent = normalize(v_tangent);
    _surface.bitangent = normalize(v_bitangent);

    // normal texture
    if(textureFlags[TEXTURE_NORMAL_INDEX]){
      mat3 tsInv = mat3(_surface.tangent, _surface.bitangent, _surface.normal);
      vec3 color = normalize(texture(u_normalTexture, v_texcoord0).rgb * 2.0 - 1.0); // FIXME: check mappingChannel to decide which texture you use.
      _surface.normal = normalize(tsInv * color);
    }

    //_surface.ambient = material.ambient;
    _surface.ambient = vec4(0, 0, 0, 1); // FIXME: check: lock ambient with diffuse
    _surface.diffuse = material.diffuse;
    _surface.specular = material.specular;
    _surface.emission = material.emission;
    _surface.multiply = material.multiply;
    _surface.transparent = material.transparent;
    _surface.reflective = material.reflective;
    _surface.ambientOcclusion = 1.0; // TODO: calculate AO
    _surface.shininess = material.shininess;
    _surface.fresnel = 0.4 * pow(1.0 - clamp(dot(_surface.view, _surface.normal), 0.0, 1.0), material.fresnelExponent); // TODO: calculate coefficient

    // TODO: check mapping channel for each material
    _surface.ambientTexcoord = v_texcoord0;
    _surface.diffuseTexcoord = v_texcoord0;
    _surface.specularTexcoord = v_texcoord0;
    if(selfIllumination){
      _surface.emissionTexcoord = v_texcoord1;
    }else{
      _surface.emissionTexcoord = v_texcoord0;
    }
    _surface.multiplyTexcoord = v_texcoord0;
    _surface.transparentTexcoord = v_texcoord0;

    if(textureFlags[TEXTURE_AMBIENT_INDEX]){
      _surface.ambient = texture(u_ambientTexture, _surface.ambientTexcoord);
    }
    if(textureFlags[TEXTURE_DIFFUSE_INDEX]){
      _surface.diffuse = texture(u_diffuseTexture, _surface.diffuseTexcoord);
      _surface.diffuse.a *= material.diffuse.a;
    }
    if(textureFlags[TEXTURE_SPECULAR_INDEX]){
      _surface.specular = texture(u_specularTexture, _surface.specularTexcoord);
    }
    if(textureFlags[TEXTURE_EMISSION_INDEX]){
      _surface.emission = texture(u_emissionTexture, _surface.emissionTexcoord);
    }
    if(textureFlags[TEXTURE_MULTIPLY_INDEX]){
      _surface.multiply = texture(u_multiplyTexture, _surface.multiplyTexcoord);
    }
    if(textureFlags[TEXTURE_TRANSPARENT_INDEX]){
      _surface.transparent = texture(u_transparentTexture, _surface.transparentTexcoord);
    }

    __USER_CUSTOM_TEXCOORD__

    #if USE_SHADER_MODIFIER_SURFACE
      shaderModifierSurface();
    #endif

    // Lighting
    int numLights = 0;
    _lightingContribution.ambient = vec3(0);
    _lightingContribution.diffuse = vec3(0);
    _lightingContribution.specular = vec3(0);

    #if NUM_AMBIENT_LIGHTS > 0
      for(int i=0; i<NUM_AMBIENT_LIGHTS; i++){
        _lightingContribution.ambient += light.ambient[i].color.rgb;
      }
    #endif

    #if NUM_DIRECTIONAL_LIGHTS > 0
      for(int i=0; i<NUM_DIRECTIONAL_LIGHTS; i++){
        // diffuse
        vec3 lightVec = normalize(v_light[numLights + i]);
        float diffuse = clamp(dot(lightVec, _surface.normal), 0.0f, 1.0f);
        //_output.color.rgb += light.directional[i].color.rgb * material.diffuse.rgb * diffuse;
        _lightingContribution.diffuse += light.directional[i].color.rgb * diffuse;

        // specular
        if(diffuse > 0.0f){
          vec3 halfVec = normalize(lightVec + _surface.view);
          float specular = pow(dot(halfVec, _surface.normal), _surface.shininess);
          // TODO: use intensity
          _lightingContribution.specular += vec3(specular);
        }
      }
      numLights += NUM_DIRECTIONAL_LIGHTS;
    #endif

    #if NUM_OMNI_LIGHTS > 0
      for(int i=0; i<NUM_OMNI_LIGHTS; i++){
        // diffuse
        vec3 lightVec = normalize(v_light[numLights + i]);
        float diffuse = clamp(dot(lightVec, _surface.normal), 0.0f, 1.0f);
        //_output.color.rgb += light.omni[i].color.rgb * material.diffuse.rgb * diffuse;
        _lightingContribution.diffuse += light.omni[i].color.rgb * diffuse;

        // specular
        if(diffuse > 0.0f){
          vec3 halfVec = normalize(lightVec + _surface.view);
          float specular = pow(dot(halfVec, _surface.normal), _surface.shininess);
          // TODO: use intensity
          _lightingContribution.specular += vec3(1, 1, 1) * specular;
        }
      }
      numLights += NUM_OMNI_LIGHTS;
    #endif

    #if NUM_SPOT_LIGHTS > 0
      // TODO: implement
    #endif

    #if NUM_IES_LIGHTS > 0
      // TODO: implement
    #endif

    #if NUM_PROBE_LIGHTS > 0
      // TODO: implement
    #endif

    __FS_LIGHTING__


    // calculate color
    _output.color = vec4(0, 0, 0, _surface.diffuse.a);

    vec3 D = _lightingContribution.diffuse;

    // lock ambient with diffuse
    D += _lightingContribution.ambient * _surface.ambientOcclusion;

    // emission
    if(selfIllumination){
      D += _surface.emission.rgb;
    }

    // diffuse
    _output.color.rgb = _surface.diffuse.rgb * D;

    vec3 S = _lightingContribution.specular;
    //S += _surface.reflective.rgb * _surface.ambientOcclusion;
    S *= _surface.specular.rgb;
    _output.color.rgb += S;

    // ambient
    _output.color.rgb += _surface.ambient.rgb * _lightingContribution.ambient;

    if(!selfIllumination){
      _output.color.rgb += _surface.emission.rgb;
    }

    // multiply
    _output.color.rgb *= _surface.multiply.rgb;

    // fresnel reflection
    if(textureFlags[TEXTURE_REFLECTIVE_INDEX]){
      vec3 r = reflect(_surface.view, _surface.normal);
      //float fresnel = f0 + (1.0 - f0) * pow(1.0 - clamp(dot(viewVec, nom), 0.0, 1.0), material.fresnelExponent);
      //float fresnel = 0.4 * pow(1.0 - clamp(dot(_surface.view, _surface.normal), 0.0, 1.0), material.fresnelExponent);
      _output.color.rgb += texture(u_reflectiveTexture, r).rgb * _surface.fresnel;
    }

    float fogFactor = pow(v_fogFactor, fog.densityExponent);
    _output.color = mix(_output.color, fog.color, fogFactor);

    _output.color.rgb *= _surface.diffuse.a;

    #if USE_SHADER_MODIFIER_FRAGMENT
      shaderModifierFragment();
    #endif

    if(_output.color.a <= 0.0){
      // avoid overwriting the depth buffer
      discard;
    }

    outColor = _output.color;

    // linear To sRGB
    //outColor.rgb = pow(_output.color.rgb, vec3(1.0/2.2));
    //outColor.a = _output.color.a;
  }
`;

/**
 * @type {string}
 */

const _SCNDefaultHitTestFragmentShader = `#version 300 es
  precision mediump float;

  uniform int objectID;
  uniform int geometryID;

  in vec3 v_normal;
  in vec3 v_position;

  layout(location = 0) out vec4 out_objectID;
  layout(location = 1) out vec4 out_faceID;
  layout(location = 2) out vec4 out_position;
  layout(location = 3) out vec4 out_normal;

  void main() {
    out_objectID = vec4(
      float(objectID >> 8) / 255.0,
      float(objectID & 0xFF) / 255.0,
      float(geometryID >> 8) / 255.0,
      float(geometryID & 0xFF) / 255.0
    );
    //out_faceID = vec4(
    //  (gl_PrimitiveID >> 24) / 255.0,
    //  ((gl_PrimitiveID >> 16) & 0xFF) / 255.0,
    //  ((gl_PrimitiveID >> 8) & 0xFF) / 255.0,
    //  (gl_PrimitiveID & 0xFF) / 255.0
    //);
    out_faceID = vec4(0, 0, 0, 0); // TODO: implement
    vec3 n = normalize(v_normal);
    out_normal = vec4((n.x + 1.0) * 0.5, (n.y + 1.0) * 0.5, (n.z + 1.0) * 0.5, 0);
    //out_position = vec4((v_position.x + 1.0) * 0.5, (v_position.y + 1.0) * 0.5, (v_position.z + 1.0) * 0.5, 0);
    float r = (v_position.z + 1.0) * 0.5;
    float g = fract(r * 255.0);
    float b = fract(g * 255.0);
    float a = fract(b * 255.0);
    float coef = 1.0 / 255.0;

    r -= g * coef;
    g -= b * coef;
    b -= a * coef;
    out_position = vec4(r, g, b, a);
  }
`;

/**
 * @type {string}
 */

const _SCNDefaultHitTestVertexShader = `#version 300 es
  precision mediump float;

  uniform mat4 viewProjectionTransform;
  uniform vec4[765] skinningJoints;
  uniform int numSkinningJoints;

  in vec3 position;
  in vec3 normal;
  in vec4 boneIndices;
  in vec4 boneWeights;
  
  out vec3 v_normal;
  out vec3 v_position;

  void main() {
    vec3 pos = vec3(0, 0, 0);
    vec3 nom = vec3(0, 0, 0);
    if(numSkinningJoints > 0){
      for(int i=0; i<numSkinningJoints; i++){
        float weight = boneWeights[i];
        if(int(boneIndices[i]) < 0){
          continue;
        }
        int idx = int(boneIndices[i]) * 3;
        mat4 jointMatrix = transpose(mat4(skinningJoints[idx],
                                          skinningJoints[idx+1],
                                          skinningJoints[idx+2],
                                          vec4(0, 0, 0, 1)));
        pos += (jointMatrix * vec4(position, 1.0)).xyz * weight;
        nom += (mat3(jointMatrix) * normal) * weight;
      }
    }else{
      mat4 jointMatrix = transpose(mat4(skinningJoints[0],
                                        skinningJoints[1],
                                        skinningJoints[2],
                                        vec4(0, 0, 0, 1)));
      pos = (jointMatrix * vec4(position, 1.0)).xyz;
      nom = mat3(jointMatrix) * normal;
    }
    //v_position = pos;
    v_normal = nom;

    gl_Position = viewProjectionTransform * vec4(pos, 1.0);
    v_position = gl_Position.xyz / gl_Position.w;
  }
`;

/**
 * @type {string}
 */

const _SCNDefaultParticleFragmentShader = `#version 300 es
  precision mediump float;

  uniform sampler2D particleTexture;

  in vec2 v_texcoord;
  in vec4 v_color;

  out vec4 outColor;

  void main() {
    vec4 texColor = texture(particleTexture, v_texcoord);
    if(texColor.a <= 0.0){
      // avoid overwriting the depth buffer
      discard;
    }

    texColor.rgb *= texColor.a;
    outColor = v_color * texColor;
  }
`;

/**
 * @type {string}
 */

const _SCNDefaultParticleVertexShader = `#version 300 es
  precision mediump float;

  uniform mat4 modelTransform;
  uniform mat4 viewTransform;
  uniform mat4 projectionTransform;
  uniform int orientationMode;
  uniform float stretchFactor;

  in vec3 position;
  in vec3 velocity;
  in vec4 rotation;
  in vec4 color;
  in float size;
  //in float life;
  in vec2 corner;
  in vec2 texcoord;

  out vec2 v_texcoord;
  out vec4 v_color;

  void main() {
    vec4 pos = viewTransform * vec4(position, 1.0);
    vec3 d;

    if(stretchFactor > 0.0){
      vec4 v = viewTransform * vec4(velocity, 0.0) * stretchFactor;
      if(corner.y > 0.0){
        pos.xyz += v.xyz;
      }
      vec2 cy = normalize(v.xy);
      vec2 cx = vec2(-cy.y, cy.x);
      d = vec3(cx * corner.x + cy * corner.y, 0) * size;
    }else{
      float sinAngle = sin(rotation.w);
      float cosAngle = cos(rotation.w);
      float tcos = 1.0 - cosAngle;

      d = vec3(
          corner.x * (rotation.x * rotation.x * tcos + cosAngle)
        + corner.y * (rotation.x * rotation.y * tcos - rotation.z * sinAngle),
          corner.x * (rotation.y * rotation.x * tcos + rotation.z * sinAngle)
        + corner.y * (rotation.y * rotation.y * tcos + cosAngle),
          corner.x * (rotation.z * rotation.x * tcos - rotation.y * sinAngle)
        + corner.y * (rotation.z * rotation.y * tcos + rotation.x * sinAngle)) * size;
      if(orientationMode == 2){
        // orientation: free
        d = mat3(viewTransform) * mat3(modelTransform) * d;
      }
    }
    pos.xyz += d;

    v_color = color;
    v_texcoord = texcoord;
    gl_Position = projectionTransform * pos;
  }
`;

/**
 * @type {string}
 */

const _SCNDefaultPBRFragmentShader = `#version 300 es
  precision mediump float;
  precision highp sampler2DShadow;

  uniform bool[12] textureFlags;
  #define TEXTURE_EMISSION_INDEX 0
  #define TEXTURE_AMBIENT_INDEX 1
  #define TEXTURE_DIFFUSE_INDEX 2
  #define TEXTURE_SPECULAR_INDEX 3
  #define TEXTURE_REFLECTIVE_INDEX 4
  #define TEXTURE_TRANSPARENT_INDEX 5
  #define TEXTURE_MULTIPLY_INDEX 6
  #define TEXTURE_NORMAL_INDEX 7
  #define TEXTURE_AMBIENT_OCCLUSION_INDEX 8
  #define TEXTURE_SELF_ILLUMINATION_INDEX 9
  #define TEXTURE_METALNESS_INDEX 10
  #define TEXTURE_ROUGHNESS_INDEX 11

  uniform bool selfIllumination;

  uniform sampler2D u_emissionTexture;
  uniform sampler2D u_ambientTexture;
  uniform sampler2D u_diffuseTexture;
  uniform sampler2D u_specularTexture;
  uniform samplerCube u_reflectiveTexture;
  uniform sampler2D u_transparentTexture;
  uniform sampler2D u_multiplyTexture;
  uniform sampler2D u_normalTexture;
  uniform sampler2D u_ambientOcclusionTexture;
  uniform sampler2D u_selfIlluminationTexture;
  uniform sampler2D u_metalnessTexture;
  uniform sampler2D u_roughnessTexture;

  #define NUM_AMBIENT_LIGHTS __NUM_AMBIENT_LIGHTS__
  #define NUM_DIRECTIONAL_LIGHTS __NUM_DIRECTIONAL_LIGHTS__
  #define NUM_DIRECTIONAL_SHADOW_LIGHTS __NUM_DIRECTIONAL_SHADOW_LIGHTS__
  #define NUM_OMNI_LIGHTS __NUM_OMNI_LIGHTS__
  #define NUM_SPOT_LIGHTS __NUM_SPOT_LIGHTS__
  #define NUM_IES_LIGHTS __NUM_IES_LIGHTS__
  #define NUM_PROBE_LIGHTS __NUM_PROBE_LIGHTS__

  #define NUM_SHADOW_LIGHTS (NUM_DIRECTIONAL_LIGHTS + NUM_DIRECTIONAL_SHADOW_LIGHTS + NUM_OMNI_LIGHTS + NUM_SPOT_LIGHTS)
  #define NUM_LIGHTS (NUM_AMBIENT_LIGHTS + NUM_DIRECTIONAL_LIGHTS + NUM_DIRECTIONAL_SHADOW_LIGHTS + NUM_OMNI_LIGHTS + NUM_SPOT_LIGHTS + NUM_IES_LIGHTS + NUM_PROBE_LIGHTS)

  #define USE_SHADER_MODIFIER_SURFACE __USE_SHADER_MODIFIER_SURFACE__
  #define USE_SHADER_MODIFIER_FRAGMENT __USE_SHADER_MODIFIER_FRAGMENT__

  layout (std140) uniform cameraUniform {
    vec4 position;
    mat4 viewTransform;
    mat4 inverseViewTransform;
    mat4 viewProjectionTransform;
  } camera;

  layout (std140) uniform materialUniform {
    vec4 ambient;
    vec4 diffuse;
    vec4 specular;
    vec4 normal;
    vec4 reflective;
    vec4 emission;
    vec4 transparent;
    vec4 multiply;
    vec4 ambientOcclusion;
    vec4 selfIllumination;
    vec4 metalness;
    vec4 roughness;
    float shininess;
    float fresnelExponent;
  } material;

  struct AmbientLight {
    vec4 color;
  };

  struct SCNShaderLightingContribution {
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
  } _lightingContribution;

  struct DirectionalLight {
    vec4 color;
    vec4 direction; // should use vec4; vec3 might cause problem for the layout
  };

  struct DirectionalShadowLight {
    vec4 color;
    vec4 direction; // should use vec4; vec3 might cause problem for the layout
    vec4 shadowColor;
    mat4 viewProjectionTransform;
    mat4 shadowProjectionTransform;
  };

  struct OmniLight {
    vec4 color;
    vec4 position; // should use vec4; vec3 might cause problem for the layout
  };

  struct ProbeLight {
    // TODO: implement
    vec4 color;
  };

  struct SpotLight {
    // TODO: implement
    vec4 color;
  };

  layout (std140) uniform lightUniform {
    #if NUM_AMBIENT_LIGHTS > 0
      AmbientLight ambient[NUM_AMBIENT_LIGHTS];
    #endif
    #if NUM_DIRECTIONAL_LIGHTS > 0
      DirectionalLight directional[NUM_DIRECTIONAL_LIGHTS];
    #endif
    #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 0
      DirectionalShadowLight directionalShadow[NUM_DIRECTIONAL_SHADOW_LIGHTS];
    #endif
    #if NUM_OMNI_LIGHTS > 0
      OmniLight omni[NUM_OMNI_LIGHTS];
    #endif
    #if NUM_SPOT_LIGHTS > 0
      SpotLight spot[NUM_SPOT_LIGHTS];
    #endif
    #if NUM_IES_LIGHTS > 0
      IESLight ies[NUM_IES_LIGHTS];
    #endif
    #if NUM_PROBE_LIGHTS > 0
      ProbeLight probe[NUM_PROBE_LIGHTS];
    #endif
    #if NUM_LIGHTS == 0
      vec4 dummy;
    #endif
  } light;
  #if NUM_SHADOW_LIGHTS > 0
    in vec3 v_light[NUM_SHADOW_LIGHTS];
  #endif
  #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 0
    in vec4 v_directionalShadowDepth[NUM_DIRECTIONAL_SHADOW_LIGHTS];
    in vec4 v_directionalShadowTexcoord[NUM_DIRECTIONAL_SHADOW_LIGHTS];
    uniform sampler2D u_shadowTexture0;
    #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 1
      uniform sampler2D u_shadowTexture1;
    #endif
    #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 2
      uniform sampler2D u_shadowTexture2;
    #endif
    #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 3
      uniform sampler2D u_shadowTexture3;
    #endif
  #endif

  layout (std140) uniform SCNLightsUniform {
    vec4 direction0;
    mat4 shadowMatrix0;
  } scn_lights;

  layout (std140) uniform fogUniform {
    vec4 color;
    float startDistance;
    float endDistance;
    float densityExponent;
  } fog;

  struct SCNShaderSurface {
    vec3 view;
    vec3 position;
    vec3 normal;
    vec2 normalTexcoord;
    vec3 geometryNormal;
    vec3 tangent;
    vec3 bitangent;
    vec4 ambient;
    vec2 ambientTexcoord;
    vec4 diffuse;
    vec2 diffuseTexcoord;
    vec4 specular;
    vec2 specularTexcoord;
    vec4 emission;
    vec2 emissionTexcoord;
    vec4 multiply;
    vec2 multiplyTexcoord;
    vec4 transparent;
    vec2 transparentTexcoord;
    vec4 reflective;
    vec2 metalnessTexcoord;
    vec2 roughnessTexcoord;
    float ambientOcclusion;
    float shininess;
    float fresnel;
    float metalness;
    float roughness;
    __USER_CUSTOM_SURFACE__
  } _surface;

  struct SCNShaderOutput {
    vec4 color;
  } _output;

  vec2 poissonDisk[4] = vec2[](
    vec2( -0.94201624, -0.39906216 ),
    vec2( 0.94558609, -0.76890725 ),
    vec2( -0.094184101, -0.92938870 ),
    vec2( 0.34495938, 0.29387760 )
  );

  //#define kSCNTexcoordCount 2
  //struct SCNShaderGeometry {
  //  vec3 position;
  //  vec3 normal;
  //  vec4 tangent;
  //  vec4 color;
  //  vec2 texcoords[kSCNTexcoordCount];
  //};

  uniform float u_time;

  in vec3 v_position;
  in vec3 v_normal;
  in vec2 v_texcoord0;
  in vec2 v_texcoord1;
  //in vec4 v_color;
  in vec3 v_eye;
  in vec3 v_tangent;
  in vec3 v_bitangent;
  in float v_fogFactor;

  //in SCNShaderGeometry _geometry;

  out vec4 outColor;

  __USER_CUSTOM_UNIFORM__

  float saturate(float value) {
    return clamp(value, 0.0, 1.0);
  }

  float convDepth(vec4 color) {
    const float rMask = 1.0;
    const float gMask = 1.0 / 255.0;
    const float bMask = 1.0 / (255.0 * 255.0);
    const float aMask = 1.0 / (255.0 * 255.0 * 255.0);
    float depth = dot(color, vec4(rMask, gMask, bMask, aMask));
    return depth * 2.0 - 1.0;
  }

  #if USE_SHADER_MODIFIER_SURFACE
  void shaderModifierSurface() {
    __SHADER_MODIFIER_SURFACE__
  }
  #endif

  #if USE_SHADER_MODIFIER_FRAGMENT
  void shaderModifierFragment() {
    __SHADER_MODIFIER_FRAGMENT__
  }
  #endif

    
  void main() {
    //_output.color = v_color;
    //_output.color = vec4(0, 0, 0, 1);

    //vec3 viewVec = normalize(v_eye);
    //vec3 nom = normalize(v_normal);
    _surface.view = normalize(v_eye);
    _surface.position = v_position;
    _surface.normal = normalize(v_normal);
    _surface.tangent = normalize(v_tangent);
    _surface.bitangent = normalize(v_bitangent);

    // normal texture
    if(textureFlags[TEXTURE_NORMAL_INDEX]){
      mat3 tsInv = mat3(_surface.tangent, _surface.bitangent, _surface.normal);
      vec3 color = normalize(texture(u_normalTexture, v_texcoord0).rgb * 2.0 - 1.0); // FIXME: check mappingChannel to decide which texture you use.
      _surface.normal = normalize(tsInv * color);
    }

    //_surface.ambient = material.ambient;
    _surface.ambient = vec4(0, 0, 0, 1); // FIXME: check: lock ambient with diffuse
    _surface.diffuse = material.diffuse;
    _surface.specular = material.specular;
    _surface.emission = material.emission;
    _surface.multiply = material.multiply;
    _surface.transparent = material.transparent;
    _surface.reflective = material.reflective;
    _surface.ambientOcclusion = material.ambientOcclusion.r;
    _surface.shininess = material.shininess;
    _surface.fresnel = 0.4 * pow(1.0 - clamp(dot(_surface.view, _surface.normal), 0.0, 1.0), material.fresnelExponent); // TODO: calculate coefficient
    _surface.metalness = material.metalness.r;
    _surface.roughness = material.roughness.r;

    // TODO: check mapping channel for each material
    _surface.ambientTexcoord = v_texcoord0;
    _surface.diffuseTexcoord = v_texcoord0;
    _surface.specularTexcoord = v_texcoord0;
    if(selfIllumination){
      _surface.emissionTexcoord = v_texcoord1;
    }else{
      _surface.emissionTexcoord = v_texcoord0;
    }
    _surface.multiplyTexcoord = v_texcoord0;
    _surface.transparentTexcoord = v_texcoord0;
    _surface.metalnessTexcoord = v_texcoord0;
    _surface.roughnessTexcoord = v_texcoord0;

    if(textureFlags[TEXTURE_AMBIENT_INDEX]){
      _surface.ambient = texture(u_ambientTexture, _surface.ambientTexcoord);
    }
    if(textureFlags[TEXTURE_DIFFUSE_INDEX]){
      _surface.diffuse = texture(u_diffuseTexture, _surface.diffuseTexcoord);
      _surface.diffuse.a *= material.diffuse.a;
    }
    if(textureFlags[TEXTURE_SPECULAR_INDEX]){
      _surface.specular = texture(u_specularTexture, _surface.specularTexcoord);
    }
    if(textureFlags[TEXTURE_EMISSION_INDEX]){
      _surface.emission = texture(u_emissionTexture, _surface.emissionTexcoord);
    }
    if(textureFlags[TEXTURE_MULTIPLY_INDEX]){
      _surface.multiply = texture(u_multiplyTexture, _surface.multiplyTexcoord);
    }
    if(textureFlags[TEXTURE_TRANSPARENT_INDEX]){
      _surface.transparent = texture(u_transparentTexture, _surface.transparentTexcoord);
    }
    if(textureFlags[TEXTURE_METALNESS_INDEX]){
      _surface.metalness = texture(u_metalnessTexture, _surface.metalnessTexcoord).r;
    }
    if(textureFlags[TEXTURE_ROUGHNESS_INDEX]){
      _surface.roughness = texture(u_roughnessTexture, _surface.roughnessTexcoord).r;
    }

    __USER_CUSTOM_TEXCOORD__

    #if USE_SHADER_MODIFIER_SURFACE
      shaderModifierSurface();
    #endif

    // Lighting
    int numLights = 0;
    _lightingContribution.ambient = vec3(0);
    _lightingContribution.diffuse = vec3(0);
    _lightingContribution.specular = vec3(0);

    #if NUM_AMBIENT_LIGHTS > 0
      for(int i=0; i<NUM_AMBIENT_LIGHTS; i++){
        _lightingContribution.ambient += light.ambient[i].color.rgb;
      }
    #endif

    #if NUM_DIRECTIONAL_LIGHTS > 0
      for(int i=0; i<NUM_DIRECTIONAL_LIGHTS; i++){
        // diffuse
        vec3 lightVec = normalize(v_light[numLights + i]);
        float diffuse = clamp(dot(lightVec, _surface.normal), 0.0f, 1.0f);
        _lightingContribution.diffuse += light.directional[i].color.rgb * diffuse;

        // specular
        if(diffuse > 0.0f){
          vec3 halfVec = normalize(lightVec + _surface.view);
          float specular = pow(dot(halfVec, _surface.normal), _surface.shininess);
          _lightingContribution.specular += vec3(specular);
        }
      }
      numLights += NUM_DIRECTIONAL_LIGHTS;
    #endif

    #if NUM_OMNI_LIGHTS > 0
      for(int i=0; i<NUM_OMNI_LIGHTS; i++){
        // diffuse
        vec3 lightVec = normalize(v_light[numLights + i]);
        float diffuse = clamp(dot(lightVec, _surface.normal), 0.0f, 1.0f);
        //_output.color.rgb += light.omni[i].color.rgb * material.diffuse.rgb * diffuse;
        _lightingContribution.diffuse += light.omni[i].color.rgb * diffuse;

        // specular
        if(diffuse > 0.0f){
          vec3 halfVec = normalize(lightVec + _surface.view);
          float specular = pow(dot(halfVec, _surface.normal), _surface.shininess);
          // TODO: use intensity
          _lightingContribution.specular += vec3(1, 1, 1) * specular;
        }
      }
      numLights += NUM_OMNI_LIGHTS;
    #endif

    #if NUM_SPOT_LIGHTS > 0
      // TODO: implement
    #endif

    #if NUM_IES_LIGHTS > 0
      // TODO: implement
    #endif

    #if NUM_PROBE_LIGHTS > 0
      // TODO: implement
    #endif

    __FS_LIGHTING__


    // calculate color
    _output.color = vec4(0, 0, 0, _surface.diffuse.a);

    //vec3 D = _lightingContribution.diffuse;
    //// lock ambient with diffuse
    //D += _lightingContribution.ambient * _surface.ambientOcclusion;
    //// emission
    //if(selfIllumination){
    //  D += _surface.emission.rgb;
    //}
    //// diffuse
    //_output.color.rgb = _surface.diffuse.rgb * D;
    //vec3 S = _lightingContribution.specular;
    ////S += _surface.reflective.rgb * _surface.ambientOcclusion;
    //S *= _surface.specular.rgb;
    //_output.color.rgb += S;
    //// ambient
    //_output.color.rgb += _surface.ambient.rgb * _lightingContribution.ambient;
    //if(!selfIllumination){
    //  _output.color.rgb += _surface.emission.rgb;
    //}
    //// multiply
    //_output.color.rgb *= _surface.multiply.rgb;
    //// fresnel reflection
    //if(textureFlags[TEXTURE_REFLECTIVE_INDEX]){
    //  vec3 r = reflect(_surface.view, _surface.normal);
    //  //float fresnel = f0 + (1.0 - f0) * pow(1.0 - clamp(dot(viewVec, nom), 0.0, 1.0), material.fresnelExponent);
    //  //float fresnel = 0.4 * pow(1.0 - clamp(dot(_surface.view, _surface.normal), 0.0, 1.0), material.fresnelExponent);
    //  _output.color.rgb += texture(u_reflectiveTexture, r).rgb * _surface.fresnel;
    //}
    //float fogFactor = pow(v_fogFactor, fog.densityExponent);
    //_output.color = mix(_output.color, fog.color, fogFactor);
    //_output.color.rgb *= _surface.diffuse.a;

    #define pi 3.14159265
    vec4 debugColor;
    float alpha = pow(_surface.roughness, 4.0);
    float invAlpha = 1.0 - alpha;
    float nv = clamp(dot(_surface.normal, _surface.view), 0.0, 1.0);
    float f0 = 0.6;
    float Gv = 1.0 / (nv + sqrt(alpha + invAlpha * nv * nv));
    for(int i=0; i<NUM_SHADOW_LIGHTS; i++){
      vec3 lightVec = normalize(v_light[i]);
      vec3 halfVec = normalize(lightVec + _surface.view);

      float nh = clamp(dot(_surface.normal, halfVec), 0.0, 1.0);
      float nl = clamp(dot(_surface.normal, lightVec), 0.0, 1.0);
      //float vh = clamp(dot(_surface.view, halfVec), 0.0, 1.0);

      float D = alpha / (pi * pow(nh * nh * (alpha - 1.0) + 1.0, 2.0));
      //float F = f0 + (1.0 - f0) * pow(vh, 5.0);
      float F = f0 + (1.0 - f0) * pow(1.0 - nh, 5.0);
      float G = Gv / (nl + sqrt(alpha + invAlpha * nl * nl));
      float specular = D * F * G;
      float diffuse = (1.0 - F) * nl / pi;
      _output.color.rgb += _surface.diffuse.rgb * mix(diffuse, specular, _surface.metalness);

      debugColor = vec4(F, nl, diffuse, 1.0);
    }

    #if USE_SHADER_MODIFIER_FRAGMENT
      shaderModifierFragment();
    #endif

    if(_output.color.a <= 0.0){
      // avoid overwriting the depth buffer
      discard;
    }

    outColor = _output.color;

    // linear To sRGB
    //outColor.rgb = pow(_output.color.rgb, vec3(1.0/2.2));
    //outColor.a = _output.color.a;

    //outColor = vec4(1.0, 0.0, 0.0, 1.0);
    //outColor = debugColor;
  }

`;

/**
 * @access private
 * @type {string}
 */

const _SCNDefaultShadowFragmentShader = `#version 300 es
  precision mediump float;

  in vec3 v_position;

  layout(location = 0) out vec4 out_depth;
  //layout(location = 0) out float out_depth;

  void main() {
    float r = (v_position.z + 1.0) * 0.5;
    float g = fract(r * 255.0);
    float b = fract(g * 255.0);
    float a = fract(b * 255.0);
    float coef = 1.0 / 255.0;

    r -= g * coef;
    g -= b * coef;
    b -= a * coef;
    out_depth = vec4(r, g, b, a);
    //out_depth = v_position.z;
  }
`;

/**
 * @access private
 * @type {string}
 */

const _SCNDefaultShadowVertexShader = `#version 300 es
  precision mediump float;

  uniform mat4 viewProjectionTransform;
  uniform vec4[765] skinningJoints;
  uniform int numSkinningJoints;

  in vec3 position;
  //in vec3 normal;
  in vec4 boneIndices;
  in vec4 boneWeights;

  out vec3 v_position;

  void main() {
    vec3 pos = vec3(0, 0, 0);
    if(numSkinningJoints > 0){
      for(int i=0; i<numSkinningJoints; i++){
        float weight = boneWeights[i];
        if(int(boneIndices[i]) < 0){
          continue;
        }
        int idx = int(boneIndices[i]) * 3;
        mat4 jointMatrix = transpose(mat4(skinningJoints[idx],
                                          skinningJoints[idx+1],
                                          skinningJoints[idx+2],
                                          vec4(0, 0, 0, 1)));
        pos += (jointMatrix * vec4(position, 1.0)).xyz * weight;
      }
    }else{
      mat4 jointMatrix = transpose(mat4(skinningJoints[0],
                                        skinningJoints[1],
                                        skinningJoints[2],
                                        vec4(0, 0, 0, 1)));
      pos = (jointMatrix * vec4(position, 1.0)).xyz;
    }
    //v_position = pos;

    gl_Position = viewProjectionTransform * vec4(pos, 1.0);
    v_position = gl_Position.xyz / gl_Position.w;
  }
`;

/**
 * @type {string}
 */

const _SCNDefaultVertexShader = `#version 300 es
  precision mediump float;

  #define NUM_AMBIENT_LIGHTS __NUM_AMBIENT_LIGHTS__
  #define NUM_DIRECTIONAL_LIGHTS __NUM_DIRECTIONAL_LIGHTS__
  #define NUM_DIRECTIONAL_SHADOW_LIGHTS __NUM_DIRECTIONAL_SHADOW_LIGHTS__
  #define NUM_OMNI_LIGHTS __NUM_OMNI_LIGHTS__
  #define NUM_SPOT_LIGHTS __NUM_SPOT_LIGHTS__
  #define NUM_IES_LIGHTS __NUM_IES_LIGHTS__
  #define NUM_PROBE_LIGHTS __NUM_PROBE_LIGHTS__

  #define NUM_SHADOW_LIGHTS (NUM_DIRECTIONAL_LIGHTS + NUM_DIRECTIONAL_SHADOW_LIGHTS + NUM_OMNI_LIGHTS + NUM_SPOT_LIGHTS)
  #define NUM_LIGHTS (NUM_AMBIENT_LIGHTS + NUM_DIRECTIONAL_LIGHTS + NUM_DIRECTIONAL_SHADOW_LIGHTS + NUM_OMNI_LIGHTS + NUM_SPOT_LIGHTS + NUM_IES_LIGHTS + NUM_PROBE_LIGHTS)

  #define USE_SHADER_MODIFIER_GEOMETRY __USE_SHADER_MODIFIER_GEOMETRY__

  layout (std140) uniform cameraUniform {
    vec4 position;
    mat4 viewTransform;
    mat4 inverseViewTransform;
    mat4 viewProjectionTransform;
  } camera;

  layout (std140) uniform materialUniform {
    vec4 ambient;
    vec4 diffuse;
    vec4 specular;
    vec4 normal;
    vec4 reflective;
    vec4 emission;
    vec4 transparent;
    vec4 multiply;
    vec4 ambientOcclusion;
    vec4 selfIllumination;
    vec4 metalness;
    vec4 roughness;
    float shininess;
    float fresnelExponent;
  } material;

  struct AmbientLight {
    vec4 color;
  };

  struct DirectionalLight {
    vec4 color;
    vec4 direction; // should use vec4; vec3 might cause problem for the layout
  };

  struct DirectionalShadowLight {
    vec4 color;
    vec4 direction; // should use vec4; vec3 might cause problem for the layout
    vec4 shadowColor;
    mat4 viewProjectionTransform;
    mat4 shadowProjectionTransform;
  };

  struct OmniLight {
    vec4 color;
    vec4 position; // should use vec4; vec3 might cause problem for the layout
  };

  struct SpotLight {
    // TODO: implement
    vec4 color;
  };

  struct IESLight {
    // TODO: implement
    vec4 color;
  };

  struct ProbeLight {
    // TODO: implement
    vec4 color;
  };

  layout (std140) uniform lightUniform {
    #if NUM_AMBIENT_LIGHTS > 0
      AmbientLight ambient[NUM_AMBIENT_LIGHTS];
    #endif
    #if NUM_DIRECTIONAL_LIGHTS > 0
      DirectionalLight directional[NUM_DIRECTIONAL_LIGHTS];
    #endif
    #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 0
      DirectionalShadowLight directionalShadow[NUM_DIRECTIONAL_SHADOW_LIGHTS];
    #endif
    #if NUM_OMNI_LIGHTS > 0
      OmniLight omni[NUM_OMNI_LIGHTS];
    #endif
    #if NUM_SPOT_LIGHTS > 0
      SpotLight spot[NUM_SPOT_LIGHTS];
    #endif
    #if NUM_IES_LIGHTS > 0
      IESLight ies[NUM_IES_LIGHTS];
    #endif
    #if NUM_PROBE_LIGHTS > 0
      ProbeLight probe[NUM_PROBE_LIGHTS];
    #endif
    #if NUM_LIGHTS == 0
      vec4 dummy;
    #endif
  } light;

  #if NUM_SHADOW_LIGHTS > 0
    out vec3 v_light[NUM_SHADOW_LIGHTS];
  #endif
  #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 0
    out vec4 v_directionalShadowDepth[NUM_DIRECTIONAL_SHADOW_LIGHTS];
    out vec4 v_directionalShadowTexcoord[NUM_DIRECTIONAL_SHADOW_LIGHTS];
  #endif

  layout (std140) uniform fogUniform {
    vec4 color;
    float startDistance;
    float endDistance;
    float densityExponent;
  } fog;

  #define kSCNTexcoordCount 2
  struct SCNShaderGeometry {
    vec3 position;
    vec3 normal;
    vec4 tangent;
    vec4 color;
    vec2 texcoords[kSCNTexcoordCount];
  };
  //struct _SCNShaderGeometry {
  //  vec3 position;
  //  vec3 normal;
  //  vec4 tangent;
  //  vec4 color;
  //  vec2 texcoord0;
  //  vec2 texcoord1;
  //};

  uniform float u_time;
  //uniform mat3x4[255] skinningJoints;
  uniform vec4[765] skinningJoints;
  uniform int numSkinningJoints;
  uniform mat4 modelTransform;

  in vec3 position;
  in vec3 normal;
  in vec3 tangent;
  in vec4 color;
  in vec2 texcoord0;
  in vec2 texcoord1;
  in vec4 boneIndices;
  in vec4 boneWeights;

  out vec3 v_position;
  out vec3 v_normal;
  out vec3 v_tangent;
  out vec3 v_bitangent;
  out vec2 v_texcoord0;
  out vec2 v_texcoord1;
  //out vec4 v_color;
  out vec3 v_eye;
  out float v_fogFactor;

  //out _SCNShaderGeometry __geometry;

  __USER_CUSTOM_UNIFORM__

  #if USE_SHADER_MODIFIER_GEOMETRY
  void shaderModifierGeometry(inout SCNShaderGeometry _geometry) {
    __SHADER_MODIFIER_GEOMETRY__
  }
  #endif

  void main() {
    SCNShaderGeometry _geometry;
    _geometry.position = position;
    _geometry.normal = normal;
    _geometry.tangent = vec4(tangent, 1.0);
    _geometry.color = color;
    _geometry.texcoords[0] = texcoord0;
    _geometry.texcoords[1] = texcoord1;
    
    #if USE_SHADER_MODIFIER_GEOMETRY
      shaderModifierGeometry(_geometry);
    #endif

    vec3 pos = vec3(0, 0, 0);
    vec3 nom = vec3(0, 0, 0);
    vec3 tng = vec3(0, 0, 0);
    vec4 col = _geometry.color;

    if(numSkinningJoints > 0){
      for(int i=0; i<numSkinningJoints; i++){
        float weight = boneWeights[i];
        if(int(boneIndices[i]) < 0){
          continue;
        }
        int idx = int(boneIndices[i]) * 3;
        mat4 jointMatrix = transpose(mat4(skinningJoints[idx],
                                          skinningJoints[idx+1],
                                          skinningJoints[idx+2],
                                          vec4(0, 0, 0, 1)));
        pos += (jointMatrix * vec4(_geometry.position, 1.0)).xyz * weight;
        nom += (mat3(jointMatrix) * _geometry.normal) * weight;
        tng += (mat3(jointMatrix) * _geometry.tangent.xyz) * weight;
      }
    }else{
      mat4 jointMatrix = transpose(mat4(skinningJoints[0],
                                        skinningJoints[1],
                                        skinningJoints[2],
                                        vec4(0, 0, 0, 1)));
      pos = (jointMatrix * vec4(_geometry.position, 1.0)).xyz;
      nom = mat3(jointMatrix) * _geometry.normal;
      tng = mat3(jointMatrix) * _geometry.tangent.xyz;
    }
    //v_position = pos;
    //v_normal = normalize(nom);
    //v_tangent = normalize(tng);
    v_position = (camera.viewTransform * vec4(pos, 1.0)).xyz;
    v_normal = normalize((camera.viewTransform * vec4(nom, 0.0)).xyz);
    v_tangent = normalize((camera.viewTransform * vec4(tng, 0.0)).xyz);
    v_bitangent = cross(v_tangent, v_normal);

    //vec3 viewVec = camera.position.xyz - pos;
    vec3 viewVec = (camera.viewTransform * vec4(camera.position.xyz - pos, 0.0)).xyz;
    v_eye = viewVec;

    //v_color = material.emission;

    // Lighting
    int numLights = 0;

    //#if NUM_AMBIENT_LIGHTS > 0
    //  for(int i=0; i<NUM_AMBIENT_LIGHTS; i++){
    //    v_color += light.ambient[i].color * material.ambient;
    //    v_ambient += light.ambient[i].color;
    //  }
    //#endif

    #if NUM_DIRECTIONAL_LIGHTS > 0
      for(int i=0; i<NUM_DIRECTIONAL_LIGHTS; i++){
        //v_light[numLights + i] = -light.directional[i].direction.xyz;
        v_light[numLights + i] = (camera.viewTransform * (-light.directional[i].direction)).xyz;
      }
      numLights += NUM_DIRECTIONAL_LIGHTS;
    #endif

    #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 0
      for(int i=0; i<NUM_DIRECTIONAL_SHADOW_LIGHTS; i++){
        //v_light[numLights + i] = -light.directionalShadow[i].direction.xyz;
        v_light[numLights + i] = (camera.viewTransform * (-light.directionalShadow[i].direction)).xyz;
        v_directionalShadowDepth[i] = light.directionalShadow[i].viewProjectionTransform * vec4(pos, 1.0);
        v_directionalShadowTexcoord[i] = light.directionalShadow[i].shadowProjectionTransform * vec4(pos, 1.0);
      }
      numLights += NUM_DIRECTIONAL_SHADOW_LIGHTS;
    #endif

    #if NUM_OMNI_LIGHTS > 0
      for(int i=0; i<NUM_OMNI_LIGHTS; i++){
        //v_light[numLights + i] = light.omni[i].position.xyz - pos;
        v_light[numLights + i] = (camera.viewTransform * vec4(light.omni[i].position.xyz - pos, 0.0)).xyz;
      }
      numLights += NUM_OMNI_LIGHTS;
    #endif

    #if NUM_SPOT_LIGHTS > 0
      for(int i=0; i<NUM_SPOT_LIGHTS; i++){
        //v_light[numLights + i] = light.spot[i].position.xyz - pos;
        v_light[numLights + i] = (camera.viewTransform * vec4(light.spot[i].position.xyz - pos, 0.0)).xyz;
      }
      numLights += NUM_SPOT_LIGHTS;
    #endif

    #if NUM_IES_LIGHTS > 0
      // TODO: implement
    #endif

    #if NUM_PROBE_LIGHTS > 0
      // TODO: implement
    #endif


    float distance = length(viewVec);
    v_fogFactor = clamp((distance - fog.startDistance) / (fog.endDistance - fog.startDistance), 0.0, 1.0);

    v_texcoord0 = _geometry.texcoords[0];
    v_texcoord1 = _geometry.texcoords[1];
    gl_Position = camera.viewProjectionTransform * vec4(pos, 1.0);
  }
`;

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var index_node = createCommonjsModule(function (module) {
module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {


/*global Buffer*/

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _ImageType = {
  noImage: 0,
  colorMapped: 1,
  RGB: 2,
  blackAndWhite: 3,
  runlengthColorMapped: 9,
  runlengthRGB: 10,
  compressedBlackAndWhite: 11,
  compressedColorMapped: 32,
  compressed4PassQTColorMapped: 33
};

var _headerLength = 18;

var TGAImage = function () {
  /**
   * constructor
   * @param {Buffer|ArrayBuffer} data -
   * @constructor
   */
  function TGAImage(data) {
    var _this = this;

    _classCallCheck(this, TGAImage);

    if (data instanceof Buffer) {
      this._buffer = data;
    } else if (typeof data === 'string') {
      this._buffer = Buffer.from(data, 'binary');
    } else if (data) {
      this._buffer = Buffer.from(data);
    } else {
      this._buffer = null;
    }

    // Header
    this._idLength = 0;
    this._colorMapType = 0;
    this._imageType = 0;
    this._colorMapOrigin = 0;
    this._colorMapLength = 0;
    this._colorMapDepth = 0;
    this._imageXOrigin = 0;
    this._imageYOrigin = 0;
    this._imageWidth = 0;
    this._imageHeight = 0;
    this._imageDepth = 0;
    this._alphaDepth = 0;
    this._leftToRight = true;
    this._topToBottom = false;
    this._interleave = false;
    this._hasAlpha = false;

    // Image Identification Field
    this._imageID = null;

    // Image Data
    this._canvas = null;
    this._context = null;
    this._imageData = null;
    this._image = null;

    // for HTML Image tag compatibility
    this._src = null;
    this.onload = null;
    this.onerror = null;

    this._resolveFunc = null;
    this._rejectFunc = null;
    this._didLoad = new Promise(function (resolve, reject) {
      _this._resolveFunc = resolve;
      _this._rejectFunc = reject;
    });

    if (data) {
      this._parseData();
    }
  }

  _createClass(TGAImage, [{
    key: '_loadURL',
    value: function _loadURL(url) {
      var _this2 = this;

      this._src = url;
      this._requestBinaryFile(url).then(function (data) {
        _this2._buffer = Buffer.from(data);
        _this2._parseData();
      }).catch(function (error) {
        _this2._reject(error);
      });
    }
  }, {
    key: '_requestBinaryFile',
    value: function _requestBinaryFile(url) {
      return new Promise(function (resolve, reject) {
        var request = new XMLHttpRequest();
        request.open('GET', url);
        request.responseType = 'arraybuffer';
        request.onload = function (ev) {
          if (request.response) {
            resolve(request.response);
          } else {
            reject(request);
          }
        };
        request.onerror = function (ev) {
          reject(ev);
        };
        request.send(null);
      });
    }
  }, {
    key: '_parseData',
    value: function _parseData() {
      this._readHeader();
      this._readImageID();
      this._initImage();

      var data = this._getImageData();

      switch (this._imageType) {
        case _ImageType.noImage:
          {
            // nothing to do
            break;
          }
        case _ImageType.colorMapped:
          {
            this._parseColorMapData(data);
            break;
          }
        case _ImageType.RGB:
          {
            this._parseRGBData(data);
            break;
          }
        case _ImageType.blackAndWhite:
          {
            this._parseBlackAndWhiteData(data);
            break;
          }
        case _ImageType.runlengthColorMapped:
          {
            this._parseColorMapData(data);
            break;
          }
        case _ImageType.runlengthRGB:
          {
            this._parseRGBData(data);
            break;
          }
        case _ImageType.compressedBlackAndWhite:
          {
            this._parseBlackAndWhiteData(data);
            break;
          }
        case _ImageType.compressedColorMapped:
          {
            console.error('parser for compressed TGA is not implemeneted');
            break;
          }
        case _ImageType.compressed4PassQTColorMapped:
          {
            console.error('parser for compressed TGA is not implemeneted');
            break;
          }
        default:
          {
            throw new Error('unknown imageType: ' + this._imageType);
          }
      }

      this._setImage();
      this._deleteBuffer();
    }
  }, {
    key: '_readHeader',
    value: function _readHeader() {
      this._idLength = this._buffer.readUIntLE(0, 1);
      this._colorMapType = this._buffer.readUIntLE(1, 1);
      this._imageType = this._buffer.readUIntLE(2, 1);
      this._colorMapOrigin = this._buffer.readUIntLE(3, 2);
      this._colorMapLength = this._buffer.readUIntLE(5, 2);
      this._colorMapDepth = this._buffer.readUIntLE(7, 1);
      this._imageXOrigin = this._buffer.readUIntLE(8, 2);
      this._imageYOrigin = this._buffer.readUIntLE(10, 2);
      this._imageWidth = this._buffer.readUIntLE(12, 2);
      this._imageHeight = this._buffer.readUIntLE(14, 2);
      this._imageDepth = this._buffer.readUIntLE(16, 1);

      var descriptor = this._buffer.readUIntLE(17, 1);
      this._alphaDepth = descriptor & 0x0F;
      this._leftToRight = (descriptor & 0x10) === 0;
      this._topToBottom = (descriptor & 0x20) > 0;
      this._interleave = descriptor & 0xC0;
    }
  }, {
    key: '_readImageID',
    value: function _readImageID() {
      if (this._idLength > 0) {
        this._imageID = this._buffer.subarray(_headerLength, this._idLength);
      }
    }
  }, {
    key: '_initImage',
    value: function _initImage() {
      if (this._imageType === _ImageType.noImage) {
        return;
      }
      if (this._imageWidth <= 0 || this._imageHeight <= 0) {
        return;
      }
      this._canvas = document.createElement('canvas');
      this._canvas.width = this._imageWidth;
      this._canvas.height = this._imageHeight;
      this._context = this._canvas.getContext('2d');
      this._imageData = this._context.createImageData(this._imageWidth, this._imageHeight);
    }
  }, {
    key: '_setImage',
    value: function _setImage() {
      var _this3 = this;

      this._context.putImageData(this._imageData, 0, 0);
      this._image = new Image();
      this._image.width = this._imageWidth;
      this._image.height = this._imageHeight;
      this._image.onload = function () {
        _this3._resolve();
      };
      this._image.src = this._canvas.toDataURL();
    }
  }, {
    key: '_deleteBuffer',
    value: function _deleteBuffer() {
      if (this._buffer) {
        delete this._buffer;
        this._buffer = null;
      }
      if (this._imageData) {
        delete this._imageData;
        this._imageData = null;
      }
    }
  }, {
    key: '_parseColorMapData',
    value: function _parseColorMapData(buf) {
      if (this._colorMapDepth === 24 || this._colorMapDepth === 16 || this._colorMapDepth === 15) {
        this._hasAlpha = false;
      } else if (this._colorMapDepth === 32) {
        this._hasAlpha = true;
      } else {
        throw new Error('unknown colorMapDepth: ' + this._colorMapDepth);
      }

      var colorMapDataPos = _headerLength + this._idLength;
      var colorMapDataSize = Math.ceil(this._colorMapDepth / 8);
      var colorMapDataLen = colorMapDataSize * this._colorMapLength;

      var imageDataSize = 1;

      var colorMap = [];
      var pos = colorMapDataPos;
      for (var i = 0; i < this._colorMapLength; i++) {
        var rgba = this._getRGBA(this._buffer, pos, this._colorMapDepth);
        colorMap.push(rgba);
        pos += colorMapDataSize;
      }

      var data = this._imageData.data;
      var initX = 0;
      var initY = 0;
      var xStep = 1;
      var yStep = 1;
      if (!this._leftToRight) {
        initX = this._imageWidth - 1;
        xStep = -1;
      }
      if (!this._topToBottom) {
        initY = this._imageHeight - 1;
        yStep = -1;
      }

      pos = 0;
      var y = initY;
      var defaultColor = [0xFF, 0xFF, 0xFF, 0xFF];
      for (var iy = 0; iy < this._imageHeight; iy++) {
        var x = initX;
        for (var ix = 0; ix < this._imageWidth; ix++) {
          var index = (y * this._imageWidth + x) * 4;
          var color = defaultColor;
          var mapNo = buf[pos] - this._colorMapOrigin;
          if (mapNo >= 0) {
            color = colorMap[mapNo];
          }
          data[index] = color[0];
          data[index + 1] = color[1];
          data[index + 2] = color[2];
          data[index + 3] = color[3];

          x += xStep;
          pos += imageDataSize;
        }
        y += yStep;
      }
    }
  }, {
    key: '_parseRGBData',
    value: function _parseRGBData(buf) {
      if (this._imageDepth === 24 || this._imageDepth === 16 || this._imageDepth === 15) {
        this._hasAlpha = false;
      } else if (this._imageDepth === 32) {
        this._hasAlpha = true;
      } else {
        throw new Error('unknown imageDepth: ' + this._imageDepth);
      }

      var imageDataSize = Math.ceil(this._imageDepth / 8);

      var data = this._imageData.data;
      var initX = 0;
      var initY = 0;
      var xStep = 1;
      var yStep = 1;
      if (!this._leftToRight) {
        initX = this._imageWidth - 1;
        xStep = -1;
      }
      if (!this._topToBottom) {
        initY = this._imageHeight - 1;
        yStep = -1;
      }

      var pos = 0;
      var y = initY;
      for (var iy = 0; iy < this._imageHeight; iy++) {
        var x = initX;
        for (var ix = 0; ix < this._imageWidth; ix++) {
          var index = (y * this._imageWidth + x) * 4;
          var rgba = this._getRGBA(buf, pos, this._imageDepth);
          data[index] = rgba[0];
          data[index + 1] = rgba[1];
          data[index + 2] = rgba[2];
          data[index + 3] = rgba[3];

          x += xStep;
          pos += imageDataSize;
        }
        y += yStep;
      }
    }
  }, {
    key: '_getRGBA',
    value: function _getRGBA(buf, offset, depth) {
      if (depth === 15) {
        var r = (buf[offset + 1] & 0x7c) << 1;
        var g = (buf[offset + 1] & 0x03) << 6 | (buf[offset] & 0xe0) >> 2;
        var b = (buf[offset] & 0x1f) << 3;
        //const a = (buf[offset+1] & 0x80) > 0 ? 255 : 0
        var a = 255;
        return [r, g, b, a];
      } else if (depth === 16) {
        var _r = (buf[offset + 1] & 0x7c) << 1;
        var _g = (buf[offset + 1] & 0x03) << 6 | (buf[offset] & 0xe0) >> 2;
        var _b = (buf[offset] & 0x1f) << 3;
        var _a = 255;
        return [_r, _g, _b, _a];
      } else if (depth === 24) {
        return [buf[offset + 2], buf[offset + 1], buf[offset], 255];
      } else if (depth === 32) {
        return [buf[offset + 2], buf[offset + 1], buf[offset], buf[offset + 3]];
      }
      throw new Error('unsupported imageDepth: ' + depth);
    }
  }, {
    key: '_parseBlackAndWhiteData',
    value: function _parseBlackAndWhiteData(buf) {
      if (this._imageDepth == 8) {
        this._hasAlpha = false;
      } else if (this._imageDepth == 16) {
        this._hasAlpha = true;
      } else {
        throw new Error('unknown imageDepth: ' + this._imageDepth);
      }

      var imageDataSize = this._imageDepth / 8;

      var data = this._imageData.data;
      var initX = 0;
      var initY = 0;
      var xStep = 1;
      var yStep = 1;
      if (!this._leftToRight) {
        initX = this._imageWidth - 1;
        xStep = -1;
      }
      if (!this._topToBottom) {
        initY = this._imageHeight - 1;
        yStep = -1;
      }

      var pos = 0;
      if (this._hasAlpha) {
        var y = initY;
        for (var iy = 0; iy < this._imageHeight; iy++) {
          var x = initX;
          for (var ix = 0; ix < this._imageWidth; ix++) {
            var index = (y * this._imageWidth + x) * 4;
            var c = buf[pos];
            var a = buf[pos + 1];
            data[index] = c;
            data[index + 1] = c;
            data[index + 2] = c;
            data[index + 3] = a;

            x += xStep;
            pos += imageDataSize;
          }
          y += yStep;
        }
      } else {
        var _y = initY;
        for (var _iy = 0; _iy < this._imageHeight; _iy++) {
          var _x = initX;
          for (var _ix = 0; _ix < this._imageWidth; _ix++) {
            var _index = (_y * this._imageWidth + _x) * 4;
            var _c = buf[pos];
            var _a2 = 255;
            data[_index] = _c;
            data[_index + 1] = _c;
            data[_index + 2] = _c;
            data[_index + 3] = _a2;

            _x += xStep;
            pos += imageDataSize;
          }
          _y += yStep;
        }
      }
    }
  }, {
    key: '_getImageData',
    value: function _getImageData() {
      var data = null;
      if (this._imageType !== _ImageType.none) {
        var colorMapDataLen = Math.ceil(this._colorMapDepth / 8) * this._colorMapLength;
        var start = _headerLength + this._idLength + colorMapDataLen;
        data = this._buffer.subarray(start);
      }

      if (this._imageType === _ImageType.runlengthColorMapped || this._imageType === _ImageType.runlengthRGB) {
        data = this._decompressRunlengthData(data);
      } else if (this._imageType === _ImageType.compressedBlackAndWhite) {
        data = this._decompressRunlengthData(data);
      } else if (this._imageType === _ImageType.compressedColorMapped) {
        // TODO: implement
        console.error('Compressed Color Mapped TGA Image data is not supported');
      } else if (this._imageType === _ImageType.compressed4PassQTColorMapped) {
        // TODO: implement
        console.error('Compressed Color Mapped TGA Image data is not supported');
      }
      return data;
    }
  }, {
    key: '_decompressRunlengthData',
    value: function _decompressRunlengthData(data) {
      var d = [];
      var elementCount = Math.ceil(this._imageDepth / 8);
      var dataLength = elementCount * this._imageWidth * this._imageHeight;
      var pos = 0;

      while (d.length < dataLength) {
        var packet = data[pos];
        pos += 1;
        if ((packet & 0x80) !== 0) {
          // RLE
          var elements = data.slice(pos, pos + elementCount);
          pos += elementCount;

          var count = (packet & 0x7F) + 1;
          for (var i = 0; i < count; i++) {
            d.push.apply(d, _toConsumableArray(elements));
          }
        } else {
          // RAW
          var len = (packet + 1) * elementCount;
          d.push.apply(d, _toConsumableArray(data.slice(pos, pos + len)));
          pos += len;
        }
      }
      return d;
    }
  }, {
    key: '_resolve',
    value: function _resolve(e) {
      if (this.onload) {
        this.onload(e);
      }
      this._resolveFunc(e);
    }
  }, {
    key: '_reject',
    value: function _reject(e) {
      if (this.onerror) {
        this.onerror(e);
      }
      this._rejectFunc(e);
    }
  }, {
    key: 'image',
    get: function get() {
      return this._image;
    }
  }, {
    key: 'canvas',
    get: function get() {
      return this._canvas;
    }
  }, {
    key: 'didLoad',
    get: function get() {
      return this._didLoad;
    }
  }, {
    key: 'src',
    get: function get() {
      return this._src;
    },
    set: function set(newValue) {
      this._loadURL(newValue);
    }
  }], [{
    key: 'imageWithData',
    value: function imageWithData(data) {
      return new TGAImage(data);
    }
  }, {
    key: 'imageWithURL',
    value: function imageWithURL(url) {
      var image = new TGAImage();
      image._loadURL(url);
      return image;
    }
  }]);

  return TGAImage;
}();

module.exports = TGAImage;

/***/ })
/******/ ]);
});

var TGAImage = unwrapExports(index_node);

/**
 * Modes that describe how SceneKit blends source colors rendered using a material with destination colors already in a rendering target, used by the blendMode property.
 * @typedef {Object} SCNBlendMode
 * @property {number} alpha - Blend by multiplying source and destination color values by their corresponding alpha values.
 * @property {number} add - Blend by adding the source color to the destination color.
 * @property {number} subtract - Blend by subtracting the source color from the destination color.
 * @property {number} multiply - Blend by multiplying the source color with the background color.
 * @property {number} screen - Blend by multiplying the inverse of the source color with the inverse of the destination color.
 * @property {number} replace - Blend by replacing the destination color with the source color, ignoring alpha.
 * @see https://developer.apple.com/documentation/scenekit/scnblendmode
 */

const SCNBlendMode = {
  alpha: 0,
  add: 1,
  subtract: 2,
  multiply: 3,
  screen: 4,
  replace: 5
};

/**
 * 
 * @access public
 * @typedef {Object} SCNColorMask
 * @property {number} red -
 * @property {number} blue -
 * @property {number} green -
 * @property {number} alpha -
 * @property {number} all -
 * @see https://developer.apple.com/documentation/scenekit/scncolormask
 */

const SCNColorMask = {
  red: 1,
  green: 2,
  blue: 4,
  alpha: 8,
  all: 15
};

/**
 * The modes SceneKit uses to determine which polygons to render in a surface, used by the cullMode property.
 * @typedef {Object} SCNCullMode
 * @property {number} back - 
 * @property {number} front - 
 * @see https://developer.apple.com/documentation/scenekit/scncullmode
 */

const SCNCullMode = {
  back: 0,
  front: 1
};

/**
 * 
 * @typedef {Object} SCNFillMode
 * @property {Symbol} fill - 
 * @property {Symbol} lines - 
 * @see https://developer.apple.com/documentation/scenekit/scnfillmode
 */

const SCNFillMode = {
  fill: 2,
  lines: 1
};

/**
 * Texture filtering modes, used by the the minificationFilter, magnificationFilter, and mipFilter properties.
 * @typedef {Object} SCNFilterMode
 * @property {number} none - No texture filtering is applied.
 * @property {number} nearest - Texture filtering returns the color from only one texel, whose location is nearest to the coordinates being sampled.
 * @property {number} linear - Texture filtering sample texels from the neighborhood of the coordinates being sampled and linearly interpolates their colors.
 * @see https://developer.apple.com/documentation/scenekit/scnfiltermode
 */

const SCNFilterMode = {
  none: 0,
  nearest: 1,
  linear: 2
};

/**
 * Returns a matrix describing a translation transformation.
 * @access public
 * @param {number} tx - 
 * @param {number} ty - 
 * @param {number} tz - 
 * @returns {SCNMatrix4} - 
 * @see https://developer.apple.com/documentation/scenekit/1409679-scnmatrix4maketranslation
 */

const SCNMatrix4MakeTranslation = function (tx, ty, tz) {
  return new SCNMatrix4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1);
};

/**
 *
 * @access public
 * @extends {NSDictionary}
 */

class SCNOrderedDictionary {
  /**
   * @access public
   * @param {NSCoder} coder -
   * @returns {Object} -
   */
  static initWithCoder(coder) {
    const dict = new SCNOrderedDictionary();

    if (typeof coder._refObj['NS.objects'] !== 'undefined') {
      const keys = coder._refObj['NS.keys'];
      const objects = coder._refObj['NS.objects'];

      if (!Array.isArray(keys)) {
        throw new Error('NS.keys must be Array');
      }

      if (!Array.isArray(objects)) {
        throw new Error('NS.objects must be Array');
      }

      if (keys.length !== objects.length) {
        throw new Error('NS.keys.length !== NS.objects.length');
      }

      const keyCoder = coder.copy();
      keyCoder._refObj = keys;
      const objCoder = coder.copy();
      objCoder._refObj = objects;

      for (let i = 0; i < keys.length; i++) {
        const key = keyCoder.decodeObjectForKey(i);
        const obj = objCoder.decodeObjectForKey(i);

        dict._keys.push(key);

        dict._values.push(obj);
      }
    } else {
      for (let i = 0;; i++) {
        const objKey = `NS.object.${i}`;
        const keyKey = `NS.key.${i}`;

        if (typeof coder._refObj[objKey] === 'undefined') {
          break;
        }

        const key = coder.decodeObjectForKey(keyKey);
        const obj = coder.decodeObjectForKey(objKey);

        dict._keys.push(key);

        dict._values.push(obj);
      }
    }

    return dict;
  }

  constructor() {
    this._keys = [];
    this._values = [];
  }

  copy() {
    const dict = new SCNOrderedDictionary();
    dict._keys = this._keys.slice(0);
    dict._values = this._values.slice(0);
    return dict;
  }

  keys() {
    return this._keys.slice(0);
  }

  dictionary() {
    const dict = {};
    const len = this._keys.length;

    for (let i = 0; i < len; i++) {
      dict[this._keys[i]] = this._values[i];
    }

    return dict;
  }

  allValues() {
    return this._values.slice(0);
  }

  allKeys() {
    return this.keys();
  }

  count() {
    return this._keys.length;
  }

  removeAllObjects() {
    this._keys = [];
    this._values = [];
  }

  removeObjectForKey(key) {
    const index = this._keys.indexOf(key);

    if (index < 0) {
      return;
    }

    this._keys.splice(index, 1);

    this._values.splice(index, 1);
  }

  objectForKey(key) {
    const index = this._keys.indexOf(key);

    if (index < 0) {
      return null;
    }

    return this._values[index];
  }

  setObjectForKey(object, key) {
    let index = this._keys.indexOf(key);

    if (index < 0) {
      index = this._keys.length;
      this._keys[index] = key;
    }

    this._values[index] = object;
  }

  valueForKey(key) {
    return this.objectForKey(key);
  }

  setValueForKey(value, key) {
    this.setObjectForKey(value, key);
  } // extension for JavaScript


  set(key, object) {
    this.setObjectForKey(object, key);
  }

  get(key) {
    return this.objectForKey(key);
  }

  clear() {
    this.removeAllObjects();
  }

  delete(key) {
    this.removeObjectForKey(key);
  }

  forEach(func) {
    const len = this._keys.length;

    for (let i = 0; i < len; i++) {
      func(this._values[i], this._keys[i]);
    }
  }

}

const _transactions = [];
let _immediateMode = true;

class _Transaction {
  constructor() {
    /**
     * @type {Object}
     */
    this._animations = [];
    /**
     * @type {number}
     */

    this._animationDuration = 0.0;
    /**
     * @type {?CAMediaTimingFunction}
     */

    this._animationTimingFunction = null;
    /**
     * @type {boolean}
     */

    this._disableActions = false;
    /**
     * @type {?function}
     */

    this._completionBlock = null;
    /**
     * @type {Map<string, Object>}
     */

    this._values = new Map();
  }

}

const _automaticTransaction = new _Transaction();
/**
 * The SCNTransaction class defines SceneKit’s mechanism for batching scene graph modifications into atomic updates. You use SCNTransaction class methods to control the animation that results from changing animatable properties in the scene graph and to combine sets of changes into nested transactions.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/scenekit/scntransaction
 */


class SCNTransaction extends NSObject {
  /**
   * constructor
   * @access public
   * @constructor
   */
  constructor() {
    super();
    throw new Error('do not create an instance of SCNTransaction');
  } // Creating and Committing Transactions

  /**
   * Begins a new transaction for the current thread.
   * @access public
   * @returns {void}
   * @desc The new transaction is nested within the thread’s current transaction, if there is one.The first time you modify the scene graph during a pass through the run loop, SceneKit automatically creates a transaction and makes it the current transaction. (SceneKit commits that transaction when the next iteration of the run loops begins.) If you call this method to create a custom transaction before modifying the scene graph, your custom transaction becomes the current transaction.
   * @see https://developer.apple.com/documentation/scenekit/scntransaction/1522820-begin
   */


  static begin() {
    const newTransaction = new _Transaction();
    newTransaction._disableActions = this._currentTransaction._disabledActions;

    _transactions.push(newTransaction);
  }
  /**
   * Commits all changes made during the current transaction.
   * @access public
   * @returns {void}
   * @desc If there is no current transaction, this method has no effect.
   * @see https://developer.apple.com/documentation/scenekit/scntransaction/1523436-commit
   */


  static commit() {
    const transaction = _transactions.pop();

    if (transaction) {
      this._apply(transaction);
    }
  }
  /**
   * Applies all changes from the current automatic transaction.
   * @access public
   * @returns {void}
   * @desc SceneKit automatically calls this method at the end of each pass through the run loop, regardless of the run loop mode. If your app does not have a run loop, you must call this method explicitly.If the current transaction has any nested transactions that are still animating, SceneKit waits to commit the current transaction’s changes until those transactions complete.NoteIf possible, avoid calling flush() explicitly. By allowing flush() to execute during the run loop, your app achieves better performance, atomic screen updates are preserved, and transactions and animations that work from transaction to transaction continue to function.
   * @see https://developer.apple.com/documentation/scenekit/scntransaction/1522860-flush
   */


  static flush() {
    // TODO: wait nested transactions
    this._apply(_automaticTransaction);
  }

  static _apply(transaction) {
    if (transaction._disableActions || transaction._animationDuration === 0) {
      transaction._animations.forEach(anim => {
        anim.target.setValueForKeyPath(anim.newValue, anim.keyPath);
      });

      if (transaction._completionBlock) {
        transaction._completionBlock();
      }
    } else {
      const promises = [];

      transaction._animations.forEach(anim => {
        const promise = new Promise((resolve, reject) => {
          const animation = new CABasicAnimation(anim.keyPath);
          animation.fromValue = anim.diff;
          animation.timingFunction = transaction._animationTimingFunction;
          animation.duration = transaction._animationDuration;
          animation.isAdditive = true;
          animation.isRemovedOnCompletion = true;
          animation.delegate = {
            animationDidStop: (_anim, _finished) => {
              if (_finished) {
                anim.target.setValueForKeyPath(anim.newValue, anim.keyPath);
                resolve(anim, animation);
              }
            }
          };
          anim.target.addAnimationForKey(animation, null);
        });
        promises.push(promise);
      });

      Promise.all(promises).then(() => {
        if (transaction._completionBlock) {
          transaction._completionBlock();
        }
      });
    }
  } // Overriding Animation Duration and Timing

  /**
   * Returns the duration, in seconds, of all animations within the current transaction.
   * @type {number}
   * @desc The default duration is zero for transactions automatically created by SceneKit, and 0.25 for animations you create using the begin() method.
   * @see https://developer.apple.com/documentation/scenekit/scntransaction/1523888-animationduration
   */


  static get animationDuration() {
    return this._currentTransaction._animationDuration;
  }
  /**
   * Returns the duration, in seconds, of all animations within the current transaction.
   * @type {number}
   * @param {number} newValue -
   * @desc The default duration is zero for transactions automatically created by SceneKit, and 0.25 for animations you create using the begin() method.
   * @see https://developer.apple.com/documentation/scenekit/scntransaction/1523888-animationduration
   */


  static set animationDuration(newValue) {
    this._currentTransaction._animationDuration = newValue;
  }
  /**
   * Returns the timing function that SceneKit uses for all animations within this transaction group. 
   * @type {?CAMediaTimingFunction}
   * @desc Media timing functions, also known as animation curves, define the relationship between the elapsed time of an animation and its effect on a property. For example, the kCAMediaTimingFunctionEaseInEaseOut function creates an effect that begins slowly, speeds up, and then finishes slowly.
   * @see https://developer.apple.com/documentation/scenekit/scntransaction/1522614-animationtimingfunction
   */


  static get animationTimingFunction() {
    return this._currentTransaction._animationTimingFunction;
  }
  /**
   * Returns the timing function that SceneKit uses for all animations within this transaction group. 
   * @type {?CAMediaTimingFunction}
   * @param {?CAMediaTimingFunction} newValue -
   * @desc Media timing functions, also known as animation curves, define the relationship between the elapsed time of an animation and its effect on a property. For example, the kCAMediaTimingFunctionEaseInEaseOut function creates an effect that begins slowly, speeds up, and then finishes slowly.
   * @see https://developer.apple.com/documentation/scenekit/scntransaction/1522614-animationtimingfunction
   */


  static set animationTimingFunction(newValue) {
    this._currentTransaction._animationTimingFunction = newValue;
  } // Temporarily Disabling Property Animations

  /**
   * Returns a Boolean value indicating whether changes to animatable properties during the transaction are implicitly animated.
   * @type {boolean}
   * @desc By default (when this property is false), any changes to animatable properties of objects in the scene graph implicitly create animations. (These animations may not be visible unless you use the animationDuration property to set a nonzero duration for the transaction.) Set this property to true to disable implicit animation during the transaction.Disabling animation applies to all property changes in the current transaction and any nested transactions within it. However, you can use this property again within a nested transaction to enable implicit animation for that transaction.
   * @see https://developer.apple.com/documentation/scenekit/scntransaction/1524238-disableactions
   */


  static get disableActions() {
    return this._currentTransaction._disableActions;
  }
  /**
   * Returns a Boolean value indicating whether changes to animatable properties during the transaction are implicitly animated.
   * @type {boolean}
   * @param {boolean} newValue -
   * @desc By default (when this property is false), any changes to animatable properties of objects in the scene graph implicitly create animations. (These animations may not be visible unless you use the animationDuration property to set a nonzero duration for the transaction.) Set this property to true to disable implicit animation during the transaction.Disabling animation applies to all property changes in the current transaction and any nested transactions within it. However, you can use this property again within a nested transaction to enable implicit animation for that transaction.
   * @see https://developer.apple.com/documentation/scenekit/scntransaction/1524238-disableactions
   */


  static set disableActions(newValue) {
    this._currentTransaction._disableActions = newValue;
  } // Getting and Setting Completion Block Objects

  /**
   * Returns the block previously associated with the current transaction.
   * @type {?function(): void}
   * @desc See setCompletionBlock(_:) for a description of the role of the completion block object.
   * @see https://developer.apple.com/documentation/scenekit/scntransaction/1523660-completionblock
   */


  static get completionBlock() {
    return this._currentTransaction._completionBlock;
  }
  /**
   * Returns the block previously associated with the current transaction.
   * @type {?function(): void}
   * @param {?function(): void} newValue -
   * @desc See setCompletionBlock(_:) for a description of the role of the completion block object.
   * @see https://developer.apple.com/documentation/scenekit/scntransaction/1523660-completionblock
   */


  static set completionBlock(newValue) {
    this._currentTransaction._completionBlock = newValue;
  } // Managing Concurrency

  /**
   * Attempts to acquire a recursive spinlock to ensure the validity of values you retrieve during the transaction.
   * @access public
   * @returns {void}
   * @desc SceneKit’s data model is thread-safe in that it ensures that internal data structures will not be corrupted by concurrent attempts to modify their contents from multiple threads. However, this model does not guarantee the validity of values you read from scene graph objects after returning them.For example, consider the following operation:_node.position = SCNVector3Make(_node.position.x, _node.position.y + 10, _node.position.z);
  The intent of this line is to move a node by ten units. But if another thread modifies the node’s position property concurrently, the new position value could be unexpected. If your app modifies the scene graph from multiple threads, use a transaction lock to ensure that your modifications take effect as intended.[SCNTransaction lock];
  _node.position = SCNVector3Make(_node.position.x, _node.position.y + 10, _node.position.z);
  [SCNTransaction unlock];
  If another thread currently holds a lock on the transaction, calling lock() has no effect._node.position = SCNVector3Make(_node.position.x, _node.position.y + 10, _node.position.z);
  [SCNTransaction lock];
  _node.position = SCNVector3Make(_node.position.x, _node.position.y + 10, _node.position.z);
  [SCNTransaction unlock];
    * @see https://developer.apple.com/documentation/scenekit/scntransaction/1523078-lock
   */


  static lock() {
    throw new Error('lock() is not implemented');
  }
  /**
   * Relinquishes a previously acquired transaction lock.
   * @access public
   * @returns {void}
   * @desc See the lock() method for more details on transaction locking.
   * @see https://developer.apple.com/documentation/scenekit/scntransaction/1523166-unlock
   */


  static unlock() {
    throw new Error('unlock() is not implemented');
  } // Getting and Setting Transaction Properties

  /**
   * Associates an arbitrary object with the current transaction using the specified key.
   * @access public
   * @param {?Object} value - 
   * @param {string} key - A unique string identifying the object for later retrieval.
   * @returns {void}
   * @desc Nested transactions have nested data scope. Setting a value for a key associates it with the current transaction (or innermost nested transaction) only, and reading the value for a key searches through nested transactions (starting from the innermost).
   * @see https://developer.apple.com/documentation/scenekit/scntransaction/1524124-setvalue
   */


  static setValueForKey(value, key) {
    this._currentTransaction._values.set(key, value);
  }
  /**
   * Returns the object previously associated with the current transaction using the specified key.
   * @access public
   * @param {string} key - The unique string identifying an object previously associated with the transaction.
   * @returns {?Object} - 
   * @desc Nested transactions have nested data scope. Setting a value for a key associates it with the current transaction (or innermost nested transaction) only, but reading the value for a key searches through nested transactions (starting from the innermost).
   * @see https://developer.apple.com/documentation/scenekit/scntransaction/1523919-value
   */


  static valueForKey(key) {
    for (let i = _transactions.length - 1; i >= 0; i--) {
      const value = _transactions[i]._values.get(key);

      if (typeof value !== 'undefined') {
        return value;
      }
    }

    return _automaticTransaction._values.get(key);
  }
  /**
   * @access private
   * @returns {_Transaction} -
   */


  static get _currentTransaction() {
    if (_transactions.length > 0) {
      return _transactions[_transactions.length - 1];
    }

    return _automaticTransaction;
  }
  /**
   * @access private
   * @param {Object} target -
   * @param {string} keyPath -
   * @param {Object|number} oldValue -
   * @param {Object|number} newValue -
   * @returns {void}
   */


  static _addChange(target, keyPath, oldValue, newValue) {
    if (this.immediateMode) {
      target.setValueForKeyPath(newValue, keyPath);
    } else {
      let diff = null;

      if (typeof newValue === 'number') {
        diff = oldValue - newValue;
      } else if (typeof newValue.sub !== 'undefined') {
        diff = oldValue.sub(newValue);
      } else {
        throw new Error(`keyPath ${keyPath} does not have sub function`);
      }

      this._currentTransaction._animations.push({
        target: target,
        keyPath: keyPath,
        diff: diff,
        oldValue: oldValue,
        newValue: newValue
      });
    }
  }
  /**
   * @access public
   * @type {boolean}
   */


  static get immediateMode() {
    if (_transactions.length > 0) {
      return false;
    }

    return _immediateMode;
  }
  /**
   * @access public
   * @type {boolean}
   * @param {boolean} newValue -
   */


  static set immediateMode(newValue) {
    _immediateMode = newValue;
  }

}

/**
 * Modes to apply to texture wrapping, used by the wrapT and wrapS properties.
 * @typedef {Object} SCNWrapMode
 * @property {number} clamp - Texture coordinates are clamped to the range from 0.0 to 1.0, inclusive.
 * @property {number} repeat - Texture sampling uses only the fractional part of texture coordinates, passing through the range from 0.0 to (but not including) 1.0.
 * @property {number} clampToBorder - Texture sampling uses texture colors for coordinates in the range from 0.0 to 1.0 (inclusive) and the material property’s borderColor value otherwise.
 * @property {number} mirror - Texture sampling of texture coordinates outside range from 0.0 to 1.0 should behave as if the range reverses before repeating.
 * @see https://developer.apple.com/documentation/scenekit/scnwrapmode
 */

const SCNWrapMode = {
  clamp: 1,
  repeat: 2,
  clampToBorder: 3,
  mirror: 4
};

/**
 * A container for the color or texture of one of a material’s visual properties. 
 * @access public
 * @extends {NSObject}
 * @implements {SCNAnimatable}
 * @see https://developer.apple.com/documentation/scenekit/scnmaterialproperty
 */

class SCNMaterialProperty extends NSObject {
  static get _propTypes() {
    return {
      color: ['NSColor', '_contents'],
      image: ['NSMutableDictionary', (obj, dict, key, coder) => {
        if (typeof dict.data !== 'undefined') {
          obj._loadContentsImageByData(dict.data);

          return;
        }

        let path = '';

        if (typeof dict.path !== 'undefined') {
          path = dict.path;
        } else if (typeof dict.URL !== 'undefined') {
          path = dict.URL;
        }

        if (coder._urlTranslator) {
          path = coder._urlTranslator(path, coder);
        }

        obj._loadContentsImage(path, coder._directoryPath);
      }],
      float: ['float', (obj, value) => {
        obj._contents = new SKColor(value, value, value, 1.0);
      }],
      intensity: 'float',
      // contentsTransform
      wrapS: 'integer',
      wrapT: 'integer',
      minificationFilter: 'integer',
      magnificationFilter: 'integer',
      mipFilter: 'integer',
      maxAnisotropy: 'float',
      mappingChannel: 'integer',
      borderColor: 'plist',
      propertyType: ['integer', null],
      parent: ['SCNMaterial', '_parent'],
      isCommonProfileProperty: ['boolean', null],
      sRGB: ['boolean', null],
      customSlotName: ['string', null],
      textureComponents: ['integer', null]
    };
  } // Creating a Material Property

  /**
   * Creates a new material property object with the specified contents.
   * @access public
   * @constructor
   * @param {Object} contents - The visual contents of the material property—a color, image, or source of animated content. For details, see the discussion of the  contents property.
   * @desc Newly created SCNMaterial objects contain SCNMaterialProperty instances for all of their visual properties. To change a material’s visual properties, you modify those instances rather than creating new material property objects.You create new SCNMaterialProperty instances to provide textures for use with custom GLSL shaders—for details, see SCNShadable.
   * @see https://developer.apple.com/documentation/scenekit/scnmaterialproperty/1395386-init
   */


  constructor(contents = null) {
    super(); // Working with Material Property Contents

    /**
     * The visual contents of the material property—a color, image, or source of animated content. Animatable.
     * @access private
     * @type {?Object}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterialproperty/1395372-contents
     */

    this._contents = contents;
    /**
     * A number between 0.0 and 1.0 that modulates the effect of the material property. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterialproperty/1395407-intensity
     */

    this.intensity = 0; // Configuring Texture Mapping Attributes

    /**
     * The transformation applied to the material property’s visual contents. Animatable.
     * @type {SCNMatrix4}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterialproperty/1395388-contentstransform
     */

    this.contentsTransform = SCNMatrix4MakeTranslation(0, 0, 0);
    /**
     * The wrapping behavior for the S texture coordinate.
     * @type {SCNWrapMode}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterialproperty/1395384-wraps
     */

    this.wrapS = SCNWrapMode.clamp;
    /**
     * The wrapping behavior for the T texture coordinate.
     * @type {SCNWrapMode}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterialproperty/1395382-wrapt
     */

    this.wrapT = SCNWrapMode.clamp;
    /**
     * Texture filtering for rendering the material property’s image contents at a size smaller than that of the original image.
     * @type {SCNFilterMode}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterialproperty/1395390-minificationfilter
     */

    this.minificationFilter = SCNFilterMode.linear;
    /**
     * Texture filtering for rendering the material property’s image contents at a size larger than that of the original image.
     * @type {SCNFilterMode}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterialproperty/1395378-magnificationfilter
     */

    this.magnificationFilter = SCNFilterMode.linear;
    /**
     * Texture filtering for using mipmaps to render the material property’s image contents at a size smaller than that of the original image.
     * @type {SCNFilterMode}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterialproperty/1395398-mipfilter
     */

    this.mipFilter = SCNFilterMode.nearest;
    /**
     * The amount of anisotropic texture filtering to be used when rendering the material property’s image contents.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterialproperty/1395402-maxanisotropy
     */

    this.maxAnisotropy = 0;
    /**
     * The source of texture coordinates for mapping the material property’s image contents.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterialproperty/1395405-mappingchannel
     */

    this.mappingChannel = 0;
    /**
     * A color used to fill in areas of a material’s surface not covered by the material property’s image contents.
     * @type {?Object}
     * @deprecated
     * @see https://developer.apple.com/documentation/scenekit/scnmaterialproperty/1395376-bordercolor
     */

    this.borderColor = null;
    /**
     * @access private
     * @type {SCNMaterial}
     */

    this._parent = null; ///////////////////
    // SCNAnimatable //
    ///////////////////

    /**
     * @access private
     * @type {Map}
     */

    this._animations = new SCNOrderedDictionary();
    this.__presentation = null;
    /**
     * @access private
     * @type {Promise}
     */

    this._loadedPromise = null;
  }

  _createPresentation() {
    if (this.__presentation === null) {
      this.__presentation = this.copy();
    }
  }

  _copyPresentation() {
    // TODO: copy other properties
    this.__presentation._contents = this._contents;
  }

  get _presentation() {
    if (this.__presentation === null) {
      return null;
    }

    return this.__presentation;
  }
  /**
   *
   * @access public
   * @returns {SCNMaterialProperty} -
   */


  copy() {
    const p = new SCNMaterialProperty();
    p._contents = this._contents; // TODO: copy

    p.intensity = this.intensity;
    p.contentsTransform = this.contentsTransform; // TODO: copy

    p.wrapS = this.wrapS;
    p.wrapT = this.wrapT;
    p.minificationFilter = this.minificationFilter;
    p.magnicifactionFilter = this.maginicifactionFilter;
    p.mipFilter = this.mipFilter;
    p.maxAnisotropy = this.maxAnisotropy;
    p.mappingChannel = this.mappingChannel;
    p.borderColor = this.borderColor; // TODO: copy
    //p._parent
    //p._animations
    //p._presentation

    return p;
  }

  valueForKeyPath(keyPath) {
    const target = this.__presentation ? this.__presentation : this; // TODO: add other keys

    if (keyPath === 'contents') {
      return target._contents;
    }

    return super.valueForKeyPath(keyPath);
  }

  setValueForKeyPath(value, keyPath) {
    const target = this.__presentation ? this.__presentation : this; // TODO: add other keys

    if (keyPath === 'contents') {
      target._contents = value;
    } else {
      super.setValueForKeyPath(value, keyPath);
    }
  }
  /**
   * The visual contents of the material property—a color, image, or source of animated content. Animatable.
   * @type {?Object}
   * @see https://developer.apple.com/documentation/scenekit/scnmaterialproperty/1395372-contents
   */


  get contents() {
    return this._contents;
  }

  set contents(newValue) {
    const oldValue = this._contents;
    this._contents = newValue;

    SCNTransaction._addChange(this, 'contents', oldValue, newValue);
  } ///////////////////
  // SCNAnimatable //
  ///////////////////
  // Managing Animations

  /**
   * Required. Adds an animation object for the specified key.
   * @access public
   * @param {CAAnimation} animation - The animation object to be added.
   * @param {?string} key - An string identifying the animation for later retrieval. You may pass nil if you don’t need to reference the animation later.
   * @returns {void}
   * @desc Newly added animations begin executing after the current run loop cycle ends.SceneKit does not define any requirements for the contents of the key parameter—it need only be unique among the keys for other animations you add. If you add an animation with an existing key, this method overwrites the existing animation.
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523386-addanimation
   */


  addAnimationForKey(animation, key) {
    //console.log('SCNMaterialProperty addAnimationForKey')
    if (typeof key === 'undefined' || key === null) {
      key = Symbol();
    }

    const anim = animation.copy(); // FIXME: use current frame time

    anim._animationStartTime = Date.now() * 0.001;
    anim._prevTime = anim._animationStartTime - 0.0000001;

    this._animations.set(key, anim);
  }
  /**
   * Required. Returns the animation with the specified key.
   * @access public
   * @param {string} key - A string identifying a previously added animation.
   * @returns {?CAAnimation} - 
   * @desc Attempting to modify any properties of the returned object results in undefined behavior.
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1524020-animation
   */


  animationForKey(key) {
    return this._animations.get(key);
  }
  /**
   * Required. Removes all the animations currently attached to the object.
   * @access public
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1522762-removeallanimations
   */


  removeAllAnimations() {
    this._animations.clear();
  }
  /**
   * Required. Removes the animation attached to the object with the specified key.
   * @access public
   * @param {string} key - A string identifying an attached animation to remove.
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1522880-removeanimation
   */


  removeAnimationForKey(key) {
    this._animations.delete(key); // TODO: reset values

  }
  /**
   * Required. Removes the animation attached to the object with the specified key, smoothly transitioning out of the animation’s effect.
   * @access public
   * @param {string} key - A string identifying an attached animation to remove.
   * @param {number} duration - The duration for transitioning out of the animation’s effect before it is removed.
   * @returns {void}
   * @desc Use this method to create smooth transitions between the effects of multiple animations. For example, the geometry loaded from a scene file for a game character may have associated animations for player actions such as walking and jumping. When the player lands from a jump, you remove the jump animation so the character continues walking. If you use the removeAnimation(forKey:) method to remove the jump animation, SceneKit abruptly switches from the current frame of the jump animation to the current frame of the walk animation. If you use the removeAnimation(forKey:fadeOutDuration:) method instead, SceneKit plays both animations at once during that duration and interpolates vertex positions from one animation to the other, creating a smooth transition.
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1522841-removeanimation
   */


  removeAnimationForKeyFadeOutDuration(key, duration) {}
  /**
   * Required. An array containing the keys of all animations currently attached to the object.
   * @type {string[]}
   * @desc This array contains all keys for which animations are attached to the object, or is empty if there are no attached animations. The ordering of animation keys in the array is arbitrary.
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523610-animationkeys
   */


  get animationKeys() {
    const keys = [];

    for (const key of this._animations.keys()) {
      keys.push(key);
    }

    return keys;
  } // Pausing and Resuming Animations

  /**
   * Required. Pauses the animation attached to the object with the specified key.
   * @access public
   * @param {string} key - A string identifying an attached animation.
   * @returns {void}
   * @desc This method has no effect if no animation is attached to the object with the specified key.
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523592-pauseanimation
   */


  pauseAnimationForKey(key) {}
  /**
   * Required. Resumes a previously paused animation attached to the object with the specified key.
   * @access public
   * @param {string} key - A string identifying an attached animation.
   * @returns {void}
   * @desc This method has no effect if no animation is attached to the object with the specified key or if the specified animation is not currently paused.
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523332-resumeanimation
   */


  resumeAnimationForKey(key) {}
  /**
   * Required. Returns a Boolean value indicating whether the animation attached to the object with the specified key is paused.
   * @access public
   * @param {string} key - A string identifying an attached animation.
   * @returns {boolean} - 
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523703-isanimationpaused
   */


  isAnimationPausedForKey(key) {
    return false;
  } // Instance Methods

  /**
   * Required. 
   * @access public
   * @param {number} speed - 
   * @param {string} key - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1778343-setanimationspeed
   */


  setAnimationSpeedForKey(speed, key) {}
  /**
   * @access private
   * @param {WebGLContext} gl -
   * @returns {number} -
   */


  _wrapSFor(gl) {
    switch (this.wrapS) {
      case SCNWrapMode.clamp:
        return gl.CLAMP_TO_EDGE;
      // FIXME: do not apply the texture out of 0-1

      case SCNWrapMode.repeat:
        return gl.REPEAT;

      case SCNWrapMode.clampToBorder:
        return gl.CLAMP_TO_EDGE;

      case SCNWrapMode.mirror:
        return gl.MIRRORED_REPEAT;

      default:
        throw new Error(`unknown wrapS: ${this.wrapS}`);
    }
  }
  /**
   * @access private
   * @param {WebGLContext} gl -
   * @returns {number} -
   */


  _wrapTFor(gl) {
    switch (this.wrapT) {
      case SCNWrapMode.clamp:
        return gl.CLAMP_TO_EDGE;
      // FIXME: do not apply the texture out of 0-1

      case SCNWrapMode.repeat:
        return gl.REPEAT;

      case SCNWrapMode.clampToBorder:
        return gl.CLAMP_TO_EDGE;

      case SCNWrapMode.mirror:
        return gl.MIRRORED_REPEAT;

      default:
        throw new Error(`unknown wrapT: ${this.wrapT}`);
    }
  }
  /**
   * @access private
   * @param {WebGLContext} gl -
   * @returns {number} -
   */


  _minificationFilterFor(gl) {
    switch (this.minificationFilter) {
      case SCNFilterMode.none:
      case SCNFilterMode.linear:
        {
          switch (this.mipFilter) {
            case SCNFilterMode.none:
              return gl.LINEAR;

            case SCNFilterMode.nearest:
              return gl.LINEAR_MIPMAP_NEAREST;

            case SCNFilterMode.linear:
              return gl.LINEAR_MIPMAP_LINEAR;

            default:
              throw new Error(`unknown mipmapFilter: ${this.mipmapFilter}`);
          }
        }

      case SCNFilterMode.nearest:
        {
          switch (this.mipFilter) {
            case SCNFilterMode.none:
              return gl.NEAREST;

            case SCNFilterMode.nearest:
              return gl.NEAREST_MIPMAP_NEAREST;

            case SCNFilterMode.linear:
              return gl.NEAREST_MIPMAP_LINEAR;

            default:
              throw new Error(`unknown mipmapFilter: ${this.mipmapFilter}`);
          }
        }

      default:
        throw new Error(`unknown minificationFilter: ${this.minificationFilter}`);
    }
  }
  /**
   * @access private
   * @param {WebGLContext} gl -
   * @returns {number} -
   */


  _magnificationFilterFor(gl) {
    switch (this.magnificationFilter) {
      case SCNFilterMode.none:
        return gl.LINEAR;
      // default value

      case SCNFilterMode.nearest:
        return gl.NEAREST;

      case SCNFilterMode.linear:
        return gl.LINEAR;

      default:
        throw new Error(`unknown magnificationFilter: ${this.magnificationFilter}`);
    }
  }
  /**
   * @access private
   * @param {string} path -
   * @param {string} dirPath -
   * @returns {Image} -
   */


  _loadContentsImage(path, dirPath) {
    const image = new Image(); // TODO: check option if it allows cross-domain.

    image.crossOrigin = 'anonymous'; // TODO: refactoring

    if (typeof path === 'object' && typeof path.then === 'function') {
      this._loadedPromise = new Promise((resolve, reject) => {
        path.then(_path => {
          image.onload = () => {
            this._contents = image;
            resolve();
          };

          image.onerror = () => {
            reject(new Error(`image ${_path} load error.`));
          };

          image.src = _path;
        });
      });
      return image;
    }

    let __path = path;

    if (__path.indexOf('file:///') === 0) {
      __path = __path.slice(8);
    } // TODO: load OpenEXR File


    __path = __path.replace(/\.exr$/, '.png');
    this._loadedPromise = new Promise((resolve, reject) => {
      const paths = __path.split('/');

      let pathCount = 1;

      let _path = dirPath + paths.slice(-pathCount).join('/');

      image.onload = () => {
        this._contents = image;
        resolve();
      };

      image.onerror = () => {
        pathCount += 1;

        if (pathCount > paths.length) {
          // try the root path
          image.onerror = () => {
            // give up
            reject();
            throw new Error(`image ${path} load error.`);
          };

          image.src = __path;
        } else {
          // retry
          _path = dirPath + paths.slice(-pathCount).join('/');
          image.src = _path;
        }
      };

      image.src = _path;
    });
    return image;
  }
  /**
   * @access private
   * @param {Uint8Array} data - 
   * @returns {Image} -
   */


  _loadContentsImageByData(data) {
    const image = new Image(); // TODO: check option if it allows cross-domain.

    image.crossOrigin = 'anonymous';
    this._loadedPromise = new Promise((resolve, reject) => {
      image.onload = () => {
        this._contents = image;
        resolve();
      };

      image.onerror = () => {
        reject();
      }; // TODO: check file type by magic


      let blob = new Blob([data], {
        type: 'image/png'
      });
      let url = URL.createObjectURL(blob);
      image.src = url;
    });
    return image;
  }
  /**
   * @access public
   * @returns {Float32Array} -
   */


  float32Array() {
    const target = this.__presentation ? this.__presentation : this;

    if (_InstanceOf(target._contents, SKColor)) {
      return target._contents.float32Array(); //return target._contents.srgbToLinear().float32Array()
    }

    return new Float32Array([1, 1, 1, 1]);
  }
  /**
   * @access private
   * @returns {Promise} -
   */


  _getLoadedPromise() {
    if (this._loadedPromise) {
      return this._loadedPromise;
    }

    return Promise.resolve();
  }
  /**
   * @access public
   * @type {Promise} -
   */


  get didLoad() {
    return this._getLoadedPromise();
  }

}

/**
 * The modes SceneKit uses to calculate the opacity of pixels rendered with a material, used by the transparencyMode property.
 * @typedef {Object} SCNTransparencyMode
 * @property {number} aOne - SceneKit derives transparency information from the alpha channel of colors. The value 1.0 is opaque.
 * @property {number} rgbZero - SceneKit derives transparency information from the luminance of colors. The value 0.0 is opaque.
 * @see https://developer.apple.com/documentation/scenekit/scntransparencymode
 */

const SCNTransparencyMode = {
  aOne: 0,
  rgbZero: 1
};

const _LightingModel = {
  blinn: 'SCNLightingModelBlinn',
  constant: 'SCNLightingModelConstant',
  lambert: 'SCNLightingModelLambert',
  phong: 'SCNLightingModelPhong',
  physicallyBased: 'SCNLightingModelPhysicallyBased'
  /**
   * A set of shading attributes that define the appearance of a geometry's surface when rendered.
   * @access public
   * @extends {NSObject}
   * @implements {SCNAnimatable}
   * @implements {SCNShadable}
   * @see https://developer.apple.com/documentation/scenekit/scnmaterial
   */

};
class SCNMaterial extends NSObject {
  static get _propTypes() {
    return {
      diffuse: ['SCNMaterialProperty', (obj, value) => {
        obj._diffuse = value;

        value._createPresentation();
      }],
      ambient: ['SCNMaterialProperty', (obj, value) => {
        obj._ambient = value;

        value._createPresentation();
      }],
      specular: ['SCNMaterialProperty', (obj, value) => {
        obj._specular = value;

        value._createPresentation();
      }],
      normal: ['SCNMaterialProperty', (obj, value) => {
        obj._normal = value;

        value._createPresentation();
      }],
      reflective: ['SCNMaterialProperty', (obj, value) => {
        obj._reflective = value;

        value._createPresentation();
      }],
      emission: ['SCNMaterialProperty', (obj, value) => {
        obj._emission = value;

        value._createPresentation();
      }],
      transparent: ['SCNMaterialProperty', (obj, value) => {
        obj._transparent = value;

        value._createPresentation();
      }],
      multiply: ['SCNMaterialProperty', (obj, value) => {
        obj._multiply = value;

        value._createPresentation();
      }],
      ambientOcclusion: ['SCNMaterialProperty', (obj, value) => {
        obj._ambientOcclusion = value;

        value._createPresentation();
      }],
      selfIllumination: ['SCNMaterialProperty', (obj, value) => {
        obj._selfIllumination = value;

        value._createPresentation();
      }],
      metalness: ['SCNMaterialProperty', (obj, value) => {
        obj._metalness = value;

        value._createPresentation();
      }],
      roughness: ['SCNMaterialProperty', (obj, value) => {
        obj._roughness = value;

        value._createPresentation();
      }],
      displacement: ['SCNMaterialProperty', (obj, value) => {
        obj._displacement = value;

        value._createPresentation();
      }],
      name: 'string',
      shininess: 'float',
      fresnelExponent: 'float',
      transparency: 'integer',
      transparencyMode: 'integer',
      lightingModelName: ['string', 'lightingModel'],
      litPerPixel: ['boolean', 'isLitPerPixel'],
      doubleSided: ['boolean', 'isDoubleSided'],
      cullMode: 'integer',
      blendMode: 'integer',
      locksAmbientWithDiffuse: 'boolean',
      writesToDepthBuffer: 'boolean',
      readsFromDepthBuffer: 'boolean',
      colorBufferWriteMask: 'integer',
      fillMode: 'integer',
      valuesForUndefinedKeys: ['NSMutableDictionary', '_valuesForUndefinedKeys'],
      shadableHelper: ['SCNShadableHelper', '_shadableHelper'],
      avoidsOverLighting: ['boolean', null],
      entityID: ['string', '_entityID'],
      indexOfRefraction: ['integer', null],
      selfIlluminationOcclusion: ['integer', null]
    };
  } // Creating a Material

  /**
   * Creates a material from the specified Model I/O material object.
   * @access public
   * @constructor
   * @param {MDLMaterial} mdlMaterial - A Model I/O material object.
   * @desc The Model I/O framework provides universal support for import, export, description, and processing of several 3D asset file formats and related resources. (For details, see Model I/O.) The MDLMaterial class is a generic description of surface rendering to be used in rendering 3D object, supporting a superset of the attributes described by the SCNMaterial class. 
   * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1419835-init
   */


  constructor(mdlMaterial) {
    super(); // Configuring a Material’s Visual Properties

    this._diffuse = new SCNMaterialProperty(SKColor.white);
    this._ambient = new SCNMaterialProperty(new SKColor(0.485, 0.485, 0.485, 1.0));
    this._specular = new SCNMaterialProperty(SKColor.black);
    this._normal = new SCNMaterialProperty(SKColor.white);
    this._reflective = new SCNMaterialProperty(SKColor.black);
    this._emission = new SCNMaterialProperty(SKColor.black);
    this._transparent = new SCNMaterialProperty(SKColor.white);
    this._multiply = new SCNMaterialProperty(SKColor.white);
    this._ambientOcclusion = new SCNMaterialProperty(SKColor.white);
    this._selfIllumination = new SCNMaterialProperty(SKColor.black);
    this._metalness = new SCNMaterialProperty(SKColor.black);
    this._roughness = new SCNMaterialProperty(new SKColor(0.485, 0.485, 0.485, 1.0));
    this._displacement = new SCNMaterialProperty(SKColor.black); // TODO: check the default value
    // Customizing a Material

    /**
     * A name associated with the material.
     * @type {?string}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462525-name
     */

    this.name = null;
    /**
     * The sharpness of specular highlights. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462533-shininess
     */

    this.shininess = 1.0;
    /**
     * A factor affecting the material’s reflectivity. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462587-fresnelexponent
     */

    this.fresnelExponent = 0.0;
    /**
     * The uniform transparency of the material. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462567-transparency
     */

    this.transparency = 1.0;
    /**
     * The mode SceneKit uses to calculate transparency for the material.
     * @type {SCNTransparencyMode}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462549-transparencymode
     */

    this.transparencyMode = SCNTransparencyMode.aOne;
    /**
     * The lighting formula that SceneKit uses to render the material.
     * @type {SCNMaterial.LightingModel}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462518-lightingmodel
     */

    this.lightingModel = _LightingModel.blinn;
    /**
     * A Boolean value that determines whether SceneKit performs lighting calculations per vertex or per pixel. Animatable.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462580-islitperpixel
     */

    this.isLitPerPixel = true;
    /**
     * A Boolean value that determines whether SceneKit should render both front and back faces of a surface. Animatable.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462531-isdoublesided
     */

    this.isDoubleSided = false;
    /**
     * The mode determining which faces of a surface SceneKit renders. Animatable.
     * @type {SCNCullMode}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462571-cullmode
     */

    this.cullMode = SCNCullMode.back;
    /**
     * The mode that determines how pixel colors rendered using this material blend with other pixel colors in the rendering target.
     * @type {SCNBlendMode}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462585-blendmode
     */

    this.blendMode = SCNBlendMode.alpha;
    /**
     * A Boolean value that determines whether the material responds identically to both ambient and diffuse lighting. Animatable.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462522-locksambientwithdiffuse
     */

    this.locksAmbientWithDiffuse = true;
    /**
     * A Boolean value that determines whether SceneKit produces depth information when rendering the material.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462545-writestodepthbuffer
     */

    this.writesToDepthBuffer = true;
    /**
     * A Boolean value that determines whether SceneKit uses depth information when rendering the material.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462562-readsfromdepthbuffer
     */

    this.readsFromDepthBuffer = true;
    /**
     *
     * @type {SCNColorMask}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial/2867554-colorbufferwritemask
     */

    this.colorBufferWriteMask = SCNColorMask.all;
    /**
     * 
     * @type {SCNFillMode}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial/2867442-fillmode
     */

    this.fillMode = SCNFillMode.fill; /////////////////
    // SCNShadable //
    /////////////////
    // Assigning a Custom Shader Program

    /**
     * A program used when rendering the object.
     * @type {?SCNProgram}
     * @see https://developer.apple.com/documentation/scenekit/scnshadable/1523689-program
     */

    this.program = null; // Customizing SceneKit’s Shader Programs

    /**
     * A dictionary of GLSL source code snippets for customizing the shader programs provided by SceneKit.
     * @type {?Map<SCNShaderModifierEntryPoint, string>}
     * @see https://developer.apple.com/documentation/scenekit/scnshadable/1523348-shadermodifiers
     */

    this.shaderModifiers = null;
    /**
     * @access private
     * @type {Map<string, SCNBindingBlock>}
     */

    this._bindingHandler = {};
    /**
     * @access private
     * @type {Map<string, SCNBindingBlock>}
     */

    this._unbindingHandler = {};
    /**
     * @access private
     * @type {Object}
     */

    this._valuesForUndefinedKeys = {}; ///////////////////
    // SCNAnimatable //
    ///////////////////

    /**
     * @access private
     * @type {Map}
     */

    this._animations = new SCNOrderedDictionary();
    /**
     * @access private
     * @type {?string}
     */

    this._entityID = null;

    this._createPresentationProperties();
    /**
     * @access private
     * @type {?SCNShadableHelper}
     */


    this._shadableHelper = null;
    /**
     * @access private
     * @type {Promise}
     */

    this._loadedPromise = null;
  } // Configuring a Material’s Visual Properties

  /**
   * An object that manages the material’s diffuse response to lighting.
   * @type {SCNMaterialProperty}
   * @desc Diffuse shading describes the amount and color of light reflected equally in all directions from each point on the material’s surface. The diffuse color of a pixel is independent of the point of view, so it can be thought of as a material’s “base” color or texture. By default, the diffuse property’s contents object is a white color. Figure 1 shows the effect of setting the diffuse property’s contents to a texture image on a material whose other properties have default contents.Figure 1 Adding a diffuse texture to a materialThe material’s lightingModel property determines the formula SceneKit uses to combine its diffuse color and other visual properties with lights and other contents in a scene to produce the final color for each rendered pixel in the rendered scene. For details, see Lighting Models.Adding a diffuse texture to a material
   * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462589-diffuse
   */


  get diffuse() {
    return this._diffuse;
  }
  /**
   * An object that manages the material’s response to ambient lighting.
   * @type {SCNMaterialProperty}
   * @desc Ambient shading describes the amount and color of ambient light reflected by the material. Ambient shading is uniform in all directions at all points on a surface. If a scene does not contain lights whose type is ambient, this property has no effect on a material’s appearance. By default, the ambient property’s contents object is a dark gray color. Changing the ambient property’s contents lets you specify a different color or texture for the areas of a surface not directly illuminated by lights in a scene. To make the material respond identically to both ambient and diffuse light, set its locksAmbientWithDiffuse property to true. Figure 1 shows a material (with a texture for its diffuse property) before and after setting the ambient property’s contents to a solid color.Figure 1 Adding an ambient color to a materialThe material’s lightingModel property determines the formula SceneKit uses to combine its ambient color and other visual properties with lights and other contents in a scene to produce the final color for each rendered pixel in the rendered scene. For details, see Lighting Models.This material property does not apply to physically-based materials (see physicallyBased).Adding an ambient color to a material
   * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462558-ambient
   */


  get ambient() {
    return this._ambient;
  }
  /**
   * An object that manages the material’s specular response to lighting.
   * @type {SCNMaterialProperty}
   * @desc Specular shading describes the amount and color of light reflected by the material directly toward the viewer, forming a bright highlight on the surface and simulating a glossy or shiny appearance. You adjust the sharpness of specular highlights using the material’s shininess property.By default, the specular property’s contents object is a black color, causing the material to appear dull or matte. Changing the specular property’s contents to a brighter color causes specular highlights to appear in that color, making the surface appear shiny. When you apply a texture to the specular property, the texture image becomes a specular map—the brightness of each pixel in the image determines the tendency of each point on the material’s surface to create specular highlights when lit. Figure 1 shows a material (with a texture for its diffuse property) before and after providing a specular map image. Notice that the bright specular highlights appear only on portions of the surface where the specular map image is white.Figure 1 Adding a specular map to a materialThe material’s lightingModel property determines the formula SceneKit uses to combine its specularity and other visual properties with lights and other contents in a scene to produce the final color for each rendered pixel in the rendered scene. For details, see Lighting Models.This material property does not apply to physically-based materials (see physicallyBased).Adding a specular map to a material
   * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462516-specular
   */


  get specular() {
    return this._specular;
  }
  /**
   * An object that defines the nominal orientation of the surface at each point for use in lighting.
   * @type {SCNMaterialProperty}
   * @desc Simulating the interaction of lights with a material requires information about the orientation of the surface at each point. Typically, normal vectors provided by a geometry object provide this information. However, this limits the level of detail for surface contours because a geometry can only provide one unique surface normal vector per vertex (and increasing vertex count to model a highly detailed surface exacts a high performance cost).Alternatively, you can use a texture image as a normal map that describes the orientation of a surface for each pixel in the texture. When SceneKit uses an image, it treats the R, G, and B components of each as the X, Y, and Z components of a surface normal vector. Because a normal map texture can store much more detailed surface information than a geometry, you can use a material’s normal property to simulate rough surfaces such as stone or add embossed or engraved designs to an otherwise smooth surface.By default, the normal property’s contents object is a white color. Setting the normal property’s contents to any solid color disables normal mapping, causing SceneKit to shade the material using only the surface normal information provided by its geometry. Setting the normal property’s contents to an image or other texture-mapped content enables normal mapping, which also automatically sets the material’s isLitPerPixel property to true. Figure 1 shows the effect of setting the normal property’s contents to a texture image on a material whose other properties have default contents.Figure 1 Adding a normal map to a materialThe material’s lightingModel property determines the formula SceneKit uses to combine its surface normals and other visual properties with lights and other contents in a scene to produce the final color for each rendered pixel in the rendered scene. For details, see Lighting Models.Adding a normal map to a material
   * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462542-normal
   */


  get normal() {
    return this._normal;
  }
  /**
   * An object that defines the reflected color for each point on a surface.
   * @type {SCNMaterialProperty}
   * @desc You can simulate a mirrored or chromed finish on a surface by causing it to reflect its environment. SceneKit does not render real-time reflections of the objects in a scene, but it can use an environment map texture to simulate reflection of a static or animated image. When rendering each pixel on the surface, SceneKit traces the light from that point to a pixel in the environment map as if the surface was reflecting that image.By default, the reflective property’s contents object is a white color, causing the property to have no visible effect. Setting the reflective property’s contents to any solid color adds uniform shading to the material. To create a reflective effect, set the property’s contents to an image or other texture-mapped content.To produce a mirror-finish effect using an environment map, the texture image should take one of two forms:A sphere map, a square image whose content depicts an environment as reflected by a mirrored sphere.A cube map, an array of six square images which together form an imaginary cube enclosing the scene, whose inner surfaces are reflected by the material. You create a cube map by setting the reflective property’s contents object to an NSArray instance containing six images, each corresponding to a direction in the scene’s world coordinate space in the following order: +X, -X, +Y, -Y, +Z, -Z (or Right, Left, Top, Bottom, Near, Far).Figure 1 shows a material (with a texture for its normal property) before and after providing a cube map for the reflective property.Figure 1 Adding a reflective cube map to a materialThis material property does not apply to physically-based materials (see physicallyBased). Instead, such materials reflect environment-based lighting (see the SCNScene lightingEnvironment property) based on their metalness and roughness properties.Adding a reflective cube map to a material
   * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462520-reflective
   */


  get reflective() {
    return this._reflective;
  }
  /**
   * An object that defines the color emitted by each point on a surface.
   * @type {SCNMaterialProperty}
   * @desc You can use an emissive map texture to simulate parts of a surface that glow with their own light. SceneKit does not treat the material as a light source—rather, the emission property determines colors for a material independent of lighting. (To create an object that appears to glow, you may wish to combine a geometry with an emissive map and additional SCNLight objects added to the scene.)By default, the emissive property’s contents object is a black color, causing the property to have no visible effect. Setting the emissive property’s contents to any solid color adds a uniform color to the material independent of lighting. To create a selective glow effect, set the property’s contents to an image or other texture-mapped content whose glowing areas use bright colors and whose other areas use darker colors. In the darker-colored portions of the emissive map (and portions with reduced opacity), the other visual properties of the material contribute to its appearance under scene lighting.Figure 1 shows a material (with a texture for its diffuse property) before and after providing an emissive map image.Figure 1 Adding an emissive map to a materialAdding an emissive map to a material
   * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462527-emission
   */


  get emission() {
    return this._emission;
  }
  /**
   * An object that determines the opacity of each point in a material.
   * @type {SCNMaterialProperty}
   * @desc Use this property to selectively make parts of a material appear transparent. You can uniformly adjust the opacity of a material using its transparency property, or of all the content attached to a node using the node’s opacity property.By default, the transparent property’s contents object is a fully opaque black color, causing the property to have no visible effect. Setting the transparent property’s contents to any solid color uniformly fades the opacity of the material based on that color’s opacity value. To make parts of a material appear transparent, set the property’s contents to an image or other texture-mapped content whose alpha channel defines areas of full or partial opacity.Figure 1 shows a semitransparent material before and after providing a texture image for its transparent property. (To make the transparency effect more visible, a blue sphere is shown behind the transparent material.)Figure 1 Adding a transparent texture to a materialThe transparencyMode property controls how SceneKit interprets color information from the transparent property’s contents.Adding a transparent texture to a material
   * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462583-transparent
   */


  get transparent() {
    return this._transparent;
  }
  /**
   * An object that provides color values that are multiplied with pixels in a material after all other shading is complete.
   * @type {SCNMaterialProperty}
   * @desc After combining a material’s other visual properties with lighting and other information about a scene, Scene kit multiplies the color of each rendered pixel by the color this property provides. You can use this property to darken or tint a surface independent of the effects of lighting and other properties, or to add precomputed lighting to a scene via a shadow map.By default, the multiply property’s contents object is a white color, causing the property to have no visible effect.Figure 1 shows a material (with textures for its diffuse and emission properties) before and after setting the multiply property’s contents to a solid color. Notice that the multiply color modulates even the bright areas added by the emissive map.Figure 1 Adding a multiply color to a materialAdding a multiply color to a material
   * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462575-multiply
   */


  get multiply() {
    return this._multiply;
  }
  /**
   * An object that provides color values to be multiplied with the ambient light affecting the material.
   * @type {SCNMaterialProperty}
   * @desc Use this property to assign an ambient occlusion texture map to a surface. This property has no effect if there is no ambient light in the scene. If this property is not nil, SceneKit ignores the ambient property.When using physically-based shading (see physicallyBased), ambient occlusion approximates large-scale surface details that obscure global illumination.
   * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462579-ambientocclusion
   */


  get ambientOcclusion() {
    return this._ambientOcclusion;
  }
  /**
   * An object that provides color values representing the global illumination of the surface.
   * @type {SCNMaterialProperty}
   * @desc Self-illumination applies to all materials, but is especially useful for those using physically-based shading (see physicallyBased). Physically-based materials work best with environment-based lighting (see the SCNScene property lightingEnvironment), but for some materials it can be useful to let a surface itself define part of its lighting—for example, an object whose position obscures it from the “sky” that provides the main lighting environment. When you assign contents to this property, they override the environmental lighting contribution to diffuse shading, but environmental lighting still contributes to specular effects.
   * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462524-selfillumination
   */


  get selfIllumination() {
    return this._selfIllumination;
  }
  /**
   * An object that provides color values to determine how metallic the material’s surface appears.
   * @type {SCNMaterialProperty}
   * @desc This property measures only the total intensity of color values; texture contents are best defined in grayscale.This property generally approximates aspects of a physical surface—such as index of refraction, tendency to produce sharp reflections, and tendency to produce Fresnel reflections at grazing angles—that together produce an overall metallic or nonmetallic (also called dielectric) appearance. Lower values (darker colors) cause the material to appear more like a dielectric surface. Higher values (brighter colors) cause the surface to appear more metallic.This property applies only when the material’s lightingModel value is physicallyBased.
   * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1640554-metalness
   */


  get metalness() {
    return this._metalness;
  }
  /**
   * An object that provides color values to determine the apparent smoothness of the surface.
   * @type {SCNMaterialProperty}
   * @desc This property measures only the total intensity of color values; texture contents are best defined in grayscale.This property approximates the level of microscopic detail—for example tiny bumps and cracks—in a surface. By approximating these “microfacets” as a single term, this property helps produce lighting calculations that resemble the energy-conserving laws of real-world physics, resulting in more realistic variation between matte and shiny surfaces. Lower values (darker colors) cause the material to appear shiny, with well-defined specular highlights. Higher values (brighter colors) cause specular highlights to spread out and the diffuse color of the material to become more retroreflective.This property applies only when the material’s lightingModel value is physicallyBased.
   * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1640555-roughness
   */


  get roughness() {
    return this._roughness;
  }
  /**
   * 
   * @type {SCNMaterialProperty}
   * @desc
   * @see https://developer.apple.com/documentation/scenekit/scnmaterial/2867516-displacement
   */


  get displacement() {
    return this._displacement;
  }

  _createPresentationProperties() {
    this._diffuse._createPresentation();

    this._ambient._createPresentation();

    this._specular._createPresentation();

    this._normal._createPresentation();

    this._reflective._createPresentation();

    this._emission._createPresentation();

    this._transparent._createPresentation();

    this._multiply._createPresentation();

    this._ambientOcclusion._createPresentation();

    this._selfIllumination._createPresentation();

    this._metalness._createPresentation();

    this._roughness._createPresentation();
  }

  _copyPresentationProperties() {
    this._diffuse._copyPresentation();

    this._ambient._copyPresentation();

    this._specular._copyPresentation();

    this._normal._copyPresentation();

    this._reflective._copyPresentation();

    this._emission._copyPresentation();

    this._transparent._copyPresentation();

    this._multiply._copyPresentation();

    this._ambientOcclusion._copyPresentation();

    this._selfIllumination._copyPresentation();

    this._metalness._copyPresentation();

    this._roughness._copyPresentation();
  } // Structures

  /**
   * @type {Object} LightingModel
   * @property {string} blinn Shading that incorporates ambient, diffuse, and specular properties, where specular highlights are calculated using the Blinn-Phong  formula.
   * @property {string} constant Uniform shading that incorporates ambient lighting only.
   * @property {string} lambert Shading that incorporates ambient and diffuse properties only.
   * @property {string} phong Shading that incorporates ambient, diffuse, and specular properties, where specular highlights are calculated using the Phong  formula.
   * @property {string} physicallyBased Shading based on a realistic abstraction of physical lights and materials.
   * @see https://developer.apple.com/documentation/scenekit/scnmaterial.lightingmodel
   */


  static get LightingModel() {
    return _LightingModel;
  } /////////////////
  // SCNShadable //
  /////////////////
  // Handling Parameters in Custom OpenGL Shader Programs

  /**
   * Specifies a block to be called before rendering with programs with the specified GLSL uniform variable or attribute name.
   * @access public
   * @param {string} symbol - A GLSL uniform variable or attribute name.
   * @param {?SCNBindingBlock} [block = null] - A block to be called by SceneKit.
   * @returns {void}
   * @desc Use this method to associate a block with a SceneKit object (geometry or material) to handle setup of an attribute or uniform variable in a custom SCNProgram shader associated with that object. SceneKit calls your block before rendering the object. In the block, you can execute any OpenGL commands or other code necessary for preparing your custom shader. For example, the following block updates the time uniform variable in a custom fragment shader for producing animated effects:CFTimeInterval startTime = CFAbsoluteTimeGetCurrent();
  [myNode.geometry.firstMaterial handleBindingOfSymbol:@"time" usingBlock:
    ^(unsigned int programID, unsigned int location, SCNNode *renderedNode, SCNRenderer *renderer) {
        glUniform1f(location, CFAbsoluteTimeGetCurrent() - startTime);
    }];
  This method is for OpenGL shader programs only. To bind custom variable data for Metal shader programs, use the handleBinding(ofBufferNamed:frequency:handler:) method.CFTimeInterval startTime = CFAbsoluteTimeGetCurrent();
  [myNode.geometry.firstMaterial handleBindingOfSymbol:@"time" usingBlock:
    ^(unsigned int programID, unsigned int location, SCNNode *renderedNode, SCNRenderer *renderer) {
        glUniform1f(location, CFAbsoluteTimeGetCurrent() - startTime);
    }];
    * @see https://developer.apple.com/documentation/scenekit/scnshadable/1523063-handlebinding
   */


  handleBindingOfSymbolHandler(symbol, block = null) {
    this._bindingHandler[symbol] = block;
  }
  /**
   * Specifies a block to be called after rendering with programs with the specified GLSL uniform variable or attribute name.
   * @access public
   * @param {string} symbol - A GLSL uniform variable or attribute name.
   * @param {?SCNBindingBlock} [block = null] - A block to be called by SceneKit.
   * @returns {void}
   * @desc Use this method to associate a block with a SceneKit object (geometry or material) to handle cleanup related to an attribute or uniform variable in a custom SCNProgram shader associated with that object. SceneKit will call your block after rendering the object. In the block, you can execute any OpenGL commands or other code necessary for post-rendering tasks.This method is for OpenGL shader programs only. To bind custom variable data for Metal shader programs, use the handleBinding(ofBufferNamed:frequency:handler:) method.
   * @see https://developer.apple.com/documentation/scenekit/scnshadable/1522783-handleunbinding
   */


  handleUnbindingOfSymbolHandler(symbol, block = null) {
    this._unbindingHandler[symbol] = block;
  }
  /**
   * @access private
   * @param {SCNNode} node -
   * @param {WebGLProgram} glProgram -
   * @param {WebGLRenderingContext} gl -
   * @param {SCNRenderer} renderer -
   * @returns {void}
   */


  _callBindingHandlerForNodeProgramContextRenderer(node, glProgram, gl, renderer) {
    const bindingKeys = Object.keys(this._bindingHandler);

    for (const key of bindingKeys) {
      const handler = this._bindingHandler[key];
      const loc = gl.getUniformBlockIndex(glProgram, key);
      handler(glProgram, loc, node, renderer);
    }
  }
  /**
   * @access private
   * @param {SCNNode} node -
   * @param {WebGLProgram} glProgram -
   * @param {WebGLRenderingContext} gl -
   * @param {SCNRenderer} renderer -
   * @returns {void}
   */


  _callUnindingHandlerForNodeProgramContextRenderer(node, glProgram, gl, renderer) {
    const bindingKeys = Object.keys(this._unbindingHandler);

    for (const key of bindingKeys) {
      const handler = this._unbindingHandler[key];
      const loc = gl.getUniformBlockIndex(glProgram, key);
      handler(glProgram, loc, node, renderer);
    }
  } ///////////////////
  // SCNAnimatable //
  ///////////////////
  // Managing Animations

  /**
   * Required. Adds an animation object for the specified key.
   * @access public
   * @param {CAAnimation} animation - The animation object to be added.
   * @param {?string} key - An string identifying the animation for later retrieval. You may pass nil if you don’t need to reference the animation later.
   * @returns {void}
   * @desc Newly added animations begin executing after the current run loop cycle ends.SceneKit does not define any requirements for the contents of the key parameter—it need only be unique among the keys for other animations you add. If you add an animation with an existing key, this method overwrites the existing animation.
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523386-addanimation
   */


  addAnimationForKey(animation, key) {
    if (typeof key === 'undefined' || key === null) {
      key = Symbol();
    }

    const anim = animation.copy(); // FIXME: use current frame time

    anim._animationStartTime = Date.now() * 0.001;
    anim._prevTime = anim._animationStartTime - 0.0000001;

    this._animations.set(key, anim);
  }
  /**
   * Required. Returns the animation with the specified key.
   * @access public
   * @param {string} key - A string identifying a previously added animation.
   * @returns {?CAAnimation} - 
   * @desc Attempting to modify any properties of the returned object results in undefined behavior.
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1524020-animation
   */


  animationForKey(key) {
    return this._animations.get(key);
  }
  /**
   * Required. Removes all the animations currently attached to the object.
   * @access public
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1522762-removeallanimations
   */


  removeAllAnimations() {
    this._animations.clear();
  }
  /**
   * Required. Removes the animation attached to the object with the specified key.
   * @access public
   * @param {string} key - A string identifying an attached animation to remove.
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1522880-removeanimation
   */


  removeAnimationForKey(key) {
    this._animations.delete(key); // TODO: reset values

  }
  /**
   * Required. Removes the animation attached to the object with the specified key, smoothly transitioning out of the animation’s effect.
   * @access public
   * @param {string} key - A string identifying an attached animation to remove.
   * @param {number} duration - The duration for transitioning out of the animation’s effect before it is removed.
   * @returns {void}
   * @desc Use this method to create smooth transitions between the effects of multiple animations. For example, the geometry loaded from a scene file for a game character may have associated animations for player actions such as walking and jumping. When the player lands from a jump, you remove the jump animation so the character continues walking. If you use the removeAnimation(forKey:) method to remove the jump animation, SceneKit abruptly switches from the current frame of the jump animation to the current frame of the walk animation. If you use the removeAnimation(forKey:fadeOutDuration:) method instead, SceneKit plays both animations at once during that duration and interpolates vertex positions from one animation to the other, creating a smooth transition.
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1522841-removeanimation
   */


  removeAnimationForKeyFadeOutDuration(key, duration) {}
  /**
   * Required. An array containing the keys of all animations currently attached to the object.
   * @type {string[]}
   * @desc This array contains all keys for which animations are attached to the object, or is empty if there are no attached animations. The ordering of animation keys in the array is arbitrary.
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523610-animationkeys
   */


  get animationKeys() {
    const keys = [];

    for (const key of this._animations.keys()) {
      keys.push(key);
    }

    return keys;
  } // Pausing and Resuming Animations

  /**
   * Required. Pauses the animation attached to the object with the specified key.
   * @access public
   * @param {string} key - A string identifying an attached animation.
   * @returns {void}
   * @desc This method has no effect if no animation is attached to the object with the specified key.
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523592-pauseanimation
   */


  pauseAnimationForKey(key) {}
  /**
   * Required. Resumes a previously paused animation attached to the object with the specified key.
   * @access public
   * @param {string} key - A string identifying an attached animation.
   * @returns {void}
   * @desc This method has no effect if no animation is attached to the object with the specified key or if the specified animation is not currently paused.
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523332-resumeanimation
   */


  resumeAnimationForKey(key) {}
  /**
   * Required. Returns a Boolean value indicating whether the animation attached to the object with the specified key is paused.
   * @access public
   * @param {string} key - A string identifying an attached animation.
   * @returns {boolean} - 
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523703-isanimationpaused
   */


  isAnimationPausedForKey(key) {
    return false;
  } // Instance Methods

  /**
   * Required. 
   * @access public
   * @param {number} speed - 
   * @param {string} key - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1778343-setanimationspeed
   */


  setAnimationSpeedForKey(speed, key) {}
  /**
   * @access private
   * @returns {Promise} -
   */


  _getLoadedPromise() {
    if (this._loadedPromise) {
      return this._loadedPromise;
    }

    const properties = [this._ambient, this._specular, this._normal, this._reflective, this._emission, this._transparent, this._multiply, this._ambientOcclusion, this._metalness, this._roughness];
    const promises = [];

    for (const p of properties) {
      if (p) {
        promises.push(p.didLoad);
      }
    } //this._loadedPromise = Promise.all(promises)
    //return this._loadedPromise


    return Promise.all(promises);
  }
  /**
   * @access public
   * @type {Promise} -
   */


  get didLoad() {
    return this._getLoadedPromise();
  }
  /**
   * Invoked by setValue(_:forKey:) when it finds no property for a given key.
   * @access public
   * @param {?Object} value - The value for the key identified by key.
   * @param {string} key - A string that is not equal to the name of any of the receiver's properties.
   * @returns {void}
   * @desc Subclasses can override this method to handle the request in some other way. The default implementation raises an NSUndefinedKeyException.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1413490-setvalue
   */


  setValueForUndefinedKey(value, key) {
    this._valuesForUndefinedKeys[key] = value;
  }
  /**
   * Invoked by value(forKey:) when it finds no property corresponding to a given key.
   * @access public
   * @param {string} key - A string that is not equal to the name of any of the receiver's properties.
   * @returns {?Object} - 
   * @desc Subclasses can override this method to return an alternate value for undefined keys. The default implementation raises an NSUndefinedKeyException.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1413457-value
   */


  valueForUndefinedKey(key) {
    if (typeof this._valuesForUndefinedKeys[key] !== 'undefined') {
      return this._valuesForUndefinedKeys[key];
    }

    return super.valueForUndefinedKey(key);
  }

}

/*global Buffer*/

const _integerPattern = new RegExp(/^(-|\+)?\d+;?/);

const _floatPattern = new RegExp(/^(-|\+)?(\d)*\.(\d)*;?/);

const _wordPattern = new RegExp(/^\w+/);

const _linePattern = new RegExp(/^.*\n/);
/**
 * TextReader class
 * @access public
 */


class TextReader {
  /**
   * constructor
   * @access public
   * @constructor
   * @param {Buffer|ArrayBuffer} data -
   * @param {string} encoding -
   */
  constructor(data, encoding = 'utf-8') {
    /**
     * @access private
     * @type {number}
     */
    this._pos = 0;
    this._partialText = '';
    this._partialOffset = 0;
    this._partialStep = 200;
    this._partialMinLength = 100;
    /**
     * @access private
     * @type {boolean}
     */

    this._eof = true;
    /**
     *
     * @access public
     * @type {Buffer}
     */

    this.buffer = null;

    if (data instanceof Buffer) {
      this.buffer = data;
    } else {
      this.buffer = Buffer.from(data);
    }
    /**
     *
     * @access public
     * @type {boolean}
     */
    //this.bigEndian = bigEndian

    /**
     *
     * @access public
     * @type {string}
     */


    this.encoding = encoding; // prepare buffered text

    this._addPartialText();
  }
  /**
   * @access public
   * @param {number} length - length of data to skip
   * @param {boolean} noAssert -
   * @returns {void}
   */


  skip(length, noAssert = false) {
    this._moveIndex(length);

    if (!noAssert) {
      this._check();
    }
  }
  /**
   *
   * @access public
   * @param {number} length - length of data to read
   * @param {?string} [encoding = null] -
   * @returns {string} -
   */


  readString(length, encoding = null) {
    const str = this._partialText.substring(0, length);

    this._moveIndex(str.length);
  }
  /**
   *
   * @access public
   * @param {number} length - 
   * @param {boolean} signed -
   * @returns {number} -
   */


  readInteger(length, signed) {
    const str = this._getString(_integerPattern);

    const val = parseInt(str[0], 10);
    return val;
  }
  /**
   *
   * @access public
   * @returns {number} -
   */


  readUnsignedByte() {
    return this.readInteger(1, false);
  }
  /**
   *
   * @access public
   * @returns {number} -
   */


  readUnsignedShort() {
    return this.readInteger(2, false);
  }
  /**
   *
   * @access public
   * @returns {number} -
   */


  readUnsignedInt() {
    return this.readInteger(4, false);
  }
  /**
   *
   * @access public
   * @returns {number} -
   */


  readInt() {
    return this.readInteger(4, true);
  }
  /**
   *
   * @access public
   * @returns {number} -
   */


  readFloat() {
    const str = this._getString(_floatPattern);

    const val = parseFloat(str[0]);
    return val;
  }
  /**
   *
   * @access public
   * @returns {number} -
   */


  readDouble() {
    return this.readFloat();
  }
  /**
   *
   * @access public
   * @param {number} length -
   * @returns {Buffer} -
   */


  readData(length) {
    const start = this._pos;
    this._pos += length;
    return this.buffer.slice(start, this._pos);
  }

  readWord() {
    const str = this._getString(_wordPattern);

    return str !== null ? str[0] : null;
  }

  readLine() {
    const str = this._getString(_linePattern);

    return str !== null ? str[0] : null;
  }

  readPattern(pattern) {
    return this._getString(pattern);
  }
  /**
   *
   * @access private
   * @returns {void}
   */


  _check() {}
  /**
   * 
   * @access private
   * @param {number[]} data - data to escape
   * @param {?string} [encoding = null] -
   * @returns {string} - escaped string
   */


  _escapeLE(data, encoding) {
    const length = data.length;
    let escapeString = '';

    for (let i = 0; i < length; i++) {
      const charCode = data.charCodeAt(i);

      if (charCode === 0) {
        break;
      } else if (charCode < 16) {
        escapeString += '%0' + charCode.toString(16);
      } else {
        escapeString += '%' + charCode.toString(16);
      }
    }

    return escapeString;
  }
  /**
   * 
   * @access private
   * @param {number[]} data - data to escape
   * @param {?string} [encoding = null] -
   * @returns {string} - escaped string
   */


  _escapeBE(data, encoding) {
    const length = data.length;
    let escapeString = '';

    for (let i = 0; i < length; i++) {
      const charCode1 = data.charCodeAt(i);

      if (charCode1 === 0) {
        break;
      }

      let str1 = '';

      if (charCode1 < 16) {
        str1 = '%0' + charCode1.toString(16);
      } else {
        str1 = '%' + charCode1.toString(16);
      }

      i++;
      const charCode2 = data.charCodeAt(i);

      if (charCode2 === 0) {
        break;
      }

      let str2 = '';

      if (charCode2 < 16) {
        str2 = '%0' + charCode2.toString(16);
      } else {
        str2 = '%' + charCode2.toString(16);
      }

      escapeString += str1 + str2;
    }

    return escapeString;
  }
  /**
   *
   * @access private
   * @param {number[]} data - data to convert
   * @param {?string} [encoding = null] -
   * @returns {string} -
   */


  _convert(data, encoding) {
    let escapeString = '';

    if (encoding === 'utf16be') {
      escapeString = this._escapeBE(data);
    } else {
      escapeString = this._escapeLE(data);
    }

    if (encoding === 'sjis') {
      return UnescapeSJIS(escapeString);
    } else if (encoding === 'euc-jp') {
      return UnescapeEUCJP(escapeString);
    } else if (encoding === 'jis-7') {
      return UnescapeJIS7(escapeString);
    } else if (encoding === 'jis-8') {
      return UnescapeJIS8(escapeString);
    } else if (encoding === 'unicode') {
      return UnescapeUnicode(escapeString);
    } else if (encoding === 'utf7') {
      return UnescapeUTF7(escapeString);
    } else if (encoding === 'utf-8') {
      return UnescapeUTF8(escapeString);
    } else if (encoding === 'utf-16') {
      return UnescapeUTF16LE(escapeString);
    } else if (encoding === 'utf16be') {
      return UnescapeUTF16LE(escapeString);
    }

    throw new Error(`unsupported encoding: ${encoding}`);
  }

  getAvailableDataLength() {
    return this.buffer.length - this._pos;
  }
  /**
   *
   * @access private
   * @param {number} len -
   * @returns {void}
   */


  _moveIndex(len) {
    this._partialText = this._partialText.substring(len);

    if (this._partialText.length < this._partialMinLength) {
      this._addPartialText();
    }
  }

  _skipSpace() {
    let i = 0;

    let code = this._partialText.charCodeAt(i); //  9: Horizontal Tab
    // 10: Line Feed
    // 11: Vertical Tab
    // 12: New Page
    // 13: Carriage Return
    // 32: Space


    while (code === 32 || 9 <= code && code <= 13) {
      i++;
      code = this._partialText.charCodeAt(i);

      if (i >= this._partialText.length) {
        this._addPartialText();
      }
    }

    if (i > 0) {
      this._moveIndex(i);
    }
  }

  _addPartialText() {
    if (this._partialOffset >= this.buffer.length) {
      return;
    }

    let newOffset = this._partialOffset + this._partialStep;

    if (newOffset > this.buffer.length) {
      newOffset = this.buffer.length;
    }

    if (Buffer.isEncoding(this.encoding)) {
      this._partialText += this.buffer.toString(this.encoding, this._partialOffset, newOffset);
    } else {
      const data = this.buffer.toString('binary', this._partialOffset, newOffset);
      this._partialText += this._convert(data, this.encoding);
    }

    this._partialOffset = newOffset;
  }

  _getString(pattern) {
    this._skipSpace();

    const str = this._partialText.match(pattern);

    if (str === null) {
      return null;
    }

    this._moveIndex(str[0].length);

    return str;
  }

}

/*global Buffer*/

class _SCNMtlLoader {
  constructor(data = null, url = null) {
    /**
     * @access private
     * @type {?string}
     */
    this._filePath = url;
    /**
     * @access private
     * @type {?_TextReader}
     */

    this._reader = null;

    if (data !== null) {
      this._reader = new TextReader(data, 'utf-8');
    }

    this._node = null;
    const funcs = {
      '#': this._Comment,
      'newmtl': this._Material,
      'Ka': this._Ambient,
      'Kd': this._Diffuse,
      'Ks': this._Specular,
      'Tf': this._TransmissionFilter,
      'illum': this._Illumination,
      'd': this._Dissolve,
      'Ns': this._Exponent,
      'sharpness': this._Sharpness,
      'Ni': this._Density,
      'map_Ka': this._AmbientTexture,
      'map_Kd': this._DiffuseTexture,
      'map_Ks': this._SpecularTexture,
      'map_Ns': this._ExponentTexture,
      'map_d': this._DissolveTexture,
      'map_aat': this._AntiAliasingTexture,
      'decal': this._Decal,
      'disp': this._Roughness,
      'bump': this._Bump,
      'refl': this._Reflection,
      'Ke': this._Emission,
      'map_Ke': this._EmissionTexture
    };
    this._funcs = {};
    Object.keys(funcs).forEach(key => {
      this._funcs[key] = funcs[key].bind(this);
    });
  }

  static unarchiveObjectWithData(data, path = null) {
    const unarchiver = new _SCNMtlLoader(data);
    unarchiver._filePath = path;
    return unarchiver._loadMtlFile();
  }

  static unarchiveObjectWithFile(path) {
    const promise = _SCNMtlLoader._getBufferOfFile(path).then(data => {
      return _SCNMtlLoader.unarchiveObjectWithData(data, path);
    });

    return promise;
  }

  static _getBufferOfFile(path) {
    const promise = new Promise((resolve, reject) => {
      const file = new File([], path);
      const reader = new FileReader();

      reader.onload = () => {
        const data = reader.result;
        resolve(data);
      };

      reader.onerror = () => {
        reject(reader.error);
      };

      reader.readAsText(file);
    });
    return promise;
  }
  /**
   * @access private
   * @param {string} line -
   * @returns {string[]) -
   */


  _getTokens(line) {
    return line.split(' ').filter(str => str !== '').map(str => str.trim());
  }
  /**
   * @access private
   * @param {string} path -
   * @returns {Promise} -
   */


  _loadTexture(path) {
    const promise = new Promise((resolve, reject) => {
      const fileName = this._filePath + path;
      console.log('obj texture path: ' + fileName);

      if (fileName.endsWith('tga')) {
        const tga = TGAImage.imageWithURL(fileName);
        tga.didLoad.then(() => {
          resolve(tga.image);
        });
      } else {
        const image = new Image(); // TODO: check option if it allows cross-domain.

        image.crossOrigin = 'anonymous';

        image.onload = () => {
          resolve(image);
        };

        image.onerror = () => {
          reject(new Error(`image ${fileName} load error`));
        };

        image.src = fileName;
      }
    });
    return promise;
  }

  _loadMtlFile() {
    console.warn('_loadMtlFile');
    this._materials = {};
    this._workingMaterial = null;
    this._promises = [];

    let line = this._reader.readLine();

    this._break = false;

    while (!this._break && line !== null) {
      const tokens = this._getTokens(line);

      if (tokens.lengt === 0) {
        line = this._reader.readLine();
        continue;
      }

      const func = this._funcs[tokens[0]];

      if (typeof func === 'undefined') {
        throw new Error('_SCNMtlLoader unknown type: ' + tokens[0]);
      }

      func(tokens);
      line = this._reader.readLine();
    }

    return this._materials;
  }
  /**
   * @access private
   * @param {string[]} tokens - 
   * @returns {void}
   */


  _Material(tokens) {
    tokens.shift();
    const materialName = tokens.join(' ');
    const material = new SCNMaterial();
    this._materials[materialName] = material;
    this._workingMaterial = material;
  }
  /**
   * @access private
   * @param {string[]} tokens - 
   * @returns {void}
   */


  _Comment(tokens) {
    return;
  }
  /**
   * @access private
   * @param {string[]} tokens - 
   * @returns {void}
   */


  _Comment(tokens) {
    return;
  }
  /**
   * @access private
   * @param {string[]} tokens - 
   * @returns {void}
   */


  _Ambient(tokens) {
    if (tokens[1] === 'spectral') ; else if (tokens[1] === 'xyz') ; else {
      const r = parseFloat(tokens[1]);
      const g = parseFloat(tokens[2]);
      const b = parseFloat(tokens[3]);
      const a = 1.0;
      this._workingMaterial.ambient.contents = new SKColor(r, g, b, a);
    }
  }
  /**
   * @access private
   * @param {string[]} tokens - 
   * @returns {void}
   */


  _Diffuse(tokens) {
    const r = parseFloat(tokens[1]);
    const g = parseFloat(tokens[2]);
    const b = parseFloat(tokens[3]);
    const a = 1.0;
    this._workingMaterial.diffuse.contents = new SKColor(r, g, b, a);
  }
  /**
   * @access private
   * @param {string[]} tokens - 
   * @returns {void}
   */


  _Specular(tokens) {
    const r = parseFloat(tokens[1]);
    const g = parseFloat(tokens[2]);
    const b = parseFloat(tokens[3]);
    const a = 1.0;
    this._workingMaterial.specular.contents = new SKColor(r, g, b, a);
  }
  /**
   * @access private
   * @param {string[]} tokens - 
   * @returns {void}
   */


  _TransmissionFilter(tokens) {}
  /**
   * @access private
   * @param {string[]} tokens - 
   * @returns {void}
   */


  _Illumination(tokens) {}
  /**
   * @access private
   * @param {string[]} tokens - 
   * @returns {void}
   */


  _Dissolve(tokens) {
    const d = parseFloat(tokens[1]);
    this._workingMaterial.multiply.contents = new SKColor(d, d, d, 1.0);
  }
  /**
   * @access private
   * @param {string[]} tokens - 
   * @returns {void}
   */


  _Exponent(tokens) {
    this._workingMaterial.shininess = parseFloat(tokens[1]);
  }
  /**
   * @access private
   * @param {string[]} tokens - 
   * @returns {void}
   */


  _Sharpness(tokens) {}
  /**
   * @access private
   * @param {string[]} tokens - 
   * @returns {void}
   */


  _Density(tokens) {} // opacity

  /**
   * @access private
   * @param {string[]} tokens - 
   * @returns {void}
   */


  _AmbientTexture(tokens) {}
  /**
   * @access private
   * @param {string[]} tokens - 
   * @returns {void}
   */


  _DiffuseTexture(tokens) {
    const material = this._workingMaterial;

    this._loadTexture(tokens[1]).then(image => {
      material.diffuse.contents = image;
    });
  }
  /**
   * @access private
   * @param {string[]} tokens - 
   * @returns {void}
   */


  _SpecularTexture(tokens) {}
  /**
   * @access private
   * @param {string[]} tokens - 
   * @returns {void}
   */


  _ExponentTexture(tokens) {}
  /**
   * @access private
   * @param {string[]} tokens - 
   * @returns {void}
   */


  _DissolveTexture(tokens) {}
  /**
   * @access private
   * @param {string[]} tokens - 
   * @returns {void}
   */


  _AntiAliasingTexture(tokens) {}
  /**
   * @access private
   * @param {string[]} tokens - 
   * @returns {void}
   */


  _Decal(tokens) {}
  /**
   * @access private
   * @param {string[]} tokens - 
   * @returns {void}
   */


  _Roughness(tokens) {}
  /**
   * @access private
   * @param {string[]} tokens - 
   * @returns {void}
   */


  _Bump(tokens) {}
  /**
   * @access private
   * @param {string[]} tokens - 
   * @returns {void}
   */


  _Reflection(tokens) {}
  /**
   * @access private
   * @param {string[]} tokens - 
   * @returns {void}
   */


  _Emission(tokens) {
    const r = parseFloat(tokens[1]);
    const g = parseFloat(tokens[2]);
    const b = parseFloat(tokens[3]);
    const a = 1.0;
    this._workingMaterial.emission.contents = new SKColor(r, g, b, a);
  }
  /**
   * @access private
   * @param {string[]} tokens - 
   * @returns {void}
   */


  _EmissionTexture(tokens) {}

}

/*global Buffer*/

const _Semantic = {
  boneIndices: 'kGeometrySourceSemanticBoneIndices',
  boneWeights: 'kGeometrySourceSemanticBoneWeights',
  color: 'kGeometrySourceSemanticColor',
  edgeCrease: 'kGeometrySourceSemanticEdgeCrease',
  normal: 'kGeometrySourceSemanticNormal',
  tangent: 'kGeometrySourceSemanticTangent',
  texcoord: 'kGeometrySourceSemanticTexcoord',
  vertex: 'kGeometrySourceSemanticVertex',
  vertexCrease: 'kGeometrySourceSemanticVertexCrease'
  /**
   * A container for vertex data forming part of the definition for a three-dimensional object, or geometry.
   * @access public
   * @extends {NSObject}
   * @see https://developer.apple.com/documentation/scenekit/scngeometrysource
   */

};
class SCNGeometrySource extends NSObject {
  static get _propTypes() {
    return {
      $constructor: (propNames, propValues) => {
        return new SCNGeometrySource(propValues.data, propValues.semantic, propValues.vectorCount, propValues.floatComponents, propValues.componentsPerVector, propValues.bytesPerComponent, propValues.dataOffset, propValues.dataStride);
      },
      data: ['NSMutableData', null],
      semantic: ['string', null],
      vectorCount: ['integer', null],
      floatComponents: ['boolean', null],
      componentsPerVector: ['integer', null],
      bytesPerComponent: ['integer', null],
      dataOffset: ['integer', null],
      dataStride: ['integer', null],
      mkSemantic: ['boolean', null] // ?

    };
  }
  /**
   * Creates a geometry source from the specified data and options.
   * @access public
   * @constructor
   * @param {number[]|Buffer} data - The data for the geometry source.
   * @param {SCNGeometrySource.Semantic} semantic - The semantic value (or attribute) that the geometry source describes for each vertex. See Geometry Semantic Identifiers for available values.
   * @param {number} vectorCount - The number of geometry source vectors.
   * @param {boolean} floatComponents - A Boolean value that indicates whether vector components are floating-point values. Specify true for floating-point values, or false for integer values.
   * @param {number} componentsPerVector - The number of scalar components in each vector.
   * @param {number} bytesPerComponent - The size, in bytes, of each vector component.
   * @param {number} offset - The offset, in bytes, from the beginning of the data to the first vector component to be used in the geometry source.
   * @param {number} stride - The number of bytes from each vector to the next in the data.
   * @desc A geometry source’s data is an array of vectors, each of which represents a particular attribute (or semantic) of a vertex in the geometry. The other parameters determine how SceneKit interprets this data. For example, an array of vertex positions may have three 32-bit floating-point components per vector, but an array of texture coordinates may have two 8-bit integer coponents per vector. You can use the offset and stride parameters together to interleave data for multiple geometry sources in the same array, improving rendering performance. See SCNGeometrySource for details.To create a custom SCNGeometry object from the geometry source, use the init(sources:elements:) method.
   * @see https://developer.apple.com/documentation/scenekit/scngeometrysource/1523320-init
   */


  constructor(data, semantic, vectorCount, floatComponents, componentsPerVector, bytesPerComponent, offset, stride) {
    super(); // Inspecting a Geometry Source

    this._data = data;
    this._semantic = semantic;
    this._vectorCount = vectorCount;
    this._usesFloatComponents = floatComponents;
    this._componentsPerVector = componentsPerVector;
    this._bytesPerComponent = bytesPerComponent;
    this._dataOffset = offset;
    this._dataStride = stride;

    if (data instanceof Buffer) {
      let loadFunc = null;

      if (floatComponents) {
        switch (bytesPerComponent) {
          case 4:
            loadFunc = _offset => {
              return data.readFloatLE(_offset);
            };

            break;

          case 8:
            loadFunc = _offset => {
              return data.readDoubleLE(_offset);
            };

            break;

          case 1:
            loadFunc = _offset => {
              return data.readIntLE(_offset, 1) / 255.0;
            };

            break;

          default:
            throw new Error(`unknown float data size: ${bytesPerComponent}`);
        }
      } else {
        loadFunc = _offset => {
          return data.readIntLE(_offset, bytesPerComponent);
        };
      }

      const _data = [];
      const count = data.length / bytesPerComponent;
      let _offset = 0;

      for (let i = 0; i < count; i++) {
        _data.push(loadFunc(_offset));

        _offset += bytesPerComponent;
      }

      this._data = _data;
    }
    /**
     * @type {TypedArray}
     * @access private
     */
    //this._glData = null
    //if(this._hasTypedArrayData()){
    //  this._glData = this._data
    //}else{
    //  if(floatComponents){
    //    if(bytesPerComponent === 4){
    //      this._glData = new Float32Array(this._data)
    //    }else if(bytesPerComponent === 8){
    //      this._glData = new Float64Array(this._data)
    //    }
    //  }else{
    //    if(bytesPerComponent === 1){
    //      this._glData = new Uint8Array(this._data)
    //    }else if(bytesPerComponent === 2){
    //      this._glData = new Uint16Array(this._data)
    //    }else if(bytesPerComponent === 4){
    //      this._glData = new Uint32Array(this._data)
    //    }
    //  }
    //}
    //if(this._glData === null){
    //  throw new Error(`unknown buffer data type: float: ${floatComponents}, size: ${bytesPerComponent}`)
    //}


    this._buffer = null;
  }

  _createBuffer(context) {
    const gl = context;
    this._buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this._buffer); // FIXME: dynamic data

    gl.bufferData(gl.ARRAY_BUFFER, this._glData, gl.STATIC_DRAW);
    return this._buffer;
  }
  /**
   * @access private
   * @returns {boolean} -
   */


  _hasTypedArrayData() {
    if (this._usesFloatComponents) {
      if (this._bytesPerComponent === 4) {
        return this._data instanceof Float32Array;
      } else if (this._bytesPerComponent === 8) {
        return this._data instanceof Float64Array;
      }
    } else {
      if (this._bytesPerComponent === 1) {
        return this._data instanceof Uint8Array;
      } else if (this._bytesPerComponent === 2) {
        return this._data instanceof Uint16Array;
      } else if (this._bytesPerComponent === 4) {
        return this._data instanceof Uint32Array;
      }
    }

    return false;
  } // Creating Geometry Sources

  /**
   * Creates a geometry source from the specified data and options.
   * @access public
   * @param {number[]} data - The data for the geometry source.
   * @param {SCNGeometrySource.Semantic} semantic - The semantic value (or attribute) that the geometry source describes for each vertex. See Geometry Semantic Identifiers for available values.
   * @param {number} vectorCount - The number of geometry source vectors.
   * @param {boolean} floatComponents - A Boolean value that indicates whether vector components are floating-point values. Specify true for floating-point values, or false for integer values.
   * @param {number} componentsPerVector - The number of scalar components in each vector.
   * @param {number} bytesPerComponent - The size, in bytes, of each vector component.
   * @param {number} dataOffset - The offset, in bytes, from the beginning of the data to the first vector component to be used in the geometry source.
   * @param {number} dataStride - The number of bytes from each vector to the next in the data.
   * @returns {SCNGeometrySource} -
   * @desc A geometry source’s data is an array of vectors, each of which represents a particular attribute (or semantic) of a vertex in the geometry. The other parameters determine how SceneKit interprets this data. For example, an array of vertex positions may have three 32-bit floating-point components per vector, but an array of texture coordinates may have two 8-bit integer coponents per vector. You can use the offset and stride parameters together to interleave data for multiple geometry sources in the same array, improving rendering performance. See SCNGeometrySource for details.To create a custom SCNGeometry object from the geometry source, use the init(sources:elements:) method.
   * @see https://developer.apple.com/documentation/scenekit/scngeometrysource/1523320-init
   */


  static geometrySourceWithDataSemanticVectorCountFloatComponentsComponentsPerVectorBytesPerComponentDataOffsetDataStride(data, semantic, vectorCount, floatComponents, componentsPerVector, bytesPerComponent, dataOffset, dataStride) {
    const instance = new SCNGeometrySource(data, semantic, vectorCount, floatComponents, componentsPerVector, bytesPerComponent, dataOffset, dataStride);
    return instance;
  }
  /**
   * Creates a geometry source from an array of vertex positions. 
   * @access public
   * @param {SCNVector3[]} vertices - An array of three-component vectors, each of which represents a vertex position for the geometry source.
   * @param {number} count - The number of vertices
   * @returns {SCNGeometrySource} -
   * @desc SceneKit converts this data to its own format to optimize rendering performance. To read the converted data, examine the properties of the created SCNGeometrySource object.To create a custom SCNGeometry object from the geometry source, use the init(sources:elements:) method.
   * @see https://developer.apple.com/documentation/scenekit/scngeometrysource/2034708-init
   */


  static geometrySourceWithVerticesCount(vertices, count) {
    const data = [];

    for (let i = 0; i < count; i++) {
      data.push(vertices[i].x, vertices[i].y, vertices[i].z);
    }

    const instance = new SCNGeometrySource(data, // data
    SCNGeometrySource.Semantic.vertex, // semantic
    count, // vectorCount
    true, // floatComponents
    3, // componentsPerVector
    4, // bytesPerComponent
    0, // offset
    12 // stride
    );
    return instance;
  }
  /**
   * Creates a geometry source from an array of texture coordinate points.
   * @access public
   * @param {CGPoint[]} texcoord - An array of points, each of which represents a texture coordinate pair for the geometry source.
   * @param {number} count - The number of texture coordinate points.
   * @returns {SCNGeometrySource} -
   * @desc SceneKit converts this data to its own format to optimize rendering performance. To read the converted data, examine the properties of the created SCNGeometrySource object.To create a custom SCNGeometry object from the geometry source, use the init(sources:elements:) method.
   * @see https://developer.apple.com/documentation/scenekit/scngeometrysource/1522718-init
   */


  static geometrySourceWithTextureCoordinatesCount(texcoord, count) {
    const data = [];

    for (let i = 0; i < count; i++) {
      data.push(texcoord[i].x, texcoord[i].y);
    }

    const instance = new SCNGeometrySource(data, // data
    SCNGeometrySource.Semantic.texcoord, // semantic
    count, // vectorCount
    true, // floatComponents
    2, // componentsPerVector
    4, // bytesPerComponent
    0, // offset
    8 // stride
    );
    return instance;
  }
  /**
   * Creates a geometry source from an array of normal vertices.
   * @access public
   * @param {SCNVector3[]} normals - An array of vectors, which represents a normal vector for the geometry source.
   * @param {number} count - The number of normals
   * @returns {SCNGeometrySource} -
   */


  static geometrySourceWithNormalsCount(normals, count) {
    const data = [];

    for (let i = 0; i < count; i++) {
      data.push(normals[i].x, normals[i].y, normals[i].z);
    }

    const instance = new SCNGeometrySource(data, // data
    SCNGeometrySource.Semantic.normal, // semantic
    count, // vectorCount
    true, // floatComponents
    3, // componentsPerVector
    4, // bytesPerComponent
    0, // offset
    12 // stride
    );
    return instance;
  } // Inspecting a Geometry Source

  /**
   * The data for the geometry source.
   * @type {Data}
   * @desc A geometry source’s data is an array of vectors, each of which represents a particular attribute (or semantic) of a vertex in the geometry. The other properties of the geometry source determine how SceneKit interprets this data. For example, an array of vertex positions may have three 32-bit floating-point components per vector, but an array of texture coordinates may have two 8-bit integer coponents per vector.
   * @see https://developer.apple.com/documentation/scenekit/scngeometrysource/1522881-data
   */


  get data() {
    return this._data.slice(0);
  }
  /**
   * The semantic value (or attribute) the geometry source describes for each vertex.
   * @type {SCNGeometrySource.Semantic}
   * @desc A semantic describes an attribute for each vertex, such as position, color, surface normal vector, or texture coordinates.See Geometry Semantic Identifiers for available values.
   * @see https://developer.apple.com/documentation/scenekit/scngeometrysource/1523071-semantic
   */


  get semantic() {
    return this._semantic;
  }
  /**
   * The number of vectors in the data.
   * @type {number}
   * @desc 
   * @see https://developer.apple.com/documentation/scenekit/scngeometrysource/1522648-vectorcount
   */


  get vectorCount() {
    return this._vectorCount;
  }
  /**
   * A Boolean value that indicates whether vector components are floating-point values.
   * @type {boolean}
   * @desc If true, SceneKit interprets the geometry source’s data as an array of vectors whose components are floating-point values. The type of floating-point value is determined by the SCNGeometrySource property: 4 bytes for float values or 8 bytes for double values. If false, SceneKit interprets the geometry source’s data as an array of vectors whose components are integer values. The type of integer value is determined by the SCNGeometrySource property; for example, 2 bytes for unsigned short values or 4 bytes for unsigned int values.
   * @see https://developer.apple.com/documentation/scenekit/scngeometrysource/1522920-usesfloatcomponents
   */


  get usesFloatComponents() {
    return this._usesFloatComponents;
  }
  /**
   * The number of scalar components in each vector.
   * @type {number}
   * @desc 
   * @see https://developer.apple.com/documentation/scenekit/scngeometrysource/1522832-componentspervector
   */


  get componentsPerVector() {
    return this._componentsPerVector;
  }
  /**
   * The size, in bytes, of each vector component.
   * @type {number}
   * @desc 
   * @see https://developer.apple.com/documentation/scenekit/scngeometrysource/1522633-bytespercomponent
   */


  get bytesPerComponent() {
    return this._bytesPerComponent;
  }
  /**
   * The offset, in bytes, from the beginning of the data to the first vector component to be used in the geometry source.
   * @type {number}
   * @desc You can use the SCNGeometrySource and SCNGeometrySource parameters can together to interleave data for multiple geometry sources in the same array, improving rendering performance. See SCNGeometrySource for details.
   * @see https://developer.apple.com/documentation/scenekit/scngeometrysource/1522834-dataoffset
   */


  get dataOffset() {
    return this._dataOffset;
  }
  /**
   * The number of bytes from a vector to the next one in the data.
   * @type {number}
   * @desc You can use the SCNGeometrySource and SCNGeometrySource parameters can together to interleave data for multiple geometry sources in the same array, improving rendering performance. See SCNGeometrySource for details.
   * @see https://developer.apple.com/documentation/scenekit/scngeometrysource/1524197-datastride
   */


  get dataStride() {
    return this._dataStride;
  } // Creating GPU-Mutable Geometry Sources

  /**
   * Creates a geometry source whose vertex data resides in the specified Metal buffer, allowing modification through a Metal compute shader.
   * @access public
   * @param {MTLBuffer} mtlBuffer - A Metal buffer containing per-vertex data for the geometry source.
   * @param {MTLVertexFormat} vertexFormat - The type of per-vertex data in the buffer. A MTLVertexFormat value defines the number of components for each vector in the geometry source and the data type and size of each component.
   * @param {SCNGeometrySource.Semantic} semantic - The semantic value (or attribute) that the geometry source describes for each vertex. See Geometry Semantic Identifiers for available values.
   * @param {number} vertexCount - The number of vertices in the geometry source.
   * @param {number} offset - The offset, in bytes, from the beginning of the data to the first vector component to be used in the geometry source.
   * @param {number} stride - The number of bytes from each vector to the next in the data.
   * @returns {SCNGeometrySource} -
   * @desc Use this method to create a geometry source whose underlying data can be modified at render time by a Metal compute shader running on the GPU. To create a MTLBuffer object for use with a geometry source, use the device property of the SceneKit view (or other renderer) responsible for drawing your scene.// Create and fill a buffer.
  id <MTLDevice> device = self.scnView.device;
  self.geometryBuffer = [device newBufferWithBytes:myData length:myLength options:myOptions];
  // Create a geometry source from the buffer.
  SCNGeometrySource *source = [SCNGeometrySource geometrySourceWithBuffer:buffer
                             vertexFormat:myVertexFormat
                                 semantic:SCNGeometrySourceSemanticVertex
                              vertexCount:myVertexCount
                               dataOffset:0
                               dataStride:0];
  Then, to modify the buffer’s contents at render time, implement a scene renderer delegate and schedule a compute command encoder during a render delegate method such as renderer(_:willRenderScene:atTime:).- (void)renderer:(id <SCNSceneRenderer>)aRenderer willRenderScene:(SCNScene *)scene atTime:(NSTimeInterval)time {
     // Get a command buffer and compute encoder from the view (or other renderer).
     id<MTLCommandBuffer> myCommandBuffer = [aRenderer.commandQueue commandBuffer];
     id<MTLComputeCommandEncoder> myComputeEncoder = [myCommandBuffer computeCommandEncoder];
       // Configure the compute command encoder.
     // (Note pipeline state is preconfigured outside of the render loop.)
     [myComputeEncoder setComputePipelineState:self.pipelineState];
     [myComputeEncoder setBuffer:self.geometryBuffer offset:0 atIndex:0];
       // Schedule the compute command and commit the command buffer.
     [myComputeEncoder dispatchThreadgroups:myThreadgroupCount
                      threadsPerThreadgroup:myThreadCount];
     [myComputeEncoder endEncoding];
     [myCommandBuffer commit];
  }
  NoteGeometry sources backed by a Metal buffer are available only with SceneKit views (or other renderers) whose renderingAPI property is metal. Metal commands that modify the buffer’s contents must be enqueued from within one of the render loop methods defined in the SCNSceneRendererDelegate protocol. The result of attempting to modify a buffer at any other time is undefined.// Create and fill a buffer.
  id <MTLDevice> device = self.scnView.device;
  self.geometryBuffer = [device newBufferWithBytes:myData length:myLength options:myOptions];
  // Create a geometry source from the buffer.
  SCNGeometrySource *source = [SCNGeometrySource geometrySourceWithBuffer:buffer
                             vertexFormat:myVertexFormat
                                 semantic:SCNGeometrySourceSemanticVertex
                              vertexCount:myVertexCount
                               dataOffset:0
                               dataStride:0];
  - (void)renderer:(id <SCNSceneRenderer>)aRenderer willRenderScene:(SCNScene *)scene atTime:(NSTimeInterval)time {
     // Get a command buffer and compute encoder from the view (or other renderer).
     id<MTLCommandBuffer> myCommandBuffer = [aRenderer.commandQueue commandBuffer];
     id<MTLComputeCommandEncoder> myComputeEncoder = [myCommandBuffer computeCommandEncoder];
       // Configure the compute command encoder.
     // (Note pipeline state is preconfigured outside of the render loop.)
     [myComputeEncoder setComputePipelineState:self.pipelineState];
     [myComputeEncoder setBuffer:self.geometryBuffer offset:0 atIndex:0];
       // Schedule the compute command and commit the command buffer.
     [myComputeEncoder dispatchThreadgroups:myThreadgroupCount
                      threadsPerThreadgroup:myThreadCount];
     [myComputeEncoder endEncoding];
     [myCommandBuffer commit];
  }
    * @see https://developer.apple.com/documentation/scenekit/scngeometrysource/1522873-init
   */


  static initBufferDataOffsetDataStride(mtlBuffer, vertexFormat, semantic, vertexCount, offset, stride) {} // Structures

  /**
   * @type {Object} Semantic
   * @property {string} boneIndices The semantic for bone index data, used for skeletal animation of skinned surfaces.
   * @property {string} boneWeights The semantic for bone weight data, used for skeletal animation of skinned surfaces.
   * @property {string} color The semantic for per-vertex color data.
   * @property {string} edgeCrease The semantic for edge crease data, used for subdividing surfaces.
   * @property {string} normal The semantic for surface normal data.
   * @property {string} tangent The semantic for surface tangent vector data.
   * @property {string} texcoord The semantic for texture coordinate data.
   * @property {string} vertex The semantic for vertex position data.
   * @property {string} vertexCrease The semantic for vertex crease data, used for subdividing surfaces.
   * @see https://developer.apple.com/documentation/scenekit/scngeometrysource.semantic
   */


  static get Semantic() {
    return _Semantic;
  }
  /**
   * @access private
   * @param {number} index -
   * @returns {number[]} -
   */


  _vectorAt(index) {
    if (index < 0 || index >= this.vectorCount) {
      throw new Error(`index out of range: ${index} (0 - ${this.vectorCount - 1})`);
    }

    const indexStride = this._dataStride / this._bytesPerComponent;
    const ind = index * indexStride + this._dataOffset / this._bytesPerComponent;
    const arr = [];

    for (let i = 0; i < this._componentsPerVector; i++) {
      arr.push(this._data[ind + i]);
    }

    return arr;
  }
  /**
   * @access private
   * @param {number} index -
   * @returns {SCNVector3|SCNVector4|number[]} -
   */


  _scnVectorAt(index) {
    const vec = this._vectorAt(index);

    if (vec.length === 2) {
      return new CGPoint(vec[0], vec[1]);
    } else if (vec.length === 3) {
      return new SCNVector3(vec[0], vec[1], vec[2]);
    } else if (vec.length === 4) {
      return new SCNVector4(vec[0], vec[1], vec[2], vec[3]);
    }

    return vec;
  }
  /**
   * @access public
   * @param {number[]|SCNVector3|SCNVector4} v -
   * @param {number} index -
   * @returns {void}
   */


  _setVectorAt(v, index) {
    if (index < 0 || index >= this.vectorCount) {
      throw new Error(`index out of range: ${index} (0 - ${this.vectorCount - 1})`);
    }

    let data = v;

    if (_InstanceOf(v, SCNVector3)) {
      data = [v.x, v.y, v.z];
    } else if (_InstanceOf(v, SCNVector4)) {
      data = [v.x, v.y, v.z, v.w];
    }

    if (data.length !== this._componentsPerVector) {
      throw new Error(`vector size inconsistent: ${data.length} != ${this._componentsPerVector}`);
    }

    const indexStride = this._dataStride / this._bytesPerComponent;
    const ind = index * indexStride + this._dataOffset / this._bytesPerComponent;

    for (let i = 0; i < this._componentsPerVector; i++) {
      this._data[ind + i] = data[i];
    }
  }
  /**
   * 
   * @access private
   * @param {SCNMatrix4} transform -
   * @returns {Object} -
   */


  _createBoundingBox(transform = null) {
    const t = transform ? transform : SCNMatrix4MakeTranslation(0, 0, 0);
    const min = new SCNVector3(Infinity, Infinity, Infinity);
    const max = new SCNVector3(-Infinity, -Infinity, -Infinity);

    if (this._componentsPerVector !== 3) {
      throw new Error('componentsPerVector !== 3');
    }

    const indexStride = this._dataStride / this._bytesPerComponent;
    let ind = this._dataOffset / this._bytesPerComponent;
    const len = this._vectorCount;

    for (let i = 0; i < len; i++) {
      const p = new SCNVector3(this._data[ind + 0], this._data[ind + 1], this._data[ind + 2]).transform(t); //const x = this._data[ind + 0]
      //const y = this._data[ind + 1]
      //const z = this._data[ind + 2]

      if (p.x < min.x) {
        min.x = p.x;
      }

      if (p.x > max.x) {
        max.x = p.x;
      }

      if (p.y < min.y) {
        min.y = p.y;
      }

      if (p.y > max.y) {
        max.y = p.y;
      }

      if (p.z < min.z) {
        min.z = p.z;
      }

      if (p.z > max.z) {
        max.z = p.z;
      }

      ind += indexStride;
    }

    return {
      min: min,
      max: max
    };
  }
  /**
   * 
   * @access public
   * @param {number} value -
   * @returns {void}
   */


  fill(value) {
    let index = this._dataOffset / this._bytesPerComponent;
    const stride = this._dataStride / this._bytesPerComponent;

    for (let i = 0; i < this._vectorCount; i++) {
      for (let j = 0; j < this._componentsPerVector; j++) {
        this._data[index + j] = value;
      }

      index += stride;
    }
  }

  copy() {
    const source = new SCNGeometrySource(this._data.slice(0), this._semantic, this._vectorCount, this._usesFloatComponents, this._componentsPerVector, this._bytesPerComponent, this._dataOffset, this._dataStride);
    return source;
  }

}

/**
 * A three-dimensional shape (also called a model or mesh) that can be displayed in a scene, with attached materials that define its appearance.
 * @access public
 * @extends {NSObject}
 * @implements {SCNAnimatable}
 * @implements {SCNBoundingVolume}
 * @implements {SCNShadable}
 * @see https://developer.apple.com/documentation/scenekit/scngeometry
 */

class SCNGeometry extends NSObject {
  static get _propTypes() {
    const addSources = (obj, sources, key, coder) => {
      //console.log(`addSources source.length: ${sources.length}, key: ${key}`)
      obj._geometrySources.push(...sources);
    };

    return {
      name: 'string',
      levelsOfDetail: 'NSArray',
      materials: 'NSArray',
      tessellator: 'SCNGeometryTessellator',
      subdivisionLevel: 'integer',
      // program
      // shaderModifiers
      elements: ['NSArray', '_geometryElements'],
      kGeometrySourceSemanticColor: ['NSArray', addSources],
      kGeometrySourceSemanticEdgeCrease: ['NSArray', addSources],
      kGeometrySourceSemanticNormal: ['NSArray', addSources],
      kGeometrySourceSemanticTangent: ['NSArray', addSources],
      kGeometrySourceSemanticTexcoord: ['NSArray', addSources],
      kGeometrySourceSemanticVertex: ['NSArray', (obj, sources) => {
        addSources(obj, sources);

        obj._updateBoundingBox();
      }],
      kGeometrySourceSemanticVertexCrease: ['NSArray', addSources],
      wantsAdaptiveSubdivision: 'boolean',
      adaptiveSubdivision: ['boolean', null],
      entityID: ['string', '_entityID'],
      subdivisionSettings: ['bytes', null],
      shadableHelper: ['SCNShadableHelper', '_shadableHelper']
    };
  } // Creating a Geometry Object

  /**
   * Creates a new geometry built from the specified geometry sources and elements.
   * @access public
   * @constructor
   * @param {SCNGeometrySource[]} sources - An array of SCNGeometrySource objects describing vertices in the geometry and their attributes.
   * @param {?SCNGeometryElement[]} elements - An array of SCNGeometryElement objects describing how to connect the geometry’s vertices.
   * @desc A geometry's visible content comes from the combination of geometry sources, which contain data describing its vertices, with geometry elements, which contain data describing how the vertices connect to form a surface. Each SCNGeometrySource object describes an attribute of all vertices in the geometry (vertex position, surface normal vector, color, or texture mapping coordinates) identified by the source's semantic property. To create a custom geometry you must provide at least one source, for the vertex semantic. Typically, you also provide sources for normals and texture coordinates for use in lighting and shading.Sources for the vertex, normal, and color semantics must be unique-if multiple objects in the sources array have the same semantic, SceneKit uses only the first. A geometry may have multiple sources for the texcoord semantic-the order of texture coordinate sources in the sources array determines the value to use for the mappingChannel property when attaching materials.Each SCNGeometryElement object describes how vertices from the geometry sources are combined into polygons to create the geometry's shape. Creating a custom geometry requires at least one element. If the elements array contains multiple objects, their order determines the arrangement of the geometry's materials-for details, see the discussion of the materials property.
   * @see https://developer.apple.com/documentation/scenekit/scngeometry/1522803-init
   */


  constructor(sources = [], elements = []) {
    super();

    if (!Array.isArray(sources)) {
      throw new Error('SCNGeometry(sources, elements): sources must be Array');
    }

    if (!Array.isArray(elements)) {
      throw new Error('SCNGeometry(sources, elements): elements must be Array');
    } // Managing Geometry Attributes

    /**
     * A name associated with the geometry object.
     * @type {?string}
     * @see https://developer.apple.com/documentation/scenekit/scngeometry/1522953-name
     */


    this.name = null;
    /**
     * An array of SCNLevelOfDetail objects for managing the geometry’s appearance when viewed from far away.
     * @type {?SCNLevelOfDetail[]}
     * @see https://developer.apple.com/documentation/scenekit/scngeometry/1523745-levelsofdetail
     */

    this.levelsOfDetail = null; // Managing a Geometry’s Materials

    /**
     * An array of SCNMaterial objects that determine the geometry’s appearance when rendered.
     * @type {SCNMaterial[]}
     * @see https://developer.apple.com/documentation/scenekit/scngeometry/1523472-materials
     */

    this.materials = []; // Managing Geometry Data

    this._geometryElements = elements;
    this._geometrySources = sources;
    this._vertexArrayObjects = null;
    this._materialBuffer = null; //this._textureFlagBuffer = null

    this._shadowVAO = null;
    this._hitTestVAO = null; // Working with Subdivision Surfaces

    /**
     * The number of subdivisions SceneKit uses to smooth the geometry’s surface at render time.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scngeometry/1524177-subdivisionlevel
     */

    this.subdivisionLevel = 0;
    /**
     * The geometry element identifying which edges of the geometry’s surface should remain sharp after subdivision.
     * @type {?SCNGeometryElement}
     * @see https://developer.apple.com/documentation/scenekit/scngeometry/1523246-edgecreaseselement
     */

    this.edgeCreasesElement = null;
    /**
     * The geometry source specifying the smoothness or sharpness of edges after surface subdivision.
     * @type {?SCNGeometrySource}
     * @see https://developer.apple.com/documentation/scenekit/scngeometry/1523479-edgecreasessource
     */

    this.edgeCreasesSource = null; /////////////////
    // SCNShadable //
    /////////////////
    // Assigning a Custom Shader Program

    /**
     * A program used when rendering the object.
     * @type {?SCNProgram}
     * @see https://developer.apple.com/documentation/scenekit/scnshadable/1523689-program
     */

    this.program = null; // Customizing SceneKit’s Shader Programs

    /**
     * A dictionary of GLSL source code snippets for customizing the shader programs provided by SceneKit.
     * @type {?Map<SCNShaderModifierEntryPoint, string>}
     * @see https://developer.apple.com/documentation/scenekit/scnshadable/1523348-shadermodifiers
     */

    this.shaderModifiers = null;
    /**
     * @access private
     * @type {Map<string, SCNBindingBlock>}
     */

    this._bindingHandler = {};
    /**
     * @access private
     * @type {Map<string, SCNBindingBlock>}
     */

    this._unbindingHandler = {};
    /**
     * @access private
     * @type {Object}
     */

    this._valuesForUndefinedKeys = {}; ///////////////////
    // SCNAnimatable //
    ///////////////////

    /**
     * @access private
     * @type {SCNOrderedDictionary}
     */

    this._animations = new SCNOrderedDictionary(); ///////////////////////
    // SCNBoundingVolume //
    ///////////////////////
    // Working with Bounding Volumes

    /**
     * The minimum and maximum corner points of the object’s bounding box.
     * @type {{min: SCNVector3, max: SCNVector3}}
     * @see https://developer.apple.com/documentation/scenekit/scnboundingvolume/2034705-boundingbox
     */

    this.boundingBox = null;
    /**
     * The center point and radius of the object’s bounding sphere.
     * @access private
     * @type {Object}
     * @parameter {SCNVector3} _boundingSphere.center
     * @parameter {number} _boundingSphere.radius
     */
    //this._boundingSphere = null

    /**
     * 
     * @type {SCNGeometryTessellator}
     * @see https://developer.apple.com/documentation/scenekit/scngeometry/2867472-tessellator
     */

    this.tessellator = null;
    /**
     *
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scngeometry/2888353-wantsadaptivesubdivision
     */

    this.wantsAdaptiveSubdivision = false; // TODO: check the default value

    this._vertexBuffer = null;
    this._indexBuffer = null;
    this._isPresentationInstance = false;
    this._presentation = null;
    /**
     * @access private
     * @type {?string}
     */

    this._entityID = null;
    /**
     * @access private
     * @type {?SCNShadableHelper}
     */

    this._shadableHelper = null;
    this._btVertices = null;
    this._btMesh = null;
    this._btShape = null;
    /**
     * @access private
     * @type {Promise}
     */

    this._loadedPromise = null;
  } // Managing a Geometry’s Materials

  /**
   * The first material attached to the geometry.
   * @type {?SCNMaterial}
   * @see https://developer.apple.com/documentation/scenekit/scngeometry/1523485-firstmaterial
   */


  get firstMaterial() {
    return this.materials[0];
  }

  set firstMaterial(newValue) {
    this.materials[0] = newValue;
  }
  /**
   * Returns the first material attached to the geometry with the specified name.
   * @access public
   * @param {string} name - The name of the material to be retrieved.
   * @returns {?SCNMaterial} - 
   * @desc You can use the name property of each SCNMaterial object to make managing your scene graph easier. Materials loaded from a scene file may have names assigned by an artist using a 3D authoring tool.If a geometry has multiple materials attached with the same name, this method returns the first according to the order of the materials array.
   * @see https://developer.apple.com/documentation/scenekit/scngeometry/1523789-material
   */


  materialNamed(name) {
    return null;
  }
  /**
   * Attaches a material to the geometry at the specified index.
   * @access public
   * @param {SCNMaterial} material - The material to attach.
   * @param {number} index - The location in the geometry’s materials array at which to add the new material.ImportantRaises an exception (rangeException) if index is greater than the number of elements in the materials array.
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scngeometry/1522876-insertmaterial
   */


  insertMaterialAt(material, index) {}
  /**
   * Removes a material attached to the geometry.
   * @access public
   * @param {number} index - The index of the attached material to be removed.ImportantRaises an exception (rangeException) if index is beyond the bounds of the materials array.
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scngeometry/1522646-removematerial
   */


  removeMaterialAt(index) {}
  /**
   * Replaces a material attached to the geometry with another.
   * @access public
   * @param {number} index - The index of the attached material to be replaced.ImportantRaises an exception (rangeException) if index is beyond the bounds of the materials array.
   * @param {SCNMaterial} material - The material with which to replace the attached material.
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scngeometry/1522714-replacematerial
   */


  replaceMaterialAtIndexWith(index, material) {} // Managing Geometry Data

  /**
   * Returns the geometry element at a specified index.
   * @access public
   * @param {number} elementIndex - The index of the geometry element.
   * @returns {SCNGeometryElement} - 
   * @desc Each SCNGeometryElement object describes how vertices from the geometry’s sources are combined into polygons to create the geometry’s shape. Visible geometries contain at least one element.
   * @see https://developer.apple.com/documentation/scenekit/scngeometry/1523266-geometryelement
   */


  geometryElementAtIndex(elementIndex) {
    return this._geometryElements[elementIndex];
  }
  /**
   * Returns the geometry sources for a specified semantic.
   * @access public
   * @param {SCNGeometrySource.Semantic} semantic - A constant identifying a semantic for which to return geometry sources. See Geometry Semantic Identifiers for possible values.
   * @returns {SCNGeometrySource[]} - 
   * @desc Each SCNGeometrySource object describes an attribute of all vertices in the geometry (such as vertex position, surface normal vector, color, or texture mapping coordinates) identified by the source’s semantic property. A geometry always has at least one source, for the vertex semantic, typically has additional sources for use in lighting and shading, and may have other sources for skeletal animation or surface subdivision information.The vertex, normal, and color semantics each refer to at most one source. A geometry may have multiple sources for the texcoord semantic—in this case, indices in the returned array correspond to values for the mappingChannel property used when attaching textures to materials.
   * @see https://developer.apple.com/documentation/scenekit/scngeometry/1522926-getgeometrysources
   */


  getGeometrySourcesForSemantic(semantic) {
    return this._geometrySources.filter(source => source.semantic === semantic);
  }
  /**
   * An array of geometry elements that describe the geometry’s shape.
   * @type {SCNGeometryElement[]}
   * @desc Each SCNGeometryElement object describes how vertices from the geometry’s sources are combined into polygons to create the geometry’s shape. Visible geometries contain at least one element.For geometries with multiple elements, you can use the materials property to attach different materials to each element.
   * @see https://developer.apple.com/documentation/scenekit/scngeometry/1523046-geometryelements
   */


  get geometryElements() {
    return this._geometryElements.slice(0);
  }
  /**
   * An array of geometry sources that provide vertex data for the geometry.
   * @type {SCNGeometrySource[]}
   * @desc Each SCNGeometrySource object describes an attribute of all vertices in the geometry (such as vertex position, surface normal vector, color, or texture mapping coordinates) identified by the source’s semantic property. A geometry always has at least one source (for the vertex semantic), typically has additional sources for use in lighting and shading, and may have other sources for skeletal animation or surface subdivision information.
   * @see https://developer.apple.com/documentation/scenekit/scngeometry/1523662-geometrysources
   */


  get geometrySources() {
    return this._geometrySources.slice(0);
  }

  get geometryGLSource() {
    return new Float32Array(this._geometrySources[0]);
  }
  /**
   * The number of geometry elements in the geometry.
   * @type {number}
   * @desc Each SCNGeometryElement object describes how vertices from the geometry’s sources are combined into polygons to create the geometry’s shape. Visible geometries contain at least one element.For geometries with multiple elements, you can use the materials property to attach different materials to each element.
   * @see https://developer.apple.com/documentation/scenekit/scngeometry/1523800-geometryelementcount
   */


  get geometryElementCount() {
    return this._geometryElements.length;
  } ///////////////////////
  // SCNBoundingVolume //
  ///////////////////////
  // Working with Bounding Volumes

  /**
   * The center point and radius of the object’s bounding sphere.
   * @type {Object}
   * @parameter {SCNVector3} _boundingSphere.center -
   * @parameter {number} _boundingSphere.radius -
   * @returns {Object} -
   * @desc Scene Kit defines a bounding sphere in the local coordinate space using a center point and a radius. For example, if a node’s bounding sphere has the center point {3, 1, 4} and radius 2.0, all points in the vertex data of node’s geometry (and any geometry attached to its child nodes) lie within 2.0 units of the center point.The coordinates provided when reading this property are valid only if the object has a volume to be measured. For a geometry containing no vertex data or a node containing no geometry (and whose child nodes, if any, contain no geometry), the values center and radius are both zero.
   * @see https://developer.apple.com/documentation/scenekit/scnboundingvolume/2034707-boundingsphere
   */


  getBoundingSphere() {
    if (this.boundingBox === null) {
      return {
        center: new SCNVector3(0, 0, 0),
        radius: 0
      };
    }

    const max = this.boundingBox.max;
    const min = this.boundingBox.min;
    const w = (max.x - min.x) * 0.5;
    const h = (max.y - min.y) * 0.5;
    const l = (max.z - min.z) * 0.5;
    const r = Math.sqrt(w * w + h * h + l * l);
    const c = new SCNVector3(min.x + w, min.y + h, min.z + l);
    return {
      center: c,
      radius: r
    };
  } /////////////////
  // SCNShadable //
  /////////////////
  // Handling Parameters in Custom OpenGL Shader Programs

  /**
   * Specifies a block to be called before rendering with programs with the specified GLSL uniform variable or attribute name.
   * @access public
   * @param {string} symbol - A GLSL uniform variable or attribute name.
   * @param {?SCNBindingBlock} [block = null] - A block to be called by SceneKit.
   * @returns {void}
   * @desc Use this method to associate a block with a SceneKit object (geometry or material) to handle setup of an attribute or uniform variable in a custom SCNProgram shader associated with that object. SceneKit calls your block before rendering the object. In the block, you can execute any OpenGL commands or other code necessary for preparing your custom shader. For example, the following block updates the time uniform variable in a custom fragment shader for producing animated effects:CFTimeInterval startTime = CFAbsoluteTimeGetCurrent();
  [myNode.geometry.firstMaterial handleBindingOfSymbol:@"time" usingBlock:
    ^(unsigned int programID, unsigned int location, SCNNode *renderedNode, SCNRenderer *renderer) {
        glUniform1f(location, CFAbsoluteTimeGetCurrent() - startTime);
    }];
  This method is for OpenGL shader programs only. To bind custom variable data for Metal shader programs, use the handleBinding(ofBufferNamed:frequency:handler:) method.CFTimeInterval startTime = CFAbsoluteTimeGetCurrent();
  [myNode.geometry.firstMaterial handleBindingOfSymbol:@"time" usingBlock:
    ^(unsigned int programID, unsigned int location, SCNNode *renderedNode, SCNRenderer *renderer) {
        glUniform1f(location, CFAbsoluteTimeGetCurrent() - startTime);
    }];
    * @see https://developer.apple.com/documentation/scenekit/scnshadable/1523063-handlebinding
   */


  handleBindingOfSymbolHandler(symbol, block = null) {
    this._bindingHandler[symbol] = block;
  }
  /**
   * Specifies a block to be called after rendering with programs with the specified GLSL uniform variable or attribute name.
   * @access public
   * @param {string} symbol - A GLSL uniform variable or attribute name.
   * @param {?SCNBindingBlock} [block = null] - A block to be called by SceneKit.
   * @returns {void}
   * @desc Use this method to associate a block with a SceneKit object (geometry or material) to handle cleanup related to an attribute or uniform variable in a custom SCNProgram shader associated with that object. SceneKit will call your block after rendering the object. In the block, you can execute any OpenGL commands or other code necessary for post-rendering tasks.This method is for OpenGL shader programs only. To bind custom variable data for Metal shader programs, use the handleBinding(ofBufferNamed:frequency:handler:) method.
   * @see https://developer.apple.com/documentation/scenekit/scnshadable/1522783-handleunbinding
   */


  handleUnbindingOfSymbolHandler(symbol, block = null) {
    this._unbindingHandler[symbol] = block;
  }
  /**
   * @access private
   * @param {SCNNode} node -
   * @param {WebGLProgram} glProgram -
   * @param {WebGLRenderingContext} gl -
   * @param {SCNRenderer} renderer -
   * @returns {void}
   */


  _callBindingHandlerForNodeProgramContextRenderer(node, glProgram, gl, renderer) {
    const bindingKeys = Object.keys(this._bindingHandler);

    for (const key of bindingKeys) {
      const handler = this._bindingHandler[key];
      const loc = gl.getUniformBlockIndex(glProgram, key);
      handler(glProgram, loc, node, renderer);
    }
  }
  /**
   * @access private
   * @param {SCNNode} node -
   * @param {WebGLProgram} glProgram -
   * @param {WebGLRenderingContext} gl -
   * @param {SCNRenderer} renderer -
   * @returns {void}
   */


  _callUnindingHandlerForNodeProgramContextRenderer(node, glProgram, gl, renderer) {
    const bindingKeys = Object.keys(this._unbindingHandler);

    for (const key of bindingKeys) {
      const handler = this._unbindingHandler[key];
      const loc = gl.getUniformBlockIndex(glProgram, key);
      handler(glProgram, loc, node, renderer);
    }
  } ///////////////////
  // SCNAnimatable //
  ///////////////////
  // Managing Animations

  /**
   * Required. Adds an animation object for the specified key.
   * @access public
   * @param {CAAnimation} animation - The animation object to be added.
   * @param {?string} key - An string identifying the animation for later retrieval. You may pass nil if you don’t need to reference the animation later.
   * @returns {void}
   * @desc Newly added animations begin executing after the current run loop cycle ends.SceneKit does not define any requirements for the contents of the key parameter—it need only be unique among the keys for other animations you add. If you add an animation with an existing key, this method overwrites the existing animation.
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523386-addanimation
   */


  addAnimationForKey(animation, key) {
    if (typeof key === 'undefined' || key === null) {
      key = Symbol();
    }

    const anim = animation.copy(); // FIXME: use current frame time

    anim._animationStartTime = Date.now() * 0.001;
    anim._prevTime = anim._animationStartTime - 0.0000001;

    this._animations.set(key, anim);
  }
  /**
   * Required. Returns the animation with the specified key.
   * @access public
   * @param {string} key - A string identifying a previously added animation.
   * @returns {?CAAnimation} - 
   * @desc Attempting to modify any properties of the returned object results in undefined behavior.
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1524020-animation
   */


  animationForKey(key) {
    return this._animations.get(key);
  }
  /**
   * Required. Removes all the animations currently attached to the object.
   * @access public
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1522762-removeallanimations
   */


  removeAllAnimations() {
    this._animations.clear();
  }
  /**
   * Required. Removes the animation attached to the object with the specified key.
   * @access public
   * @param {string} key - A string identifying an attached animation to remove.
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1522880-removeanimation
   */


  removeAnimationForKey(key) {
    this._animations.delete(key); // TODO: reset values

  }
  /**
   * Required. Removes the animation attached to the object with the specified key, smoothly transitioning out of the animation’s effect.
   * @access public
   * @param {string} key - A string identifying an attached animation to remove.
   * @param {number} duration - The duration for transitioning out of the animation’s effect before it is removed.
   * @returns {void}
   * @desc Use this method to create smooth transitions between the effects of multiple animations. For example, the geometry loaded from a scene file for a game character may have associated animations for player actions such as walking and jumping. When the player lands from a jump, you remove the jump animation so the character continues walking. If you use the removeAnimation(forKey:) method to remove the jump animation, SceneKit abruptly switches from the current frame of the jump animation to the current frame of the walk animation. If you use the removeAnimation(forKey:fadeOutDuration:) method instead, SceneKit plays both animations at once during that duration and interpolates vertex positions from one animation to the other, creating a smooth transition.
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1522841-removeanimation
   */


  removeAnimationForKeyFadeOutDuration(key, duration) {}
  /**
   * Required. An array containing the keys of all animations currently attached to the object.
   * @type {string[]}
   * @desc This array contains all keys for which animations are attached to the object, or is empty if there are no attached animations. The ordering of animation keys in the array is arbitrary.
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523610-animationkeys
   */


  get animationKeys() {
    const keys = [];

    for (const key of this._animations.keys()) {
      keys.push(key);
    }

    return keys;
  } // Pausing and Resuming Animations

  /**
   * Required. Pauses the animation attached to the object with the specified key.
   * @access public
   * @param {string} key - A string identifying an attached animation.
   * @returns {void}
   * @desc This method has no effect if no animation is attached to the object with the specified key.
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523592-pauseanimation
   */


  pauseAnimationForKey(key) {}
  /**
   * Required. Resumes a previously paused animation attached to the object with the specified key.
   * @access public
   * @param {string} key - A string identifying an attached animation.
   * @returns {void}
   * @desc This method has no effect if no animation is attached to the object with the specified key or if the specified animation is not currently paused.
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523332-resumeanimation
   */


  resumeAnimationForKey(key) {}
  /**
   * Required. Returns a Boolean value indicating whether the animation attached to the object with the specified key is paused.
   * @access public
   * @param {string} key - A string identifying an attached animation.
   * @returns {boolean} - 
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523703-isanimationpaused
   */


  isAnimationPausedForKey(key) {
    return false;
  } // Instance Methods

  /**
   * Required. 
   * @access public
   * @param {number} speed - 
   * @param {string} key - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1778343-setanimationspeed
   */


  setAnimationSpeedForKey(speed, key) {}
  /**
   * @access private
   * @param {WebGLContext} gl -
   * @param {SCNGeometry} geometry - 
   * @param {boolean} update -
   * @returns {WebGLBuffer} -
   */
  //_createVertexBuffer(gl, baseGeometry, update = false) {


  _createVertexBuffer(gl, node, update = false, _base = null) {
    const baseGeometry = _base === null ? node.geometry : _base;
    const baseSkinner = node.skinner;
    const skinner = node.presentation.skinner;

    if (this._vertexBuffer === null) {
      this._vertexBuffer = gl.createBuffer();
    } else if (!update) {
      return this._vertexBuffer;
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
    const arr = [];
    const vertexSource = baseGeometry.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.vertex)[0];
    const normalSource = baseGeometry.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.normal)[0];
    let tangentSource = baseGeometry.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.tangent)[0];
    const colorSource = baseGeometry.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.color)[0];
    const texcoordSource0 = baseGeometry.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.texcoord)[0];
    const texcoordSource1 = baseGeometry.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.texcoord)[1];
    const indexSource = baseSkinner ? baseSkinner._boneIndices : null;
    const weightSource = baseSkinner ? baseSkinner._boneWeights : null;
    const vectorCount = vertexSource.vectorCount;
    const pVertexSource = this.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.vertex)[0];
    const pNormalSource = this.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.normal)[0];
    let pTangentSource = this.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.tangent)[0];
    const pColorSource = this.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.color)[0];
    const pTexcoordSource0 = this.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.texcoord)[0];
    const pTexcoordSource1 = this.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.texcoord)[1]; //const pIndexSource = this.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.boneIndices)[0]

    const pIndexSource = skinner ? skinner._boneIndices : null; //const pWeightSource = this.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.boneWeights)[0]

    const pWeightSource = skinner ? skinner._boneWeights : null;

    if (typeof vertexSource === 'undefined') {
      throw new Error('vertexSource is undefined');
    }

    if (typeof normalSource !== 'undefined' && normalSource.vectorCount !== vectorCount) {
      throw new Error('normalSource.vectorCount !== vertexSource.vectorCount');
    }

    if (typeof tangentSource !== 'undefined' && tangentSource.vectorCount !== vectorCount) {
      throw new Error('tangentSource.vectorCount !== vertexSource.vectorCount');
    }

    if (typeof colorSource !== 'undefined' && colorSource.vectorCount !== vectorCount) {
      throw new Error('colorSource.vectorCount !== vertexSource.vectorCount');
    }

    if (typeof texcoordSource0 !== 'undefined' && texcoordSource0.vectorCount !== vectorCount) {
      throw new Error('texcoordSource0.vectorCount !== vertexSource.vectorCount');
    }

    if (typeof texcoordSource1 !== 'undefined' && texcoordSource1.vectorCount !== vectorCount) {
      throw new Error('texcoordSource1.vectorCount !== vertexSource.vectorCount');
    }

    if (typeof tangentSource === 'undefined' && this.materials.find(m => !_InstanceOf(m._normal._contents, SKColor))) {
      tangentSource = this._createTangentSource();
      pTangentSource = tangentSource;

      this._geometrySources.push(tangentSource);

      if (baseGeometry !== this) {
        baseGeometry._geometrySources.push(tangentSource);
      }
    } //const vertexArray = vertexSource ? vertexSource.data : null


    const vertexComponents = vertexSource ? vertexSource.componentsPerVector : 0; //const normalArray = normalSource ? normalSource.data : null

    const normalComponents = normalSource ? normalSource.componentsPerVector : 0;
    const tangentComponents = tangentSource ? tangentSource.componentsPerVector : 0;
    const colorComponents = colorSource ? colorSource.componentsPerVector : 0; //const texcoordArray = texcoordSource ? texcoordSource.data : null

    const texcoord0Components = texcoordSource0 ? texcoordSource0.componentsPerVector : 0;
    const texcoord1Components = texcoordSource1 ? texcoordSource1.componentsPerVector : 0;

    for (let i = 0; i < vectorCount; i++) {
      if (vertexSource) {
        arr.push(...vertexSource._vectorAt(i));
      }

      if (normalSource) {
        arr.push(...normalSource._vectorAt(i));
      }

      if (tangentSource) {
        arr.push(...tangentSource._vectorAt(i));
      }

      if (colorSource) {
        arr.push(...colorSource._vectorAt(i));
      }

      if (texcoordSource0) {
        arr.push(...texcoordSource0._vectorAt(i));
      }

      if (texcoordSource1) {
        arr.push(...texcoordSource1._vectorAt(i));
      }
    } //console.log(`vertex(0): ${vertexSource._vectorAt(0)}`)
    //console.log(`normal(0): ${normalSource._vectorAt(0)}`)
    //console.log(`texcoord(0): ${texcoordSource._vectorAt(0)}`)
    // update geometry sources
    // FIXME: Don't change geometry sources. Use other variables


    const bytesPerComponent = 4;
    let offset = 0;
    const stride = (vertexComponents + normalComponents + tangentComponents + colorComponents + texcoord0Components + texcoord1Components) * bytesPerComponent;
    pVertexSource._bytesPerComponent = bytesPerComponent;
    pVertexSource._dataOffset = offset;
    pVertexSource._dataStride = stride;
    offset += vertexComponents * bytesPerComponent;

    if (pNormalSource) {
      pNormalSource._bytesPerComponent = bytesPerComponent;
      pNormalSource._dataOffset = offset;
      pNormalSource._dataStride = stride;
      offset += normalComponents * bytesPerComponent;
    }

    if (pTangentSource) {
      pTangentSource._bytesPerComponent = bytesPerComponent;
      pTangentSource._dataOffset = offset;
      pTangentSource._dataStride = stride;
      offset += tangentComponents * bytesPerComponent;
    }

    if (pColorSource) {
      pColorSource._bytesPerComponent = bytesPerComponent;
      pColorSource._dataOffset = offset;
      pColorSource._dataStride = stride;
      offset += colorComponents * bytesPerComponent;
    }

    if (pTexcoordSource0) {
      pTexcoordSource0._bytesPerComponent = bytesPerComponent;
      pTexcoordSource0._dataOffset = offset;
      pTexcoordSource0._dataStride = stride;
      offset += texcoord0Components * bytesPerComponent;
    }

    if (pTexcoordSource1) {
      pTexcoordSource1._bytesPerComponent = bytesPerComponent;
      pTexcoordSource1._dataOffset = offset;
      pTexcoordSource1._dataStride = stride;
      offset += texcoord1Components * bytesPerComponent;
    } //console.log(`offset: ${offset}, vectorCount: ${vectorCount}`)


    offset *= vectorCount;
    const indexArray = indexSource ? indexSource.data : null;
    const indexComponents = indexSource ? indexSource.componentsPerVector : 0;
    const weightArray = weightSource ? weightSource.data : null;
    const weightComponents = weightSource ? weightSource.componentsPerVector : 0;
    const boneStride = (indexComponents + weightComponents) * bytesPerComponent;

    for (let i = 0; i < vectorCount; i++) {
      if (indexSource) {
        arr.push(...indexSource._vectorAt(i));
      }

      if (weightSource) {
        arr.push(...weightSource._vectorAt(i));
      }
    }

    if (pIndexSource) {
      pIndexSource._bytesPerComponent = bytesPerComponent;
      pIndexSource._dataOffset = offset;
      pIndexSource._dataStride = boneStride;
      offset += indexComponents * bytesPerComponent;
    }

    if (pWeightSource) {
      pWeightSource._bytesPerComponent = bytesPerComponent;
      pWeightSource._dataOffset = offset;
      pWeightSource._dataStride = boneStride;
      offset += weightComponents * bytesPerComponent;
    }

    const vertexData = new Float32Array(arr); //console.log(`vertexData length: ${arr.length}`)

    gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.DYNAMIC_DRAW); // set new data

    pVertexSource._data = arr;

    if (pNormalSource) {
      pNormalSource._data = arr;
    }

    if (pTangentSource) {
      pTangentSource._data = arr;
    }

    if (pColorSource) {
      pColorSource._data = arr;
    }

    if (pTexcoordSource0) {
      pTexcoordSource0._data = arr;
    }

    if (pTexcoordSource1) {
      pTexcoordSource1._data = arr;
    }

    if (pIndexSource) {
      pIndexSource._data = arr;
    }

    if (pWeightSource) {
      pWeightSource._data = arr;
    }

    return this._vertexBuffer;
  }
  /**
   * @access private
   * @param {WebGLContext} gl -
   * @param {boolean} update -
   * @returns {WebGLBuffer} -
   */


  _createIndexBuffer(gl, update = false) {
    if (this._indexBuffer && !update) {
      return this._indexBuffer;
    }

    this._indexBuffer = this._geometryElements[0]._createBuffer(gl);
    return this._indexBuffer;
  }
  /**
   * @access private
   * @param {WebGLRenderingContext} gl -
   * @param {SCNGeometry} baseGeometry - 
   * @returns {void}
   */


  _updateVertexBuffer(gl, baseGeometry) {
    const pVertexSource = this.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.vertex)[0];
    const vertexData = new Float32Array(pVertexSource._data);
    gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.DYNAMIC_DRAW);
  }
  /**
   * @access private
   * @param {WebGLRenderingContext} gl -
   * @param {WebGLProgram} program -
   * @param {number} index - material index
   * @param {number} opacity -
   * @returns {void}
   */


  _bufferMaterialData(gl, program, index, opacity) {
    // TODO: move this function to SCNProgram
    const materialCount = this.materials.length;
    let material = this.materials[index % materialCount];

    if (!material) {
      // FIXME: What should I do if there's no material? 
      material = new SCNMaterial();
    }

    if (material.lightingModel === SCNMaterial.LightingModel.constant) {
      this._bindMaterialDataForConstantLighting(material, gl, program, opacity);

      return;
    }

    let diffuse = material.diffuse.float32Array();
    diffuse[3] *= opacity;
    let ambient = null;

    if (material.locksAmbientWithDiffuse) {
      ambient = diffuse;
    } else {
      ambient = material.ambient.float32Array();
      ambient[3] *= opacity;
    }

    const materialData = new Float32Array([...ambient, ...diffuse, ...material.specular.float32Array(), ...material.normal.float32Array(), ...material.reflective.float32Array(), ...material.emission.float32Array(), ...material.transparent.float32Array(), ...material.multiply.float32Array(), ...material.ambientOcclusion.float32Array(), ...material.selfIllumination.float32Array(), ...material.metalness.float32Array(), ...material.roughness.float32Array(), material.shininess * 100.0, material.fresnelExponent, 0, 0 // needs padding for 16-byte alignment
    ]);
    gl.bindBuffer(gl.UNIFORM_BUFFER, this._materialBuffer);
    gl.bufferData(gl.UNIFORM_BUFFER, materialData, gl.DYNAMIC_DRAW);
    gl.bindBuffer(gl.UNIFORM_BUFFER, null);
    const textureFlags = []; // emission

    let selfIllumination = 0;

    if (material._selfIllumination._contents instanceof Image || material._selfIllumination._contents instanceof WebGLTexture) {
      this._setTextureToName(gl, material._selfIllumination, 'TEXTURE0', textureFlags);

      selfIllumination = 1;
    } else if (material._emission._contents instanceof Image || material._emission._contents instanceof WebGLTexture) {
      this._setTextureToName(gl, material._emission, 'TEXTURE0', textureFlags);
    } else {
      textureFlags.push(0);
    }

    gl.uniform1i(gl.getUniformLocation(program, 'selfIllumination'), selfIllumination); // ambient

    this._setTextureToName(gl, material._ambient, 'TEXTURE1', textureFlags); // diffuse


    this._setTextureToName(gl, material._diffuse, 'TEXTURE2', textureFlags); // specular


    this._setTextureToName(gl, material._specular, 'TEXTURE3', textureFlags); // reflective


    this._setCubeTextureToName(gl, material._reflective, 'TEXTURE4', textureFlags); // transparent


    this._setTextureToName(gl, material._transparent, 'TEXTURE5', textureFlags); // multiply


    this._setTextureToName(gl, material._multiply, 'TEXTURE6', textureFlags); // normal


    this._setTextureToName(gl, material._normal, 'TEXTURE7', textureFlags); // ambientOcclusion


    this._setTextureToName(gl, material._ambientOcclusion, 'TEXTURE8', textureFlags); // selfIllumination


    this._setTextureToName(gl, material._selfIllumination, 'TEXTURE9', textureFlags); // metalness


    this._setTextureToName(gl, material._metalness, 'TEXTURE10', textureFlags); // roughness


    this._setTextureToName(gl, material._roughness, 'TEXTURE11', textureFlags); // TODO: cache uniform location


    gl.uniform1iv(gl.getUniformLocation(program, 'textureFlags'), new Int32Array(textureFlags));

    if (material.isDoubleSided) {
      gl.disable(gl.CULL_FACE);
    } else {
      gl.enable(gl.CULL_FACE);

      if (material.cullMode === SCNCullMode.back) {
        gl.cullFace(gl.BACK);
      } else {
        gl.cullFace(gl.FRONT);
      }
    }

    const blendFuncSrc = [gl.SRC_ALPHA, // alpha
    gl.ONE, // add
    gl.ZERO, // subtract
    gl.ZERO, // multiply
    gl.SRC_ALPHA, // screen
    gl.ONE // replace
    ];
    const blendFuncDst = [gl.ONE_MINUS_SRC_ALPHA, // alpha
    gl.ONE, // add
    gl.ONE_MINUS_SRC_COLOR, // subtract
    gl.SRC_COLOR, // multiply
    gl.ONE, // screen
    gl.ZERO // replace
    ];
    gl.blendFunc(blendFuncSrc[material.blendMode], blendFuncDst[material.blendMode]);
  }
  /**
   * @access private
   * @param {SCNMaterial} material -
   * @param {WebGLRenderingContext} gl -
   * @param {WebGLProgram} program -
   * @param {number} opacity -
   */


  _bindMaterialDataForConstantLighting(material, gl, program, opacity) {
    const ambient = material.ambient.float32Array();
    ambient[3] *= opacity;
    const materialData = new Float32Array([...ambient, 0, 0, 0, 1, // diffuse
    0, 0, 0, 1, // specular
    0, 0, 0, 1, // normal
    0, 0, 0, 1, // reflective
    0, 0, 0, 1, // emission
    0, 0, 0, 1, // transparent
    1, 1, 1, 1, // multiply
    0, 0, 0, 1, // ambientOcclusion
    0, 0, 0, 1, // selfIllumination
    0, 0, 0, 1, // metalness
    0, 0, 0, 1, // roughness
    0, // shininess
    0, // fresnelExponent
    0, 0 // needs padding for 16-byte alignment
    ]);
    gl.bindBuffer(gl.UNIFORM_BUFFER, this._materialBuffer);
    gl.bufferData(gl.UNIFORM_BUFFER, materialData, gl.DYNAMIC_DRAW);
    gl.bindBuffer(gl.UNIFORM_BUFFER, null);
    const textureFlags = []; // emission

    textureFlags.push(0);
    gl.uniform1i(gl.getUniformLocation(program, 'selfIllumination'), 0); // ambient

    this._setTextureToName(gl, material._ambient, 'TEXTURE1', textureFlags);

    textureFlags.push(0); // diffuse

    textureFlags.push(0); // specular

    textureFlags.push(0); // reflective

    textureFlags.push(0); // transparent

    textureFlags.push(0); // multiply

    textureFlags.push(0); // normal

    textureFlags.push(0); // ambientOcclusion

    textureFlags.push(0); // selfIllumination

    textureFlags.push(0); // metalness

    textureFlags.push(0); // roughness
    // TODO: cache uniform location

    gl.uniform1iv(gl.getUniformLocation(program, 'textureFlags'), new Int32Array(textureFlags));

    if (material.isDoubleSided) {
      gl.disable(gl.CULL_FACE);
    } else {
      gl.enable(gl.CULL_FACE);

      if (material.cullMode === SCNCullMode.back) {
        gl.cullFace(gl.BACK);
      } else {
        gl.cullFace(gl.FRONT);
      }
    }

    const blendFuncSrc = [gl.SRC_ALPHA, // alpha
    gl.ONE, // add
    gl.ZERO, // subtract
    gl.ZERO, // multiply
    gl.SRC_ALPHA, // screen
    gl.ONE // replace
    ];
    const blendFuncDst = [gl.ONE_MINUS_SRC_ALPHA, // alpha
    gl.ONE, // add
    gl.ONE_MINUS_SRC_COLOR, // subtract
    gl.SRC_COLOR, // multiply
    gl.ONE, // screen
    gl.ZERO // replace
    ];
    gl.blendFunc(blendFuncSrc[material.blendMode], blendFuncDst[material.blendMode]);
  }
  /**
   * @access private
   * @param {WebGLRenderingContext} gl -
   * @param {SCNMaterialProperty} m -
   * @param {string} name -
   * @param {boolean[]} textureFlags -
   * @returns {void}
   */


  _setCubeTextureToName(gl, m, name, textureFlags) {
    if (m._contents instanceof Image) {
      m._contents = this._createCubeTexture(gl, m._contents);
    }

    if (m._contents instanceof WebGLTexture) {
      textureFlags.push(1);
      gl.activeTexture(gl[name]);
      gl.bindTexture(gl.TEXTURE_CUBE_MAP, m._contents);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, m._magnificationFilterFor(gl));
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, m._minificationFilterFor(gl));
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, m._wrapSFor(gl));
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, m._wrapTFor(gl));
    } else {
      textureFlags.push(0);
    }
  }
  /**
   * @access private
   * @param {WebGLRenderingContext} gl -
   * @param {SCNMaterialProperty} m -
   * @param {string} name -
   * @param {boolean[]} textureFlags -
   * @returns {void}
   */


  _setTextureToName(gl, m, name, textureFlags) {
    if (m._contents instanceof Image) {
      m._contents = this._createTexture(gl, m._contents);
    }

    if (m._contents instanceof WebGLTexture) {
      textureFlags.push(1);
      gl.activeTexture(gl[name]);
      gl.bindTexture(gl.TEXTURE_2D, m._contents);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, m._magnificationFilterFor(gl));
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, m._minificationFilterFor(gl));
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, m._wrapSFor(gl));
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, m._wrapTFor(gl));
    } else {
      textureFlags.push(0);
    }
  }

  _createTangentSource() {
    const elements = this._geometryElements;
    const vertex = this.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.vertex)[0];
    const texcoord = this.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.texcoord)[0];
    const data = [];
    const semantic = SCNGeometrySource.Semantic.tangent;
    const vectorCount = vertex.vectorCount;
    const floatComponents = true;
    const componentsPerVector = 3;
    const bytesPerComponent = 4;
    const dataOffset = 0;
    const dataStride = 12;
    const tangent = [];

    for (let i = 0; i < vectorCount; i++) {
      tangent.push(new SCNVector3(0, 0, 0));
    }

    for (const element of elements) {
      const len = element.primitiveCount;

      for (let i = 0; i < len; i++) {
        const index = element._indexAt(i);

        const pos0 = vertex._scnVectorAt(index[0]);

        const pos1 = vertex._scnVectorAt(index[1]);

        const pos2 = vertex._scnVectorAt(index[2]);

        const tex0 = texcoord._scnVectorAt(index[0]);

        const tex1 = texcoord._scnVectorAt(index[1]);

        const tex2 = texcoord._scnVectorAt(index[2]);

        const p1 = pos1.sub(pos0);
        const p2 = pos2.sub(pos0);
        const t1 = tex1.sub(tex0);
        const t2 = tex2.sub(tex0);
        const t = p1.mul(t2.y).sub(p2.mul(t1.y));
        tangent[index[0]] = tangent[index[0]].add(t);
        tangent[index[1]] = tangent[index[1]].add(t);
        tangent[index[2]] = tangent[index[2]].add(t);
      }
    }

    for (let i = 0; i < vectorCount; i++) {
      data.push(...tangent[i].normalize().floatArray());
    }

    return new SCNGeometrySource(data, semantic, vectorCount, floatComponents, componentsPerVector, bytesPerComponent, dataOffset, dataStride);
  }

  copy() {
    const geometry = new SCNGeometry();
    geometry.name = this.name;
    geometry.levelsOfDetail = this.levelsOfDetail;
    geometry.materials = this.materials;
    geometry._geometryElements = this._geometryElements.slice(0);
    geometry._geometrySources = this._geometrySources.slice(0);
    geometry._vertexArrayObjects = this._vertexArrayObjects ? this._vertexArrayObjects.slice(0) : null;
    geometry.subdivisonLevel = this.subdivisionLevel;
    geometry.edgeCreasesElement = this.edgeCreasesElement;
    geometry.edgeCreasesSource = this.edgeCreasesSource;
    geometry.program = this.program;
    geometry.shaderModifiers = this.shaderModifiers; //geometry._animationKeys = this._animationKeys

    geometry.boundingBox = this.boundingBox; //geometry._boundingSphere = this._boundingSphere

    geometry._vertexBuffer = this._vertexBuffer;
    geometry._indexBuffer = this._indexBuffer;
    geometry._animations = this._animations.copy();
    geometry._shadableHelper = this._shadableHelper;
    return geometry;
  }
  /**
   * @access private
   * @param {WebGLRenderingContext} gl -
   * @param {Image} image -
   * @returns {WebGLTexture} -
   */


  _createCubeTexture(gl, image) {
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture); // texImage2D(target, level, internalformat, width, height, border, format, type, source)
    // Safari complains that 'source' is not ArrayBufferView type, but WebGL2 should accept HTMLCanvasElement.

    const targets = [gl.TEXTURE_CUBE_MAP_POSITIVE_Z, gl.TEXTURE_CUBE_MAP_POSITIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, gl.TEXTURE_CUBE_MAP_NEGATIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, gl.TEXTURE_CUBE_MAP_POSITIVE_Y]; //const tx = [0, 1.0/6.0, 2.0/6.0, 3.0/6.0, 4.0/6.0, 5.0/6.0, 1]
    //const itx = [4, 1, 5, 0, 2, 3]

    const margin = 0.001;
    const sx = [4.0 / 6.0 + margin, 1.0 / 6.0 + margin, 5.0 / 6.0 + margin, 0 + margin, 2.0 / 6.0 + margin, 3.0 / 6.0 + margin];
    const imageWidth = image.naturalWidth;
    const imageHeight = image.naturalHeight;
    const srcWidth = imageHeight - margin * 2;

    for (let i = 0; i < 6; i++) {
      const canvas = document.createElement('canvas');
      canvas.width = imageHeight;
      canvas.height = imageHeight;
      canvas.getContext('2d').drawImage(image, sx[i], 0, srcWidth, imageHeight, 0, 0, imageHeight, imageHeight);
      gl.texImage2D(targets[i], 0, gl.RGBA, imageHeight, imageHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
    }

    gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
    return texture;
  }
  /**
   * @access private
   * @param {WebGLRenderingContext} gl -
   * @param {Image} image -
   * @returns {WebGLTexture} -
   */


  _createTexture(gl, image) {
    const texture = gl.createTexture();
    const canvas = document.createElement('canvas');
    canvas.width = image.naturalWidth;
    canvas.height = image.naturalHeight; //console.warn(`image size: ${image.naturalWidth} ${image.naturalHeight}`)

    canvas.getContext('2d').drawImage(image, 0, 0);
    gl.bindTexture(gl.TEXTURE_2D, texture); // texImage2D(target, level, internalformat, width, height, border, format, type, source)
    // Safari complains that 'source' is not ArrayBufferView type, but WebGL2 should accept HTMLCanvasElement.

    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, image.width, image.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
    gl.generateMipmap(gl.TEXTURE_2D); //gl.bindTexture(gl.TEXTURE_2D, null)

    return texture;
  }
  /**
   * @access private
   * @returns {Ammo.btCollisionShape} -
   * @desc call Ammo.destroy(shape) after using it.
   */


  _createBtCollisionShape() {
    return this._createBtConvexTriangleMeshShape();
  }

  _createBtConvexTriangleMeshShape() {//this._destoryShape()
    //this._btVertices = []
    //const vertexSource = this.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.vertex)[0]
    //const vertexCount = vertexSource.vectorCount
    //for(let i=0; i<vertexCount; i++){
    //  this._btVertices.push(vertexSource._scnVectorAt(i)._createBtVector3())
    //}
    //this._btMesh = new Ammo.btTriangleMesh(false, false) // 16bit indices, 3 component vertices
    //for(const element of this._geometryElements){
    //  const indexCount = element._primitiveCount
    //  for(let i=0; i<indexCount; i++){
    //    // TODO: check primitiveType
    //    const indices = element._indexAt(i)
    //    this._btMesh.addTriangle(
    //      this._btVertices[indices[0]],
    //      this._btVertices[indices[1]],
    //      this._btVertices[indices[2]],
    //      true
    //    )
    //  }
    //}
    //const calcAabb = true
    //this._btShape = new Ammo.btTriangleMeshShape(this._btMesh, calcAabb)
    //return this._btShape
  }

  _destroyShape() {//if(this._btShape === null){
    //  return
    //}
    //Ammo.destroy(this._btShape)
    //this._btShape = null
    //Ammo.destroy(this._btMesh)
    //this._btMesh = null
    //for(const v of this._btVertices){
    //  Ammo.destroy(v)
    //}
    //this._btVerices = null
  }

  _execDestory() {
    // TODO: delete indexBuffer, vertexBuffer
    this._destroyShape();
  }

  _updateBoundingBox() {
    return this._updateBoundingBoxForSkinner();
  }

  _updateBoundingBoxForSkinner(skinner = null) {
    let transform = null;

    if (skinner) {
      transform = skinner.baseGeometryBindTransform;
    }

    const sources = this.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.vertex);
    const min = new SCNVector3(Infinity, Infinity, Infinity);
    const max = new SCNVector3(-Infinity, -Infinity, -Infinity);

    for (const src of sources) {
      const result = src._createBoundingBox(transform);

      if (result.min.x < min.x) {
        min.x = result.min.x;
      }

      if (result.max.x > max.x) {
        max.x = result.max.x;
      }

      if (result.min.y < min.y) {
        min.y = result.min.y;
      }

      if (result.max.y > max.y) {
        max.y = result.max.y;
      }

      if (result.min.z < min.z) {
        min.z = result.min.z;
      }

      if (result.max.z > max.z) {
        max.z = result.max.z;
      }
    }

    this.boundingBox = {
      min: min,
      max: max
    };
    return this.boundingBox;
  }
  /**
   * @access private
   * @param {SCNGeometry} geometry -
   * @returns {boolean} -
   */


  _intersectsBoundingBox(geometry) {
    const b1 = this.boundingBox;
    const b2 = geometry.boundingBox;

    if (b1.min.x > b2.max.x || b1.max.x < b2.min.x) {
      return false;
    }

    if (b1.min.y > b2.max.y || b1.max.y < b2.min.y) {
      return false;
    }

    if (b1.min.z > b2.max.z || b1.max.z < b2.min.z) {
      return false;
    }

    return true;
  }
  /**
   * @access private
   * @returns {Promise} -
   */


  _getLoadedPromise() {
    if (this._loadedPromise) {
      return this._loadedPromise;
    }

    const promises = [];

    for (const m of this.materials) {
      promises.push(m.didLoad);
    } //this._loadedPromise = Promise.all(promises)
    //return this._loadedPromise


    return Promise.all(promises);
  }
  /**
   * @access public
   * @type {Promise} -
   */


  get didLoad() {
    return this._getLoadedPromise();
  }
  /**
   * Invoked by setValue(_:forKey:) when it finds no property for a given key.
   * @access public
   * @param {?Object} value - The value for the key identified by key.
   * @param {string} key - A string that is not equal to the name of any of the receiver's properties.
   * @returns {void}
   * @desc Subclasses can override this method to handle the request in some other way. The default implementation raises an NSUndefinedKeyException.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1413490-setvalue
   */


  setValueForUndefinedKey(value, key) {
    this._valuesForUndefinedKeys[key] = value;
  }
  /**
   * Invoked by value(forKey:) when it finds no property corresponding to a given key.
   * @access public
   * @param {string} key - A string that is not equal to the name of any of the receiver's properties.
   * @returns {?Object} - 
   * @desc Subclasses can override this method to return an alternate value for undefined keys. The default implementation raises an NSUndefinedKeyException.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1413457-value
   */


  valueForUndefinedKey(key) {
    if (typeof this._valuesForUndefinedKeys[key] !== 'undefined') {
      return this._valuesForUndefinedKeys[key];
    }

    return super.valueForUndefinedKey(key);
  }

}

/**
 * The drawing primitive that connects vertices when rendering a geometry element, used by the primitiveType property to specify how SceneKit interprets the geometry element’s data.
 * @typedef {Object} SCNGeometryPrimitiveType
 * @property {number} triangles - The geometry element’s data is a sequence of triangles, with each triangle described by three new vertices.
 * @property {number} triangleStrip - The geometry element’s data is a sequence of triangles, with each triangle described by one new vertex and two vertices from the previous triangle. 
 * @property {number} line - The geometry element’s data is a sequence of line segments, with each line segment described by two new vertices. 
 * @property {number} point - The geometry element’s data is a sequence of unconnected points.
 * @property {number} polygon - 
 * @see https://developer.apple.com/documentation/scenekit/scngeometryprimitivetype
 */

const SCNGeometryPrimitiveType = {
  triangles: 0,
  triangleStrip: 1,
  line: 2,
  point: 3,
  polygon: 4
};

/*global Buffer*/

/**
 * A container for index data describing how vertices connect to define a three-dimensional object, or geometry.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/scenekit/scngeometryelement
 */

class SCNGeometryElement extends NSObject {
  static get _propTypes() {
    return {
      $constructor: (propNames, propValues) => {
        const element = new SCNGeometryElement(propValues.elementData, propValues.primitiveType, propValues.primitiveCount, propValues.bytesPerIndex);

        if (typeof propValues.maximumPointScreenSpaceRadius !== 'undefined') {
          element.maximumPointScreenSpaceRadius = propValues.maximumPointScreenSpaceRadius;
        }

        if (typeof propValues.minimumPointScreenSpaceRadius !== 'undefined') {
          element.minimumPointScreenSpaceRadius = propValues.minimumPointScreenSpaceRadius;
        }

        if (typeof propValues.ptSize !== 'undefined') {
          element.pointSize = propValues.ptSize;
        }

        return element;
      },
      primitiveType: ['integer', null],
      primitiveCount: ['integer', null],
      elementData: ['NSMutableData', null],
      bytesPerIndex: ['integer', null],
      primitiveRangeLocation: ['integer', null],
      primitiveRangeLength: ['integer', null],
      ptSize: ['float', null],
      indicesChannelCount: ['integer', null],
      interleavedIndicesChannels: ['integer', null],
      minimumPointScreenSpaceRadius: ['float', null],
      maximumPointScreenSpaceRadius: ['float', null]
    };
  } // Creating a Geometry Element

  /**
   * Creates a geometry element from the specified array of index values. 
   * @access public
   * @constructor
   * @param {number[]|Buffer} indices - An array of index values, each of which identifies a vertex in a geometry source.
   * @param {SCNGeometryPrimitiveType} primitiveType - The drawing primitive that connects vertices when rendering the geometry element. For possible values, see SCNGeometryPrimitiveType.
   * @param {?number} primitiveCount -
   * @param {number} [bytesPerIndex = 2] -
   * @desc SceneKit connects the vertices in the order specified by the indices array, arranged according to the primitiveType parameter.This initializer is equivalent to the init(data:primitiveType:primitiveCount:bytesPerIndex:) initializer, but does not require an intermediary Data object; instead, it automatically infers the necessary allocation size and bytesPerIndex values based on the contents of the indices array. To create a custom SCNGeometry object from the geometry element, use the init(sources:elements:) initializer.
   * @see https://developer.apple.com/documentation/scenekit/scngeometryelement/1523191-init
   */


  constructor(indices, primitiveType, primitiveCount = null, bytesPerIndex = 2) {
    super(); // Inspecting a Geometry Element

    this._data = indices;

    if (indices instanceof Buffer) {
      const _data = [];
      const count = indices.length / bytesPerIndex;
      let _offset = 0;

      for (let i = 0; i < count; i++) {
        _data.push(indices.readUIntLE(_offset, bytesPerIndex));

        _offset += bytesPerIndex;
      }

      this._data = _data;
    }

    this._primitiveType = primitiveType;

    if (primitiveCount !== null) {
      this._primitiveCount = primitiveCount;
    } else {
      switch (primitiveType) {
        case SCNGeometryPrimitiveType.triangles:
          this._primitiveCount = this._data.length / 3;
          break;

        case SCNGeometryPrimitiveType.triangleStrip:
          this._primitiveCount = this._data.length - 2;
          break;

        case SCNGeometryPrimitiveType.line:
          this._primitiveCount = this._data.length / 2;
          break;

        case SCNGeometryPrimitiveType.point:
          this._primitiveCount = this._data.length;
          break;

        case SCNGeometryPrimitiveType.polygon:
          this._primitiveCount = this._data.length / 2;
          break;

        default:
          throw new Error('unknown primitive type: ' + primitiveType);
      }
    }

    this._bytesPerIndex = bytesPerIndex;
    /**
     * @type {TypedArray}
     * @access private
     */

    this._glData = null; //console.log(`SCNGeometryElement: bytesPerIndex: ${bytesPerIndex}`)

    if (bytesPerIndex === 1) {
      this._glData = new Uint8Array(this._data);
    } else if (bytesPerIndex === 2) {
      this._glData = new Uint16Array(this._data);
    } else if (bytesPerIndex === 4) {
      this._glData = new Uint32Array(this._data);
    } else {
      throw new Error(`unknown data size: ${bytesPerIndex}`);
    }
    /**
     * @type {number}
     */


    this.maximumPointScreenSpaceRadius = 0.0; // TODO: check the default value

    /**
     * @type {number}
     */

    this.minimumPointScreenSpaceRadius = 0.0; // TODO: check the default value

    /**
     * @type {number}
     */

    this.pointSize = 0.0; // TODO: check the default value

    /**
     * @type {NSRange}
     */

    this.primitiveRange = null; // TODO: check the default value
  }
  /**
   * Creates a geometry element from the specified Model I/O submesh object.
   * @access public
   * @param {MDLSubmesh} mdlSubMesh - 
   * @returns {void}
   * @desc The Model I/O framework provides universal support for import, export, description, and processing of several 3D asset file formats and related resources. (For details, see Model I/O.) The MDLSubmesh class is a generic description of an index buffer to be used in rendering a 3D object, along with an assigned material. In SceneKit, materials are assigned to a geometry rather than to its elements, so importing a submesh as a geometry element does not import its material assignment. To import a Model I/O mesh along with its materials, use the SCNGeometry init(mdlMesh:) method.
   * @see https://developer.apple.com/documentation/scenekit/scngeometryelement/1419843-init
   */


  initMdlSubmesh(mdlSubMesh) {} // Inspecting a Geometry Element

  /**
   * The drawing primitive that connects vertices when rendering the geometry element.
   * @type {SCNGeometryPrimitiveType}
   * @desc For possible values, see SCNGeometryPrimitiveType.
   * @see https://developer.apple.com/documentation/scenekit/scngeometryelement/1522917-primitivetype
   */


  get primitiveType() {
    return this._primitiveType;
  }
  /**
   * The number of primitives in the element.
   * @type {number}
   * @desc 
   * @see https://developer.apple.com/documentation/scenekit/scngeometryelement/1523404-primitivecount
   */


  get primitiveCount() {
    return this._primitiveCount;
  }
  /**
   * The data describing the geometry element.
   * @type {Data}
   * @desc An element’s data is an array of index values identifying vertices in a geometry source. SceneKit interprets the data as an array of unsigned integers, whose size is specified by the bytesPerIndex property.
   * @see https://developer.apple.com/documentation/scenekit/scngeometryelement/1523367-data
   */


  get data() {
    return this._data;
  }
  /**
   * The number of bytes that represent each index value in the element’s data.
   * @type {number}
   * @desc An element’s data property holds an array of index values identifying vertices in a geometry source. SceneKit interprets the data as an array of unsigned integers, whose size is specified by the bytesPerIndex property.
   * @see https://developer.apple.com/documentation/scenekit/scngeometryelement/1522720-bytesperindex
   */


  get bytesPerIndex() {
    return this._bytesPerIndex;
  }

  _createBuffer(context) {
    const gl = context;
    this._buffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._buffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._glData, gl.STATIC_DRAW);
    return this._buffer;
  }

  copy() {
    const element = new SCNGeometryElement(this._data.slice(0), this._primitiveType, this._primitiveCount, this._bytesPerIndex);
    return element;
  }
  /**
   * @access private
   * @param {number} index -
   * @returns {number[]} -
   */


  _indexAt(index) {
    if (index < 0 || index >= this.primitiveCount) {
      throw new Error(`index out of range: ${index} (0 - ${this.primitiveCount - 1})`);
    }
    const len = this._primitiveCount;

    if (this._primitiveType === SCNGeometryPrimitiveType.triangles) {
      const i = index * 3;
      return [this._data[i + 0], this._data[i + 1], this._data[i + 2]];
    } else if (this._primitiveType === SCNGeometryPrimitiveType.triangleStrip) {
      return [this._data[index + 0], this._data[index + 1], this._data[index + 2]];
    } else if (this._primitiveType === SCNGeometryPrimitiveType.line) {
      const i = index * 2;
      return [this._data[i + 0], this._data[i + 1]];
    } else if (this._primitiveType === SCNGeometryPrimitiveType.point) {
      return [this._data[index]];
    } else if (this._primitiveType === SCNGeometryPrimitiveType.polygon) {
      return [this._data[0], this._data[index + 1], this._data[index + 2]];
    }

    throw new Error(`unknown primitive type: ${this._primitiveType}`);
  }

}

/**
 * Values that inform SceneKit’s rendering for movement-related effects, used by the movabilityHint property.
 * @typedef {Object} SCNMovabilityHint
 * @property {number} fixed - The node is not expected to move over time.
 * @property {number} movable - The node is expected to move over time.
 * @see https://developer.apple.com/documentation/scenekit/scnmovabilityhint
 */

const SCNMovabilityHint = {
  fixed: 0,
  movable: 1
};

/**
 * A six-sided polyhedron geometry whose faces are all rectangles, optionally with rounded edges and corners.
 * @access public
 * @extends {SCNGeometry}
 * @see https://developer.apple.com/documentation/scenekit/scnbox
 */

class SCNBox extends SCNGeometry {
  static get _propTypes() {
    return {
      $constructor: (propNames, propValues) => {
        const box = new SCNBox(propValues.boxwidth, propValues.boxheight, propValues.boxlength, propValues.boxchamferRadius);
        box.widthSegmentCount = propValues.boxwidthSegmentCount;
        box.heightSegmentCount = propValues.boxheightSegmentCount;
        box.lengthSegmentCount = propValues.boxlengthSegmentCount;
        box.chamferSegmentCount = propValues.boxchamferSegmentCount;
        box.name = propValues.name; // propValues.boxPrimitiveType

        box.materials = propValues.materials;
        box.tessellator = propValues.tessellator;
        box.wantsAdaptiveSubdivision = propValues.wantsAdaptiveSubdivision;
        box.subdivisionLevel = propValues.subdivisionLevel;
        return box;
      },
      name: ['string', null],
      boxwidth: ['float', null],
      boxheight: ['float', null],
      boxlength: ['float', null],
      boxwidthSegmentCount: ['integer', null],
      boxheightSegmentCount: ['integer', null],
      boxlengthSegmentCount: ['integer', null],
      boxchamferRadius: ['float', null],
      boxchamferSegmentCount: ['integer', null],
      boxprimitiveType: ['integer', null],
      materials: ['NSArray', null],
      tessellator: ['SCNGeometryTessellator', null],
      wantsAdaptiveSubdivision: ['boolean', null],
      subdivisionLevel: ['integer', null],
      subdivisionSettings: ['bytes', null]
    };
  }
  /**
   * Creates a box geometry with the specified width, height, length, and chamfer radius.
   * @access public
   * @constructor
   * @param {number} [width = 1.0] - The width of the box along the x-axis of its local coordinate space.
   * @param {number} [height = 1.0] - The height of the box along the y-axis of its local coordinate space.
   * @param {number} [length = 1.0] - The length of the box along the z-axis of its local coordinate space.
   * @param {number} [chamferRadius = 0.0] - The radius of curvature for the edges and corners of the box.
   * @desc The box is centered in its local coordinate system. For example, if you create a box whose width, height and length are all 10.0, it extends from -5.0 to 5.0 along in each of the x-, y-, and z-axes.
   * @see https://developer.apple.com/documentation/scenekit/scnbox/1522620-init
   */


  constructor(width = 1.0, height = 1.0, length = 1.0, chamferRadius = 0.0) {
    super([], []); // Adjusting a Box’s Dimensions

    /**
     * The extent of the box along its x-axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnbox/1523898-width
     */

    this.width = width;
    /**
     * The extent of the box along its y-axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnbox/1522901-height
     */

    this.height = height;
    /**
     * The extent of the box along its z-axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnbox/1523514-length
     */

    this.length = length; // Configuring Box Properties

    /**
     * The number of subdivisions in each face of the box along its x-axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnbox/1523559-widthsegmentcount
     */

    this.widthSegmentCount = 1;
    /**
     * The number of subdivisions in each face of the box along its y-axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnbox/1522869-heightsegmentcount
     */

    this.heightSegmentCount = 1;
    /**
     * The number of subdivisions in each face of the box along its z-axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnbox/1523721-lengthsegmentcount
     */

    this.lengthSegmentCount = 1; // Adding Rounded Edges and Corners

    /**
     * The radius of curvature for the edges and corners of the box. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnbox/1523302-chamferradius
     */

    this.chamferRadius = chamferRadius;
    /**
     * The number of line segments used to create each rounded edge of the box. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnbox/1522976-chamfersegmentcount
     */

    this.chamferSegmentCount = 10;

    this._createGeometry();

    this.materials.push(new SCNMaterial());
  }

  _createGeometry() {
    const sourceData = [];
    const indexData = [];
    const left = -this.width * 0.5;
    const right = this.width * 0.5;
    const top = this.height * 0.5;
    const bottom = -this.height * 0.5;
    const front = this.length * 0.5;
    const back = -this.length * 0.5; // front

    sourceData.push(left, bottom, front); // position

    sourceData.push(0, 0, 1); // normal

    sourceData.push(0, 1); // texcoord

    sourceData.push(left, top, front);
    sourceData.push(0, 0, 1);
    sourceData.push(0, 0);
    sourceData.push(right, bottom, front);
    sourceData.push(0, 0, 1);
    sourceData.push(1, 1);
    sourceData.push(right, top, front);
    sourceData.push(0, 0, 1);
    sourceData.push(1, 0);
    indexData.push(0, 3, 1);
    indexData.push(0, 2, 3); // right

    sourceData.push(right, bottom, front);
    sourceData.push(1, 0, 0);
    sourceData.push(0, 1);
    sourceData.push(right, top, front);
    sourceData.push(1, 0, 0);
    sourceData.push(0, 0);
    sourceData.push(right, bottom, back);
    sourceData.push(1, 0, 0);
    sourceData.push(1, 1);
    sourceData.push(right, top, back);
    sourceData.push(1, 0, 0);
    sourceData.push(1, 0);
    indexData.push(4, 7, 5);
    indexData.push(4, 6, 7); // back

    sourceData.push(right, bottom, back);
    sourceData.push(0, 0, -1);
    sourceData.push(0, 1);
    sourceData.push(right, top, back);
    sourceData.push(0, 0, -1);
    sourceData.push(0, 0);
    sourceData.push(left, bottom, back);
    sourceData.push(0, 0, -1);
    sourceData.push(1, 1);
    sourceData.push(left, top, back);
    sourceData.push(0, 0, -1);
    sourceData.push(1, 0);
    indexData.push(8, 11, 9);
    indexData.push(8, 10, 11); // left

    sourceData.push(left, bottom, back);
    sourceData.push(-1, 0, 0);
    sourceData.push(0, 1);
    sourceData.push(left, top, back);
    sourceData.push(-1, 0, 0);
    sourceData.push(0, 0);
    sourceData.push(left, bottom, front);
    sourceData.push(-1, 0, 0);
    sourceData.push(1, 1);
    sourceData.push(left, top, front);
    sourceData.push(-1, 0, 0);
    sourceData.push(1, 0);
    indexData.push(12, 15, 13);
    indexData.push(12, 14, 15); // top

    sourceData.push(left, top, front);
    sourceData.push(0, 1, 0);
    sourceData.push(0, 1);
    sourceData.push(left, top, back);
    sourceData.push(0, 1, 0);
    sourceData.push(0, 0);
    sourceData.push(right, top, front);
    sourceData.push(0, 1, 0);
    sourceData.push(1, 1);
    sourceData.push(right, top, back);
    sourceData.push(0, 1, 0);
    sourceData.push(1, 0);
    indexData.push(16, 19, 17);
    indexData.push(16, 18, 19); // bottom

    sourceData.push(left, bottom, back);
    sourceData.push(0, -1, 0);
    sourceData.push(0, 1);
    sourceData.push(left, bottom, front);
    sourceData.push(0, -1, 0);
    sourceData.push(0, 0);
    sourceData.push(right, bottom, back);
    sourceData.push(0, -1, 0);
    sourceData.push(1, 1);
    sourceData.push(right, bottom, front);
    sourceData.push(0, -1, 0);
    sourceData.push(1, 0);
    indexData.push(20, 23, 21);
    indexData.push(20, 22, 23);
    const vertexSource = new SCNGeometrySource(sourceData, // data
    SCNGeometrySource.Semantic.vertex, // semantic
    24, // vectorCount
    true, // floatComponents
    3, // componentsPerVector
    4, // bytesPerComponent
    0, // offset
    32 // sride
    );
    const normalSource = new SCNGeometrySource(sourceData, // data
    SCNGeometrySource.Semantic.normal, // semantic
    24, // vectorCount
    true, // floatComponents
    3, // componentsPerVector
    4, // bytesPerComponent
    12, // offset
    32 // stride
    );
    const texcoordSource = new SCNGeometrySource(sourceData, // data
    SCNGeometrySource.Semantic.texcoord, // semantic
    24, // vectorCount
    true, // floatComponents
    2, // componentsPerVector
    4, // bytesPerComponent
    24, // offset
    32 // stride
    );
    const element = new SCNGeometryElement(indexData, SCNGeometryPrimitiveType.triangles);
    this._geometryElements = [element];
    this._geometrySources = [vertexSource, normalSource, texcoordSource];
    this.boundingBox = {
      min: new SCNVector3(left, bottom, back),
      max: new SCNVector3(right, top, front)
    };
  }

  _updateBoundingBoxForSkinner(skinner = null) {
    if (skinner === null) {
      return this.boundingBox;
    }

    return super._updateBoundingBoxForSkinner(skinner);
  }
  /**
   * @access private
   * @param {number[]} sourceData -
   * @param {number[]} indexData -
   * @param {SCNVector3} v1 - position 1
   * @param {SCNVector3} v2 - position 2
   * @param {SCNVector3} v3 - position 3
   * @param {SCNVector3} v4 - position 4
   * @param {number} s1 - segmentCount 1
   * @param {number} s2 - segmentCount 2
   * @returns {void}
   */


  _createFace(sourceData, indexData, v1, v2, v3, v4, s1, s2) {}
  /**
   * @access private
   * @returns {Ammo.btCollisionShape} -
   * @desc call Ammo.destroy(shape) after using it.
   */


  _createBtCollisionShape() {//const size = new Ammo.btVector3(this.width * 0.5, this.height * 0.5, this.length * 0.5)
    //const shape = new Ammo.btBoxShape(size)
    //Ammo.destroy(size)
    //return shape
  }

}

/**
 * A right circular cylinder geometry whose ends are capped with hemispheres.
 * @access public
 * @extends {SCNGeometry}
 * @see https://developer.apple.com/documentation/scenekit/scncapsule
 */

class SCNCapsule extends SCNGeometry {
  static get _propTypes() {
    return {
      capsulecapRadius: ['float', 'capRadius'],
      capsulecapSegmentCount: ['integer', 'capSegmentCount'],
      capsuleheight: ['float', null],
      capsuleheightSegmentCount: ['integer', null],
      capsuleprimitiveType: ['integer', null],
      capsuleradialSegmentCount: ['integer', 'radialSegmentCount'],
      materials: 'NSArray',
      subdivisionLevel: 'integer',
      subdivisionSettings: ['bytes', null],
      tessellator: 'SCNGeometryTessellator',
      wantsAdaptiveSubdivision: 'boolean'
    };
  } // Creating a Capsule

  /**
   * Creates a capsule geometry with the specified radius and height.
   * @access public
   * @constructor
   * @param {number} capRadius - The radius both of the capsule’s cylindrical body and of its hemispherical ends.
   * @param {number} height - The height of the capsule along the y-axis of its local coordinate space.
   * @desc The capsule is centered in its local coordinate system. For example, if you create a capsule whose cap radius is 5.0 and height is 20.0, it extends from -10.0 to 10.0 in the y-axis, and the circular cross section at the center of its body extends from -5.0 to 5.0 along the x- and z-axes.
   * @see https://developer.apple.com/documentation/scenekit/scncapsule/1523790-init
   */


  constructor(capRadius = 0.5, height = 2.0) {
    super([], []); // Adjusting a Capsule’s Dimensions

    /**
     * The radius both of the capsule’s circular center cross section and of its hemispherical ends. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncapsule/1523926-capradius
     */

    this.capRadius = capRadius;
    /**
     * The extent of the capsule along its y-axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncapsule/1522789-height
     */

    this.height = height; // Adjusting Geometric Detail

    /**
     * The number of subdivisions around the lateral circumference of the capsule. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncapsule/1522735-radialsegmentcount
     */

    this.radialSegmentCount = 24;
    /**
     * The number of subdivisions in the height of each hemispherical end of the capsule. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncapsule/1523561-capsegmentcount
     */

    this.capSegmentCount = 48;
    /**
     * The number of subdivisions in the sides of the capsule along its y-axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncapsule/1523697-heightsegmentcount
     */

    this.heightSegmentCount = 1;

    this._createGeometry();

    this.materials.push(new SCNMaterial());
  }

  _createGeometry() {
    const sourceData = [];
    const indexData = [];
    const vectorCount = (this.radialSegmentCount * 2 + 1) * (this.capSegmentCount + 4); //const primitiveCount = this.radialSegmentCount * this.capSegmentCount * 4

    const yNom = [];
    const ySin = [];

    for (let lat = 0; lat <= this.capSegmentCount; lat++) {
      yNom.push(-Math.cos(Math.PI * lat / this.capSegmentCount));
      ySin.push(Math.sin(Math.PI * lat / this.capSegmentCount));
    }

    const cylinderHeight = this.height - this.capRadius * 2;
    const hemiLen = this.capSegmentCount / 2;
    const rad2 = this.radialSegmentCount * 2;

    for (let lng = 0; lng <= rad2; lng++) {
      const x = -Math.sin(2.0 * Math.PI * lng / rad2);
      const z = -Math.cos(2.0 * Math.PI * lng / rad2);
      const tx = lng / rad2;
      let y = -cylinderHeight * 0.5;

      for (let lat = 0; lat <= hemiLen; lat++) {
        const xNom = x * ySin[lat];
        const zNom = z * ySin[lat]; // vertex

        sourceData.push(xNom * this.capRadius, y + yNom[lat] * this.capRadius, zNom * this.capRadius); // normal

        sourceData.push(xNom, yNom[lat], zNom); // texcoord

        sourceData.push(tx, 1.0 - 0.25 * lat / hemiLen);

        if (lat === hemiLen) {
          // put the same data again
          sourceData.push(xNom * this.capRadius, y + yNom[lat] * this.capRadius, zNom * this.capRadius);
          sourceData.push(xNom, yNom[lat], zNom);
          sourceData.push(tx, 1.0 - 0.25 * lat / hemiLen);
        }
      }

      y = cylinderHeight * 0.5;

      for (let lat = hemiLen; lat <= this.capSegmentCount; lat++) {
        const xNom = x * ySin[lat];
        const zNom = z * ySin[lat]; // vertex

        sourceData.push(xNom * this.capRadius, y + yNom[lat] * this.capRadius, zNom * this.capRadius); // normal

        sourceData.push(xNom, yNom[lat], zNom); // texcoord

        sourceData.push(tx, 0.50 - 0.25 * lat / hemiLen);

        if (lat === hemiLen) {
          // put the same data again
          sourceData.push(xNom * this.capRadius, y + yNom[lat] * this.capRadius, zNom * this.capRadius);
          sourceData.push(xNom, yNom[lat], zNom);
          sourceData.push(tx, 0.50 - 0.25 * lat / hemiLen);
        }
      }
    } // index


    const capLen = this.capSegmentCount;
    const radLen = this.radialSegmentCount * 2 + 1;

    for (let i = 0; i < capLen; i++) {
      let index1 = i * (this.capSegmentCount + 4);
      let index2 = index1 + this.capSegmentCount + 5;
      indexData.push(index1, index2, index1 + 1);
      index1 += 1;

      for (let j = 0; j < radLen; j++) {
        if (Math.abs(j - this.radialSegmentCount) !== 1) {
          indexData.push(index1, index2 + 1, index1 + 1);
          indexData.push(index1, index2, index2 + 1);
        }

        index1 += 1;
        index2 += 1;
      }

      indexData.push(index1, index2, index2 + 1);
    }

    const vertexSource = new SCNGeometrySource(sourceData, // data
    SCNGeometrySource.Semantic.vertex, // semantic
    vectorCount, // vectorCount
    true, // floatComponents
    3, // componentsPerVector
    4, // bytesPerComponent
    0, // offset
    32 // sride
    );
    const normalSource = new SCNGeometrySource(sourceData, // data
    SCNGeometrySource.Semantic.normal, // semantic
    vectorCount, // vectorCount
    true, // floatComponents
    3, // componentsPerVector
    4, // bytesPerComponent
    12, // offset
    32 // stride
    );
    const texcoordSource = new SCNGeometrySource(sourceData, // data
    SCNGeometrySource.Semantic.texcoord, // semantic
    vectorCount, // vectorCount
    true, // floatComponents
    2, // componentsPerVector
    4, // bytesPerComponent
    24, // offset
    32 // stride
    );
    const element = new SCNGeometryElement(indexData, SCNGeometryPrimitiveType.triangles);
    this._geometryElements = [element];
    this._geometrySources = [vertexSource, normalSource, texcoordSource];
    this.boundingBox = {
      min: new SCNVector3(-this.capRadius, -this.height * 0.5, -this.capRadius),
      max: new SCNVector3(this.capRadius, this.height * 0.5, this.capRadius)
    };
  }
  /**
   * @access private
   * @returns {Ammo.btCollisionShape} -
   * @desc call Ammo.destroy(shape) after using it.
   */


  _createBtCollisionShape() {} //const height = (this.height - this.capRadius) * 0.5
  //const shape = new Ammo.btCapsuleShape(this.capRadius, height)
  //return shape

  /**
   * The center point and radius of the object’s bounding sphere.
   * @type {Object}
   * @parameter {SCNVector3} _boundingSphere.center -
   * @parameter {number} _boundingSphere.radius -
   * @returns {Object} -
   * @desc Scene Kit defines a bounding sphere in the local coordinate space using a center point and a radius. For example, if a node’s bounding sphere has the center point {3, 1, 4} and radius 2.0, all points in the vertex data of node’s geometry (and any geometry attached to its child nodes) lie within 2.0 units of the center point.The coordinates provided when reading this property are valid only if the object has a volume to be measured. For a geometry containing no vertex data or a node containing no geometry (and whose child nodes, if any, contain no geometry), the values center and radius are both zero.
   * @see https://developer.apple.com/documentation/scenekit/scnboundingvolume/2034707-boundingsphere
   */


  getBoundingSphere() {
    const c = new SCNVector3(0, 0, 0);
    const r = this.height * 0.5;
    return {
      center: c,
      radius: r
    };
  }

  _updateBoundingBoxForSkinner(skinner = null) {
    if (skinner === null) {
      return this.boundingBox;
    }

    return super._updateBoundingBoxForSkinner(skinner);
  }

}

//import SCNVector3 from './SCNVector3'
//import SCNMatrix4 from './SCNMatrix4'
//import CGPoint from '../CoreGraphics/CGPoint'

/**
 * Detailed information about a result from searching for elements of a scene located at a specified point, or along a specified line segment (or ray).
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/scenekit/scnhittestresult
 */

class SCNHitTestResult extends NSObject {
  /**
   * constructor
   * @access public
   * @constructor
   */
  constructor() {
    super(); // Retrieving Information About a Hit-Test Result

    this._node = null;
    this._geometryIndex = 0;
    this._faceIndex = 0;
    this._localCoordinates = null;
    this._worldCoordinates = null;
    this._localNormal = null;
    this._worldNormal = null;
    this._modelTransform = null;
    this._distance = null; // Instance Properties

    this._boneNode = null;
  } // Retrieving Information About a Hit-Test Result

  /**
   * Returns the texture coordinates at the point of intersection for the specified texture mapping channel.
   * @access public
   * @param {number} channel - The index of the mapping channel in which to look up texture coordinates.
   * @returns {CGPoint} - 
   * @desc An SCNGeometry object can contain multiple sources of texture coordinates, or texture mapping channels. (With multiple channels, you can map texture images for different material properties in different ways.) To use the texture coordinates of a hit-test result, specify which texture coordinate source to look up coordinates in. For example, to add “scorch marks” to a game character hit by a laser, you might modify a texture image mapped to the multiply property of the geometry’s material. Use the mappingChannel index from that material property as the channel parameter when calling textureCoordinates(withMappingChannel:) to ensure that you modify the correct location in the texture image.
   * @see https://developer.apple.com/documentation/scenekit/scnhittestresult/1522771-texturecoordinates
   */


  textureCoordinatesWithMappingChannel(channel) {
    return null;
  }
  /**
   * The node whose geometry intersects the search ray.
   * @type {SCNNode}
   * @desc 
   * @see https://developer.apple.com/documentation/scenekit/scnhittestresult/1523256-node
   */


  get node() {
    return this._node;
  }
  /**
   * The index of the geometry element whose surface the search ray intersects.
   * @type {number}
   * @desc Every SCNGeometry object contains one or more SCNGeometryElement objects that define how its vertices connect to form a surface. This property provides the index of the geometry element intersecting the search ray. For more information about that geometry element, use the geometry’s geometryElement(at:) method.
   * @see https://developer.apple.com/documentation/scenekit/scnhittestresult/1522625-geometryindex
   */


  get geometryIndex() {
    return this._geometryIndex;
  }
  /**
   * The index of the primitive in the geomety element intersected by the search ray.
   * @type {number}
   * @desc 
   * @see https://developer.apple.com/documentation/scenekit/scnhittestresult/1522888-faceindex
   */


  get faceIndex() {
    return this._faceIndex;
  }
  /**
   * The point of intersection between the geometry and the search ray, in the local coordinate system of the node containing the geometry.
   * @type {SCNVector3}
   * @desc 
   * @see https://developer.apple.com/documentation/scenekit/scnhittestresult/1523032-localcoordinates
   */


  get localCoordinates() {
    return this._localCoordinates;
  }
  /**
   * The point of intersection between the geometry and the search ray, in the scene’s world coordinate system.
   * @type {SCNVector3}
   * @desc 
   * @see https://developer.apple.com/documentation/scenekit/scnhittestresult/1523058-worldcoordinates
   */


  get worldCoordinates() {
    return this._worldCoordinates;
  }
  /**
   * The surface normal vector at the point of intersection, in the local coordinate system of the node containing the geometry intersected by the search ray.
   * @type {SCNVector3}
   * @desc 
   * @see https://developer.apple.com/documentation/scenekit/scnhittestresult/1523953-localnormal
   */


  get localNormal() {
    return this._localNormal;
  }
  /**
   * The surface normal vector at the point of intersection, in the scene’s world coordinate system.
   * @type {SCNVector3}
   * @desc 
   * @see https://developer.apple.com/documentation/scenekit/scnhittestresult/1524066-worldnormal
   */


  get worldNormal() {
    return this._worldNormal;
  }
  /**
   * The world transform matrix of the node containing the intersection.
   * @type {SCNMatrix4}
   * @desc Use this matrix to transform vectors from the local coordinate space of the node whose geometry is intersected by the search ray to the scene’s world coordinate system.
   * @see https://developer.apple.com/documentation/scenekit/scnhittestresult/1523496-modeltransform
   */


  get modelTransform() {
    return this._modelTransform;
  } // Instance Properties

  /**
   * 
   * @type {SCNNode}
   * @desc 
   * @see https://developer.apple.com/documentation/scenekit/scnhittestresult/1823463-bonenode
   */


  get boneNode() {
    return this._boneNode;
  }

}

/**
 * Constants that determine how a physics body interacts with forces and other bodies, used by the type property and when creating a physics body.
 * @typedef {Object} SCNPhysicsBodyType
 * @property {number} static - A physics body that is unaffected by forces or collisions and cannot move.
 * @property {number} dynamic - A physics body that can be affected by forces and collisions.
 * @property {number} kinematic - A physics body that is unaffected by forces or collisions but that can cause collisions affecting other bodies when moved.
 * @see https://developer.apple.com/documentation/scenekit/scnphysicsbodytype
 */

const SCNPhysicsBodyType = {
  static: 0,
  dynamic: 1,
  kinematic: 2
};

//import SCNVector3 from './SCNVector3'

/**
 * Detailed information about a contact between two physics bodies in a scene’s physics simulation. 
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/scenekit/scnphysicscontact
 */

class SCNPhysicsContact extends NSObject {
  /**
   * constructor
   * @access public
   * @constructor
   */
  constructor() {
    super(); // Inspecting the Contact Properties

    this._nodeA = null;
    this._nodeB = null;
    this._contactPoint = null;
    this._contactNormal = null;
    this._collisionImpulse = 0;
    this._penetrationDistance = 0;
  } // Inspecting the Contact Properties

  /**
   * The node containing the first body in the contact.
   * @type {SCNNode}
   * @desc Use the node’s physicsBody property to examine physics characteristics of the node.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicscontact/1523445-nodea
   */


  get nodeA() {
    return this._nodeA;
  }
  /**
   * The node containing the second body in the contact.
   * @type {SCNNode}
   * @desc Use the node’s physicsBody property to examine physics characteristics of the node.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicscontact/1524232-nodeb
   */


  get nodeB() {
    return this._nodeB;
  }
  /**
   * The contact point between the two physics bodies, in scene coordinates.
   * @type {SCNVector3}
   * @desc 
   * @see https://developer.apple.com/documentation/scenekit/scnphysicscontact/1523810-contactpoint
   */


  get contactPoint() {
    return this._contactPoint;
  }
  /**
   * The normal vector at the contact point between the two physics bodies, in scene coordinates.
   * @type {SCNVector3}
   * @desc This vector tells you which direction the bodies were moving relative to one another at the time of the collision. For example, in a game you can examine this vector to have enemy characters take damage when struck from above by the player character but damage the player character instead when they collide side-to-side.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicscontact/1522833-contactnormal
   */


  get contactNormal() {
    return this._contactNormal;
  }
  /**
   * The force over time of the collision, in newton-seconds.
   * @type {number}
   * @desc This property’s value tells you how hard the bodies struck each other in a collision. For example, in a game you might allow a character to proceed unhindered after a minor collision, but take damage when struck with sufficient force.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicscontact/1523944-collisionimpulse
   */


  get collisionImpulse() {
    return this._collisionImpulse;
  }
  /**
   * The distance of overlap, in units of scene coordinate space, between the two physics bodies.
   * @type {number}
   * @desc 
   * @see https://developer.apple.com/documentation/scenekit/scnphysicscontact/1522870-penetrationdistance
   */


  get penetrationDistance() {
    return this._penetrationDistance;
  }

}

/**
 * A sphere (or ball or globe) geometry.
 * @access public
 * @extends {SCNGeometry}
 * @see https://developer.apple.com/documentation/scenekit/scnsphere
 */

class SCNSphere extends SCNGeometry {
  static get _propTypes() {
    return {
      $constructor: (propNames, propValues) => {
        const sphere = new SCNSphere(propValues.sphereradius);
        sphere.isGeodesic = propValues.spheregeodesic;
        sphere.segmentCount = propValues.spheresegmentCount;
        sphere.name = propValues.name;
        sphere._sphereRadialSpan = propValues.sphereRadialSpan;
        sphere._isHemispheric = propValues.spherehemispheric;
        sphere._spherePrimitiveType = propValues.sphereprimitiveType;
        sphere.materials = propValues.materials;
        sphere.tessellator = propValues.tessellator;
        sphere.subdivisionLevel = propValues.subdivisionLevel;
        sphere.wantsAdaptiveSubdivision = propValues.wantsAdaptiveSubdivision;

        sphere._createGeometry();

        return sphere;
      },
      sphereradius: ['float', null],
      spheregeodesic: ['boolean', null],
      spheresegmentCount: ['integer', null],
      materials: ['NSArray', null],
      tessellator: ['SCNGeometryTessellator', null],
      wantsAdaptiveSubdivision: ['boolean', null],
      adaptiveSubdivision: ['boolean', null],
      name: ['string', null],
      sphereradialSpan: ['float', null],
      spherehemispheric: ['boolean', null],
      sphereprimitiveType: ['integer', null],
      subdivisionLevel: ['integer', null],
      subdivisionSettings: ['bytes', null]
    };
  } // Creating a Sphere

  /**
   * Creates a sphere geometry with the specified radius.
   * @access public
   * @constructor
   * @param {number} radius - The radius of the sphere in its local coordinate space.
   * @desc The sphere is centered in its local coordinate system. For example, if you create a sphere whose radius is 5.0, it extends from -5.0 to 5.0 along each of the the x, y, and z-axes.
   * @see https://developer.apple.com/documentation/scenekit/scnsphere/1522601-init
   */


  constructor(radius = 0.5) {
    super([], []); // Adjusting a Sphere’s Dimensions

    /**
     * The radius of the sphere. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnsphere/1523787-radius
     */

    this.radius = radius; // Adjusting Geometric Detail

    /**
     * A Boolean value specifying whether SceneKit uses a geodesic polygon mesh to render the sphere.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnsphere/1523268-isgeodesic
     */

    this.isGeodesic = false;
    /**
     * A number determining the detail of the polygon mesh SceneKit uses to render the sphere. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnsphere/1523912-segmentcount
     */

    this.segmentCount = 24;
    this._sphereRadialSpan = 0;
    this._spherePrimitiveType = 0;
    this._isHemispheric = false;

    this._createGeometry();

    this.materials.push(new SCNMaterial());
  }

  _createGeometry() {
    const sourceData = [];
    const indexData = [];
    const vectorCount = (this.segmentCount + 1) * (this.segmentCount + 1);
    const primitiveCount = (this.segmentCount - 1) * this.segmentCount * 2;
    const yNom = [];
    const ySin = [];

    for (let lat = 0; lat <= this.segmentCount; lat++) {
      yNom.push(-Math.cos(Math.PI * lat / this.segmentCount));
      ySin.push(Math.sin(Math.PI * lat / this.segmentCount));
    }

    for (let lng = 0; lng <= this.segmentCount; lng++) {
      const x = -Math.sin(2.0 * Math.PI * lng / this.segmentCount);
      const z = -Math.cos(2.0 * Math.PI * lng / this.segmentCount);

      for (let lat = 0; lat <= this.segmentCount; lat++) {
        const xNom = x * ySin[lat];
        const zNom = z * ySin[lat]; // vertex

        sourceData.push(xNom * this.radius, yNom[lat] * this.radius, zNom * this.radius); // normal

        sourceData.push(xNom, yNom[lat], zNom); // texcoord

        sourceData.push(lng / this.segmentCount, 1.0 - lat / this.segmentCount);
      }
    }

    for (let i = 0; i < this.segmentCount; i++) {
      let index1 = i * (this.segmentCount + 1);
      let index2 = index1 + this.segmentCount + 2;
      indexData.push(index1, index2, index1 + 1);
      index1 += 1;

      for (let j = 0; j < this.segmentCount - 2; j++) {
        indexData.push(index1, index2 + 1, index1 + 1);
        indexData.push(index1, index2, index2 + 1);
        index1 += 1;
        index2 += 1;
      }

      indexData.push(index1, index2, index2 + 1);
    }

    const vertexSource = new SCNGeometrySource(sourceData, // data
    SCNGeometrySource.Semantic.vertex, // semantic
    vectorCount, // vectorCount
    true, // floatComponents
    3, // componentsPerVector
    4, // bytesPerComponent
    0, // offset
    32 // sride
    );
    const normalSource = new SCNGeometrySource(sourceData, // data
    SCNGeometrySource.Semantic.normal, // semantic
    vectorCount, // vectorCount
    true, // floatComponents
    3, // componentsPerVector
    4, // bytesPerComponent
    12, // offset
    32 // stride
    );
    const texcoordSource = new SCNGeometrySource(sourceData, // data
    SCNGeometrySource.Semantic.texcoord, // semantic
    vectorCount, // vectorCount
    true, // floatComponents
    2, // componentsPerVector
    4, // bytesPerComponent
    24, // offset
    32 // stride
    );
    const element = new SCNGeometryElement(indexData, SCNGeometryPrimitiveType.triangles);
    this._geometryElements = [element];
    this._geometrySources = [vertexSource, normalSource, texcoordSource];
    this.boundingBox = {
      min: new SCNVector3(-this.radius, -this.radius, -this.radius),
      max: new SCNVector3(this.radius, this.radius, this.radius)
    };
  }

  _updateBoundingBoxForSkinner(skinner = null) {
    if (skinner === null) {
      return this.boundingBox;
    }

    return super._updateBoundingBoxForSkinner(skinner);
  }

}

const _Option = {
  collisionMargin: 'SCNPhysicsShapeCollisionMarginKey',
  keepAsCompound: 'SCNPhysicsShapeKeepAsCompoundKey',
  scale: 'SCNPhysicsShapeScaleKey',
  type: 'SCNPhysicsShapeTypeKey'
};
const _ShapeType = {
  boundingBox: 'boundingBox',
  concavePolyhedron: 'concaveMesh',
  convexHull: 'convexHull'
  /**
   * An abstraction of a physics body’s solid volume for use in tuning or optimizing collision detection.
   * @access public
   * @extends {NSObject}
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsshape
   */

};
class SCNPhysicsShape extends NSObject {
  static get _propTypes() {
    return {
      $constructor: (propNames, propValues) => {
        return new SCNPhysicsShape(propValues.referenceObject, propValues.options);
      },
      options: ['NSArray', null],
      referenceObject: ['NSObject', null],
      transform0: ['SCNMatrix4', null],
      transform1: ['SCNMatrix4', null],
      transform2: ['SCNMatrix4', null],
      transform3: ['SCNMatrix4', null],
      transformsCount: ['integer', null]
    };
  } // Creating Physics Shapes

  /**
   * Creates a physics shape based on a geometry object.
   * @access public
   * @constructor
   * @param {SCNGeometry} geometry - A geometry object.
   * @param {?Map<SCNPhysicsShape.Option, Object>} [options = null] - A dictionary of options affecting the level of detail of the physics shape, or nil to use default options. For applicable keys and their possible values, see Shape Creation Options Keys.
   * @desc If you create a physics shape using one of the basic geometry classes (SCNBox, SCNSphere, SCNPyramid, SCNCone, SCNCylinder, or SCNCapsule), SceneKit uses an idealized form of that geometry for the physics shape instead of using the geometry’s vertex data to simulate collisions. For example, if you create a physics shape from an SCNSphere object, SceneKit simulates collisions for any object that passes within the sphere’s radius. Because the idealized forms of simple geometries are computationally much simpler than the vertex data needed for displaying them, using basic geometries for physics shapes (or compound shapes created from basic geometries with the init(shapes:transforms:) method) often provides the best balance between simulation accuracy and performance. To use the newly created physics shape, create a physics body with the the init(type:shape:) method, or assign the shape to the physicsShape property of an existing body.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsshape/1508897-init
   */


  constructor(geometry, options = null) {
    super();
    let _options = options;

    if (Array.isArray(options)) {
      _options = {};

      for (const arr of options) {
        _options[arr[0]] = arr[1];
      }
    }
    /**
     * @type {SCNGeometry}
     */


    this._sourceGeometry = null;
    /**
     * @type {Object}
     */

    this._options = _options;
    /**
     * @type {SCNMatrix4}
     */

    this._transforms = null;
    /**
     * @type {SCNGeometry}
     */

    this._shape = null;
    /**
     * @type {SCNVector3}
     */

    this._center = new SCNVector3(0, 0, 0); // Getting Information About a Shape

    this._sourceObject = null;

    this._setSourceObject(geometry);

    this._createShape();
  }

  _setSourceObject(obj) {
    this._sourceObject = obj;

    if (_InstanceOf(this._sourceObject, SCNGeometry)) {
      this._sourceGeometry = this._sourceObject;
    } else if (_InstanceOf(this._sourceObject, SCNNode) && this._sourceObject.geometry) {
      // TODO: get geometries recursively
      this._sourceGeometry = this._sourceObject.geometry;
    }

    if (!this._sourceGeometry) ;
  }

  _createShape() {
    if (!this._sourceGeometry) {
      //throw new Error('SCNPhysicsShape: must have a geometry')
      return;
    } //if(this._options && this._options.get(_Option.type) === _ShapeType.boundingBox){


    if (this._options && this._options[_Option.type] === _ShapeType.boundingBox) {
      this._createShapeAsBoundingBox();
    } else if (_InstanceOf(this._sourceGeometry, SCNCapsule)) {
      // FIXME: do not convert to SCNBox
      this._createShapeAsBoundingBox();
    } else if (_InstanceOf(this._sourceGeometry, SCNBox)) {
      this._createShapeAsBox();
    } else if (_InstanceOf(this._sourceGeometry, SCNSphere)) {
      this._createShapeAsSphere(); //}else if(this._options && this._options.get(_Option.type) === _ShapeType.convecHull){

    } else if (this._options && this._options[_Option.type] === _ShapeType.concavePolyhedron) {
      // give up making a simple shape
      this._shape = this._sourceGeometry;
    } else {
      this._createShapeAsSphere();
    }
  }

  _createShapeAsBoundingBox() {
    const boundingBox = this._sourceGeometry._updateBoundingBox();

    const width = boundingBox.max.x - boundingBox.min.x;
    const height = boundingBox.max.y - boundingBox.min.y;
    const length = boundingBox.max.z - boundingBox.min.z;
    const chamferRadius = 0;
    const box = new SCNBox(width, height, length, chamferRadius);
    this._shape = box;
    this._center = new SCNVector3(boundingBox.min.x + width * 0.5, boundingBox.min.y + height * 0.5, boundingBox.min.z + length * 0.5);
  }

  _createShapeAsBox() {
    // TODO: copy the geometry
    this._shape = this._sourceGeometry;
    this._center = new SCNVector3(0, 0, 0);
  }

  _createShapeAsSphere() {
    if (_InstanceOf(this._sourceGeometry, SCNSphere)) {
      // TODO: copy the geometry
      this._shape = this._sourceGeometry;
      this._center = new SCNVector3(0, 0, 0);
      return;
    }

    const boundingSphere = this._sourceGeometry.getBoundingSphere();

    const sphere = new SCNSphere(boundingSphere.radius);
    this._shape = sphere;
    this._center = boundingSphere.center;
  } // Getting Information About a Shape

  /**
   * The object that was used to create the shape.
   * @type {Object}
   * @desc This property, along with the transforms and options properties, provides the information that was used to create the shape. You can use this information, for example, to draw editing or debugging UI in your scene.If the shape was created with the init(geometry:options:) method, the source object is an SCNGeometry object, and the options property contains the options affecting the shape’s construction from that geometry.If the shape was created with the init(node:options:) method, the source object is an SCNNode object, and the options property contains the options affecting the shape’s construction from that node.If the shape was created with the init(shapes:transforms:) method, the source object is an array of SCNPhysicsShape objects and the transforms property describes how those shapes combine to form a compound shape.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsshape/1508888-sourceobject
   */


  get sourceObject() {
    return this._sourceObject;
  }
  /**
   * The options dictionary that was used to create the shape.
   * @type {?Map<SCNPhysicsShape.Option, Object>}
   * @desc You provide this dictionary in the init(geometry:options:) or init(node:options:) method. Use this dictionary along with the sourceObject property to recover the information that was used to create the shape. If the shape was created with the init(shapes:transforms:) method, this property’s value is nil.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsshape/1508904-options
   */


  get options() {
    return this._options;
  }

  get _type() {
    if (!this._options) {
      return null;
    }

    return this._options[_Option.type];
  }
  /**
   * The array of transforms that was used to create a compound shape.
   * @type {?NSValue[]}
   * @desc You provide this array of NSValue objects, each containing an SCNMatrix4 value, in the init(shapes:transforms:) method to create a compound shape. Use this array along with the sourceObject property to recover the information that was used to create the shape. If the shape was created with the init(geometry:options:) or init(node:options:) method, this property's value is nil.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsshape/1508898-transforms
   */


  get transforms() {
    return this._transforms;
  } // Structures

  /**
   * @type {Object} Option
   * @property {string} collisionMargin 
   * @property {string} keepAsCompound An option for selecting whether to create a group of independent shapes or combine them into a single shape.
   * @property {string} scale An option for selecting the scale factor of the shape relative to the local coordinate space of the node containing it.
   * @property {string} type An option for selecting the level of detail at which to create shapes from geometry.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsshape.option
   */


  static get Option() {
    return _Option;
  }
  /**
   * @type {Object} ShapeType
   * @property {string} boundingBox The physics shape is the smallest box containing the geometry.
   * @property {string} concavePolyhedron The physics shape is a concave polyhedron closely following the surface of the geometry.
   * @property {string} convexHull The physics shape is a convex polyhedron roughly enclosing the geometry.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsshape.shapetype
   */


  static get ShapeType() {
    return _ShapeType;
  }
  /**
   * @access private
   * @returns {Ammo.btCollisionShape} -
   * @desc call Ammo.destroy(shape) after using it.
   */


  _createBtCollisionShape() {
    if (this._sourceObject === null) {
      throw new Error('_sourceObject is null');
    }

    return this._sourceObject._createBtCollisionShape();
  }

}

const _TestOption = {
  backfaceCulling: 'backfaceCulling',
  collisionBitMask: 'collisionBitMask',
  searchMode: 'results'
};
const _TestSearchMode = {
  all: 'all',
  any: 'any',
  closest: 'closest'
  /**
   * The global simulation of collisions, gravity, joints, and other physics effects in a scene.
   * @access public
   * @extends {NSObject}
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsworld
   */

};
class SCNPhysicsWorld extends NSObject {
  static get _propTypes() {
    return {
      gravity: 'SCNVector3',
      speed: 'double',
      timeStep: 'double',
      scale: ['double', '_scale'],
      // _allBehaviors
      // contactDelegate
      scene: ['SCNScene', '_scene']
    };
  }
  /**
   * constructor
   * @access public
   * @constructor
   */


  constructor() {
    super(); // Managing the Physics Simulation

    /**
     * A vector that specifies the gravitational acceleration applied to physics bodies in the physics world.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsworld/1512855-gravity
     */

    this.gravity = new SCNVector3(0, 0, 0);
    /**
     * The rate at which the simulation executes.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsworld/1512851-speed
     */

    this.speed = 0;
    /**
     * The time interval between updates to the physics simulation.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsworld/1512881-timestep
     */

    this.timeStep = 0;
    /**
     * @access private
     * @type {number}
     */

    this._scale = 1.0; // Registering Physics Behaviors

    this._allBehaviors = []; // Detecting Contacts Between Physics Bodies

    /**
     * A delegate that is called when two physics bodies come in contact with each other.
     * @type {?SCNPhysicsContactDelegate}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsworld/1512843-contactdelegate
     */

    this.contactDelegate = null; //const collisionConfiguration = new Ammo.btDefaultCollisionConfiguration()
    //const dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration)
    //const overlappingPairCache = new Ammo.btDbvtBroadphase()
    //const solver = new Ammo.btSequentialImpulseConstraintSolver()
    //this._world = new Ammo.btDiscreteDynamicsWorld(
    //  dispatcher, overlappingPairCache, solver, collisionConfiguration
    //)

    this._prevTime = null;
    /**
     * @access private
     * @type {SCNScene}
     */

    this._scene = null; // for rayTest

    this._renderer = null;
  } // Managing the Physics Simulation

  /**
   * Forces the physics engine to reevaluate possible collisions between physics bodies.
   * @access public
   * @returns {void}
   * @desc By default, SceneKit checks for collisions between physics bodies only once per simulation step. If you directly change the positions of any physics bodies outside of a SCNPhysicsContactDelegate method, call the updateCollisionPairs() method before using any of the methods listed in Searching for Physics Bodies Detecting Contacts Between Physics Bodies.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsworld/1512877-updatecollisionpairs
   */


  updateCollisionPairs() {} // Registering Physics Behaviors

  /**
   * Adds a behavior to the physics world.
   * @access public
   * @param {SCNPhysicsBehavior} behavior - The behavior to be added.
   * @returns {void}
   * @desc Physics behaviors constrain or modify the effects of the physics simulation on sets of physics bodies. For example, the SCNPhysicsHingeJoint behavior causes two bodies to move as if connected by a hinge that pivots around a specific axis, and the SCNPhysicsVehicle behavior causes a body to roll like a car or other wheeled vehicle.To use a behavior in your scene, follow these steps:Create SCNPhysicsBody objects and attach them to each node that participates in the behavior.Create and configure a behavior object joining the physics bodies. See SCNPhysicsBehavior for a list of behavior classes.Call addBehavior(_:) on your scene’s physics world object to add the behavior to the physics simulation.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsworld/1512839-addbehavior
   */


  addBehavior(behavior) {
    if (this._allBehaviors.indexOf(behavior) >= 0) {
      return;
    }

    this._allBehaviors.push(behavior);
  }
  /**
   * Removes a behavior from the physics world.
   * @access public
   * @param {SCNPhysicsBehavior} behavior - The behavior to be removed.
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsworld/1512870-removebehavior
   */


  removeBehavior(behavior) {
    const index = this._allBehaviors.indexOf(behavior);

    if (index < 0) {
      return;
    }

    this._allBehaviors.splice(index, 1);
  }
  /**
   * Removes all behaviors affecting bodies in the physics world.
   * @access public
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsworld/1512849-removeallbehaviors
   */


  removeAllBehaviors() {
    this._allBehaviors = [];
  }
  /**
   * The list of behaviors affecting bodies in the physics world.
   * @type {SCNPhysicsBehavior[]}
   * @desc 
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsworld/1512853-allbehaviors
   */


  get allBehaviors() {
    return this._allBehaviors.slice(0);
  } // Detecting Contacts Between Physics Bodies

  /**
   * Checks for contacts between two physics bodies.
   * @access public
   * @param {SCNPhysicsBody} bodyA - The first body (to test for contact with the second).
   * @param {SCNPhysicsBody} bodyB - The second body (to test for contact with the first).
   * @param {?Map<SCNPhysicsWorld.TestOption, Object>} [options = null] - A dictionary of options affecting the test, or nil to use default options. For applicable keys and the possible values, see Physics Test Options Keys.
   * @returns {SCNPhysicsContact[]} - 
   * @desc SceneKit sends messages to the physics world’s contactDelegate object only when collisions occur between bodies whose collisionBitMask and categoryBitMask properties overlap, and only for collisions between certain types of bodies. (For details, see SCNPhysicsBodyType.) Use this method to directly test for contacts between any two bodies at a time of your choosing. For example, to implement a game where the player character can pick up an item, you might call this method when the player presses the “pick up” button to see if the player character is in contact with the item to be picked up.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsworld/1512875-contacttestbetween
   */


  contactTestBetween(bodyA, bodyB, options = null) {
    // FIXME: use physics library
    if ((bodyA.categoryBitMask & bodyB.contactTestBitMask) === 0) {
      return [];
    }

    if (!bodyA.physicsShape || !bodyB.physicsShape) {
      return [];
    }

    if (bodyA.type === SCNPhysicsBodyType.static && bodyB.type === SCNPhysicsBodyType.static) {
      return [];
    }

    if (bodyA._position.sub(bodyB._position).length() > bodyA._radius + bodyB._radius) {
      return [];
    }

    const shapeA = bodyA.physicsShape._shape;
    const shapeB = bodyB.physicsShape._shape;

    if (shapeA instanceof SCNBox && shapeB instanceof SCNBox) {
      return SCNPhysicsWorld._contactTestBetweenBoxes(bodyA, bodyB, options);
    } else if (shapeA instanceof SCNBox && shapeB instanceof SCNSphere) {
      return SCNPhysicsWorld._contactTestBetweenBoxAndSphere(bodyA, bodyB, options);
    } else if (shapeB instanceof SCNBox && shapeA instanceof SCNSphere) {
      return SCNPhysicsWorld._contactTestBetweenBoxAndSphere(bodyB, bodyA, options, true);
    } else if (shapeA instanceof SCNSphere && shapeB instanceof SCNSphere) {
      return SCNPhysicsWorld._contactTestBetweenSpheres(bodyA, bodyB, options);
    }

    return [];
  }
  /**
   * @access private
   * @param {SCNPhysicsBody} boxA -
   * @param {SCNPhysicsBody} boxB -
   * @param {Object} options -
   * @returns {SCNPhysicsContact[]} -
   */


  static _contactTestBetweenBoxes(boxA, boxB, options) {
    const shapeA = boxA.physicsShape._shape;
    const shapeB = boxB.physicsShape._shape;

    const tb = boxB._transform.mult(boxA._invTransform);

    const nb1 = new SCNVector3(tb.m11, tb.m12, tb.m13).normalize();
    const nb2 = new SCNVector3(tb.m21, tb.m22, tb.m23).normalize();
    const nb3 = new SCNVector3(tb.m31, tb.m32, tb.m33).normalize();
    const b1 = nb1.mul(shapeB.width * 0.5);
    const b2 = nb2.mul(shapeB.height * 0.5);
    const b3 = nb3.mul(shapeB.length * 0.5);
    const d = tb.getTranslation();
    const lax = shapeA.width * 0.5;
    const lay = shapeA.height * 0.5;
    const laz = shapeA.length * 0.5; // Ae1

    let rA = lax;
    let rB = Math.abs(b1.x) + Math.abs(b2.x) + Math.abs(b3.x);
    let L = Math.abs(d.x);

    if (L > rA + rB) {
      return [];
    } // Ae2


    rA = lay;
    rB = Math.abs(b1.y) + Math.abs(b2.y) + Math.abs(b3.y);
    L = Math.abs(d.y);

    if (L > rA + rB) {
      return [];
    } // Ae3


    rA = laz;
    rB = Math.abs(b1.z) + Math.abs(b2.z) + Math.abs(b3.z);
    L = Math.abs(d.z);

    if (L > rA + rB) {
      return [];
    } // Be1


    rA = Math.abs(nb1.x * lax) + Math.abs(nb1.y * lay) + Math.abs(nb1.z * laz);
    rB = b1.length();
    L = Math.abs(d.dot(nb1));

    if (L > rA + rB) {
      return [];
    } // Be2


    rA = Math.abs(nb2.x * lax) + Math.abs(nb2.y * lay) + Math.abs(nb2.z * laz);
    rB = b2.length();
    L = Math.abs(d.dot(nb2));

    if (L > rA + rB) {
      return [];
    } // Be3


    rA = Math.abs(nb3.x * lax) + Math.abs(nb3.y * lay) + Math.abs(nb3.z * laz);
    rB = b3.length();
    L = Math.abs(d.dot(nb3));

    if (L > rA + rB) {
      return [];
    } // C11


    let axis = new SCNVector3(0, -nb1.z, nb1.y);
    rA = Math.abs(axis.y * lay) + Math.abs(axis.z * laz);
    rB = Math.abs(axis.dot(b2)) + Math.abs(axis.dot(b3));
    L = Math.abs(d.dot(axis));

    if (L > rA + rB) {
      return [];
    } // C12


    axis = new SCNVector3(0, -nb2.z, nb2.y);
    rA = Math.abs(axis.y * lay) + Math.abs(axis.z * laz);
    rB = Math.abs(axis.dot(b3)) + Math.abs(axis.dot(b1));
    L = Math.abs(d.dot(axis));

    if (L > rA + rB) {
      return [];
    } // C13


    axis = new SCNVector3(0, -nb3.z, nb3.y);
    rA = Math.abs(axis.y * lay) + Math.abs(axis.z * laz);
    rB = Math.abs(axis.dot(b1)) + Math.abs(axis.dot(b2));
    L = Math.abs(d.dot(axis));

    if (L > rA + rB) {
      return [];
    } // C21


    axis = new SCNVector3(nb1.z, 0, -nb1.x);
    rA = Math.abs(axis.x * lax) + Math.abs(axis.z * laz);
    rB = Math.abs(axis.dot(b2)) + Math.abs(axis.dot(b3));
    L = Math.abs(d.dot(axis));

    if (L > rA + rB) {
      return [];
    } // C22


    axis = new SCNVector3(nb2.z, 0, -nb2.x);
    rA = Math.abs(axis.x * lax) + Math.abs(axis.z * laz);
    rB = Math.abs(axis.dot(b3)) + Math.abs(axis.dot(b1));
    L = Math.abs(d.dot(axis));

    if (L > rA + rB) {
      return [];
    } // C23


    axis = new SCNVector3(nb3.z, 0, -nb3.x);
    rA = Math.abs(axis.x * lax) + Math.abs(axis.z * laz);
    rB = Math.abs(axis.dot(b1)) + Math.abs(axis.dot(b2));
    L = Math.abs(d.dot(axis));

    if (L > rA + rB) {
      return [];
    } // C31


    axis = new SCNVector3(-nb1.y, nb1.x, 0);
    rA = Math.abs(axis.x * lax) + Math.abs(axis.y * lay);
    rB = Math.abs(axis.dot(b2)) + Math.abs(axis.dot(b3));
    L = Math.abs(d.dot(axis));

    if (L > rA + rB) {
      return [];
    } // C32


    axis = new SCNVector3(-nb2.y, nb2.x, 0);
    rA = Math.abs(axis.x * lax) + Math.abs(axis.y * lay);
    rB = Math.abs(axis.dot(b3)) + Math.abs(axis.dot(b1));
    L = Math.abs(d.dot(axis));

    if (L > rA + rB) {
      return [];
    } // C33


    axis = new SCNVector3(-nb3.y, nb3.x, 0);
    rA = Math.abs(axis.x * lax) + Math.abs(axis.y * lay);
    rB = Math.abs(axis.dot(b1)) + Math.abs(axis.dot(b2));
    L = Math.abs(d.dot(axis));

    if (L > rA + rB) {
      return [];
    }

    const contact = new SCNPhysicsContact();
    contact._nodeA = boxA._node;
    contact._nodeB = boxB._node;
    contact._contactPoint = boxA._position.add(d.mul(0.5)); // TODO: implement

    contact._contactNormal = d.normalize(); // TODO: implement

    contact._penetrationDistance = 0; // TODO: implement

    return [contact];
  }
  /**
   * @access private
   * @param {SCNPhysicsBody} sphereA -
   * @param {SCNPhysicsBody} sphereB -
   * @param {Object} options -
   * @returns {SCNPhysicsContact[]} -
   */


  static _contactTestBetweenSpheres(sphereA, sphereB, options) {
    const shapeA = sphereA.physicsShape._shape;
    const shapeB = sphereB.physicsShape._shape;
    const posA = sphereA._position;
    const posB = sphereB._position;
    const radA = shapeA.radius;
    const radB = shapeB.radius;
    const vec = posA.sub(posB);
    const l = vec.length();

    if (l > radA + radB) {
      return [];
    }

    const contact = new SCNPhysicsContact();
    contact._nodeA = sphereA._node;
    contact._nodeB = sphereB._node;
    contact._contactPoint = posA.add(vec.mul((radA - radB + l) * 0.5));
    contact._contactNormal = vec.mul(-1).normalize();
    contact._penetrationDistance = radA + radB - l;
    return [contact];
  }
  /**
   * @access private
   * @param {SCNPhysicsBody} box -
   * @param {SCNPhysicsBody} sphere -
   * @param {Object} options -
   * @returns {SCNPhysicsContact[]} -
   */


  static _contactTestBetweenBoxAndSphere(box, sphere, reverse = false) {
    const boxShape = box.physicsShape._shape;
    const sphereShape = sphere.physicsShape._shape;

    const spherePos = sphere._position.transform(box._invTransform);

    const v = new SCNVector3();
    const w = boxShape.width * 0.5;
    const h = boxShape.height * 0.5;
    const l = boxShape.length * 0.5;

    if (Math.abs(spherePos.x) - w <= 0) {
      v.x = 0;
    } else {
      v.x = spherePos.x - w;
    }

    if (Math.abs(spherePos.y) - h <= 0) {
      v.y = 0;
    } else {
      v.y = spherePos.y - h;
    }

    if (Math.abs(spherePos.z) - l <= 0) {
      v.z = 0;
    } else {
      v.z = spherePos.z - l;
    }

    const d = v.length();

    if (d > sphereShape.radius) {
      return [];
    }

    const contact = new SCNPhysicsContact();

    if (reverse) {
      contact._nodeA = sphere._node;
      contact._nodeB = box._node;
    } else {
      contact._nodeA = box._node;
      contact._nodeB = sphere._node;
    }

    contact._contactPoint = v.transform(box._transform);
    contact._contactNormal = v.rotate(box._transform).normalize();

    if (reverse) {
      contact._contactNormal = contact._contactNormal.mul(-1);
    }

    contact._penetrationDistance = d - sphereShape.radius;
    return [contact];
  }
  /**
   * Checks for contacts between one physics body and any other bodies in the physics world.
   * @access public
   * @param {SCNPhysicsBody} body - The body to test for contact.
   * @param {?Map<SCNPhysicsWorld.TestOption, Object>} [options = null] - A dictionary of options affecting the test, or nil to use default options. For applicable keys and the possible values, see Physics Test Options Keys.
   * @returns {SCNPhysicsContact[]} - 
   * @desc SceneKit sends messages to the physics world’s contactdelegate object only when collisions occur between bodies whose collisionBitMask and categoryBitMask properties overlap, and only for collisions between certain types of bodies. (For details, see SCNPhysicsBodyType.) Use this method to directly test for all contacts between one body and any other bodies at a time of your choosing. For example, to implement a game with a “wall jump” effect, you could call this method when the player presses the jump button to see if the player character is in contact with any walls.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsworld/1512841-contacttest
   */


  contactTestWith(body, options = null) {
    return [];
  } // Searching for Physics Bodies

  /**
   * Searches for physics bodies along a line segment between two points in the physics world.
   * @access public
   * @param {SCNVector3} origin - An endpoint of the line segment to search, specified in the scene’s world coordinate system.
   * @param {SCNVector3} dest - The other endpoint of the line segment to search, specified in the scene’s world coordinate system.
   * @param {?Map<SCNPhysicsWorld.TestOption, Object>} [options = null] - A dictionary of options affecting the test, or nil to use default options. For applicable keys and the possible values, see Physics Test Options Keys.
   * @returns {SCNHitTestResult[]} - 
   * @desc Use this method to implement concepts such as line of sight in your app. For example, in a game you might implement behavior for an enemy character by searching for physics bodies along a line between the enemy character’s position and the player character’s position, as illustrated below:// Options: Look only for the closest object along line of sight,
  // and use the collision bitmask to avoid finding the enemy itself.
  NSDictionary *options = @{ SCNPhysicsTestSearchModeKey : SCNPhysicsTestSearchModeClosest,
                     SCNPhysicsTestCollisionBitMaskKey : @(kMyCategoryPlayer) };
  NSArray *results = [physicsWorld rayTestWithSegmentFromPoint:enemy.position
                                                     toPoint:player.position
                                                     options:options];
  if (results.firstObject.node == player) {
    // Enemy can see player: begin pursuit.
  } else {
    // Enemy cannot see player: remain idle.
  }
  // Options: Look only for the closest object along line of sight,
  // and use the collision bitmask to avoid finding the enemy itself.
  NSDictionary *options = @{ SCNPhysicsTestSearchModeKey : SCNPhysicsTestSearchModeClosest,
                     SCNPhysicsTestCollisionBitMaskKey : @(kMyCategoryPlayer) };
  NSArray *results = [physicsWorld rayTestWithSegmentFromPoint:enemy.position
                                                     toPoint:player.position
                                                     options:options];
  if (results.firstObject.node == player) {
    // Enemy can see player: begin pursuit.
  } else {
    // Enemy cannot see player: remain idle.
  }
    * @see https://developer.apple.com/documentation/scenekit/scnphysicsworld/1512857-raytestwithsegment
   */


  rayTestWithSegmentFromTo(origin, dest, options = null) {
    let opt = options;

    if (Array.isArray(options)) {
      opt = new Map(options);
    } else if (options === null) {
      opt = new Map();
    }

    const results = [];
    let backfaceCulling = true;
    let collisionBitMask = -1;
    let searchMode = _TestSearchMode.any;

    if (opt.has(_TestOption.backfaceCulling)) {
      backfaceCulling = opt.get(_TestOption.backfaceCulling);
    }

    if (opt.has(_TestOption.collisionBitMask)) {
      collisionBitMask = opt.get(_TestOption.collisionBitMask);
    }

    if (opt.has(_TestOption.searchMode)) {
      searchMode = opt.get(_TestOption.searchMode);
    } //return this._renderer._physicsHitTestByGPU(origin, dest, opt)


    this._scene.rootNode.enumerateChildNodes(child => {
      if (child.presentation && child.presentation.physicsBody && child.presentation.physicsBody.categoryBitMask & collisionBitMask) {
        const hits = SCNPhysicsWorld._hitTestWithSegmentPhysicsNode(origin, dest, child.presentation);

        if (hits.length > 0) {
          // convert from child's coordinate to this node's coordinate
          for (const h of hits) {
            h._node = child;
            h._worldCoordinates = child.convertPositionTo(h._localCoordinates, null);
            h._worldNormal = child.convertPositionTo(h._localNormal, null);
            h._localCoordinates = child.convertPositionFrom(h._localCoordinates, child);
            h._localNormal = child.convertPositionFrom(h._localNormal, child);
          }

          results.push(...hits);

          if (searchMode === _TestSearchMode.any) {
            // stop searching
            return true;
          }
        }
      }

      return false;
    });

    if (results.length === 0) {
      return results;
    }

    let sortedResults = results.sort((a, b) => a._distance - b._distance);

    if (searchMode === _TestSearchMode.closest) {
      sortedResults = [sortedResults[0]];
    }

    return sortedResults;
  }
  /**
   * Searches for physics bodies in the space formed by moving a convex shape through the physics world.
   * @access public
   * @param {SCNPhysicsShape} shape - A physics shape. This shape must enclose a convex volume. For details on creating shapes that satisfy this requirement, see SCNPhysicsShape.
   * @param {SCNMatrix4} from - A transform matrix representing the initial position and orientation of the shape.
   * @param {SCNMatrix4} to - A transform matrix representing the final position and orientation of the shape.
   * @param {?Map<SCNPhysicsWorld.TestOption, Object>} [options = null] - A dictionary of options affecting the test, or nil to use default options. For applicable keys and the possible values, see Physics Test Options Keys.
   * @returns {SCNPhysicsContact[]} - 
   * @desc Use this method when it’s important to plan for (or avoid) collisions ahead of the physics simulation. For example, in a game you might plan maneuvers for a flying character to fit through the gaps between static bodies in the physics world, as illustrated below:// Look for potential collisions along the spaceship's current path.
  SCNMatrix4 current = spaceship.transform;
  SCNMatrix4 upAhead = SCNMatrix4Translate(current, 0, 0, LOOK_AHEAD_DISTANCE);
  NSArray *contacts = [physicsWorld convexSweepTestWithShape:spaceship.physicsBody.physicsShape
                                             fromTransform:current
                                               toTransform:upAhead
                                                   options:nil];
  if (contacts.count == 0) {
    // Flight path looks okay.
  } else {
    // Flight path will cause a collision: look for another way around.
  }
  // Look for potential collisions along the spaceship's current path.
  SCNMatrix4 current = spaceship.transform;
  SCNMatrix4 upAhead = SCNMatrix4Translate(current, 0, 0, LOOK_AHEAD_DISTANCE);
  NSArray *contacts = [physicsWorld convexSweepTestWithShape:spaceship.physicsBody.physicsShape
                                             fromTransform:current
                                               toTransform:upAhead
                                                   options:nil];
  if (contacts.count == 0) {
    // Flight path looks okay.
  } else {
    // Flight path will cause a collision: look for another way around.
  }
    * @see https://developer.apple.com/documentation/scenekit/scnphysicsworld/1512859-convexsweeptest
   */


  convexSweepTestWith(shape, from, to, options = null) {
    // TODO: implement
    return [];
  } // Structures

  /**
   * @type {Object} TestOption
   * @property {string} backfaceCulling The key for choosing whether to ignore back-facing polygons in physics shapes when searching for contacts.
   * @property {string} collisionBitMask The key for selecting which categories of physics bodies that SceneKit should test for contacts.
   * @property {string} searchMode The key for selecting the number and order of contacts to be tested.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsworld.testoption
   */


  static get TestOption() {
    return _TestOption;
  }
  /**
   * @type {Object} TestSearchMode
   * @property {string} all Searches should return all contacts matching the search parameters.
   * @property {string} any Searches should return only the first contact found regardless of its position relative to the search parameters.
   * @property {string} closest Searches should return only the closest contact to the beginning of the search.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsworld.testsearchmode
   */


  static get TestSearchMode() {
    return _TestSearchMode;
  }

  _simulate(time) {
    // FIXME: use physics library
    //this._world.stepSimulation(1.0/60.0, 0)
    if (!this._renderer) {
      return;
    }

    const objects = this._renderer._createRenderingPhysicsNodeArray();

    const contacts = [];

    for (const obj of objects) {
      const body = obj.physicsBody;
      body._prevPosition = body._position;

      if (body.type === SCNPhysicsBodyType.kinematic) {
        body._resetTransform();
      } else if (body.type === SCNPhysicsBodyType.dynamic) ;

      body._positionDiff = body._position.sub(body._prevPosition);
    }

    for (let i = 0; i < objects.length; i++) {
      const bodyA = objects[i].presentation.physicsBody;

      if (bodyA.physicsShape._sourceGeometry instanceof SCNCapsule) {
        contacts.push(...SCNPhysicsWorld._capsuleTestWithObjects(bodyA, objects));
      }

      for (let j = 0; j < objects.length; j++) {
        if (i === j) {
          continue;
        }

        const bodyB = objects[j].presentation.physicsBody;
        contacts.push(...this.contactTestBetween(bodyA, bodyB));
      }
    }

    if (this.contactDelegate) {
      for (const contact of contacts) {
        if (this.contactDelegate.physicsWorldDidBegin) {
          this.contactDelegate.physicsWorldDidBegin(this, contact);
        }
      } // TODO: callback
      // this.contactDelegate.physicsWorldDidUpdate
      // this.contactDelegate.physicsWorldDidEnd

    }

    for (const obj of objects) {
      const body = obj.physicsBody;
      body._prevPosition = body._position;
    }
  }
  /**
   * @access private
   * @param {SCNPhysicsBody} body -
   * @param {SCNNode[]} objects -
   * @returns {SCNPhysicsContact[]} -
   */


  static _capsuleTestWithObjects(body, objects) {
    const result = [];
    const objs = objects.filter(obj => {
      const bodyB = obj.presentation.physicsBody;

      if (bodyB === body) {
        return false;
      }

      if (bodyB.physicsShape._type !== SCNPhysicsShape.ShapeType.concavePolyhedron) {
        return false;
      }

      if ((body.categoryBitMask & bodyB.contactTestBitMask) !== 0) {
        return true;
      }

      if ((bodyB.categoryBitMask & body.contactTestBitMask) !== 0) {
        return true;
      }

      return false;
    });

    if (objs.length === 0) {
      return result;
    }

    const bodyTransform = body._node._worldTransform;
    const capsule = body.physicsShape._sourceGeometry;

    for (const obj of objs) {
      if (!this._intersectsBoundingBox(body._node, obj)) {
        continue;
      }

      const contacts = this._contactTestCapsuleAndConcave(body._node, obj);

      result.push(...contacts);
    }

    return result;
  }
  /**
   *
   * @access private
   * @param {SCNNode} node1 -
   * @param {SCNNode} node2 -
   * @returns {boolean} -
   */


  static _intersectsBoundingBox(node1, node2) {
    const pos1 = node1._worldTranslation;
    const pos2 = node2._worldTranslation;
    const geo1 = node1.physicsBody.physicsShape._sourceGeometry;
    const geo2 = node2.physicsBody.physicsShape._sourceGeometry;

    if (!geo1 || !geo2) {
      return false;
    }

    const box1 = geo1.boundingBox;
    const box2 = geo2.boundingBox;

    if (box1.min.x + pos1.x > box2.max.x + pos2.x || box1.max.x + pos1.x < box2.min.x + pos2.x) {
      return false;
    }

    if (box1.min.y + pos1.y > box2.max.y + pos2.y || box1.max.y + pos1.y < box2.min.y + pos2.y) {
      return false;
    }

    if (box1.min.z + pos1.z > box2.max.z + pos2.z || box1.max.z + pos1.z < box2.min.z + pos2.z) {
      return false;
    }

    return true;
  }
  /**
   * @access private
   * @param {SCNNode} capNode - the node which has a capsule physicsShape
   * @param {SCNNode} conNode - the node which has a concave physicsShape
   * @returns {SCNPhysicsContact[]} -
   */


  static _contactTestCapsuleAndConcave(capNode, conNode) {
    const result = [];
    const capBody = capNode.physicsBody;
    const conBody = conNode.physicsBody;
    const capsule = capBody.physicsShape._sourceGeometry;
    const concave = conBody.physicsShape._sourceGeometry;

    const transform = capBody._transform.mult(conBody._invTransform);

    const capSize = capsule.capRadius;
    const capHeight = capsule.height * 0.5 - capSize;

    const capV = capBody._positionDiff.rotate(transform).normalize();

    const p0 = new SCNVector3(0, capHeight, 0).transform(transform);
    const p1 = new SCNVector3(0, -capHeight, 0).transform(transform);
    const elems = concave.geometryElements;
    const vert = concave.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.vertex)[0];

    for (const elem of elems) {
      if (elem._primitiveType !== SCNGeometryPrimitiveType.triangles) {
        // TODO: support other primitive types.
        continue;
      }

      const edata = elem._data;
      const elen = elem._primitiveCount;
      let ind = 0; //console.warn(`    elen = ${elen}`)

      for (let i = 0; i < elen; i++) {
        const v0 = vert._scnVectorAt(edata[ind]);

        const v1 = vert._scnVectorAt(edata[ind + 1]);

        const v2 = vert._scnVectorAt(edata[ind + 2]);

        ind += 3; //const n = this._normalOfTriangle(v0, v1, v2)
        //if(n.dot(capV) >= 0){
        //  continue
        //}

        const contactInfo = this._capsuleTriangleContact(p0, p1, capSize, v0, v1, v2);

        if (contactInfo) {
          const contact = new SCNPhysicsContact();
          contact._nodeA = capNode;
          contact._nodeB = conNode;
          contact._contactPoint = contactInfo.point;
          contact._contactNormal = contactInfo.normal;
          contact._penetrationDistance = contactInfo.penetration;
          result.push(contact);
        }
      }
    } //console.warn(`    result length = ${result.length}`)


    return result;
  } // http://marupeke296.com/COL_3D_No27_CapsuleCapsule.html

  /**
   * 
   * @access private
   * @param {SCNVector3} p0 - position of an edge of the capsule (in the triangle's coordinate)
   * @param {SCNVector3} p1 - position of another edge of the capsule (in the triangle's coordinate)
   * @param {number} capSize - capsule radius
   * @param {SCNVector3} v0 - vertex position (in the triangle's coordinate)
   * @param {SCNVector3} v1 - vertex position (in the triangle's coordinate)
   * @param {SCNVector3} v2 - vertex position (in the triangle's coordinate)
   * @returns {?Object} -
   *    {SCNVector3} point -
   *    {SCNVector3} normal -
   *    {number} distance -
   */


  static _capsuleTriangleContact(p0, p1, capSize, v0, v1, v2) {
    const seg = p1.sub(p0);

    const segTri = this._segmentTriangleIntersection(p0, p1, v0, v1, v2);

    if (segTri.intersection) {
      let penetration = 0;

      if (segTri.d0 < 0) {
        penetration = capSize - segTri.d0;
      } else {
        penetration = capSize - segTri.d1;
      }

      return {
        point: segTri.intersection,
        normal: segTri.normal,
        distance: 0,
        penetration: penetration
      };
    }

    const d0 = this._segmentSegmentDist(p0, p1, v0, v1);

    let min = d0;

    const d1 = this._segmentSegmentDist(p0, p1, v1, v2);

    if (d1.distance < min.distance) {
      min = d1;
    }

    const d2 = this._segmentSegmentDist(p0, p1, v2, v0);

    if (d2.distance < min.distance) {
      min = d2;
    }

    const h0 = p0.add(segTri.normal.mul(-segTri.d0));

    if (this._pointIsInsideTriangle(h0, v0, v1, v2)) {
      if (Math.abs(segTri.d0) < min.distance) {
        min.distance = Math.abs(segTri.d0);
        min.nearestPos1 = h0;
      }
    }

    const h1 = p1.add(segTri.normal.mul(-segTri.d1));

    if (this._pointIsInsideTriangle(h1, v0, v1, v2)) {
      if (Math.abs(segTri.d1) < min.distance) {
        min.distance = Math.abs(segTri.d1);
        min.nearestPos1 = h1;
      }
    }

    if (min.distance < capSize) {
      return {
        point: min.nearestPos1,
        normal: segTri.normal,
        distance: 0,
        penetration: capSize - min.distance
      };
    }

    return null;
  }
  /**
   *
   * @access private
   * @param {SCNVector3} p0 - an edge of the segment
   * @param {SCNVector3} p1 - another edge of the segment
   * @param {SCNVector3} v0 - the first point of the vertex
   * @param {SCNVector3} v1 - the second point of the vertex
   * @param {SCNVector3} v2 - the third point of the vertex
   * @returns {Object} -
   *    {SCNVector3} normal - normal vector of the vertex
   *    {number} d0 - distance between p0 and the plane which contains the vertex
   *    {number} d1 - distance between p1 and the plane which contains the vertex
   *    {?SCNVector3} intersection - intersection point of the segment and the vertex
   */


  static _segmentTriangleIntersection(p0, p1, v0, v1, v2) {
    const v0p0 = p0.sub(v0);
    const v0p1 = p1.sub(v0);

    const n = this._normalOfTriangle(v0, v1, v2);

    const d0 = v0p0.dot(n);
    const d1 = v0p1.dot(n);
    const result = {
      normal: n,
      d0: d0,
      d1: d1,
      intersection: null
    };

    if (d0 * d1 > 0) {
      return result;
    }

    const t = d0 / (d0 - d1);
    const h = v0p0.mul(1 - t).add(v0p1.mul(t)).add(v0);

    if (!this._pointIsInsideTriangle(h, v0, v1, v2)) {
      return result;
    }

    result.intersection = h;
    return result;
  }
  /**
   * 
   * @access private
   * @param {SCNVector3} p0 - the first point of the triangle
   * @param {SCNVector3} p1 - the second point of the triangle
   * @param {SCNVector3} p2 - the third point of the triangle
   * @returns {SCNVector3} - normal vector (normalized)
   */


  static _normalOfTriangle(p0, p1, p2) {
    const v1 = p1.sub(p0);
    const v2 = p2.sub(p0);
    return v1.cross(v2).normalize();
  }
  /**
   * 
   * @access private
   * @param {SCNVector3} p - point
   * @param {SCNVector3} p0 - the first point of the triangle
   * @param {SCNVector3} p1 - the second point of the triangle
   * @param {SCNVector3} p2 - the third point of the triangle
   * @returns {boolean} - true if the point is in the triangle.
   */


  static _pointIsInsideTriangle(p, p0, p1, p2) {
    const n = this._normalOfTriangle(p0, p1, p2);

    const v0 = p1.sub(p0).cross(n).dot(p.sub(p0));
    const v1 = p2.sub(p1).cross(n).dot(p.sub(p1));
    const v2 = p0.sub(p2).cross(n).dot(p.sub(p2));

    if (v0 < 0 && v1 < 0 && v2 < 0) {
      return true;
    }

    if (v0 > 0 && v1 > 0 && v2 > 0) {
      return true;
    }

    return false;
  }
  /**
   * 
   * @access private
   * @param {SCNVector3} p - point
   * @param {SCNVector3} lp - a point on the line
   * @param {SCNVector3} lv - line vector
   * @returns {Object} -
   *    {number} coeff -
   *    {SCNVector3} nearestPos -
   *    {number} distance -
   */


  static _pointLineDist(p, lp, lv) {
    const len2 = lv.length2();
    let t = 0;

    if (len2 > 0) {
      t = lv.dot(p.sub(lp)) / len2;
    }

    const h = lp.add(lv.mul(t));
    const d = h.sub(p).length();
    return {
      coeff: t,
      nearestPos: h,
      distance: d
    };
  }
  /**
   *
   * @access private
   * @param {SCNVector3} p - point
   * @param {SCNVector3} s0 - an edge of the segment
   * @param {SCNVector3} s1 - another edge of the segment
   * @returns {Object} -
   *    {number} coeff -
   *    {SCNVector3} nearestPos -
   *    {number} distance -
   */


  static _pointSegmentDist(p, s0, s1) {
    const lv = s1.sub(s0);

    const plDist = this._pointLineDist(p, s0, lv);

    if (plDist.coeff < 0) {
      const d = s0.sub(p).length();
      return {
        coeff: plDist.coeff,
        nearestPos: s0,
        distance: d
      };
    } else if (plDist.coeff > 1) {
      const d = s1.sub(p).length();
      return {
        coeff: plDist.coeff,
        nearestPos: s1,
        distance: d
      };
    }

    return plDist;
  }
  /**
   *
   * @access private
   * @param {SCNVector3} p0 - a point on the first line
   * @param {SCNVector3} v0 - a line vector
   * @param {SCNVector3} p1 - a point on the second line
   * @param {SCNVector3} v1 - a line vector
   * @returns {Object} -
   *    {number} coeff0 -
   *    {SCNVector3} nearestPos0 - 
   *    {number} coeff1 -
   *    {SCNVector3} nearestPos1 -
   *    {number} distance -
   */


  static _lineLineDist(p0, v0, p1, v1) {
    if (this._isParallel(v0, v1)) {
      const plDist = this._pointLineDist(p0, p1, v1);

      return {
        coeff0: 0,
        nearestPos0: p0,
        coeff1: plDist.coeff,
        nearestPos1: plDist.nearestPos,
        distance: plDist.distance
      };
    }

    const v01 = v0.dot(v1);
    const v00 = v0.dot(v0);
    const v11 = v1.dot(v1);
    const p10 = p0.sub(p1);
    const coeff0 = (v01 * v1.dot(p10) - v11 * v0.dot(p10)) / (v00 * v11 - v01 * v01);
    const np0 = p0.add(v0.mul(coeff0));
    const coeff1 = v1.dot(np0.sub(p1)) / v11;
    const np1 = p1.add(v1.mul(coeff1));
    const d = np1.sub(np0).length();
    return {
      coeff0: coeff0,
      nearestPos0: np0,
      coeff1: coeff1,
      nearestPos1: np1,
      distance: d
    };
  }
  /**
   *
   * @access private
   * @param {SCNVector3} v0 - line vector
   * @param {SCNVector3} v1 - line vector
   * @returns {boolean} - true if the lines are parallel
   */


  static _isParallel(v0, v1) {
    const l = v0.cross(v1).length2();
    return l < 0.0000000000001;
  }
  /**
   * 
   * @access private
   * @param {number} -
   * @returns {number} -
   */


  static _clamp(val) {
    if (val < 0) {
      return 0;
    }

    if (val > 1) {
      return 1;
    }

    return val;
  }
  /**
   *
   * @access private
   * @param {SCNVector3} s00 - an edge of the first segment
   * @param {SCNVector3} s01 - another edge of the first segment
   * @param {SCNVector3} s10 - an edge of the second segment
   * @param {SCNVector3} s11 - another edge of the second segment
   * @returns {Object} -
   *    {number} coeff0 -
   *    {SCNVector3} nearestPos0 -
   *    {number} coeff1 -
   *    {SCNVector3} nearestPos1 -
   *    {number} distance -
   */


  static _segmentSegmentDist(s00, s01, s10, s11) {
    const v0 = s01.sub(s00);
    const v1 = s11.sub(s10);
    let dist = null;

    if (this._isParallel(v0, v1)) {
      dist = this._pointSegmentDist(s00, s10, s11);

      if (0.0 <= dist.coeff && dist.coeff <= 1.0) {
        return {
          coeff0: 0.0,
          nearestPos0: s00,
          coeff1: dist.coeff,
          nearestPos1: dist.nearestPos,
          distance: dist.distance
        };
      }

      dist.coeff0 = 0.0;
      dist.coeff1 = dist.coeff;
    } else {
      dist = this._lineLineDist(s00, v0, s10, v1);

      if (0.0 <= dist.coeff0 && dist.coeff0 <= 1.0 && 0.0 <= dist.coeff1 && dist.coeff1 <= 1.0) {
        return dist;
      }
    }

    let dist2 = dist;

    const t0 = this._clamp(dist.coeff0);

    if (t0 !== dist.coeff0) {
      const p0 = s00.add(v0.mul(t0));
      dist2 = this._pointSegmentDist(p0, s10, s11);

      if (0.0 <= dist2.coeff && dist2.coeff <= 1.0) {
        return {
          coeff0: t0,
          nearestPos0: p0,
          coeff1: dist2.coeff,
          nearestPos1: dist2.nearestPos,
          distance: dist2.distance
        };
      }

      dist2.coeff1 = dist2.coeff;
    }

    const t1 = this._clamp(dist2.coeff1);

    const p1 = s10.add(v1.mul(t1));

    const dist3 = this._pointSegmentDist(p1, s00, s01);

    if (0.0 <= dist3.coeff && dist3.coeff <= 1.0) {
      return {
        coeff0: dist3.coeff,
        nearestPos0: dist3.nearestPos,
        coeff1: t1,
        nearestPos1: p1,
        distance: dist3.distance
      };
    }

    const t = this._clamp(dist3.coeff);

    const p = s00.add(v0.mul(t));
    const d = p1.sub(p).length();
    return {
      coeff0: t,
      nearestPos0: p,
      coeff1: t1,
      nearestPos1: p1,
      distance: d
    };
  }
  /**
   * @access private
   * @param {SCNVector3} p0 - An endpoint of the line segment to test, specified in the world coordinate system.
   * @param {SCNVector3} p1 - The other endpoint of the line segment to test, specified in the world coordinate system.
   * @param {SCNNode} node -
   * @returns {SCNHitTestResult[]} -
   */


  static _hitTestWithSegmentNode(pointA, pointB, node) {
    let n = node;

    if (node.presentation && node.presentation.geometry) {
      n = node.presentation;
    }

    const geo = n.geometry;

    if (!geo) {
      return [];
    }

    const pA = n.convertPositionFrom(pointA, null);
    const pB = n.convertPositionFrom(pointB, null); //if(this._segmentBoundingBoxIntersects(pA, pB, geo.boundingBox) !== null){

    const r = this._segmentBoundingBoxIntersects(pA, pB, geo.boundingBox);

    if (r !== null) {
      console.error('segmentBoundingBoxIntersects: ' + r.near + ', ' + r.far);
      return this._hitTestWithSegmentGeometry(pA, pB, geo);
    }

    return [];
  }
  /**
   * @access private
   * @param {SCNVector3} p0 - An endpoint of the line segment to test, specified in the world coordinate system.
   * @param {SCNVector3} p1 - The other endpoint of the line segment to test, specified in the world coordinate system.
   * @param {SCNNode} node -
   * @returns {SCNHitTestResult[]} -
   */


  static _hitTestWithSegmentPhysicsNode(pointA, pointB, node) {
    let n = node;

    if (node.presentation && node.presentation.physicsBody) {
      n = node.presentation;
    }

    const body = n.physicsBody;

    if (body === null) {
      return [];
    }

    const shape = body.physicsShape;

    if (shape === null) {
      return [];
    }

    const geo = shape._sourceGeometry;

    if (geo === null) {
      return [];
    }

    const pA = pointA.transform(body._invTransform);
    const pB = pointB.transform(body._invTransform);

    const r = this._segmentBoundingBoxIntersects(pA, pB, geo.boundingBox);

    if (r !== null) {
      return this._hitTestWithSegmentGeometry(pA, pB, geo);
    }

    return [];
  }
  /**
   * @access private
   * @param {SCNVector3} pointA -
   * @param {SCNVector3} pointB -
   * @param {Object} boundingBox -
   * @results {?Object} -
   */


  static _segmentBoundingBoxIntersects(pointA, pointB, boundingBox) {
    const v = pointB.sub(pointA);

    const r = this._lineBoundingBoxIntersects(pointA, v, boundingBox);

    if (r === null) {
      return null;
    }

    if (r.near > 1 || r.far < 0) {
      return null;
    }

    return r;
  }
  /**
   * @access private
   * @param {SCNVector3} p - a point on the line
   * @param {SCNVector3} v - line vector
   * @param {Object} boundingBox -
   * @returns {?Object} -
   */


  static _lineBoundingBoxIntersects(p, v, boundingBox) {
    const epsilon = 0.000001;
    const odd = new SCNVector3(1.0 / v.x, 1.0 / v.y, 1.0 / v.z);
    const bmin = boundingBox.min;
    const bmax = boundingBox.max;
    const t1 = bmin.sub(p).mulv(odd);
    const t2 = bmax.sub(p).mulv(odd);
    let near = -Infinity;
    let far = Infinity;

    if (Math.abs(v.x) < epsilon) {
      if (p.x < bmin.x || bmax.x < p.x) {
        return null;
      }
    } else if (t1.x < t2.x) {
      near = Math.max(near, t1.x);
      far = Math.min(far, t2.x);
    } else {
      near = Math.max(near, t2.x);
      far = Math.min(far, t1.x);
    }

    if (Math.abs(v.y) < epsilon) {
      if (p.y < bmin.y || bmax.y < p.y) {
        return null;
      }
    } else if (t1.y < t2.y) {
      near = Math.max(near, t1.y);
      far = Math.min(far, t2.y);
    } else {
      near = Math.max(near, t2.y);
      far = Math.min(far, t1.y);
    }

    if (Math.abs(v.z) < epsilon) {
      if (p.z < bmin.z || bmax.z < p.z) {
        return null;
      }
    } else if (t1.z < t2.z) {
      near = Math.max(near, t1.z);
      far = Math.min(far, t2.z);
    } else {
      near = Math.max(near, t2.z);
      far = Math.min(far, t1.z);
    }

    if (near > far) {
      return null;
    }

    return {
      near: near,
      far: far
    };
  }
  /**
   * @access private
   * @param {SCNVector3} p0 - An endpoint of the line segment to test, specified in the geometry's local coordinate system.
   * @param {SCNVector3} p1 - The other endpoint of the line segment to test, specified in the geometry's local coordinate system.
   * @param {SCNGeometry} geometry -
   * @returns {SCNHitTestResult[]} -
   */


  static _hitTestWithSegmentGeometry(pointA, pointB, geometry) {
    const results = [];
    const elems = geometry.geometryElements;
    const elemCount = elems.length;
    const vert = geometry.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.vertex)[0];

    for (let i = 0; i < elemCount; i++) {
      const elem = elems[i];

      if (elem._primitiveType !== SCNGeometryPrimitiveType.triangles) {
        // TODO: support other primitive types.
        continue;
      }

      const edata = elem._data;
      const elen = elem._primitiveCount;
      let ind = 0;

      for (let j = 0; j < elen; j++) {
        const v0 = vert._scnVectorAt(edata[ind]);

        const v1 = vert._scnVectorAt(edata[ind + 1]);

        const v2 = vert._scnVectorAt(edata[ind + 2]);

        ind += 3;

        const r = this._segmentTriangleIntersection(pointA, pointB, v0, v1, v2);

        if (r.intersection) {
          const result = new SCNHitTestResult();
          result._geometryIndex = i;
          result._faceIndex = j;
          result._localCoordinates = r.intersection;
          result._localNormal = r.normal;
          result._distance = r.intersection.sub(pointA).length();
          results.push(result);
        }
      }
    }

    return results;
  }

}

const _localFront = new SCNVector3(0, 0, 1);

const _localRight = new SCNVector3(1, 0, 0);

const _localUp = new SCNVector3(0, 1, 0);
/**
 * A structural element of a scene graph, representing a position and transform in a 3D coordinate space, to which you can attach geometry, lights, cameras, or other displayable content.
 * @access public
 * @extends {NSObject}
 * @implements {SCNActionable}
 * @implements {SCNAnimatable}
 * @implements {SCNBoundingVolume}
 * @see https://developer.apple.com/documentation/scenekit/scnnode
 */


class SCNNode extends NSObject {
  static get _propTypes() {
    return {
      name: 'string',
      light: 'SCNLight',
      camera: 'SCNCamera',
      geometry: ['SCNGeometry', (obj, value) => {
        obj.geometry = value;
        obj.boundingBox = value.boundingBox;
      }],
      morpher: 'SCNMorpher',
      skinner: 'SCNSkinner',
      categoryBitMask: 'integer',
      paused: ['boolean', 'isPaused'],
      position: ['SCNVector3', '_position'],
      rotation: ['SCNVector4', '_rotation'],
      orientation: ['SCNVector4', (obj, value) => {
        obj.orientation = value;
      }],
      scale: ['SCNVector3', '_scale'],
      hidden: ['boolean', 'isHidden'],
      opacity: ['float', '_opacity'],
      renderingOrder: 'integer',
      castsShadow: 'boolean',
      childNodes: ['NSArray', (obj, childNodes) => {
        childNodes.forEach(child => {
          if (child) {
            obj.addChildNode(child);
          }
        });
      }],
      physicsBody: ['SCNPhysicsBody', (obj, body) => {
        obj.physicsBody = body;
      }],
      physicsField: 'SCNPhysicsField',
      particleSystem: ['NSArray', '_particleSystems'],
      animations: ['NSMutableDictionary', (obj, anims) => {
        this._loadAnimationArray(obj, anims);

        obj._setAnimationsToPlayers();
      }],
      'animation-keys': ['NSMutableArray', (obj, keys) => {
        obj._animationPlayers._keys = keys;
      }],
      'animation-players': ['NSMutableArray', (obj, players) => {
        obj._animationPlayers._values = players;

        obj._setAnimationsToPlayers();
      }],
      'action-keys': ['NSArray', null],
      actions: ['NSMutableDictionary', (obj, acts) => {
        this._loadActionArray(obj, acts);
      }],
      eulerAngles: ['SCNVector3', (obj, value) => {
        obj.eulerAngles = value;
      }],
      movabilityHint: 'integer',
      clientAttributes: ['NSMutableDictionary', null],
      nodeID: ['string', '_nodeID'],
      entityID: ['string', '_entityID']
    };
  } // Creating a Node

  /**
   * Creates and returns a node object with the specified geometry attached.
   * @access public
   * @constructor
   * @param {?SCNGeometry} [geometry = null] - The geometry to be attached.
   * @see https://developer.apple.com/documentation/scenekit/scnnode/1408020-init
   */


  constructor(geometry = null) {
    super(); // Managing Node Attributes

    /**
     * A name associated with the node.
     * @type {?string}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1408014-name
     */

    this.name = null;
    /**
     * The light attached to the node.
     * @type {?SCNLight}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1408004-light
     */

    this.light = null;
    /**
     * The camera attached to the node.
     * @type {?SCNCamera}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407976-camera
     */

    this.camera = null;
    /**
     * The geometry attached to the node.
     * @type {?SCNGeometry}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407966-geometry
     */

    this._geometry = geometry;
    /**
     * The morpher object responsible for blending the node’s geometry.
     * @type {?SCNMorpher}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1408022-morpher
     */

    this.morpher = null;
    /**
     * The skinner object responsible for skeletal animations of node’s contents.
     * @type {?SCNSkinner}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407953-skinner
     */

    this.skinner = null;
    /**
     * A mask that defines which categories the node belongs to.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407994-categorybitmask
     */

    this.categoryBitMask = 0; // Working With Node Animation

    /**
     * A Boolean value that determines whether to run actions and animations attached to the node and its child nodes.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407962-ispaused
     */

    this.isPaused = false;
    /**
     * A node object representing the state of the node as it currently appears onscreen.
     * @type {SCNNode}
     * @access private
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1408030-presentation
     */

    this._presentation = null;
    /**
     * 
     * @type {boolean}
     * @access private
     */

    this._isPresentationInstance = false; // Managing the Node’s Transformation

    /**
     * The transformation applied to the node relative to its parent. Animatable.
     * @type {SCNMatrix4}
     * @access private
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407964-transform
     */

    this._transform = new SCNMatrix4();
    this._worldTransform = new SCNMatrix4();
    /**
     * 
     * @type {boolean}
     * @access private
     */

    this._transformUpToDate = false;
    /**
     * The translation applied to the node. Animatable.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1408026-position
     */

    this._position = new SCNVector3(0, 0, 0);
    /**
     * The node’s orientation, expressed as a rotation angle about an axis. Animatable.
     * @type {SCNVector4}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1408034-rotation
     */

    this._rotation = new SCNVector4(1, 0, 0, 0);
    /**
     * The node’s orientation, expressed as pitch, yaw, and roll angles, each in radians. Animatable.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407980-eulerangles
     */
    //this.eulerAngles = null

    /**
     * The node’s orientation, expressed as a quaternion. Animatable.
     * @type {SCNQuaternion}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1408048-orientation
     */
    //this.orientation = null

    /**
     * The scale factor applied to the node. Animatable.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1408050-scale
     */

    this._scale = new SCNVector3(1, 1, 1);
    /**
     * The pivot point for the node’s position, rotation, and scale. Animatable.
     * @type {SCNMatrix4}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1408044-pivot
     */

    this.pivot = null;
    /**
     * A list of constraints affecting the node’s transformation.
     * @type {?SCNConstraint[]}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1408016-constraints
     */

    this.constraints = null; //this._worldTransform = null
    // Modifying the Node Visibility

    /**
     * A Boolean value that determines the visibility of the node’s contents. Animatable.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407967-ishidden
     */

    this.isHidden = false;
    /**
     * The opacity value of the node. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1408010-opacity
     */

    this._opacity = 1;
    this._worldOpacity = 1;
    /**
     * The order the node’s content is drawn in relative to that of other nodes.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407978-renderingorder
     */

    this.renderingOrder = 0;
    /**
     * A Boolean value that determines whether SceneKit renders the node’s contents into shadow maps.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407955-castsshadow
     */

    this.castsShadow = false;
    /**
     * A value that indicates how SceneKit should handle the node when rendering movement-related effects.
     * @type {SCNMovabilityHint}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1690499-movabilityhint
     */

    this.movabilityHint = SCNMovabilityHint.fixed; // Managing the Node Hierarchy

    /**
     * The node’s parent in the scene graph hierarchy.
     * @type {?SCNNode}
     * @access private
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407968-parent
     */

    this._parent = null;
    /**
     * An array of the node’s children in the scene graph hierarchy.
     * @type {SCNNode[]}
     * @access private
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407984-childnodes
     */

    this._childNodes = []; // Customizing Node Rendering

    /**
     * An array of Core Image filters to be applied to the rendered contents of the node.
     * @type {?CIFilter[]}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407949-filters
     */

    this.filters = null;
    /**
     * An object responsible for rendering custom contents for the node using Metal or OpenGL.
     * @type {?SCNNodeRendererDelegate}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1408012-rendererdelegate
     */

    this.rendererDelegate = null; // Adding Physics to a Node

    /**
     * The physics body associated with the node.
     * @type {?SCNPhysicsBody}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407988-physicsbody
     */

    this._physicsBody = null;
    /**
     * The physics field associated with the node.
     * @type {?SCNPhysicsField}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1408006-physicsfield
     */

    this.physicsField = null; // Working With Particle Systems

    this._particleSystems = null; // Working With Positional Audio

    this._audioPlayers = [];
    /**
     * 
     * @type {?GKEntity}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/2873004-entity
     */

    this.entity = null;
    /**
     * 
     * @type {SCNNodeFocusBehavior}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/2881853-focusbehavior
     */

    this.focusBehavior = null; ///////////////////
    // SCNActionable //
    ///////////////////
    // Inspecting a Node’s Running Action
    //this._hasActions = false

    /**
     * @access private
     * @type {Map}
     */

    this._actions = new Map(); ///////////////////
    // SCNAnimatable //
    ///////////////////

    /**
     * @access private
     * @type {SCNOrderedDictionary}
     */

    this._animations = new SCNOrderedDictionary();
    /**
     * @access private
     * @type {SCNOrderedDictionary}
     */

    this._animationPlayers = new SCNOrderedDictionary(); ///////////////////////
    // SCNBoundingVolume //
    ///////////////////////
    // Working with Bounding Volumes

    /**
     * The minimum and maximum corner points of the object’s bounding box.
     * @type {{min: SCNVector3, max: SCNVector3}}
     * @see https://developer.apple.com/documentation/scenekit/scnboundingvolume/2034705-boundingbox
     */

    this._boundingBox = null;
    this._fixedBoundingBox = null; //this._boundingSphere = null

    /**
     * @access private
     * @type {?string}
     */

    this._entityID = null;
    /**
     * @access private
     * @type {?string}
     */

    this._nodeID = null;

    this._updateBoundingBox();
    /**
     * @access private
     * @type {Promise}
     */


    this._loadedPromise = null;
  }

  static _loadAnimationArray(node, animations) {
    //console.log('_loadAnimationArray start')
    for (const animName of Object.keys(animations)) {
      const data = animations[animName];

      const animation = this._loadAnimationData(data, animName);

      node.addAnimationForKey(animation, animName);
    } //console.log('_loadAnimationArray done')

  }

  static _loadAnimationData(data, key) {
    //console.log(`_loadAnimationData ${key} start`)
    if (data.class === 'group') {
      return this._loadAnimationGroup(data);
    } else if (data.class === 'keyframe') {
      return this._loadKeyframeAnimation(data.animation, key);
    } else if (data.class === 'basic') {
      const keyPath = data.keyPath || key;
      return this._loadBasicAnimation(data.animation, keyPath);
    } else if (data.type === 'keyframedAnimation') {
      return this._loadKeyframeAnimation(data, key);
    } //console.error(`unknown animation class: ${data.class}, type: ${data.type}, key: ${key}`)


    throw new Error(`unknown animation class: ${data.class}, type: ${data.type}, key: ${key}`);
  }

  static _loadAnimationGroup(animation) {
    //console.log('_loadAnimationGroup start')
    const group = new CAAnimationGroup();
    const data = animation.animation;
    group.isRemovedOnCompletion = Boolean(animation.removeOnCompletion); // group.timingFunction
    // group.delegate

    group.usesSceneTimeBase = Boolean(animation.usesSceneTimeBase);
    group.fadeInDuration = data.fadeInDuration;
    group.fadeOutDuration = data.fadeOutDuration;
    group.beginTime = data.beginTime;
    group.timeOffset = data.timeOffset;
    group.repeatCount = data.repeatCount; // group.repeatDuration

    group.duration = data.duration;
    group.speed = data.speed;
    group.autoreverses = data.autoreverses;
    const fillMode = [kCAFillModeRemoved, kCAFillModeForwards, kCAFillModeBackwards, kCAFillModeBoth];
    group.fillMode = fillMode[data.fillModeMask]; // data.cumulative
    // data.additive
    // data.attributes

    data.channels.forEach(channel => {
      const keyPath = channel.targetPath.join('.'); //console.error(`SCNNode animation group keyPath: ${keyPath}`)

      const chAnim = this._loadAnimationData(channel.animation, keyPath);

      group.animations.push(chAnim);
    }); //console.log('_loadAnimationGroup done')

    return group;
  }

  static _loadKeyframeAnimation(data, keyPath) {
    //console.log(`_loadKeyframeAnimation ${keyPath} start`)
    const anim = new CAKeyframeAnimation(keyPath);
    anim.isRemovedOnCompletion = Boolean(data.removeOnCompletion); // anim.timingFunction
    // anim.delegate

    anim.usesSceneTimeBase = Boolean(data.sceneTimeBased);
    anim.fadeInDuration = data.fadeInDuration;
    anim.fadeOutDuration = data.fadeOutDuration;
    anim.beginTime = data.beginTime;
    anim.timeOffset = data.timeOffset;
    anim.repeatCount = data.repeatCount; // anim.repeatDuration

    anim.duration = data.duration;
    anim.speed = data.speed;
    anim.autoreverses = data.autoreverses;
    const fillMode = [kCAFillModeRemoved, kCAFillModeForwards, kCAFillModeBackwards, kCAFillModeBoth];
    anim.fillMode = fillMode[data.fillModeMask];
    anim.isCumulative = Boolean(data.cumulative);
    anim.isAdditive = Boolean(data.additive); // data.attributes

    const keyframe = data.keyframeController;
    anim.values = this._loadData(keyframe, 'values'); //anim.path

    anim.keyTimes = this._loadData(keyframe, 'keytimes');

    switch (keyframe.interpolationMode) {
      case 0:
      default:
        //anim.timingFunctions =
        break;
    }

    anim.keyTimes = anim.keyTimes.map(keyTime => {
      return keyTime / anim.duration;
    });
    const calculationModes = [kCAAnimationLinear, kCAAnimationDiscrete, kCAAnimationPaced, kCAAnimationCubic, kCAAnimationCubicPaced];
    anim.calculationMode = calculationModes[keyframe.calculationMode]; //anim.rotationMode
    //anim.tensionValues
    //anim.continuityValues
    //anim.biasValues
    //console.log(`_loadKeyframeAnimation ${keyPath} done`)

    return anim;
  }

  static _loadBasicAnimation(data, keyPath) {
    //console.log(`_loadBasicAnimation ${keyPath} start`)
    const anim = new CABasicAnimation(keyPath);
    anim.isRemovedOnCompletion = Boolean(data.removeOnCompletion);
    anim.timingFunction = new CAMediaTimingFunction(data.timingFunction.c0, data.timingFunction.c1, data.timingFunction.c2, data.timingFunction.c3); // anim.delegate

    anim.usesSceneTimeBase = Boolean(data.sceneTimeBased);
    anim.fadeInDuration = data.fadeInDuration;
    anim.fadeOutDuration = data.fadeOutDuration;
    anim.beginTime = data.beginTime;
    anim.timeOffset = data.timeOffset;
    anim.repeatCount = data.repeatCount; // anim.repeatDuration

    anim.duration = data.duration;
    anim.speed = data.speed;
    anim.autoreverses = data.autoreverses;
    const fillMode = [kCAFillModeRemoved, kCAFillModeForwards, kCAFillModeBackwards, kCAFillModeBoth];
    anim.fillMode = fillMode[data.fillModeMask];
    anim.isCumulative = Boolean(data.cumulative);
    anim.isAdditive = Boolean(data.additive); // data.attributes
    // data.baseType
    //console.log(`_loadBasicAnimation ${keyPath} done`)

    return anim;
  }

  static _loadActionArray(node, actions) {
    //console.log('_loadActionArray start')
    for (const actName of Object.keys(actions)) {
      const data = actions[actName]; //const action = this._loadActionData(data, actName)
      //node.runActionForKey(action, actName)

      node.runActionForKey(data, actName);
    } //console.log('_loadAnimationArray done')

  } //static _loadActionData(data, key) {
  //  console.log(`_loadActionData ${key} start`)
  //}


  static _loadData(data, key) {
    //console.log(`_loadData ${key} start`)
    const accessor = data[key].accessor;
    const components = accessor.componentsPerValue;
    const stride = accessor.stride;
    const offset = accessor.offset;
    const typeId = accessor.sourceTypeID;
    const padding = accessor.padding;
    const count = accessor.valuesCount;
    const sourceKey = `${key}-data`;
    const source = data[sourceKey];
    const result = [];
    let pos = offset;

    if (accessor.componentsType === 1) {
      // float
      for (let i = 0; i < count; i++) {
        result.push(source.readFloatBE(pos));
        pos += stride;
      }
    } else if (accessor.componentsType === 6) {
      // double
      for (let i = 0; i < count; i++) {
        result.push(source.readDoubleBE(pos));
        pos += stride;
      }
    } else if (accessor.componentsType === 9) {
      // SCNVector3
      for (let i = 0; i < count; i++) {
        result.push(SCNVector3._initWithData(source, pos, true));
        pos += stride;
      }
    } else if (accessor.componentsType === 10) {
      // SCNVector4
      for (let i = 0; i < count; i++) {
        result.push(SCNVector4._initWithData(source, pos, true));
        pos += stride;
      }
    } else if (accessor.componentsType === 11) {
      // SCNMatrix4
      for (let i = 0; i < count; i++) {
        result.push(SCNMatrix4._initWithData(source, pos, true));
        pos += stride;
      }
    } else if (accessor.componentsType === 13) {
      // SKColor
      for (let i = 0; i < count; i++) {
        result.push(SKColor._initWithData(source, pos, true));
        pos += stride;
      }
    } else {
      console.error(`unknown accessor componentsType: ${accessor.componentsType}`);
    } //console.log(`_loadData ${key} done`)


    return result;
  }
  /**
   * Constructor for JSExport compatibility
   * @access public
   * @returns {SCNNode} -
   */


  static node() {
    return new SCNNode();
  }
  /**
   * Constructor for JSExport compatibility
   * @access public
   * @param {?SCNGeometry} [geometry] - The geometry to be attached.
   * @returns {SCNNode} -
   */


  static nodeWithGeometry(geometry) {
    return new SCNNode(geometry);
  } // Managing Node Attributes


  get geometry() {
    return this._geometry;
  }

  set geometry(newValue) {
    this._geometry = newValue;

    this._updateBoundingBox();
  } // Working With Node Animation

  /**
   * A node object representing the state of the node as it currently appears onscreen.
   * @type {SCNNode}
   * @desc When you use implicit animation (see SCNTransaction) to change a node’s properties, those node properties are set immediately to their target values, even though the animated node content appears to transition from the old property values to the new. During the animation SceneKit maintains a copy of the node, called the presentation node, whose properties reflect the transitory values determined by any in-flight animations currently affecting the node. The presentation node’s properties provide a close approximation to the version of the node that is currently displayed. SceneKit also uses the presentation node when computing the results of explicit animations, physics, and constraints.Do not modify the properties of the presentation node. (Attempting to do so results in undefined behavior.) Instead, you use the presentation node to read current animation values—for example, to create a new animation starting at those values. The presentation node has no parent or child nodes. To access animated properties of related nodes, use the node’s own parent and childNodes properties and the presentation property of each related node.
   * @see https://developer.apple.com/documentation/scenekit/scnnode/1408030-presentation
   */


  get presentation() {
    if (this._presentation === null && !this._isPresentationInstance) {
      this._createPresentation();
    }

    return this._presentation;
  }

  _createPresentation() {
    if (this._isPresentationInstance) {
      return;
    } else if (this._presentation) {
      return;
    }

    let p = this.copy();
    p._isPresentationInstance = true;

    if (this.geometry !== null) {
      p.geometry = this.geometry.copy();
      p.geometry._isPresentationInstance = true;
      p.geometry._geometryElements = [];

      this.geometry._geometryElements.forEach(element => {
        p.geometry._geometryElements.push(element.copy());
      });

      p.geometry._geometrySources = [];

      this.geometry._geometrySources.forEach(source => {
        p.geometry._geometrySources.push(source.copy());
      });

      this.geometry._presentation = p.geometry;
    }

    if (this._particleSystems) {
      p._particleSystems = [];

      for (const system of this._particleSystems) {
        const pSystem = system._createPresentation();

        p._particleSystems.push(pSystem);
      }
    }

    this._presentation = p;
  } // Managing the Node’s Transformation

  /**
   * The transformation applied to the node relative to its parent. Animatable.
   * @type {SCNMatrix4}
   * @see https://developer.apple.com/documentation/scenekit/scnnode/1407964-transform
   */


  get transform() {
    // FIXME: it should return the copy of _transform,
    //        but you should be able to change value with this statement:
    //          let node = new SCNNode()
    //          node.transform.m14 = 123
    //          console.log(node.transform.m14)   // '123'
    if (!this._transformUpToDate) {
      this._updateTransform();
    }

    return this._transform;
  }

  set transform(newValue) {
    this._transform = newValue;
    this._position = this._transform.getTranslation();
    this._rotation = this._transform.getRotation();
    this._scale = this._transform.getScale();
    this._transformUpToDate = true;
  }
  /**
   * The world transform applied to the node.
   * @type {SCNMatrix4}
   * @desc A world transform is the node’s coordinate space transformation relative to the scene’s coordinate space. This transformation is the concatenation of the node’s transform property with that of its parent node, the parent’s parent, and so on up to the rootNode object of the scene.
   * @see https://developer.apple.com/documentation/scenekit/scnnode/1407970-worldtransform
   */


  get worldTransform() {
    /*
    if(this._parent === null){
      if(this._isPresentationInstance){
        return this._worldTransform
      }
      return this.transform
    }
    return this.transform.mult(this._parent.worldTransform)
    */
    return this._worldTransform;
  }

  _updateWorldTransform() {
    let p = null;

    if (this._parent === null) {
      p = SCNMatrix4MakeTranslation(0, 0, 0);
    } else {
      p = this._parent._worldTransform;
    }

    this._worldTransform = this.transform.mult(p);

    if (this._presentation) {
      let pp = null;
      let ppOpacity = 1.0;

      if (this._parent === null) {
        pp = SCNMatrix4MakeTranslation(0, 0, 0);
      } else if (this._parent._presentation === null) {
        pp = this._parent._worldTransform;
        ppOpacity = this._parent._worldOpacity;
      } else {
        pp = this._parent._presentation._worldTransform;
        ppOpacity = this._parent._presentation._worldOpacity;
      }

      this._presentation._updateTransform();

      this._presentation._worldTransform = this._presentation.transform.mult(pp);
      this._presentation._worldOpacity = this._presentation._opacity * ppOpacity;
    }

    this._childNodes.forEach(child => {
      child._updateWorldTransform();
    });
  }
  /*
  _updatePresentationTransform() {
    let p = null
    if(this._parent === null){
      p = SCNMatrix4MakeTranslation(0, 0, 0)
    }else{
      p = this._parent._presentation._worldTransform
    }
    
    this._presentation._worldTransform = this._presentation.transform.mult(parentTransform)
    this._childNodes.forEach((child) => {
      child._updatePrsentationTransform(this._presentation._worldTransform)
    })
  }
  */

  /**
   * The translation applied to the node. Animatable.
   * @type {SCNVector3}
   * @see https://developer.apple.com/documentation/scenekit/scnnode/1408026-position
   */


  get position() {
    return this._position;
  }

  set position(newValue) {
    if (typeof newValue.x !== 'number' || typeof newValue.y !== 'number' || typeof newValue.z !== 'number') {
      throw new Error('error: SCNNode.position must have x, y, z values');
    }

    this._position.x = newValue.x;
    this._position.y = newValue.y;
    this._position.z = newValue.z;
    this._transformUpToDate = false;

    this._updateWorldTransform();
  }

  get rotation() {
    return this._rotation;
  }

  set rotation(newValue) {
    if (typeof newValue.x !== 'number' || typeof newValue.y !== 'number' || typeof newValue.z !== 'number' || typeof newValue.w !== 'number') {
      throw new Error('error: SCNNode.rotation must have x, y, z, w values');
    }

    const oldValue = this._rotation._copy();

    this._rotation.x = newValue.x;
    this._rotation.y = newValue.y;
    this._rotation.z = newValue.z;
    this._rotation.w = newValue.w;
    this._transformUpToDate = false;

    this._updateWorldTransform();

    SCNTransaction._addChange(this, 'rotation', oldValue, newValue);
  }

  get scale() {
    return this._scale;
  }

  set scale(newValue) {
    if (typeof newValue.x !== 'number' || typeof newValue.y !== 'number' || typeof newValue.z !== 'number') {
      throw new Error('error: SCNNode.scale must have x, y, z values');
    }

    this._scale.x = newValue.x;
    this._scale.y = newValue.y;
    this._scale.z = newValue.z;
    this._transformUpToDate = false;

    this._updateWorldTransform();
  }
  /**
   * The node’s orientation, expressed as pitch, yaw, and roll angles, each in radians. Animatable.
   * @type {SCNVector3}
   * @see https://developer.apple.com/documentation/scenekit/scnnode/1407980-eulerangles
   */


  get eulerAngles() {
    /*
    const rot = this._rotation
    const euler = new SCNVector3()
    const sinW = Math.sin(rot.w)
    const cosWR = 1.0 - Math.cos(rot.w)
    const len2 = rot.x * rot.x + rot.y * rot.y + rot.z * rot.z
    if(len2 === 0){
      return euler
    }
    const r = 1.0 / Math.sqrt(len2)
    const x = rot.x * r
    const y = rot.y * r
    const z = rot.z * r
    const s = y * sinW - x * z * cosWR
     if(s > 0.998){
      // TODO: check SceneKit implementation
      euler.x = 0
      euler.y = -Math.PI * 0.5
      euler.z = -2.0 * Math.atan2(z * Math.sin(rot.w * 0.5), Math.cos(rot.w * 0.5))
    }else if(s < -0.998){
      // TODO: check SceneKit implementation
      euler.x = 0
      euler.y = Math.PI * 0.5
      euler.z = 2.0 * Math.atan2(z * Math.sin(rot.w * 0.5), Math.cos(rot.w * 0.5))
    }else{
      euler.x = Math.atan2(x * sinW + y * z * cosWR, 1 - (y * y + x * x) * cosWR)
      euler.y = Math.asin(s)
      euler.z = Math.atan2(z * sinW + x * y * cosWR, 1 - (z * z + y * y) * cosWR)
    }
     return euler
    */
    return this._rotation.rotationToEulerAngles();
  }

  set eulerAngles(newValue) {
    this._rotation = newValue.eulerAnglesToRotation();
    this._transformUpToDate = false;
  }
  /**
   * The node’s orientation, expressed as a quaternion. Animatable.
   * @type {SCNQuaternion}
   * @see https://developer.apple.com/documentation/scenekit/scnnode/1408048-orientation
   */


  get orientation() {
    return this._rotation.rotationToQuat();
  }

  set orientation(newValue) {
    if (!_InstanceOf(newValue, SCNVector4)) {
      throw new Error('orientation must be SCNVector4');
    }

    this._rotation = newValue.quatToRotation();
    this._transformUpToDate = false;
  }
  /**
   * @access private
   * @returns {SCNVector4} -
   */


  get _presentationWorldOrientation() {
    if (this._parent === null) {
      return this.presentation.orientation;
    }

    return this._parent._presentationWorldOrientation.cross(this.presentation.orientation);
  }
  /**
   * @access private
   * @returns {SCNVector4} -
   */


  get _worldOrientation() {
    if (this._parent === null) {
      return this.orientation;
    }

    return this._parent._worldOrientation.cross(this.orientation);
  }
  /**
   * @access private
   * @returns {SCNVector4} -
   */


  get _worldRotation() {
    return this._worldOrientation.quatToRotation();
  }
  /**
   * @access private
   * @returns {SCNVector3} -
   */


  get _presentationWorldTranslation() {
    return this.presentation.worldTransform.getTranslation();
  }
  /**
   * @access private
   * @returns {SCNVector3} -
   */


  get _worldTranslation() {
    return this.worldTransform.getTranslation();
  }

  get worldPosition() {
    return this.worldTransform.getTranslation();
  }

  set worldPosition(newValue) {
    let parentTransform = null;

    if (this._parent === null) {
      parentTransform = SCNMatrix4MakeTranslation(0, 0, 0);
    } else {
      parentTransform = this._parent.worldTransform;
    }

    const transform = SCNMatrix4MakeTranslation(newValue.x, newValue.y, newValue.z);
    const inv = parentTransform.invert();
    const newTransform = transform.mult(inv);
    this._transform.m41 = newTransform.m41;
    this._transform.m42 = newTransform.m42;
    this._transform.m43 = newTransform.m43;
    this.transform = this._transform;
  }
  /**
   * @access private
   * @returns {SCNVector3} -
   */


  get _worldScale() {}
  /**
   * The opacity value of the node. Animatable.
   * @type {number}
   * @see https://developer.apple.com/documentation/scenekit/scnnode/1408010-opacity
   */


  get opacity() {
    return this._opacity;
  }

  set opacity(newValue) {
    const oldValue = this._opacity;
    this._opacity = newValue;

    SCNTransaction._addChange(this, '_opacity', oldValue, newValue);
  } // Managing the Node Hierarchy

  /**
   * Adds a node to the node’s array of children.
   * @access public
   * @param {SCNNode} child - The node to be added.
   * @returns {void}
   * @desc Calling this method appends the node to the end of the childNodes array.
   * @see https://developer.apple.com/documentation/scenekit/scnnode/1407974-addchildnode
   */


  addChildNode(child) {
    if (this._childNodes.indexOf(child) >= 0) {
      return;
    }

    child.removeFromParentNode();

    this._childNodes.push(child);

    child._parent = this;

    child._resetPhysicsTransformRecursively(true);
  }
  /**
   * Adds a node to the node’s array of children at a specified index.
   * @access public
   * @param {SCNNode} child - The node to be inserted.ImportantRaises an exception (invalidArgumentException) if child is nil.
   * @param {number} index - The position at which to insert the new child node.ImportantRaises an exception (rangeException) if index is greater than the number of elements in the node’s childNodes array.
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnnode/1407958-insertchildnode
   */


  insertChildNodeAt(child, index) {
    if (this._childNodes.indexOf(child) >= 0) {
      return;
    }

    child.removeFromParentNode();

    this._insertObjectInChildNodesAtIndex(child, index);

    this._parent = this;
  }
  /**
   * Removes the node from its parent’s array of child nodes.
   * @access public
   * @returns {void}
   * @desc Removing nodes from the node hierarchy serves two purposes. Nodes own their contents (child nodes or attached lights, geometries, and other objects), so deallocating unneeded nodes can reduce memory usage. Additionally, SceneKit does more work at rendering time with a large, complex node hierarchy, so removing nodes whose contents you don’t need to display can improve rendering performance.
   * @see https://developer.apple.com/documentation/scenekit/scnnode/1407991-removefromparentnode
   */


  removeFromParentNode() {
    const parentNode = this._parent;

    if (parentNode === null) {
      return;
    }

    const index = parentNode._childNodes.indexOf(this);

    if (index < 0) {
      return;
    }

    parentNode._removeObjectFromChildNodesAtIndex(index);
  }
  /**
   * Removes a child from the node’s array of children and inserts another node in its place. 
   * @access public
   * @param {SCNNode} oldChild - 
   * @param {SCNNode} newChild - 
   * @returns {void}
   * @desc If both the child and child2 nodes are children of the node, calling this method swaps their positions in the array. Note that removing a node from the node hierarchy may result in it being deallocated.Calling this method results in undefined behavior if the child parameter does not refer to a child of this node.
   * @see https://developer.apple.com/documentation/scenekit/scnnode/1408002-replacechildnode
   */


  replaceChildNodeWith(oldChild, newChild) {
    const index = this._childNodes.indexOf(oldChild);

    if (index < 0) {
      return;
    }

    this._removeObjectFromChildNodesAtIndex(index);

    this._insertObjectInChildNodesAtIndex(newChild, index);
  }
  /**
   *
   * @access private
   * @param {number} index -
   * @returns {void}
   */


  _removeObjectFromChildNodesAtIndex(index) {
    const arr = this._childNodes.splice(index, 1);

    if (arr.length === 0) {
      return;
    }

    const obj = arr[0];
    obj._parent = null;
    obj._transformUpToDate = false;
  }
  /**
   *
   * @access private
   * @param {SCNNode} object -
   * @param {number} index -
   * @returns {void}
   */


  _insertObjectInChildNodesAtIndex(object, index) {
    const length = this._childNodes.length;

    if (index > length) {
      throw new Error(`SCNNode.childNodes out of index: ${index} > ${length}`);
    }

    this._childNodes.splice(index, 0, object);
  }
  /**
   * @access private
   * @type {?SCNNode}
   */


  get _rootNode() {
    if (this._parent === null) {
      return this;
    }

    return this._parent._rootNode;
  }
  /**
   * The node’s parent in the scene graph hierarchy.
   * @type {?SCNNode}
   * @desc For a scene’s rootNode object, the value of this property is nil.
   * @see https://developer.apple.com/documentation/scenekit/scnnode/1407968-parent
   */


  get parent() {
    return this._parent;
  }
  /**
   * An array of the node’s children in the scene graph hierarchy.
   * @type {SCNNode[]}
   * @see https://developer.apple.com/documentation/scenekit/scnnode/1407984-childnodes
   */


  get childNodes() {
    return this._childNodes.slice(0);
  } // Searching the Node Hierarchy

  /**
   * Returns all nodes in the node’s child node subtree that satisfy the test applied by a block.
   * @access public
   * @param {function(child: SCNNode, stop: UnsafeMutablePointer<ObjCBool>): boolean} predicate - The block to apply to the node’s child and descendant nodes .The block takes two parameters:child The child node currently being searched. stop A reference to a Boolean value. Set *stop to true in the block to abort further processing of the child node subtree.The block returns a Boolean value indicating whether to include the child node in the search results array.
   * @returns {SCNNode[]} - 
   * @desc Use this method to search for nodes using a test you specify. For example, you can search for empty nodes using a block that returns YES for nodes whose light, camera, and geometry properties are all nil.SceneKit uses a recursive preorder traversal to search the child node subtree—that is, the block searches a node before it searches each of the node’s children, and it searches all children of a node before searching any of that node’s sibling nodes.
   * @see https://developer.apple.com/documentation/scenekit/scnnode/1407982-childnodes
   */


  childNodesPassingTest(predicate) {
    let result = [];
    return result;
  }
  /**
   * Returns the first node in the node’s child node subtree with the specified name.
   * @access public
   * @param {string} name - The name of the node to search for.
   * @param {boolean} [recursively = true] - true to search the entire child node subtree, or false to search only the node’s immediate children.
   * @returns {?SCNNode} - 
   * @desc If the recursive parameter is true, SceneKit uses a preorder traversal to search the child node subtree—that is, the block searches a node before it searches each of the node’s children, and it searches all children of a node before searching any of that node’s sibling nodes. Otherwise, SceneKit searches only those nodes in the node’s childNodes array.
   * @see https://developer.apple.com/documentation/scenekit/scnnode/1407951-childnode
   */


  childNodeWithNameRecursively(name, recursively = true) {
    for (let i = 0; i < this._childNodes.length; i++) {
      if (this._childNodes[i].name === name) {
        return this._childNodes[i];
      }

      if (recursively) {
        const result = this._childNodes[i].childNodeWithNameRecursively(name, recursively);

        if (result !== null) {
          return result;
        }
      }
    }

    return null;
  }
  /**
   * Returns the first node in the node’s child nodearray with the specified name.
   * @access public
   * @param {string} name - The name of the node to search for.
   * @returns {?SCNNode} - 
   * @desc SceneKit searches only those nodes in the node’s childNodes array.
   * @see https://developer.apple.com/documentation/scenekit/scnnode/1407951-childnode
   */


  childNodeWithName(name) {
    return this.childNodeWithNameRecursively(name, false);
  }
  /**
   * @access private
   * @param {string} nodeID -
   * @param {boolean} recursively -
   * @returns {?SCNNode} -
   */


  _childNodeWithNodeIDRecursively(nodeID, recursively = true) {
    for (let i = 0; i < this._childNodes.length; i++) {
      if (this._childNodes[i]._nodeID === nodeID) {
        return this._childNodes[i];
      }

      if (recursively) {
        const result = this._childNodes[i]._childNodeWithNodeIDRecursively(nodeID, recursively);

        if (result !== null) {
          return result;
        }
      }
    }

    return null;
  }
  /**
   * @access private
   * @param {string} nodeID -
   * @returns {?SCNNode} -
   */


  _childNodeWithNodeID(nodeID) {
    return this._childNodeWithNodeIDRecursively(name, false);
  }
  /**
   * Executes the specified block for each of the node’s child and descendant nodes.
   * @access public
   * @param {function(child: SCNNode, stop: UnsafeMutablePointer<ObjCBool>): void} block - The block to apply to the node’s child and descendant nodes.The block takes two parameters:childThe child node currently being evaluated.stopA reference to a Boolean value. Set *stop to true in the block to abort further processing of the child node subtree.
   * @returns {void}
   * @desc SceneKit uses a recursive preorder traversal to process the child node subtree—that is, the block runs for a node before it runs for each of the node’s children, and it processes all children of a node before processing any of that node’s sibling nodes.
   * @see https://developer.apple.com/documentation/scenekit/scnnode/1408032-enumeratechildnodes
   */


  enumerateChildNodes(block) {
    //this._childNodes.some((child) => {
    this.childNodes.some(child => {
      return this._enumerateChildNodesRecursive(child, block);
    });
  }
  /**
   * Executes the specified block for each of the node’s child and descendant nodes, as well as for the node itself.
   * @access public
   * @param {function(arg1: SCNNode, arg2: UnsafeMutablePointer<ObjCBool>): void} block - The block to apply to the node’s child and descendant nodes.The block takes two parameters:childThe child node currently being evaluated.stopA reference to a Boolean value. Set *stop to true in the block to abort further processing of the child node subtree.
   * @returns {void}
   * @desc SceneKit uses a recursive preorder traversal to process the child node subtree—that is, the block runs for a node before it runs for each of the node’s children, and it processes all children of a node before processing any of that node’s sibling nodes.This method is equivalent to the enumerateChildNodes(_:) method, but unlike that method it also runs the block to process the node itself, not just its child nodes.
   * @see https://developer.apple.com/documentation/scenekit/scnnode/1642248-enumeratehierarchy
   */


  enumerateHierarchy(block) {
    this._enumerateChildNodesRecursive(this, block);
  }

  _enumerateChildNodesRecursive(node, block) {
    let stop = block(node);

    if (stop === true) {
      return true;
    }

    stop = node._childNodes.some(child => {
      return this._enumerateChildNodesRecursive(child, block);
    });
    return stop;
  } // Adding Physics to a Node


  get physicsBody() {
    return this._physicsBody;
  }

  set physicsBody(newValue) {
    if (this._physicsBody) {
      this._physicsBody._node = null;
    }

    this._physicsBody = newValue;

    if (this._physicsBody) {
      this._physicsBody._node = this;

      this._physicsBody.resetTransform();
    }
  }

  _resetPhysicsTransformRecursively(updateWorldTransform = false) {
    if (this._physicsBody) {
      this._physicsBody._resetTransform(updateWorldTransform);
    }

    for (const child of this._childNodes) {
      child._resetPhysicsTransformRecursively(updateWorldTransform);
    }
  } // Working With Particle Systems

  /**
   * Attaches a particle system to the node.
   * @access public
   * @param {SCNParticleSystem} system - A particle system.
   * @returns {void}
   * @desc When attached to a node, a particle system’s emitter location follows that node as it moves through the scene. To instead attach a particle system to a location in the scene’s world coordinate space, use the corresponding method on SCNScene.For details on particle systems, see SCNParticleSystem.
   * @see https://developer.apple.com/documentation/scenekit/scnnode/1523123-addparticlesystem
   */


  addParticleSystem(system) {
    if (this._particleSystems === null) {
      this._particleSystems = [];
    }

    system.reset();

    this._particleSystems.push(system);
  }
  /**
   * Removes a particle system attached to the node.
   * @access public
   * @param {SCNParticleSystem} system - A particle system.
   * @returns {void}
   * @desc This method has no effect if the system parameter does not reference a particle system directly attached to the node.
   * @see https://developer.apple.com/documentation/scenekit/scnnode/1524014-removeparticlesystem
   */


  removeParticleSystem(system) {
    if (this._particleSystems === null) {
      return;
    }

    const index = this._particleSystems.indexOf(system);

    this._particleSystems.splice(index, 1);
  }
  /**
   * Removes any particle systems directly attached to the node.
   * @access public
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnnode/1522801-removeallparticlesystems
   */


  removeAllParticleSystems() {
    this._particleSystems = [];
  }
  /**
   * The particle systems attached to the node.
   * @access public
   * @type {?SCNParticleSystem[]}
   * @desc An array of SCNParticleSystem objects directly attached to the node. This array does not include particle systems attached to the node's child nodes. For details on particle systems, see SCNParticleSystem.
   * @see https://developer.apple.com/documentation/scenekit/scnnode/1522705-particlesystems
   */


  get particleSystems() {
    return this._particleSystems;
  } // Working With Positional Audio

  /**
   * Adds the specified auto player to the node and begins playback.
   * @access public
   * @param {SCNAudioPlayer} player - An audio player object.
   * @returns {void}
   * @desc Positional audio effects from a player attached to a node are based on that node’s position relative to the audioListener position in the scene.After playback has completed, SceneKit automatically removes the audio player from the node.
   * @see https://developer.apple.com/documentation/scenekit/scnnode/1523464-addaudioplayer
   */


  addAudioPlayer(player) {
    if (this._audioPlayers.indexOf(player) < 0) {
      this._audioPlayers.push(player);

      player._play();
    }
  }
  /**
   * Removes the specified audio player from the node, stopping playback.
   * @access public
   * @param {SCNAudioPlayer} player - An audio player attached to the node.
   * @returns {void}
   * @desc This method has no effect if the player parameter does not reference an audio player directly attached to the node.
   * @see https://developer.apple.com/documentation/scenekit/scnnode/1522767-removeaudioplayer
   */


  removeAudioPlayer(player) {
    const index = this._audioPlayers.indexOf(player);

    if (index >= 0) {
      player._stop();

      delete this._audioPlayers[index];
    }
  }
  /**
   * Removes all audio players attached to the node, stopping playback.
   * @access public
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnnode/1523570-removeallaudioplayers
   */


  removeAllAudioPlayers() {
    this._audioPlayers.forEach(player => {
      player._stop();
    });

    this._audioPlayers = [];
  }
  /**
   * The audio players currently attached to the node.
   * @type {SCNAudioPlayer[]}
   * @desc Positional audio effects from a player attached to a node are based on that node’s position relative to the audioListener position in the scene.After an audio player completes playback, SceneKit automatically removes it from the node. Therefore, this array always contains audio players that are currently playing back audio.
   * @see https://developer.apple.com/documentation/scenekit/scnnode/1523244-audioplayers
   */


  get audioPlayers() {
    return this._audioPlayers.slice(0);
  } // Copying a Node

  /**
   * Creates a copy of the node and its children.
   * @access public
   * @returns {SCNNode} - 
   * @desc This method recursively copies the node and its child nodes. For a nonrecursive copy, use the inherited copy() method, which creates a copy of the node without any child nodes.Cloning or copying a node creates a duplicate of the node object, but not the geometries, lights, cameras, and other SceneKit objects attached to it—instead, each copied node shares references to these objects.This behavior means that you can use cloning to, for example, place the same geometry at several locations within a scene without  maintaining multiple copies of the geometry and its materials. However, it also means that changes to the objects attached to one node will affect other nodes that share the same attachments. For example, to render two copies of a node using different materials, you must copy both the node and its geometry before assigning a new material.- (void)duplicateNode:(SCNNode *)node withMaterial:(SCNMaterial *)material
  {
    SCNNode *newNode = [node clone];
    newNode.geometry = [node.geometry copy];
    newNode.geometry.firstMaterial = material;
  }
  Multiple copies of an SCNGeometry object efficiently share the same vertex data, so you can copy geometries without a significant performance penalty.- (void)duplicateNode:(SCNNode *)node withMaterial:(SCNMaterial *)material
  {
    SCNNode *newNode = [node clone];
    newNode.geometry = [node.geometry copy];
    newNode.geometry.firstMaterial = material;
  }
    * @see https://developer.apple.com/documentation/scenekit/scnnode/1408046-clone
   */


  clone() {
    const node = this.copy();

    this._childNodes.forEach(child => {
      node.addChildNode(child.clone());
    });

    return node;
  }
  /**
   * Creates an optimized copy of the node and its children.
   * @access public
   * @returns {SCNNode} - 
   * @desc Rendering complex node hierarchies can incur a performance cost. Each geometry and material requires a separate draw command to be sent to the GPU, and each draw command comes with a performance overhead. If you plan for a portion of your scene’s node hierarchy to remain static (with respect to itself, if not the rest of the scene), use this method to create a single node containing all elements of that node hierarchy that SceneKit can render using fewer draw commands.
   * @see https://developer.apple.com/documentation/scenekit/scnnode/1407960-flattenedclone
   */


  flattenedClone() {
    return null;
  } // Hit-Testing

  /**
   * Searches the node’s child node subtree for objects intersecting a line segment between two specified points.
   * @access public
   * @param {SCNVector3} pointA - An endpoint of the line segment to search along, specified in the node’s local coordinate system.
   * @param {SCNVector3} pointB - The other endpoint of the line segment to search along, specified in the node’s local coordinate system.
   * @param {?Map<string, Object>} [options = null] - A dictionary of options affecting the search. See Hit Testing Options Keys for acceptable values.
   * @returns {SCNHitTestResult[]} - 
   * @desc Hit-testing is the process of finding elements of a scene located along a specified line segment in the scene’s coordinate space (or that of a particular node in the scene). For example, you can use this method to determine whether a projectile launched by a game character will hit its target.To search for the scene element corresponding to a two-dimensional point in the rendered image, use the renderer’s hitTest(_:options:) method instead.
   * @see https://developer.apple.com/documentation/scenekit/scnnode/1407998-hittestwithsegment
   */


  hitTestWithSegmentFromTo(pointA, pointB, options = null) {
    const worldPointA = this.convertPositionTo(pointA, null);
    const worldPointB = this.convertPositionTo(pointB, null);
    const results = [];
    this.enumerateChildNodes(child => {
      if (child.presentation.geometry) {
        const hits = SCNPhysicsWorld._hitTestWithSegmentNode(worldPointA, worldPointB, child.presentation);

        if (hits.length > 0) {
          // convert from the child's coordinate to this node's coordinate
          for (const h of hits) {
            h._node = child;
            h._worldCoordinates = child.convertPositionTo(h._localCoordinates, null);
            h._worldNormal = child.convertPositionTo(h._localNormal, null);
            h._localCoordinates = this.convertPositionFrom(h._localCoordinates, child);
            h._localNormal = this.convertPositionFrom(h._localNormal, child);
          }

          results.push(...hits);
        }
      }
    }); // TODO: sort by the distance

    if (results.length > 0) {
      console.error('hitTestWithSegmentFromTo: ' + results.length);
    }

    return results;
  } // Converting Between Node Coordinate Spaces

  /**
   * Converts a position to the node’s coordinate space from that defined by another node.
   * @access public
   * @param {SCNVector3} position - A position in the local coordinate space defined by the other node.
   * @param {?SCNNode} node - Another node in the same scene graph as the node, or nil to convert from the scene’s world coordinate space.
   * @returns {SCNVector3} - 
   * @see https://developer.apple.com/documentation/scenekit/scnnode/1408018-convertposition
   */


  convertPositionFrom(position, node) {
    if (node === null) {
      return position.transform(this._worldTransform.invert());
    }

    return position.transform(node._worldTransform).transform(this._worldTransform.invert());
  }
  /**
   * Converts a position from the node’s coordinate space to that defined by another node.
   * @access public
   * @param {SCNVector3} position - A position in the node’s local coordinate space.
   * @param {?SCNNode} node - Another node in the same scene graph as the node, or nil to convert to the scene’s world coordinate space.
   * @returns {SCNVector3} - 
   * @see https://developer.apple.com/documentation/scenekit/scnnode/1407990-convertposition
   */


  convertPositionTo(position, node) {
    if (node === null) {
      return position.transform(this._worldTransform);
    }

    return position.transform(this._worldTransform).transform(node._worldTransform.invert());
  }
  /**
   * Converts a transformation to the node’s coordinate space from that defined by another node.
   * @access public
   * @param {SCNMatrix4} transform - A transformation relative to the local coordinate space defined by the other node.
   * @param {?SCNNode} node - Another node in the same scene graph as the node, or nil to convert from the scene’s world coordinate space.
   * @returns {SCNMatrix4} - 
   * @see https://developer.apple.com/documentation/scenekit/scnnode/1407996-converttransform
   */


  convertTransformFrom(transform, node = null) {
    if (node === null) {
      return transform.mult(this._worldTransform.invert());
    }

    return transform.mult(node._worldTransform).mult(this._worldTransform.invert());
  }
  /**
   * Converts a transformation from the node’s coordinate space to that defined by another node.
   * @access public
   * @param {SCNMatrix4} transform - A transformation relative to the node’s coordinate space.
   * @param {?SCNNode} node - Another node in the same scene graph as the node, or nil to convert to the scene’s world coordinate space.
   * @returns {SCNMatrix4} - 
   * @see https://developer.apple.com/documentation/scenekit/scnnode/1407986-converttransform
   */


  convertTransformTo(transform, node = null) {
    if (node === null) {
      return transform.mult(this._worldTransform);
    }

    return transform.mult(this._worldTransform).mult(node._worldTransform.invert());
  }
  /**
   * 
   * @type {SCNVector3}
   * @desc 
   * @see https://developer.apple.com/documentation/scenekit/scnnode/2867392-worldfront
   */


  get worldFront() {
    return _localFront.rotate(this.worldTransform);
  }
  /**
   * 
   * @type {SCNVector3}
   * @desc 
   * @see https://developer.apple.com/documentation/scenekit/scnnode/2867404-worldright
   */


  get worldRight() {
    return _localRight.rotate(this.worldTransform);
  }
  /**
   * 
   * @type {SCNVector3}
   * @desc 
   * @see https://developer.apple.com/documentation/scenekit/scnnode/2867395-worldup
   */


  get worldUp() {
    return _localUp.rotate(this.worldTransform);
  }
  /**
   * 
   * @type {SCNVector3}
   * @desc 
   * @see https://developer.apple.com/documentation/scenekit/scnnode/2867393-localfront
   */


  static get localFront() {
    return _localFront;
  }
  /**
   * 
   * @type {SCNVector3}
   * @desc 
   * @see https://developer.apple.com/documentation/scenekit/scnnode/2867400-localright
   */


  static get localRight() {
    return _localRight;
  }
  /**
   * 
   * @type {SCNVector3}
   * @desc 
   * @see https://developer.apple.com/documentation/scenekit/scnnode/2867386-localup
   */


  static get localUp() {
    return _localUp;
  }
  /**
   * 
   * @access public
   * @param {SCNVector3} vector - 
   * @param {?SCNNode} node - 
   * @returns {SCNVector3} - 
   * @see https://developer.apple.com/documentation/scenekit/scnnode/2867403-convertvector
   */


  convertVectorFrom(vector, node) {} // TODO: implement

  /**
   * 
   * @access public
   * @param {SCNVector3} vector - 
   * @param {?SCNNode} node - 
   * @returns {SCNVector3} - 
   * @see https://developer.apple.com/documentation/scenekit/scnnode/2867397-convertvector
   */


  convertVectorTo(vector, node) {} // TODO: implement

  /**
   * 
   * @access public
   * @param {SCNQuaternion} rotation - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnnode/2867398-localrotate
   */


  localRotateBy(rotation) {} // TODO: implement

  /**
   * 
   * @access public
   * @param {SCNVector3} translation - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnnode/2867383-localtranslate
   */


  localTranslateBy(translation) {} // TODO: implement

  /**
   * 
   * @access public
   * @param {SCNVector3} worldTarget - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnnode/2867394-look
   */


  lookAt(worldTarget) {} // TODO: implement

  /**
   * 
   * @access public
   * @param {SCNVector3} worldTarget - 
   * @param {SCNVector3} worldUp - 
   * @param {SCNVector3} localFront - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnnode/2867396-look
   */


  lookAtUp(worldTarget, worldUp, localFront) {} // TODO: implement

  /**
   * 
   * @access public
   * @param {SCNQuaternion} worldRotation - 
   * @param {SCNVector3} worldTarget - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnnode/2867399-rotate
   */


  rotateByAroundTarget(worldRotation, worldTarget) {} // TODO: implement

  /**
   * 
   * @access public
   * @param {SCNMatrix4} worldTransform - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnnode/2867401-setworldtransform
   */


  setWorldTransform(worldTransform) {} // TODO: implement
  ///////////////////
  // SCNActionable //
  ///////////////////
  // Running Actions

  /**
   * Required. Adds an action to the list of actions executed by the node.
   * @access public
   * @param {SCNAction} action - The action to be performed.
   * @returns {void}
   * @desc SceneKit begins running a newly added action when it prepares to render the next frame.
   * @see https://developer.apple.com/documentation/scenekit/scnactionable/1523164-runaction
   */


  runAction(action) {
    this.runActionForKey(action, Symbol());
  }
  /**
   * Required. Adds an action to the list of actions executed by the node. SceneKit calls the specified block when the action completes.
   * @access public
   * @param {SCNAction} action - The action to be performed.
   * @param {?function(): void} [block = null] - A completion block that SceneKit calls when the action completes.
   * @returns {void}
   * @desc The new action is processed the next time SceneKit prepares to render a frame.SceneKit calls your block after the action’s duration is complete. For example, in a game you could use this method to show a Game Over message after performing a fade-out action on a node that displays a player character.
   * @see https://developer.apple.com/documentation/scenekit/scnactionable/1524219-runaction
   */


  runActionCompletionHandler(action, block = null) {
    this.runActionForKeyCompletionHandler(action, Symbol(), block);
  }
  /**
   * Required. Adds an identifiable action to the list of actions executed by the node.
   * @access public
   * @param {SCNAction} action - The action to be performed.
   * @param {?string} key - A unique key used to identify the action.
   * @returns {void}
   * @desc This method is identical to runAction(_:), but the action is stored and identified so that you can retrieve or cancel it later. If an action using the same key is already running, SceneKit removes it before adding the new action.
   * @see https://developer.apple.com/documentation/scenekit/scnactionable/1524222-runaction
   */


  runActionForKey(action, key) {
    this.runActionForKeyCompletionHandler(action, key, null);
  }
  /**
   * Required. Adds an identifiable action to the list of actions executed by the node. SceneKit calls the specified block when the action completes.
   * @access public
   * @param {SCNAction} action - The action to be performed.
   * @param {?string} key - A unique key used to identify the action.
   * @param {?function(): void} [block = null] - A completion block called when the action completes.
   * @returns {void}
   * @desc This method is identical to runAction(_:completionHandler:), but the action is stored and identified so that you can retrieve or cancel it later. If an action using the same key is already running, SceneKit removes it before adding the new action.SceneKit calls your block after the action’s duration is complete. For example, you can use this method with a wait action to execute some code after a timed delay. If during the delay period you need to prevent the code from running, use the removeAction(forKey:) method to cancel it.
   * @see https://developer.apple.com/documentation/scenekit/scnactionable/1522791-runaction
   */


  runActionForKeyCompletionHandler(action, key, block = null) {
    if (typeof key === 'undefined' || key === null) {
      key = Symbol();
    }

    const act = action.copy(); // FIXME: use current frame time

    act._actionStartTime = Date.now() * 0.001;
    act._completionHandler = block;

    this._actions.set(key, act); //this._copyTransformToPresentationRecursive()

  } // Inspecting a Node’s Running Actions

  /**
   * Required. Returns an action associated with a specific key.
   * @access public
   * @param {string} key - A string that uniquely identifies a action.
   * @returns {?SCNAction} - 
   * @desc Use this method to retrieve actions you scheduled using the runAction(_:forKey:) or runAction(_:forKey:completionHandler:) method.
   * @see https://developer.apple.com/documentation/scenekit/scnactionable/1523287-action
   */


  actionForKey(key) {
    return this._actions.get(key);
  }
  /**
   * Required. A Boolean value that indicates whether the node is currently executing any actions.
   * @type {boolean}
   * @desc This value is true if the node has any executing actions; otherwise the value is false.
   * @see https://developer.apple.com/documentation/scenekit/scnactionable/1523794-hasactions
   */


  get hasActions() {
    return this._actions.size > 0;
  }
  /**
   * Required. The list of keys for which the node has attached actions.
   * @type {string[]}
   * @desc Use this property to list actions you scheduled using the runAction(_:forKey:) or runAction(_:forKey:completionHandler:) method.
   * @see https://developer.apple.com/documentation/scenekit/scnactionable/1523036-actionkeys
   */


  get actionKeys() {
    const keys = [];

    for (const key of this._actions.keys()) {
      keys.push(key);
    }

    return keys;
  } // Canceling a Node’s Running Actions

  /**
   * Required. Removes an action associated with a specific key.
   * @access public
   * @param {string} key - A string that uniquely identifies a action.
   * @returns {void}
   * @desc If the node is currently running an action that matches the key, SceneKit removes that action from the node, skipping any remaining animation it would perform but keeping any changes already made to the node.Use this method to cancel actions you scheduled using the runAction(_:forKey:) or runAction(_:forKey:completionHandler:) method.
   * @see https://developer.apple.com/documentation/scenekit/scnactionable/1523617-removeaction
   */


  removeActionForKey(key) {
    // TODO: stop action
    this._actions.delete(key);
  }
  /**
   * Required. Ends and removes all actions from the node.
   * @access public
   * @returns {void}
   * @desc When SceneKit removes an action from a node, it skips any remaining animation the action would perform. However, any changes the action has already made to the node’s state remain in effect.
   * @see https://developer.apple.com/documentation/scenekit/scnactionable/1524181-removeallactions
   */


  removeAllActions() {
    // TODO: stop actions
    this._actions.clear();
  } ///////////////////
  // SCNAnimatable //
  ///////////////////
  // Managing Animations

  /**
   * Required. Adds an animation object for the specified key.
   * @access public
   * @param {CAAnimation} animation - The animation object to be added.
   * @param {?string} key - An string identifying the animation for later retrieval. You may pass nil if you don’t need to reference the animation later.
   * @returns {void}
   * @desc Newly added animations begin executing after the current run loop cycle ends.SceneKit does not define any requirements for the contents of the key parameter—it need only be unique among the keys for other animations you add. If you add an animation with an existing key, this method overwrites the existing animation.
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523386-addanimation
   */


  addAnimationForKey(animation, key) {
    if (typeof key === 'undefined' || key === null) {
      key = Symbol();
    } //const anim = animation.copy()


    const anim = animation; // FIXME: use current frame time

    anim._animationStartTime = Date.now() * 0.001;

    this._animations.set(key, anim);

    this._copyTransformToPresentationRecursive();
  }
  /**
   * @access private
   * @param {CAAnimation} animatino -
   * @param {number} time -
   * @returns {void}
   */

  /*
  _setAnimationStartTime(animation, time) {
    animation._animationStartTime = time
    animation._prevTime = time - 0.0000001
    if(animation instanceof CAAnimationGroup){
      animation.animations.forEach((anim) => {
        this._setAnimationStartTime(anim, time)
      })
    }
  }
  */

  /**
   * Required. Returns the animation with the specified key.
   * @access public
   * @param {string} key - A string identifying a previously added animation.
   * @returns {?CAAnimation} - 
   * @desc Attempting to modify any properties of the returned object results in undefined behavior.
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1524020-animation
   */


  animationForKey(key) {
    return this._animations.get(key);
  }
  /**
   * Required. Removes all the animations currently attached to the object.
   * @access public
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1522762-removeallanimations
   */


  removeAllAnimations() {
    // TODO: stop animations
    this._animations.clear();
  }
  /**
   * Required. Removes the animation attached to the object with the specified key.
   * @access public
   * @param {string} key - A string identifying an attached animation to remove.
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1522880-removeanimation
   */


  removeAnimationForKey(key) {
    this.removeAnimationForKeyBlendOutDuration(key, 0);
  }
  /**
   *
   * @access public
   * @param {string} key -
   * @param {number} duration -
   * @returns {void}
   */


  removeAnimationForKeyBlendOutDuration(key, duration) {
    // FIXME: use duration
    this._animations.delete(key);

    this._copyTransformToPresentationRecursive();
  }
  /**
   * Required. Removes the animation attached to the object with the specified key, smoothly transitioning out of the animation’s effect.
   * @access public
   * @param {string} key - A string identifying an attached animation to remove.
   * @param {number} duration - The duration for transitioning out of the animation’s effect before it is removed.
   * @returns {void}
   * @desc Use this method to create smooth transitions between the effects of multiple animations. For example, the geometry loaded from a scene file for a game character may have associated animations for player actions such as walking and jumping. When the player lands from a jump, you remove the jump animation so the character continues walking. If you use the removeAnimation(forKey:) method to remove the jump animation, SceneKit abruptly switches from the current frame of the jump animation to the current frame of the walk animation. If you use the removeAnimation(forKey:fadeOutDuration:) method instead, SceneKit plays both animations at once during that duration and interpolates vertex positions from one animation to the other, creating a smooth transition.
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1522841-removeanimation
   */


  removeAnimationForKeyFadeOutDuration(key, duration) {
    // FIXME: use fadeout duration
    this.removeAnimationForKey(key);
  }
  /**
   * Required. An array containing the keys of all animations currently attached to the object.
   * @type {string[]}
   * @desc This array contains all keys for which animations are attached to the object, or is empty if there are no attached animations. The ordering of animation keys in the array is arbitrary.
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523610-animationkeys
   */


  get animationKeys() {
    const keys = [];

    for (const key of this._animations.keys()) {
      keys.push(key);
    }

    return keys;
  } // Pausing and Resuming Animations

  /**
   * Required. Pauses the animation attached to the object with the specified key.
   * @access public
   * @param {string} key - A string identifying an attached animation.
   * @returns {void}
   * @desc This method has no effect if no animation is attached to the object with the specified key.
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523592-pauseanimation
   */


  pauseAnimationForKey(key) {}
  /**
   * Required. Resumes a previously paused animation attached to the object with the specified key.
   * @access public
   * @param {string} key - A string identifying an attached animation.
   * @returns {void}
   * @desc This method has no effect if no animation is attached to the object with the specified key or if the specified animation is not currently paused.
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523332-resumeanimation
   */


  resumeAnimationForKey(key) {}
  /**
   * Required. Returns a Boolean value indicating whether the animation attached to the object with the specified key is paused.
   * @access public
   * @param {string} key - A string identifying an attached animation.
   * @returns {boolean} - 
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523703-isanimationpaused
   */


  isAnimationPausedForKey(key) {
    return false;
  } // Instance Methods

  /**
   * Required. 
   * @access public
   * @param {number} speed - 
   * @param {string} key - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1778343-setanimationspeed
   */


  setAnimationSpeedForKey(speed, key) {}

  _setAnimationsToPlayers() {
    const len = this._animationPlayers._values.length;

    if (len > 0 && this._animations._values.length > 0) {
      for (let i = 0; i < len; i++) {
        this._animationPlayers._values[i]._animation = this._animations._values[i];
      }
    }
  }
  /**
   *
   * @access public
   * @param {SCNAnimationPlayer} player -
   * @param {?string} key -
   * @returns {void}
   */


  addAnimationPlayerForKey(player, key) {
    if (typeof key === 'undefined' || key === null) {
      key = Symbol();
    }

    this._animationPlayers.set(key, player);

    this._copyTransformToPresentationRecursive();
  }
  /**
   * 
   * @access public
   * @param {string} key -
   * @returns {SCNAnimationPlayer} -
   */


  animationPlayerForKey(key) {
    return this._animationPlayers.get(key);
  } ///////////////////////
  // SCNBoundingVolume //
  ///////////////////////
  // Working with Bounding Volumes

  /**
   * The minimum and maximum corner points of the object’s bounding box.
   * @type {{min: SCNVector3, max: SCNVector3}}
   * @see https://developer.apple.com/documentation/scenekit/scnboundingvolume/2034705-boundingbox
   */


  get boundingBox() {
    if (this._fixedBoundingBox) {
      return this._fixedBoundingBox;
    }

    this._updateBoundingBox();

    return this._boundingBox;
  }

  set boundingBox(newValue) {
    this._fixedBoundingBox = newValue;
  }
  /**
   * The center point and radius of the object’s bounding sphere.
   * @type {{center: SCNVector3, radius: number}}
   * @desc Scene Kit defines a bounding sphere in the local coordinate space using a center point and a radius. For example, if a node’s bounding sphere has the center point {3, 1, 4} and radius 2.0, all points in the vertex data of node’s geometry (and any geometry attached to its child nodes) lie within 2.0 units of the center point.The coordinates provided when reading this property are valid only if the object has a volume to be measured. For a geometry containing no vertex data or a node containing no geometry (and whose child nodes, if any, contain no geometry), the values center and radius are both zero.
   * @see https://developer.apple.com/documentation/scenekit/scnboundingvolume/2034707-boundingsphere
   */


  get boundingSphere() {
    // TODO: calculate bounding sphere
    return {
      center: new SCNVector3(),
      radius: 0
    };
  }

  _geometryBoundingBox() {
    if (this._geometry === null) {
      return {
        min: new SCNVector3(Infinity, Infinity, Infinity),
        max: new SCNVector3(-Infinity, -Infinity, -Infinity)
      };
    }

    const boundingBox = this._geometry.boundingBox; // FIXME: rotate and scale

    if (this.skinner && this.skinner.baseGeometryBindTransform) {
      const tx = this.skinner.baseGeometryBindTransform.m41;
      const ty = this.skinner.baseGeometryBindTransform.m42;
      const tz = this.skinner.baseGeometryBindTransform.m43;
      boundingBox.min.x += tx;
      boundingBox.min.y += ty;
      boundingBox.min.z += tz;
      boundingBox.max.x += tx;
      boundingBox.max.y += ty;
      boundingBox.max.z += tz;
    } //return this._geometry.boundingBox
    //return this._geometry._updateBoundingBoxForSkinner(this.skinner)


    return boundingBox;
  }

  _updateBoundingBox() {
    // FIXME: use rotation of the node
    let box = this._geometryBoundingBox();

    const p = this._presentation ? this._presentation : this;

    if (p.geometry !== null) {
      if (box === null) {
        box = p.geometry._updateBoundingBox();
      }

      box = this._unionBoundingBox(box, p.geometry.boundingBox);
    }

    const scale = p._scale;

    if (scale.x < 0) {
      const minX = box.max.x * scale.x;
      const maxX = box.min.x * scale.x;
      box.min.x = minX;
      box.max.x = maxX;
    } else {
      box.min.x *= scale.x;
      box.max.x *= scale.x;
    }

    if (scale.y < 0) {
      const minY = box.max.y * scale.y;
      const maxY = box.min.y * scale.y;
      box.min.y = minY;
      box.max.y = maxY;
    } else {
      box.min.y *= scale.y;
      box.max.y *= scale.y;
    }

    if (scale.z < 0) {
      const minZ = box.max.z * scale.z;
      const maxZ = box.min.z * scale.z;
      box.min.z = minZ;
      box.max.z = maxZ;
    } else {
      box.min.z *= scale.z;
      box.max.z *= scale.z;
    }

    for (const child of this._childNodes) {
      const cbox = child._updateBoundingBox();

      box = this._unionChildBoundingBox(box, cbox);
    }

    this._boundingBox = box;
    return box;
  }

  _unionBoundingBox(box1, box2) {
    if (box1 === null) {
      return box2;
    }

    if (box2 === null) {
      return box1;
    }

    const min = new SCNVector3();
    const max = new SCNVector3();
    min.x = Math.min(box1.min.x, box2.min.x);
    min.y = Math.min(box1.min.y, box2.min.y);
    min.z = Math.min(box1.min.z, box2.min.z);
    max.x = Math.max(box1.max.x, box2.max.x);
    max.y = Math.max(box1.max.y, box2.max.y);
    max.z = Math.max(box1.max.z, box2.max.z);
    return {
      min: min,
      max: max
    };
  }

  _unionChildBoundingBox(box, cbox) {
    const p = this._presentation ? this._presentation : this;
    const pos = p._position;
    const scale = p._scale;
    const min = new SCNVector3((cbox.min.x + pos.x) * scale.x, (cbox.min.y + pos.y) * scale.y, (cbox.min.z + pos.z) * scale.z);
    const max = new SCNVector3((cbox.max.x + pos.x) * scale.x, (cbox.max.y + pos.y) * scale.y, (cbox.max.z + pos.z) * scale.z);
    return this._unionBoundingBox(box, {
      min: min,
      max: max
    });
  }

  _updateTransform() {
    const m1 = SCNMatrix4.matrixWithScale(this._scale);
    const m2 = m1.rotation(this._rotation);
    const m3 = m2.translation(this._position);
    this._transform = m3;
    this._transformUpToDate = true;
  }
  /**
   *
   * @access public
   * @returns {SCNNode} -
   */


  copy() {
    const node = new SCNNode();
    node.name = this.name;
    node.light = this.light;
    node.camera = this.camera;
    node._geometry = this._geometry;
    node.morpher = this.morpher ? this.morpher._copy() : null;
    node.skinner = this.skinner;
    node.categoryBitMask = this.categoryBitMask;
    node.isPaused = this.isPaused;
    node._presentation = this._presentation ? this._presentation.copy() : null;
    node._isPresentationInstance = this._isPresentationInstance;
    node.constraints = this.constraints ? this.constraints.slice(0) : null;
    node.isHidden = this.isHidden;
    node._opacity = this._opacity;
    node.renderingOrder = this.renderingOrder;
    node.castsShadow = this.castsShadow;
    node.movabilityHint = this.movabilityHint;
    node.filters = this.filters ? this.filters.slice(0) : null;
    node.rendererDelegate = this.rendererDelegate;
    node._physicsBody = this._physicsBody; // FIXME: copy

    node.physicsField = this.physicsField;
    node._particleSystems = this._particleSystems ? this._particleSystems.slice(0) : null;
    node._audioPlayers = this._audioPlayers; //node._hasActions = this._hasActions

    node._actions = new Map(this._actions);
    node._animations = this._animations.copy();
    node._boundingBox = this._boundingBox; //node._boundingSphere = this._boundingSphere

    node._position = new SCNVector3(this._position.x, this._position.y, this._position.z);
    node._rotation = new SCNVector4(this._rotation.x, this._rotation.y, this._rotation.z, this._rotation.w);
    node._scale = new SCNVector3(this._scale.x, this._scale.y, this._scale.z);
    node._transformUpToDate = false;
    return node;
  }

  _copyTransformToPresentation() {
    if (this._presentation === null) {
      return;
    }

    const p = this._presentation;
    p._position = this._position._copy();
    p._rotation = this._rotation._copy();
    p._scale = this._scale._copy();
  }

  _copyTransformToPresentationRecursive() {
    const nodes = [this];

    while (nodes.length > 0) {
      const node = nodes.shift();

      node._copyTransformToPresentation();

      nodes.push(...node._childNodes);
    }
  }

  _copyMaterialPropertiesToPresentation() {
    const p = this._presentation;

    if (this._geometry) {
      for (const material of this._geometry.materials) {
        material._copyPresentationProperties();
      }
    }

    p.opacity = this.opacity;
  }

  _copyMorpherToPresentation() {
    const p = this._presentation;

    if (this.morpher) {
      p.morpher.targets = this.morpher.targets.slice(0);
      p.morpher._weights = this.morpher._weights.slice(0);
      p.morpher.calculationMode = this.morpher.calculationMode;
    }
  }

  get viewTransform() {
    return this.worldTransform.invert();
  }

  get inverseViewTransform() {
    return this.worldTransform;
  }

  get projectionTransform() {
    if (this.camera === null) {
      return null;
    }

    return this.camera.projectionTransform;
  }

  get viewProjectionTransform() {
    if (this.camera === null) {
      return null;
    }

    const proj = this.camera.projectionTransform;
    const view = this.viewTransform;
    return view.mult(proj);
  }

  get lightViewProjectionTransform() {
    if (this.light === null) {
      return null;
    }

    this.light._updateProjectionTransform();

    const proj = this.light._projectionTransform;
    const view = this.viewTransform;
    return view.mult(proj);
  }

  get shadowProjectionTransform() {
    if (this.light === null) {
      return null;
    }

    const vp = this.lightViewProjectionTransform;
    const scale = SCNMatrix4MakeTranslation(1.0, 1.0, 0.0).scale(0.5, 0.5, 1.0); // [-1, 1] => [0, 1]

    return vp.mult(scale);
  }
  /**
   * Invoked by value(forKey:) when it finds no property corresponding to a given key.
   * @access public
   * @param {string} key - A string that is not equal to the name of any of the receiver's properties.
   * @returns {?Object} - 
   * @desc Subclasses can override this method to return an alternate value for undefined keys. The default implementation raises an NSUndefinedKeyException.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1413457-value
   */


  valueForUndefinedKey(key) {
    if (key.charAt(0) === '/') {
      const nodeID = key.substr(1);

      if (this._nodeID === nodeID) {
        return this;
      }

      let node = this._childNodeWithNodeIDRecursively(nodeID);

      if (node) {
        return node;
      }

      node = this.childNodeWithNameRecursively(nodeID);

      if (node) {
        return node;
      }

      const rootNode = this._rootNode;

      if (rootNode !== this) {
        node = rootNode._childNodeWithNodeIDRecursively(nodeID);

        if (node) {
          return node;
        }

        node = rootNode.childNodeWithNameRecursively(nodeID);

        if (node) {
          return node;
        }
      }
    }

    return super.valueForUndefinedKey(key);
  }

  valueForKeyPath(keyPath, usePresentation = true) {
    const target = usePresentation && this._presentation ? this._presentation : this;
    const paths = keyPath.split('.');
    const key = paths[0];
    const key2 = paths[1];

    if (key === 'position') {
      if (key2) {
        return target.position[key2];
      }

      return target.position;
    } else if (key === 'rotation') {
      if (key2) {
        return target.rotation[key2];
      }

      return target.rotation;
    } else if (key === 'scale') {
      if (key2) {
        return target.scale[key2];
      }

      return target.scale;
    } else if (key === 'eulerAngles') {
      if (key2) {
        return target.eulerAngles[key2];
      }

      return target.eulerAngles;
    } else if (key === 'orientation') {
      if (key2) {
        return target.orientation[key2];
      }

      return target.orientation;
    } else if (key === 'transform') {
      if (key2) {
        return target.transform[key2];
      }

      return target.transform;
    }

    return super.valueForKeyPath(keyPath, usePresentation);
  }

  setValueForKey(value, key) {
    // FIXME: check flags to decide to use a presentation node
    const target = this._presentation ? this._presentation : this;

    if (key === 'position') {
      target.position = value;
    } else if (key === 'rotation') {
      target.rotation = value;
    } else if (key === 'scale') {
      target.scale = value;
    } else if (key === 'eulerAngles') {
      target.eulerAngles = value;
    } else if (key === 'orientation') {
      target.orientation = value;
    } else if (key === 'transform') {
      target.transform = value;
    } else {
      super.setValueForKey(value, key);
    }
  }

  setValueForKeyPath(value, keyPath) {
    const target = this._presentation ? this._presentation : this;
    const paths = keyPath.split('.');
    const key = paths.shift();
    const restPath = paths.join('.'); //console.log(`SCNNode setValueForKeyPath ${this.name} ${key} ${restPath}`)

    if (key === 'transform') {
      switch (restPath) {
        case 'rotation.x':
          target._rotation.x = value;
          target._transformUpToDate = false;
          return;

        case 'rotation.y':
          target._rotation.y = value;
          target._transformUpToDate = false;
          return;

        case 'rotation.z':
          target._rotation.z = value;
          target._transformUpToDate = false;
          return;

        case 'rotation':
          target._rotation.z = value;
          target._transformUpToDate = false;
          return;

        case 'quaternion':
          target.orientation = value;
          target._transformUpToDate = false;
          return;

        case 'scale.x':
          target._scale.x = value;
          target._transformUpToDate = false;
          return;

        case 'scale.y':
          target._scale.y = value;
          target._transformUpToDate = false;
          return;

        case 'scale.z':
          target._scale.z = value;
          target._transformUpToDate = false;
          return;

        case 'scale':
          {
            target._scale.x = value.x;
            target._scale.y = value.y;
            target._scale.z = value.z;
            target._transformUpToDate = false;
            return;
          }

        case 'translation.x':
          target._position.x = value;
          target._transformUpToDate = false;
          return;

        case 'translation.y':
          target._position.y = value;
          target._transformUpToDate = false;
          return;

        case 'translation.z':
          target._position.z = value;
          target._transformUpToDate = false;
          return;

        case 'translation':
          target._position.x = value.x;
          target._position.y = value.y;
          target._transformUpToDate = false;
          return;

        default: // do nothing

      }
    } else if (key === 'position') {
      if (restPath !== '') {
        target._position[restPath] = value;
      } else {
        target._position = value;
      }

      return;
    } else if (key === 'rotation') {
      if (restPath !== '') {
        target._rotation[restPath] = value;
      } else {
        target._rotation = value;
      }

      return;
    } else if (key === 'orientation') {
      if (restPath !== '') {
        const v = target.orientation;
        v[restPath] = value;
        target.orientation = v;
      } else {
        target.orientation = value;
      }

      return;
    } else if (key === 'eulerAngles') {
      if (restPath !== '') {
        const v = target.eulerAngles;
        v[restPath] = value;
        target.eulerAngles = v;
      } else {
        target.eulerAngles = value;
      }

      return;
    } else if (key === 'scale') {
      if (restPath !== '') {
        target._scale[restPath] = value;
      } else {
        target._scale = value;
      }

      return;
    } else if (key === 'morpher') {
      if (target.morpher === null) {
        throw new Error('target morpher === null');
      }

      target.morpher.setValueForKeyPath(value, restPath);
      return;
    } // TODO: add other properties


    super.setValueForKeyPath(value, keyPath);
  }
  /**
   * @access private
   * @returns {Ammo.btTransform} -
   * @desc call Ammo.destroy(transform) after using it.
   */


  _createBtTransform() {//const transform = new Ammo.btTransform()
    //const pos = this.position.createBtVector3()
    //const rot = this.orientation.craeteBtQuaternion()
    //transform.setIdentity()
    //transform.setOrigin(pos)
    //transform.setRotation(rot)
    //Ammo.destroy(pos)
    //Ammo.destroy(rot)
    //return transform
  }

  _createBtCollisionShape() {//if(this._geometry === null){
    //  throw new Error('geometry is null')
    //}
    //return this._geometry._createBtCollisionShape()
  }

  destory() {} //if(this.physicsBody !== null){
  //  this.physicsBody.destory()
  //  this.physicsBody = null
  //}
  //if(this._geometry !== null){
  //  // the geometry might be shared with other nodes...
  //  //this.geometry.destroy()
  //}

  /**
   * @access private
   * @returns {void}
   */


  _resetPromise() {
    this._loadedPromise = null;
  }
  /**
   * @access private
   * @returns {void}
   */


  _resetPromiseRecursively() {
    this._resetPromise();

    for (const child of this._childNodes) {
      child._resetPromiseRecursively();
    }
  }
  /**
   * @access private
   * @returns {Promise} -
   */


  _getLoadedPromise() {
    if (this._loadedPromise) {
      return this._loadedPromise;
    }

    const promises = [];

    for (const child of this._childNodes) {
      promises.push(child.didLoad);
    }

    if (this._particleSystems) {
      for (const system of this._particleSystems) {
        promises.push(system.didLoad);
      }
    }

    if (this._geometry) {
      promises.push(this._geometry.didLoad);
    }

    for (const player of this._audioPlayers) {
      promises.push(player.didLoad);
    } //this._loadedPromise = Promise.all(promises)
    //return this._loadedPromise


    return Promise.all(promises);
  }
  /**
   * @access public
   * @returns {Promise} -
   */


  get didLoad() {
    return this._getLoadedPromise();
  }

}

/**
 * AjaxRequest class
 * @access public
 */

class AjaxRequest {
  /**
   * constructor
   * @access public
   * @constructor
   */
  constructor() {
    this.defaultOptions = {
      method: 'POST',
      async: true,
      data: null,
      user: null,
      password: null,
      mimeType: null,
      isJSONP: false,
      responseType: null,
      requestHeader: {}
    };
    this.jsonpScripts = [];
    this.jsonpCallbackPrefix = 'jsonpCallback_';
  }

  get(url, options = {}) {
    options.method = 'GET';
    return this.request(url, options);
  }

  post(url, options = {}) {
    options.method = 'POST';
    return this.request(url, options);
  }

  jsonp(url, callbackParam = 'callback', options = {}) {
    let requestURL = url;
    const script = document.createElement('script');

    const callbackFuncName = this._getNewFuncName(this.jsonpCallbackPrefix);

    if (!options.data) {
      options.data = {};
    }

    options.data[callbackParam] = callbackFuncName;
    const queryArray = [];
    options.data.forEach((key, value) => {
      queryArray.push(encodeURI(key) + '=' + encodeURI(value));
    });
    requestURL += '?' + queryArray.join('&');
    const promise = new Promise((resolve, reject) => {
      window[callbackFuncName] = resolve;
      script.addEventListener('error', reject);
    }).catch(error => {
      delete window[callbackFuncName];
      document.head.removeChild(script);
      return Promise.reject(error);
    }).then(result => {
      delete window[callbackFuncName];
      document.head.removeChild(script);
      return Promise.resolve(result);
    });
    script.src = requestURL;
    document.head.appendChild(script);
    return promise;
  }

  _getNewFuncName(prefix = '') {
    // ESLint prefers for(;;) more than while(true)
    for (;;) {
      const funcName = prefix + Math.random().toString(16).slice(2);

      if (typeof window[funcName] === 'undefined') {
        return funcName;
      }
    }
  }

  request(url, options = {}) {
    let requestURL = url;
    let method = typeof options.method === 'undefined' ? this.defaultOptions.method : options.method;
    const async = typeof options.async === 'undefined' ? this.defaultOptions.async : options.async;
    let data = this.defaultOptions.data;
    const user = typeof options.user === 'undefined' ? this.defaultOptions.user : options.user;
    const password = typeof options.password === 'undefined' ? this.defaultOptions.password : options.password;
    const mimeType = typeof options.mimeType === 'undefined' ? this.defaultOptions.mimeType : options.mimeType;
    const header = typeof options.requestHeader === 'undefined' ? this.defaultOptions.requestHeader : options.requestHeader;
    const isJSONP = typeof options.isJSONP === 'undefined' ? this.defaultOptions.isJSONP : options.isJSONP;
    const responseType = typeof options.responseType === 'undefined' ? this.defaultOptions.responseType : options.responseType;

    if (method !== 'POST' && method !== 'GET') {
      method = 'POST';
    }

    if (options.data) {
      const dataArray = [];

      if (options.data instanceof Map) {
        options.data.forEach((key, value) => {
          dataArray.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
        });
      } else {
        Object.keys(options.data).forEach(key => {
          const value = options.data[key];
          dataArray.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
        });
      }

      if (method === 'POST') {
        data = dataArray.join('&').replace(/%20/g, '+');
      } else {
        requestURL += '?' + dataArray.join('&').replace(/%20/g, '+');
      }
    }

    if (method === 'POST' && typeof header['Content-Type'] === 'undefined') {
      header['Content-Type'] = 'application/x-www-form-urlencoded';
    }

    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest();

      if (mimeType) {
        xhr.overrideMimeType(mimeType);
      }

      if (responseType) {
        xhr.responseType = responseType;
      }

      if (user) {
        xhr.open(method, requestURL, async, user, password);
      } else {
        xhr.open(method, requestURL, async);
      }

      if (header) {
        for (const key in header) {
          // Reflect is not yet implemented...
          //if(Reflect.apply({}.hasOwnProperty, header, [key])){
          if ({}.hasOwnProperty.call(header, key)) {
            xhr.setRequestHeader(key, header[key]);
          }
        }
      }

      xhr.onload = () => {
        if (xhr.readyState === 4 && xhr.status === 200) {
          resolve(xhr.response);
        } else {
          reject(new Error(xhr.statusText));
        }
      };

      xhr.onerror = () => {
        reject(new Error(xhr.statusText));
      };

      xhr.send(data);
    });
  }

}
var _AjaxRequest = new AjaxRequest();

/**
 * BinaryRequest class
 * @access public
 */

class BinaryRequest extends AjaxRequest {
  /**
   * constructor
   * @access public
   * @constructor
   */
  constructor() {
    super();
    this.defaultOptions.mimeType = 'text/plain; charset=x-user-defined';
  }

}
var _BinaryRequest = new BinaryRequest();

const _AnimationImportPolicy = {
  doNotPlay: 'keepSeparate',
  play: 'playOnce',
  playRepeatedly: 'playRepeatedly',
  playUsingSceneTimeBase: 'playUsingSceneTime'
};
const _LoadingOption = {
  animationImportPolicy: 'kSceneSourceAnimationLoadingMode',
  assetDirectoryURLs: 'kSceneSourceAssetDirectoryURLs',
  checkConsistency: 'kSceneSourceCheckConsistency',
  convertToYUp: 'kSceneSourceConvertToYUpIfNeeded',
  convertUnitsToMeters: 'kSceneSourceConvertToUnit',
  createNormalsIfAbsent: 'kSceneSourceCreateNormalsIfAbsent',
  flattenScene: 'kSceneSourceFlattenScene',
  overrideAssetURLs: 'kSceneSourceOverrideAssetURLs',
  preserveOriginalTopology: 'kSceneSourcePreserveOriginalTopology',
  strictConformance: 'kSceneSourceStrictConformanceKey',
  useSafeMode: 'kSceneSourceUseSafeMode',
  _urlTranslator: 'kSceneSourceURLTranslator'
  /**
   * Manages the data-reading tasks associated with loading scene contents from a file or data.
   * @access public
   * @extends {NSObject}
   * @see https://developer.apple.com/documentation/scenekit/scnscenesource
   */

};
class SCNSceneSource extends NSObject {
  // Creating a Scene Source

  /**
   * Initializes a scene source for reading the scene graph contained in an NSData object.
   * @access public
   * @constructor
   * @param {Blob} data - A data object containing a scene file in a format recognized by SceneKit.
   * @param {?Map<SCNSceneSource.LoadingOption, Object>} [options = null] - A dictionary containing options that affect scene loading. See Scene Loading Options for available keys and values. Pass nil to use default options.
   * @desc The data parameter of this method should contain the same data as directly read from a scene file (such as by using the NSData method dataWithContentsOfURL:). Use this method when you have the contents of a scene file but not the file itself—for example, if your app downloads scene files from the network.
   * @see https://developer.apple.com/documentation/scenekit/scnscenesource/1523500-init
   */
  constructor(data, options = null) {
    super(); // Getting Information about the Scene

    this._url = null;
    this._options = options;
    this._data = data;
    /**
     * @access private
     * @type {Promise}
     */

    this._loadedPromise = new Promise((resolve, reject) => {
      this._resolveFunction = resolve;
      this._rejectFunction = reject;
    });

    if (data) {
      this._resolveFunction();
    }
  }
  /**
   * @access public
   * @param {Blob} data -
   * @param {?Map<SCNSceneSource.LoadingOption, Object>} [options = null] -
   * @returns {SCNSceneSource} -
   */


  static sceneSourceWithDataOptions(data, options) {
    return new SCNSceneSource(data, options);
  }
  /**
   * @access public
   * @param {string|File} url -
   * @param {?Map<SCNSceneSource.LoadingOption, Object>} [options = null] -
   * @returns {SCNSceneSource} -
   */


  static sceneSourceWithURLOptions(url, options = null) {
    let _options = options;

    if (_options === null) {
      _options = new Map();
    }

    if (typeof _options.get(_LoadingOption.assetDirectoryURLs) === 'undefined') {
      const paths = url.split('/');
      const name = paths.pop();
      const directory = paths.join('/');

      _options.set(_LoadingOption.assetDirectoryURLs, directory);
    }

    const source = new SCNSceneSource();
    source._url = url;

    _BinaryRequest.get(url).then(data => {
      source._data = data;
      source._options = _options;

      source._resolveFunction();
    });

    return source;
  } // Loading a Complete Scene

  /**
   * Loads the entire scene graph from the scene source and calls the specified block to provide progress information.
   * @access public
   * @param {?Map<SCNSceneSource.LoadingOption, Object>} [options = null] - A dictionary containing options that affect scene loading. See Scene Loading Options for available keys and values. Pass nil to use default options.
   * @param {?SCNSceneSourceStatusHandler} [statusHandler = null] - An SCNSceneSourceStatusHandler block. SceneKit calls this block periodically to report progress while loading the scene.
   * @returns {?SCNScene} - 
   * @desc Use this method if you need to monitor progress while loading a scene from the scene source. For simpler scene loading, use the scene(options:) method or the SCNScene method init(url:options:).A scene source can contain objects that are not part of its scene graph. To obtain these objects, you must load them individually with the the entryWithIdentifier:withClass: or entries(passingTest:) method. For example, a scene file containing a game character could include several animations for the character geometry (such as running, jumping, and standing idle). Because you typically do not apply multiple animations at once, the scene file contains these animations without their being attached to the character geometry.
   * @see https://developer.apple.com/documentation/scenekit/scnscenesource/1522887-scene
   */


  scene(options = null, statusHandler = null) {
    let _options = options;

    if (!_options) {
      if (this._options) {
        _options = this._options;
      }
    }

    let url = this._url;

    const assetDirectoryURLs = _options.get(_LoadingOption.assetDirectoryURLs);

    if (assetDirectoryURLs) {
      let dir = assetDirectoryURLs;

      if (Array.isArray(dir)) {
        dir = dir[0];
      }

      url = dir + '/';

      if (this._url) {
        url += this._url.split('/').pop();
      }
    }

    if (this._data.match(/\nv -?[0-9]+(\.[0-9]+)? -?[0-9]+(\.[0-9]+)? -?[0-9]+(\.[0-9]+)?\s*\n/)) {
      // seems obj data
      return _SCNObjLoader.unarchiveObjectWithData(this._data, url, _options);
    }

    return NSKeyedUnarchiver.unarchiveObjectWithData(this._data, url, _options);
  } // Loading and Inspecting Scene Elements

  /**
   * Returns the identifiers for all objects in the scene source of the specified class.
   * @access public
   * @param {Object} entryClass - The class of objects to find identifiers for.
   * @returns {string[]} - 
   * @desc SceneKit recognizes objects of the following classes in scene files:CAAnimationNSImageSCNCameraSCNGeometrySCNLightSCNMaterialSCNMorpherSCNNodeSCNSceneSCNSkinnerEach object in a scene file has an identifier that is unique for its class. These identifiers are determined by the software that created the scene file—for example, they may be descriptive names assigned by an artist using 3D authoring tools. For SceneKit classes with a name property (such as nodes and geometries), the name of an object loaded from a scene file is based on its identifier in the scene file.Use this method to enumerate all objects in a scene file of a specified class without loading the objects and their content. For example, the following code finds the identifiers for all animations stored in a scene source:NSArray *animations = [sceneSource identifiersOfEntriesWithClass:[CAAnimation class]];
  NSArray *animations = [sceneSource identifiersOfEntriesWithClass:[CAAnimation class]];
    * @see https://developer.apple.com/documentation/scenekit/scnscenesource/1523656-identifiersofentries
   */


  identifiersOfEntriesWithClass(entryClass) {
    return null;
  }
  /**
   * Loads and returns all objects in the scene source that pass the test in a given block.
   * @access public
   * @param {function(arg1: Object, arg2: string, arg3: UnsafeMutablePointer<ObjCBool>): boolean} predicate - The block to be applied to each object in the scene source.The block takes three parameters:entryThe object to be tested.identifierThe unique identifier of the object in the scene source.stopA reference to a Boolean value. Set *stop to true within the block to abort further processing of the scene source’s contents.The block returns a Boolean value indicating whether the entry object passed the test and should be included in the method’s returned array.
   * @returns {Object[]} - 
   * @desc SceneKit recognizes objects of the following classes in scene files:CAAnimationNSImageSCNCameraSCNGeometrySCNLightSCNMaterialSCNMorpherSCNNodeSCNSceneSCNSkinnerEach object in a scene file has an identifier that is unique for its class. These identifiers are determined by the software that created the scene file—for example, they may be descriptive names assigned by an artist using 3D authoring tools. For SceneKit classes with a name property (such as nodes and geometries), the name of an object loaded from a scene file is based on its identifier in the scene file.Use this method to selectively load objects from a scene source matching criteria you specify. For example, the following code loads from a scene file only the nodes that have attached geometry:NSArray *geometryNodes = [sceneSource entriesPassingTest:^BOOL(id entry, NSString *identifier, BOOL *stop) {
    if ([entry isKindOfClass:[SCNNode class]]) {
        SCNNode *node = (SCNNode *)entry;
        return (node.geometry != nil);
    } else {
        return NO;
    }
  }];
  NSArray *geometryNodes = [sceneSource entriesPassingTest:^BOOL(id entry, NSString *identifier, BOOL *stop) {
    if ([entry isKindOfClass:[SCNNode class]]) {
        SCNNode *node = (SCNNode *)entry;
        return (node.geometry != nil);
    } else {
        return NO;
    }
  }];
    * @see https://developer.apple.com/documentation/scenekit/scnscenesource/1523055-entries
   */


  entriesPassingTest(predicate) {
    return null;
  } // Getting Information about the Scene

  /**
   * Returns metadata about the scene.
   * @access public
   * @param {string} key - A constant identifying a metadata property of the scene source. See Scene Source Properties for available keys and the formats of their values.
   * @returns {?Object} - 
   * @desc This method returns information about the scene that is defined in the file but is not directly referenced by the scene.
   * @see https://developer.apple.com/documentation/scenekit/scnscenesource/1523277-property
   */


  propertyForKey(key) {
    return null;
  }
  /**
   * The URL identifying the file from which the scene source was created.
   * @type {?string}
   * @desc The value of this property is nil if the scene source was not created using the sceneSourceWithURL:options: or init(url:options:) method.
   * @see https://developer.apple.com/documentation/scenekit/scnscenesource/1524038-url
   */


  get url() {
    return this._url;
  }
  /**
   * The data object from which the scene source loads scene content.
   * @type {?Data}
   * @desc If the scene source was created using the sceneSourceWithData:options: or init(data:options:) method, this property’s value is the data from which the scene source was created. If the scene source was created from a scene file using the the sceneSourceWithURL:options: or init(url:options:) method, this property’s value is the data loaded from that URL at the time the scene source was created.
   * @see https://developer.apple.com/documentation/scenekit/scnscenesource/1523061-data
   */


  get data() {
    return this._data;
  } // Instance Methods

  /**
   * 
   * @access public
   * @param {string} uid - 
   * @param {T.Type} entryClass - 
   * @returns {Object} - 
   * @see https://developer.apple.com/documentation/scenekit/scnscenesource/2805685-entrywithidentifier
   */


  entryWithIdentifierWithClass(uid, entryClass) {
    return null;
  } // Structures

  /**
   * @type {Object} AnimationImportPolicy
   * @property {string} doNotPlay Animations are not loaded from the scene file.
   * @property {string} play Animations loaded from the scene file are immediately added to the scene and played once.
   * @property {string} playRepeatedly Animations loaded from the scene file are immediately added to the scene and played repeatedly.
   * @property {string} playUsingSceneTimeBase Animations loaded from the scene file are immediately added to the scene and played according to the scene’s sceneTime property.
   * @see https://developer.apple.com/documentation/scenekit/scnscenesource.animationimportpolicy
   */


  static get AnimationImportPolicy() {
    return _AnimationImportPolicy;
  }
  /**
   * @type {Object} LoadingOption
   * @property {string} animationImportPolicy An option for controlling the playback of animations in a scene file.
   * @property {string} assetDirectoryURLs Locations to use for resolving relative URLs to external resources.
   * @property {string} checkConsistency An option to validate scene files while loading.
   * @property {string} convertToYUp An option for whether to transform assets loaded from the scene file for use in a coordinate system where the y-axis points up.
   * @property {string} convertUnitsToMeters An option for whether to automatically scale the scene’s contents.
   * @property {string} createNormalsIfAbsent An option for automatically generating surface normals if they are absent when loading geometry.
   * @property {string} flattenScene An option for automatically merging portions of a scene graph during loading.
   * @property {string} overrideAssetURLs An option to attempt loading external resources using their URLs as specified in a scene file.
   * @property {string} preserveOriginalTopology 
   * @property {string} strictConformance An option to interpret scene files exactly as specified by the scene file format.
   * @property {string} useSafeMode An option to limit filesystem and network access for external resources referenced by a scene file.
   * @see https://developer.apple.com/documentation/scenekit/scnscenesource.loadingoption
   */


  static get LoadingOption() {
    return _LoadingOption;
  }
  /**
   * @access private
   * @returns {Promise* -
   */


  _getLoadedPromise() {
    return this._loadedPromise;
  }
  /**
   * @access public
   * @type {Promise}
   */


  get didLoad() {
    return this._getLoadedPromise();
  }

}

const _Attribute = {
  endTime: 'kSceneEndTimeAttributeKey',
  frameRate: 'kSceneFrameRateAttributeKey',
  startTime: 'kSceneStartTimeAttributeKey',
  upAxis: 'kSceneUpAxisAttributeKey'
  /**
   * A scene graph—a hierarchy of nodes with attached geometries, lights, cameras and other attributes that together form a displayable 3D scene.
   * @access public
   * @extends {NSObject}
   * @see https://developer.apple.com/documentation/scenekit/scnscene
   */

};
class SCNScene extends NSObject {
  static get _propTypes() {
    return {
      paused: ['boolean', 'isPaused'],
      rootNode: ['SCNNode', '_rootNode'],
      upAxis: ['SCNVector3', null],
      physicsWorld: ['SCNPhysicsWorld', (obj, value) => {
        obj._physicsWorld = value;
        obj._physicsWorld._scene = obj;
      }],
      background: ['SCNMaterialProperty', (obj, value) => {
        obj._skyBox.geometry.firstMaterial._emission = value;

        obj._skyBox.geometry.firstMaterial._emission._createPresentation();
      }],
      startTime: ['double', null],
      endTime: ['double', null],
      frameRate: ['double', null],
      fogDensityExponent: 'double',
      fogStartDistance: 'double',
      fogEndDistance: 'double',
      fogColor: 'plist',
      environment: ['SCNMaterialProperty', '_lightingEnvironment'],
      version: ['float', null],
      userAttributes: ['NSMutableDictionary', null],
      sourceURL: ['NSURL', null]
    };
  }
  /**
   * Loads a scene from the specified URL.
   * @access public
   * @constructor
   * @param {string} url - The URL to the scene file to load.
   * @param {?Map<SCNSceneSource.LoadingOption, Object>} [options = null] - A dictionary of options affecting scene loading, or nil for default options. For available keys, see Scene Loading Options.
   * @param {function} onload -
   * @param {function} onerror -
   * @throws {Error}
   * @desc This method provides a convenient way to load a complete scene from a file at an arbitrary URL. For more detailed options or to load only part of a file’s scene graph, use the SCNSceneSource class.Handling Errors in Swift:
  In Swift, this method returns a nonoptional result and is marked with the throws keyword to indicate that it throws an error in cases of failure.
  You call this method in a try expression and handle any errors in the catch clauses of a do statement, as described in Error Handling in The Swift Programming Language (Swift 3.1) and Error Handling in Using Swift with Cocoa and Objective-C (Swift 3.1).
    * @see https://developer.apple.com/documentation/scenekit/scnscene/1522660-init
   */


  constructor(url, options = null, onload = null, onerror = null) {
    super(); // Managing Animated Effects in a Scene

    /**
     * A Boolean value that determines whether to run actions, animations, particle systems, and physics simulations in the scene graph.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnscene/1523604-ispaused
     */

    this.isPaused = false; // Accessing Scene Contents

    this._rootNode = new SCNNode();
    this._lightingEnvironment = null; // Adding Fog to a Scene

    /**
     * The distance from a point of view at which the scene’s contents begin to be obscured by fog. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnscene/1522790-fogstartdistance
     */

    this.fogStartDistance = 0;
    /**
     * The distance from a point of view at which the scene’s contents are completely obscured by fog. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnscene/1523836-fogenddistance
     */

    this.fogEndDistance = 0;
    /**
     * The transition curve for the fog’s intensity between its start and end distances. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnscene/1523776-fogdensityexponent
     */

    this.fogDensityExponent = 0;
    /**
     * The color of the fog effect to be rendered with the scene. Animatable.
     * @type {Object}
     * @see https://developer.apple.com/documentation/scenekit/scnscene/1522774-fogcolor
     */

    this.fogColor = null; // Working With Physics in the Scene

    this._physicsWorld = new SCNPhysicsWorld();
    this._physicsWorld._scene = this; // Working with Particle Systems in the Scene

    this._particleSystems = null;
    this._particleSystemsTransform = null;
    /**
     * @access private
     * @type {Promise}
     */

    this._dataLoadedPromise = null;

    if (url) {
      const promise = this._loadSceneWithURL(url, options).then(scene => {
        this._copyValue(scene);

        if (onload) {
          onload(this);
        }
      }).catch(error => {
        if (onerror) {
          onerror(error);
        }
      });

      this._dataLoadedPromise = promise;
    }

    this._createSkyBox();
    /**
     * @access private
     * @type {Promise}
     */


    this._loadedPromise = null;
  }

  _copyValue(src) {
    this.isPaused = src.isPaused;
    this._rootNode = src._rootNode; //this._background = src._background

    this._skyBox.geometry = src._skyBox.geometry.copy();
    this._lightingEnvironment = src._lightingEnvironment;
    this.fogStartDistance = src.fogStartDistance;
    this.fogEndDistance = src.fogEndDistance;
    this.fogDensityExponent = src.fogDensityExponent;
    this.fogColor = src.fogColor;
    this._physicsWorld = src._physicsWorld; // TODO: copy SCNPhysicsWorld

    this._particleSystems = src._particleSystems ? src._particleSystems.slice(0) : null;
    this._particleSystemsTransform = src._particleSystemsTransform ? src._particleSystemsTransform.slice(0) : null;
  }
  /**
   * @access private
   * @param {string} url -
   * @param {Object} options -
   * @returns {Promise} -
   */


  _loadSceneWithURL(url, options) {
    let _options = options;

    if (_options === null) {
      _options = new Map();
    }

    if (typeof _options.get(SCNSceneSource.LoadingOption.assetDirectoryURLs) === 'undefined') {
      const paths = url.split('/');
      const name = paths.pop();
      const directory = paths.join('/');

      _options.set(SCNSceneSource.LoadingOption.assetDirectoryURLs, directory);
    }

    if (url instanceof File) {
      return Promise((resolve, reject) => {
        const reader = new FileReader();

        reader.onload = () => {
          const scene = this._loadSceneWithData(reader.result, _options);

          resolve(scene);
        };

        reader.onerror = () => {
          reject(reader.error);
        };

        reader.readAsBinaryString(url);
      });
    }

    return _BinaryRequest.get(url).then(data => {
      return this._loadSceneWithData(data, _options);
    });
  }
  /**
   * @access private
   * @param {Blob} data -
   * @param {Object} options -
   * @returns {SCNScene} -
   */


  _loadSceneWithData(data, options) {
    const source = new SCNSceneSource(data, options);
    return source.scene();
  }

  _createSkyBox() {
    const skyBoxGeometry = new SCNBox();
    const material = new SCNMaterial();
    material._diffuse._contents = SKColor.black;
    material._ambient._contents = SKColor.black;
    material._emission._contents = null;
    material.isDoubleSided = true;
    skyBoxGeometry.firstMaterial = material;
    const texSrc = skyBoxGeometry.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.texcoord)[0];
    const margin = 0.001;
    const w0 = 0.0;
    const w1 = 1.0 / 6.0;
    const w2 = 2.0 / 6.0;
    const w3 = 3.0 / 6.0;
    const w4 = 4.0 / 6.0;
    const w5 = 5.0 / 6.0;
    const w6 = 1.0;
    const data = [w5 - margin, 1, w5 - margin, 0, w4 + margin, 1, w4 + margin, 0, w2 - margin, 1, w2 - margin, 0, w1 + margin, 1, w1 + margin, 0, w6 - margin, 1, w6 - margin, 0, w5 + margin, 1, w5 + margin, 0, w1 - margin, 1, w1 - margin, 0, w0 + margin, 1, w0 + margin, 0, w3 - margin, 1, w3 - margin, 0, w2 + margin, 1, w2 + margin, 0, w4 - margin, 1, w4 - margin, 0, w3 + margin, 1, w3 + margin, 0];
    let dataIndex = 0;
    let srcIndex = 6;

    for (let i = 0; i < 24; i++) {
      texSrc._data[srcIndex + 0] = data[dataIndex + 0];
      texSrc._data[srcIndex + 1] = data[dataIndex + 1];
      srcIndex += 8;
      dataIndex += 2;
    }

    this._skyBox = new SCNNode(skyBoxGeometry);
    this._skyBox._presentation = this._skyBox;
  } // Creating or Loading a Scene

  /**
   * Loads a scene from a file with the specified name in the app’s main bundle.
   * @access public
   * @param {string} name - The name of a scene file in the app bundle’s resources directory.
   * @returns {void}
   * @desc This method provides a convenient way to load a complete scene from a file in the app’s main bundle. Calling this method is equivalent to using the Bundle class to locate the scene file and passing the resulting URL to the init(url:options:) method, specifying no options and no error handling.For more detailed options or to load only part of a file’s scene graph, use the SCNSceneSource class.
   * @see https://developer.apple.com/documentation/scenekit/scnscene/1523355-init
   */


  static sceneNamed(name) {
    return this.sceneNamedInDirectory(name);
  }
  /**
   * Loads a scene from a file with the specified name in a specific subdirectory of the app’s main bundle.
   * @access public
   * @param {string} name - The name of a scene file in the app bundle.
   * @param {?string} directory - The path to the subdirectory of the bundle’s resources directory containing the scene file.
   * @param {?Map<SCNSceneSource.LoadingOption, Object>} [options = null] - A dictionary of options affecting scene loading, or nil for default options. For available keys, see Scene Loading Options.
   * @returns {void}
   * @desc This method provides a convenient way to load a complete scene from a file in the app’s main bundle. Calling this method is equivalent to using the Bundle class to locate the scene file and passing the resulting URL to the init(url:options:) method.For more detailed options or to load only part of a file’s scene graph, use the SCNSceneSource class.
   * @see https://developer.apple.com/documentation/scenekit/scnscene/1522851-init
   */


  static sceneNamedInDirectory(name, directory, options = null) {
    let path = name;

    if (directory) {
      path = directory + '/' + name;
    }

    return new SCNScene(path, options);
  }
  /**
   * Loads a scene from the specified URL.
   * @access public
   * @param {string} url - The URL to the scene file to load.
   * @param {?Map<SCNSceneSource.LoadingOption, Object>} [options = null] - A dictionary of options affecting scene loading, or nil for default options. For available keys, see Scene Loading Options.
   * @returns {SCNScene} -
   * @throws {Error}
   * @desc This method provides a convenient way to load a complete scene from a file at an arbitrary URL. For more detailed options or to load only part of a file’s scene graph, use the SCNSceneSource class.Handling Errors in Swift:
  In Swift, this method returns a nonoptional result and is marked with the throws keyword to indicate that it throws an error in cases of failure.
  You call this method in a try expression and handle any errors in the catch clauses of a do statement, as described in Error Handling in The Swift Programming Language (Swift 3.1) and Error Handling in Using Swift with Cocoa and Objective-C (Swift 3.1).
    * @see https://developer.apple.com/documentation/scenekit/scnscene/1522660-init
   */


  static scene(url, options = null) {
    return new SCNScene(url, options);
  } // Accessing Scene Contents

  /**
   * The root node of the scene graph.
   * @type {SCNNode}
   * @desc All scene content—nodes, geometries and their materials, lights, cameras, and related objects—is organized in a node hierarchy with a single common root node.Some scene files created using external tools may describe node hierarchies containing multiple root nodes. When SceneKit imports such files, their separate root nodes will be made children of a new, unique root node.Each child node’s coordinate system is defined relative to the transformation of its parent node. You should not modify the transform property of the root node.
   * @see https://developer.apple.com/documentation/scenekit/scnscene/1524029-rootnode
   */


  get rootNode() {
    return this._rootNode;
  }
  /**
   * A background to be rendered before the rest of the scene.
   * @type {SCNMaterialProperty}
   * @desc If the material property’s contents object is nil, SceneKit does not draw any background before drawing the rest of the scene. (If the scene is presented in an SCNView instance, the view’s background color is visible behind the contents of the scene.)If you specify a cube map texture for the material property (see the discussion of the contents property), SceneKit renders the background as a skybox.
   * @see https://developer.apple.com/documentation/scenekit/scnscene/1523665-background
   */


  get background() {
    return this._skyBox.geometry.firstMaterial._emission;
  }
  /**
   * A cube map texture that depicts the environment surrounding the scene’s contents, used for advanced lighting effects.
   * @type {SCNMaterialProperty}
   * @desc When rendering materials with the physicallyBased lighting model, SceneKit illuminates surfaces differently according to the environment that surrounds them. For example, with physically based shading, even a diffuse surface takes on some color from the sky above it and the ground below it.TipFor realistic results, reuse the same contents for both the lighting environment and the background property.For information about defining cube maps, see the discussion of the contents property.
   * @see https://developer.apple.com/documentation/scenekit/scnscene/1639532-lightingenvironment
   */


  get lightingEnvironment() {
    return this._lightingEnvironment;
  } // Managing Scene Attributes

  /**
   * Returns the scene attribute for the specified key.
   * @access public
   * @param {string} key - One of the constants described in Scene Attributes that identifies the attribute to be read.
   * @returns {?Object} - 
   * @see https://developer.apple.com/documentation/scenekit/scnscene/1522858-attribute
   */


  attributeForKey(key) {
    return null;
  }
  /**
   * Sets a scene attribute for the specified key.
   * @access public
   * @param {?Object} attribute - An object that specifies the value of the attribute to be written.
   * @param {string} key - One of the constants described in Scene Attributes that identifies the attribute to be written.
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnscene/1524229-setattribute
   */


  setAttributeForKey(attribute, key) {} // Exporting a Scene File

  /**
   * Exports the scene and its contents to a file at the specified URL.
   * @access public
   * @param {string} url - The URL to write the scene file to. This URL must use the file scheme.
   * @param {?Map<string, Object>} [options = null] - A dictionary of options affecting scene loading, or nil for default options. For available keys, see Scene Loading Options.
   * @param {?SCNSceneExportDelegate} delegate - A delegate object to customize export of external resources used by the scene. Pass nil for default export of external resources.
   * @param {?SCNSceneExportProgressHandler} [progressHandler = null] - A block that SceneKit calls repeatedly to report progress of the export operation.
   * @returns {boolean} - 
   * @desc SceneKit creates and writes a file containing the scene graph in the Digital Asset Exchange (DAE) format. The format of the file created depends on OS version and on the filename extension you specify:In iOS 10.0, tvOS 10.0, watchOS 3.0, OS X v10.11, and later versions, specify the .scn extension to save a file in SceneKit’s native format. This format supports all features of SceneKit (including physics, constraints, and particle systems), and reading files in this format is faster than importing from other scene file formats.In macOS only, specify the .dae extension to export in Digital Asset Exchange (DAE) format for use by other apps. Exported DAE files do not contain scene elements specific to SceneKit, such as physics bodies and fields, constraints, and particle systems.If the scene references external resources, such as image files used in material properties, SceneKit exports these files to a nearby location and references their URLs in the exported scene file. To override SceneKit’s exporting of external resources, provide an object implementing the SCNSceneExportDelegate protocol in the delegate parameter.
   * @see https://developer.apple.com/documentation/scenekit/scnscene/1523577-write
   */


  writeTo(url, options = null, delegate, progressHandler = null) {
    return false;
  } // Working With Physics in the Scene

  /**
   * The physics simulation associated with the scene.
   * @type {SCNPhysicsWorld}
   * @desc Every scene automatically creates a physics world object to simulate physics on nodes in the scene. You use this property to access the scene’s global physics properties, such as gravity, and to manage physics interactions between nodes. To make a node in the scene participate in the physics simulation, use either or both of its physicsBody and physicsField properties.
   * @see https://developer.apple.com/documentation/scenekit/scnscene/1522643-physicsworld
   */


  get physicsWorld() {
    return this._physicsWorld;
  } // Working with Particle Systems in the Scene

  /**
   * Attaches a particle system to the scene, using the specified transform.
   * @access public
   * @param {SCNParticleSystem} system - A particle system.
   * @param {SCNMatrix4} transform - A transformation matrix that positions and orients the particle system relative to the world coordinate space of the scene.
   * @returns {void}
   * @desc A particle system directly attached to a scene is not related to the coordinate space of any node in the scene. To attach a particle system whose emitter location follows the movement of a node within the scene, use the corresponding SCNNode method.For details on particle systems, see SCNParticleSystem.
   * @see https://developer.apple.com/documentation/scenekit/scnscene/1523359-addparticlesystem
   */


  addParticleSystem(system, transform) {
    if (this._particleSystems === null) {
      this._particleSystems = [];
      this._particleSystemsTransform = [];
    } //system._startTime = Date.now() * 0.001


    system.reset();

    this._particleSystems.push(system);

    this._particleSystemsTransform.push(transform);

    if (this._particleSystems.length !== this._particleSystemsTransform.length) {
      throw new Error('particleSystems array length inconsistency');
    }
  }
  /**
   * Removes a particle system attached to the scene.
   * @access public
   * @param {SCNParticleSystem} system - A particle system.
   * @returns {void}
   * @desc This method has no effect if the system parameter does not reference a particle system directly attached to the scene.
   * @see https://developer.apple.com/documentation/scenekit/scnscene/1523498-removeparticlesystem
   */


  removeParticleSystem(system) {
    if (this._particleSystems === null) {
      return;
    }

    const index = this._particleSystems.indexOf(system);

    if (index < 0) {
      return;
    }

    this._particleSystems.splice(index, 1);

    this._particleSystemsTransform.splice(index, 1);
  }
  /**
   * Removes any particle systems directly attached to the scene.
   * @access public
   * @returns {void}
   * @desc Calling this method does not remove particle systems attached to nodes within the scene.
   * @see https://developer.apple.com/documentation/scenekit/scnscene/1522786-removeallparticlesystems
   */


  removeAllParticleSystems() {
    this._particleSystems = [];
    this._particleSystemsTransform = [];
  }
  /**
   * The particle systems attached to the scene.
   * @type {?SCNParticleSystem[]}
   * @desc An array of SCNParticleSystem objects directly attached to the scene. This array does not include particle systems attached to nodes within the scene.For details on particle systems, see SCNParticleSystem.
   * @see https://developer.apple.com/documentation/scenekit/scnscene/1522787-particlesystems
   */


  get particleSystems() {
    return this._particleSystems.slice(0);
  }
  /**
   * @access private
   * @returns {Promise} -
   */


  _getLoadedPromise() {
    if (this._loadedPromise) {
      return this._loadedPromise;
    }

    if (!this._dataLoadedPromise) {
      return Promise.resolve();
    }

    this._loadedPromise = this._dataLoadedPromise.then(() => {
      const promises = [];
      promises.push(this._rootNode.didLoad);
      promises.push(this._skyBox.didLoad);

      if (this._lightingEnvironment) {
        promises.push(this._lightingEnvironment.didLoad);
      }

      return Promise.all(promises);
    });
    return this._loadedPromise;
  }
  /**
   * @access public
   * @type {Promise} -
   */


  get didLoad() {
    return this._getLoadedPromise();
  } // Structures

  /**
   * @type {Object} Attribute
   * @property {string} endTime A floating-point value (in an NSNumber object) for the end time of the scene.
   * @property {string} frameRate A floating-point value (in an NSNumber object) for the frame rate of the scene.
   * @property {string} startTime A floating-point value (in an NSNumber object) for the start time of the scene.
   * @property {string} upAxis An SCNVector3 structure (in an NSValue object) specifying the orientation of the scene.
   * @see https://developer.apple.com/documentation/scenekit/scnscene.attribute
   */


  static get Attribute() {
    return _Attribute;
  }

}

/*global Buffer*/

class _SCNObjLoader {
  constructor(data = null, url = null) {
    /**
     * @access private
     * @type {?string}
     */
    this._filePath = url;
    /**
     * @access private
     * @type {?_TextReader}
     */

    this._reader = null;

    if (data !== null) {
      this._reader = new TextReader(data, 'utf-8');
    }

    this._node = null;
    this._currentNode = null;
    const funcs = {
      '#': this._Comment,
      'v': this._GeometricVertices,
      'vt': this._TextureVertices,
      'vn': this._VertexNormals,
      'vp': this._ParameterSpaceVertices,
      'cstype': this._CurveSurfaceType,
      'deg': this._Degree,
      'bmat': this._BasisMatrix,
      'step': this._StepSize,
      'p': this._Point,
      'l': this._Line,
      'f': this._Face,
      'curv': this._Curve,
      'curv2': this._2DCurve,
      'surf': this._Surface,
      'parm': this._ParameterValues,
      'trim': this._OuterTrimmingLoop,
      'hole': this._InnerTrimmingLoop,
      'scrv': this._SpecialCurve,
      'sp': this._SpecialPoint,
      'end': this._EndStatement,
      'con': this._Connect,
      'g': this._GroupName,
      's': this._SmoothingGroup,
      'mg': this._MergingGroup,
      'o': this._ObjectName,
      'bevel': this._BevelInterpolation,
      'c_interp': this._ColorInterpolation,
      'd_interp': this._DissolveInterpolation,
      'lod': this._LevelOfDetail,
      'usemtl': this._MaterialName,
      'mtllib': this._MaterialLibrary,
      'shadow_obj': this._ShadowCasting,
      'trace_obj': this._RayTracing,
      'ctech': this._CurveApproximationTechnique,
      'stech': this._SurfaceApproximationTechnique
    };
    this._funcs = {};
    Object.keys(funcs).forEach(key => {
      this._funcs[key] = funcs[key].bind(this);
    });
  }
  /**
   * @access public
   * @param {Buffer} data -
   * @param {?string} [path = null] -
   * @returns {SCNScene} -
   */


  static unarchiveObjectWithData(data, path = null) {
    const unarchiver = new _SCNObjLoader(data);
    unarchiver._filePath = path;
    return unarchiver._loadObjFile();
  }
  /**
   * @access public
   * @param {?string} [path = null] -
   * @returns {Promise} -
   */


  static unarchiveObjectWithFile(path) {
    const promise = _SCNObjLoader._getBufferOfFile(path).then(data => {
      return _SCNObjLoader.unarchiveObjectWithData(data, path);
    });

    return promise;
  }

  static _getBufferOfFile(path) {
    const promise = new Promise((resolve, reject) => {
      const file = new File([], path);
      const reader = new FileReader();

      reader.onload = () => {
        const data = reader.result;
        resolve(data);
      };

      reader.onerror = () => {
        reject(reader.error);
      };

      reader.readAsText(file);
    });
    return promise;
  }
  /**
   * @access private
   * @param {string} line -
   * @returns {string[]) -
   */


  _getTokens(line) {
    return line.split(' ').filter(str => str !== '').map(str => str.trim());
  }

  _loadObjFile() {
    console.error('_loadObjFile');
    const defaultGroupName = 'default';
    const defaultMtlName = '_SCNObjLoader.default';
    this._scene = new SCNScene();
    this._node = new SCNNode();
    this._currentNode = new SCNNode();

    this._scene.rootNode.addChildNode(this._node);

    this._vertexArray = [new SCNVector3(0, 0, 0)];
    this._normalArray = [new SCNVector3(0, 0, 0)];
    this._texcoordArray = [new CGPoint(0, 0)];
    this._materialPromise = Promise.resolve();
    this._materialMap = {};
    this._skinArray = [];
    this._indexArrayMap = {
      [defaultMtlName]: []
    };
    this._currentMtlName = defaultMtlName;
    this._currentIndexArray = this._indexArrayMap[defaultMtlName];
    this._currentGroupName = defaultGroupName;
    this._vertexSource = null;
    this._elementArray = [];

    let line = this._reader.readLine();

    this._break = false;

    while (!this._break && line !== null) {
      const tokens = this._getTokens(line);

      if (tokens.length === 0) {
        line = this._reader.readLine();
        continue;
      }

      const func = this._funcs[tokens[0]];

      if (typeof func === 'undefined') {
        throw new Error('_SCNObjLoader unknown type: ' + tokens[0]);
      }

      func(tokens);
      line = this._reader.readLine();
    }

    const promise = this._materialPromise.then(materialArray => {
      const materialCount = materialArray.length;

      for (let i = materialCount - 1; i >= 0; i--) {
        const material = materialArray[i];
        Object.keys(material).forEach(name => {
          this._materialMap[name] = material[name];
        });
      }

      this._createGeometry();
    });

    this._node._loadedPromise = promise;
    return this._scene;
  }
  /**
   * @access private
   * @returns {void} -
   */


  _createGeometry() {
    const skinCount = this._skinArray.length;
    const vertexData = [];
    const texcoordData = [];
    const normalData = []; // vertex data

    for (let i = 0; i < skinCount; i++) {
      const skin = this._skinArray[i];
      let vertex = null;
      let texcoord = null;
      let normal = null;

      if (skin) {
        vertex = this._vertexArray[skin.vertex];
        texcoord = this._texcoordArray[skin.texcoord];
        normal = this._normalArray[skin.normal];
      }

      if (vertex) {
        vertexData.push(vertex.x, vertex.y, vertex.z);
      } else {
        vertexData.push(0, 0, 0);
      }

      if (texcoord) {
        texcoordData.push(texcoord.x, texcoord.y);
      } else {
        texcoordData.push(0, 0);
      }

      if (normal) {
        normalData.push(normal.x, normal.y, normal.z);
      } else {
        normalData.push(0, 0, 0);
      }
    }

    const vertexSource = new SCNGeometrySource(vertexData, // data
    SCNGeometrySource.Semantic.vertex, // semantic
    skinCount, // vectorCount
    true, // usesFloatComponents
    3, // componentsPerVector
    4, // bytesPerComponent,
    0, // dataOffset
    12 // dataStride
    );
    const normalSource = new SCNGeometrySource(normalData, // data
    SCNGeometrySource.Semantic.normal, // semantic
    skinCount, // vectorCount
    true, // usesFloatComponents
    3, // componentsPerVector
    4, // bytesPerComponent,
    0, // dataOffset
    12 // dataStride
    );
    const texcoordSource = new SCNGeometrySource(texcoordData, // data
    SCNGeometrySource.Semantic.texcoord, // semantic
    skinCount, // vectorCount
    true, // usesFloatComponents
    2, // componentsPerVector
    4, // bytesPerComponent
    0, // dataOffset
    8 // dataStride
    );
    const materialNames = Object.keys(this._indexArrayMap);
    const materialArray = [];
    materialNames.forEach(materialName => {
      const indexArray = this._indexArrayMap[materialName];
      const indexCount = indexArray.length / 3;

      if (indexCount === 0) {
        return;
      }

      const material = this._materialMap[materialName] || new SCNMaterial();
      const element = new SCNGeometryElement(indexArray, // data
      SCNGeometryPrimitiveType.triangles, // primitiveType
      indexCount, // primitiveCount
      4 // bytesPerIndex
      );
      materialArray.push(material);

      this._elementArray.push(element);
    });
    const geometry = new SCNGeometry([vertexSource, normalSource, texcoordSource], this._elementArray);
    geometry.materials = materialArray;
    geometry.name = 'Geometry';
    const geometryNode = new SCNNode(geometry);
    geometryNode.name = 'Geometry';

    this._node.addChildNode(geometryNode);
  }
  /**
   * @access private
   * @param {string[]} tokens - 
   * @returns {void}
   */


  _Comment(tokens) {
    return;
  }
  /**
   * @access private
   * @param {string[]} tokens - 
   * @returns {void}
   */


  _GeometricVertices(tokens) {
    const pos = new SCNVector3();
    pos.x = parseFloat(tokens[1]);
    pos.y = parseFloat(tokens[2]);
    pos.z = parseFloat(tokens[3]);

    this._vertexArray.push(pos);
  }
  /**
   * @access private
   * @param {string[]} tokens - 
   * @returns {void}
   */


  _TextureVertices(tokens) {
    const uv = new CGPoint();
    uv.x = parseFloat(tokens[1]);
    uv.y = 1.0 - parseFloat(tokens[2]);

    this._texcoordArray.push(uv);
  }
  /**
   * @access private
   * @param {string[]} tokens - 
   * @returns {void}
   */


  _VertexNormals(tokens) {
    const n = new SCNVector3();
    n.x = parseFloat(tokens[1]);
    n.y = parseFloat(tokens[2]);
    n.z = parseFloat(tokens[3]);

    this._normalArray.push(n);
  }
  /**
   * @access private
   * @param {string[]} tokens - 
   * @returns {void} -
   */


  _ParameterSpaceVertices(tokens) {}

  _CurveSurfaceType(tokens) {}

  _Degree(tokens) {}

  _BasisMatrix(tokens) {}

  _StepSize(tokens) {}

  _Point(tokens) {}

  _Line(tokens) {}

  _Face(tokens) {
    const numFaces = tokens.length - 3;

    if (numFaces <= 0) {
      throw new Error(`numFaces(${numFaces}) <= 0`);
    }

    let index1 = this._getIndexForData(tokens[1].split('/'));

    let index2 = null;

    let index3 = this._getIndexForData(tokens[2].split('/'));

    for (let i = 0; i < numFaces; i++) {
      index2 = index3;
      index3 = this._getIndexForData(tokens[i + 3].split('/'));

      this._currentIndexArray.push(index1, index2, index3); // TODO: consider smoothingGroup

    }
  }
  /**
   * @access private
   * @param {number[]} data -
   * @returns {void} -
   */


  _getIndexForData(data) {
    const nv = parseInt(data[0]);
    const nt = parseInt(data[1]) || 0;
    const nn = parseInt(data[2]) || 0;
    let skin = this._skinArray[nv];

    if (typeof skin === 'undefined') {
      skin = {
        index: nv,
        vertex: nv,
        texcoord: nt,
        normal: nn,
        next: null
      };
      this._skinArray[nv] = skin;
    }

    let lastSkin = skin;

    while (skin && (skin.texcoord !== nt || skin.normal !== nn)) {
      lastSkin = skin;
      skin = skin.next;
    }

    if (!skin) {
      const newIndex = this._skinArray.length;
      skin = {
        index: newIndex,
        vertex: nv,
        texcoord: nt,
        normal: nn,
        next: null
      };
      this._skinArray[newIndex] = skin;
      lastSkin.next = skin;
    }

    return skin.index;
  }

  _Curve(tokens) {}

  _2DCurve(tokens) {}

  _Surface(tokens) {}

  _ParameterValues(tokens) {}

  _OuterTrimmingLoop(tokens) {}

  _InnerTrimmingLoop(tokens) {}

  _SpecialCurve(tokens) {}

  _SpecialPoint(tokens) {}

  _EndStatement(tokens) {
    this._break = true;
  }

  _Connect(tokens) {}

  _GroupName(tokens) {
    if (tokens.length <= 1) {
      throw new Error('group name format error');
    } else {
      tokens.shift();
      this._currentGroupName = tokens.join(' ');
    }
  }

  _SmoothingGroup(tokens) {
    return;
    /*
    if(tokens[1] === 'off' || tokens[1] <= 0){
      currentSmoothingGroup = 0
      currentSmoothingVertices = null
    }else{
      currentSmoothingGroup = tokens[1]
      currentSmoothingVertices = smoothingVerticesHash[currentSmoothingGroup]
      if(!currentSmoothingVertices){
        currentSmoothingVertices = []
        smoothingVerticesHash[currentSmoothingGroup] = currentSmoothingVertices
      }
    }
    */
  }

  _MergingGroup(tokens) {}

  _ObjectName(tokens) {}

  _BevelInterpolation(tokens) {}

  _ColorInterpolation(tokens) {}

  _DissolveInterpolation(tokens) {}

  _LevelOfDetail(tokens) {}

  _MaterialName(tokens) {
    tokens.shift();
    this._currentMtlName = tokens.join(' ');
    this._currentIndexArray = this._indexArrayMap[this._currentMtlName];

    if (typeof this._currentIndexArray === 'undefined') {
      this._currentIndexArray = [];
      this._indexArrayMap[this._currentMtlName] = this._currentIndexArray;
    }
  }

  _MaterialLibrary(tokens) {
    const promises = [];

    for (let i = 1; i < tokens.length; i++) {
      const path = this._filePath + tokens[i];
      const dir = path.substring(0, path.lastIndexOf('/') + 1);

      const promise = _BinaryRequest.get(path).then(data => {
        console.log('mtl data: ' + data);
        return _SCNMtlLoader.unarchiveObjectWithData(data, dir);
      });

      promises.push(promise);
    }

    this._materialPromise = Promise.all(promises);
  }

  _ShadowCasting(tokens) {}

  _RayTracing(tokens) {}

  _CurveApproximationTechnique(tokens) {}

  _SurfaceApproximationTechnique(tokens) {}

}

/**
 * The abstract superclass for objects that automatically adjust the position, rotation, or scale of a node based on rules you define.
 * @access public
 * @extends {NSObject}
 * @implements {SCNAnimatable}
 * @see https://developer.apple.com/documentation/scenekit/scnconstraint
 */

class SCNConstraint extends NSObject {
  /**
   * constructor
   * @access public
   * @constructor
   */
  constructor() {
    super(); // Tuning a Constraint’s Effect on Nodes

    /**
     * The influence of the constraint on the node’s transformation.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnconstraint/1468692-influencefactor
     */

    this.influenceFactor = 0;
  }

}

/**
 * 
 * @access public
 * @extends {SCNConstraint}
 * @see https://developer.apple.com/documentation/scenekit/scnaccelerationconstraint
 */

class SCNAccelerationConstraint extends SCNConstraint {
  /**
   * constructor
   * @access public
   * @constructor
   */
  constructor() {
    super(); // Instance Properties

    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnaccelerationconstraint/2873359-damping
     */

    this.damping = 0;
    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnaccelerationconstraint/2873367-decelerationdistance
     */

    this.decelerationDistance = 0;
    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnaccelerationconstraint/2873355-maximumlinearacceleration
     */

    this.maximumLinearAcceleration = 0;
    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnaccelerationconstraint/2873384-maximumlinearvelocity
     */

    this.maximumLinearVelocity = 0;
  }

}

/**
 * Constants affecting the animation curve of an action, used by the timingMode property.
 * @typedef {Object} SCNActionTimingMode
 * @property {number} linear - Linear pacing. The animation progresses evenly throughout its duration.
 * @property {number} easeIn - Ease-in pacing. The animation begins slowly, and then speeds up as it progresses.
 * @property {number} easeOut - Ease-out pacing. The animation begins quickly, and then slows as it completes.
 * @property {number} easeInEaseOut - Ease-in ease-out pacing. The animation begins slowly, accelerates through the middle of its duration, and then slows again before completing.
 * @see https://developer.apple.com/documentation/scenekit/scnactiontimingmode
 */

const SCNActionTimingMode = {
  linear: 0,
  easeIn: 1,
  easeOut: 2,
  easeInEaseOut: 3
};

/**
 * A simple, reusable animation that changes attributes of any node you attach it to.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/scenekit/scnaction
 */

class SCNAction extends NSObject {
  /**
   * constructor
   * @access public
   * @constructor
   */
  constructor() {
    super(); // Adjusting an Action’s Animation Properties

    /**
     * The duration required to complete an action.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnaction/1524162-duration
     */

    this._duration = 0;
    /**
     * A speed factor that modifies how fast an action runs.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnaction/1522811-speed
     */

    this._speed = 1.0;
    /**
     * The timing mode used to execute an action.
     * @type {SCNActionTimingMode}
     * @see https://developer.apple.com/documentation/scenekit/scnaction/1524055-timingmode
     */

    this._timingMode = SCNActionTimingMode.linear;
    /**
     * A block SceneKit calls to determine the action’s animation timing.
     * @type {?SCNActionTimingFunction}
     * @see https://developer.apple.com/documentation/scenekit/scnaction/1524130-timingfunction
     */

    this._timingFunction = null;
    /**
     * @access private
     * @type {boolean}
     */

    this._finished = false;
    this._beginTime = 0;
    this._isRunning = false;
    this._pausedTime = 0;
    this._completionHandler = null;
    this.__actionStartTime = null;
  } // Creating Actions That Move a Node

  /**
   * Creates an action that moves a node relative to its current position.
   * @access public
   * @param {number} deltaX - The distance to move the node in the X direction of its parent node’s local coordinate space.
   * @param {number} deltaY - The distance to move the node in the Y direction of its parent node’s local coordinate space.
   * @param {number} deltaZ - The distance to move the node in the Z direction of its parent node’s local coordinate space.
   * @param {number} duration - The duration, in seconds, of the animation.
   * @returns {SCNAction} - 
   * @desc When the action executes, the node’s position property animates from its current position to its new position.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction moveByX: -deltaX y: -deltaY z: -deltaZ duration: duration];
  [SCNAction moveByX: -deltaX y: -deltaY z: -deltaZ duration: duration];
    * @see https://developer.apple.com/documentation/scenekit/scnaction/1523238-moveby
   */


  static moveByXYZ(deltaX, deltaY, deltaZ, duration) {
    //return SCNActionMove.moveByXYZ(deltaX, deltaY, deltaZ, duration)
    throw new Error('not implemented');
  }
  /**
   * Creates an action that moves a node relative to its current position.
   * @access public
   * @param {SCNVector3} delta - A vector that describes the change to be applied to the node’s position.
   * @param {number} duration - The duration, in seconds, of the animation.
   * @returns {SCNAction} - 
   * @desc When the action executes, the node’s position property animates from its current position to its new position.This action is reversible; the reverse is created as if the following code had been executed:SCNVector3 reverseDelta = SCNVector3Make(-delta.x, -delta.y, -delta.z);
  [SCNAction moveBy: reverseDelta duration: duration];
  SCNVector3 reverseDelta = SCNVector3Make(-delta.x, -delta.y, -delta.z);
  [SCNAction moveBy: reverseDelta duration: duration];
    * @see https://developer.apple.com/documentation/scenekit/scnaction/1522605-move
   */


  static moveBy(delta, duration) {
    //return SCNActionMove.moveBy(delta, duration)
    throw new Error('not implemented');
  }
  /**
   * Creates an action that moves a node to a new position.
   * @access public
   * @param {SCNVector3} location - The coordinates for the node’s new position in its parent node’s local coordinate space.
   * @param {number} duration - The duration, in seconds, of the animation.
   * @returns {SCNAction} - 
   * @desc When the action executes, the node’s position property animates from its current position to its new position.This action is not reversible; the reverse of this action has the same duration but does not move the node.
   * @see https://developer.apple.com/documentation/scenekit/scnaction/1522826-move
   */


  static moveTo(location, duration) {
    //return SCNActionMove.moveTo(location, duration)
    throw new Error('not implemented');
  } // Creating Actions That Rotate a Node

  /**
   * Creates an action that rotates the node in each of the three principal axes by angles relative to its current orientation.
   * @access public
   * @param {number} xAngle - The amount to rotate the node counterclockwise around the x-axis of its local coordinate space, in radians.
   * @param {number} yAngle - The amount to rotate the node counterclockwise around the y-axis of its local coordinate space, in radians.
   * @param {number} zAngle - The amount to rotate the node counterclockwise around the z-axis of its local coordinate space, in radians.
   * @param {number} duration - The duration, in seconds, of the animation.
   * @returns {SCNAction} - 
   * @desc When the action executes, the node’s rotation property animates to the new angle.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction rotateByX: -xAngle y: -yAngle z: -zAngle duration: duration];
  [SCNAction rotateByX: -xAngle y: -yAngle z: -zAngle duration: duration];
    * @see https://developer.apple.com/documentation/scenekit/scnaction/1523522-rotateby
   */


  static rotateByXYZ(xAngle, yAngle, zAngle, duration) {
    //return SCNActionRotate.rotateByXYZ(xAngle, yAngle, zAngle, duration)
    throw new Error('not implemented');
  }
  /**
   * Creates an action that rotates the node to absolute angles in each of the three principal axes.
   * @access public
   * @param {number} xAngle - The amount to rotate the node counterclockwise around the x-axis of its local coordinate space, in radians.
   * @param {number} yAngle - The amount to rotate the node counterclockwise around the y-axis of its local coordinate space, in radians.
   * @param {number} zAngle - The amount to rotate the node counterclockwise around the z-axis of its local coordinate space, in radians.
   * @param {number} duration - The duration, in seconds, of the animation.
   * @returns {SCNAction} - 
   * @desc When the action executes, the node’s rotation property animates to the new angle. Calling this method is equivalent to calling rotateTo(x:y:z:duration:usesShortestUnitArc:) and passing false for the shortestUnitArc parameter.This action is not reversible; the reverse of this action has the same duration but does not change anything.
   * @see https://developer.apple.com/documentation/scenekit/scnaction/1524044-rotateto
   */


  static rotateToXYZ(xAngle, yAngle, zAngle, duration) {
    //return SCNActionRotate.rotateToXYZ(xAngle, yAngle, zAngle, duration)
    throw new Error('not implemented');
  }
  /**
   * Creates an action that rotates the node to absolute angles in each of the three principal axes.
   * @access public
   * @param {number} xAngle - The amount to rotate the node counterclockwise around the x-axis of its local coordinate space, in radians.
   * @param {number} yAngle - The amount to rotate the node counterclockwise around the y-axis of its local coordinate space, in radians.
   * @param {number} zAngle - The amount to rotate the node counterclockwise around the z-axis of its local coordinate space, in radians.
   * @param {number} duration - The duration, in seconds, of the animation.
   * @param {boolean} shortestUnitArc - If false (the default), the animation interpolates each component of the node’s rotation between its current value and the new value. If true, the animation makes the most direct rotation possible from the node’s current orientation to the new orientation.
   * @returns {SCNAction} - 
   * @desc When the action executes, the node’s rotation property animates to the new angle.This action is not reversible; the reverse of this action has the same duration but does not change anything.
   * @see https://developer.apple.com/documentation/scenekit/scnaction/1522808-rotateto
   */


  static rotateToXYZUsesShortestUnitArc(xAngle, yAngle, zAngle, duration, shortestUnitArc) {
    //return SCNActionRotate.rotateToXYZUsesShortestUnitArc(xAngle, yAngle, zAngle, duration, shortestUnitArc)
    throw new Error('not implemented');
  }
  /**
   * Creates an action that rotates the node by an angle around a specified axis.
   * @access public
   * @param {number} angle - The amount to rotate the node counterclockwise around the specified axis, in radians.
   * @param {SCNVector3} axis - A vector in the node’s local coordinate space whose direction specifies the axis of rotation.
   * @param {number} duration - The duration, in seconds, of the animation.
   * @returns {SCNAction} - 
   * @desc When the action executes, the node’s rotation property animates to the new angle.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction rotateByAngle: -angle aroundAxis: axis duration: sec];
  [SCNAction rotateByAngle: -angle aroundAxis: axis duration: sec];
    * @see https://developer.apple.com/documentation/scenekit/scnaction/1523805-rotate
   */


  static rotateByAround(angle, axis, duration) {
    //return SCNActionRotate.rotateByAround(angle, axis, duration)
    throw new Error('not implemented');
  }
  /**
   * Creates an action that rotates the node to an absolute angle around a specified axis.
   * @access public
   * @param {SCNVector4} axisAngle - A four-component vector whose first three components are a vector in the node’s local coordinate space specifying an axis and whose fourth component is the amount to rotate the node counterclockwise around that axis, in radians.
   * @param {number} duration - The duration, in seconds, of the animation.
   * @returns {SCNAction} - 
   * @desc When the action executes, the node’s rotation property animates to the new angle.This action is not reversible; the reverse of this action has the same duration but does not change anything.
   * @see https://developer.apple.com/documentation/scenekit/scnaction/1524191-rotate
   */


  static rotateToAxisAngle(axisAngle, duration) {
    //return SCNActionRotate.rotateToAxisAngle(axisAngle, duration)
    throw new Error('not implemented');
  } // Creating Actions That Change a Node’s Scale

  /**
   * Creates an action that uniformly changes the scale factor of a node by a relative value.
   * @access public
   * @param {number} scale - The amount of change to make to all three components of the node’s scale.
   * @param {number} sec - The duration, in seconds, of the animation.
   * @returns {SCNAction} - 
   * @desc When the action executes, the node’s scale property animates to the new value.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction scaleBy: -scale duration: sec];
  [SCNAction scaleBy: -scale duration: sec];
    * @see https://developer.apple.com/documentation/scenekit/scnaction/1523129-scale
   */


  static scaleByDuration(scale, sec) {
    //return SCNActionScale.scaleByDuration(scale, sec)
    throw new Error('not implemented');
  }
  /**
   * Creates an action that uniformly changes the scale factor of a node to an absolute value.
   * @access public
   * @param {number} scale - The new value for all three components of the node’s scale.
   * @param {number} sec - The duration, in seconds, of the animation.
   * @returns {SCNAction} - 
   * @desc When the action executes, the node’s scale property animates to the new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
   * @see https://developer.apple.com/documentation/scenekit/scnaction/1523322-scale
   */


  static scaleToDuration(scale, sec) {
    //return SCNActionScale.scaleToDuration(scale, sec)
    throw new Error('not implemented');
  } // Creating Actions That Change a Node’s Opacity

  /**
   * Creates an action that changes the opacity of the node to 1.0.
   * @access public
   * @param {number} sec - The duration, in seconds, of the animation.
   * @returns {SCNAction} - 
   * @desc When the action executes, the node’s opacity property animates from its current value to 1.0.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction fadeOutWithDuration: sec];
  [SCNAction fadeOutWithDuration: sec];
    * @see https://developer.apple.com/documentation/scenekit/scnaction/1522777-fadein
   */


  static fadeInDuration(sec) {
    //return SCNActionFade.fadeInDuration(sec)
    throw new Error('not implemented');
  }
  /**
   * Creates an action that changes the opacity of the node to 0.0.
   * @access public
   * @param {number} sec - The duration, in seconds, of the animation.
   * @returns {SCNAction} - 
   * @desc When the action executes, the node’s opacity property animates from its current value to 0.0.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction fadeInWithDuration: sec];
  [SCNAction fadeInWithDuration: sec];
    * @see https://developer.apple.com/documentation/scenekit/scnaction/1523922-fadeout
   */


  static fadeOutDuration(sec) {
    //return SCNActionFade.fadeOutDuration(sec)
    throw new Error('not implemented');
  }
  /**
   * Creates an action that adjusts the opacity of a node by a relative value.
   * @access public
   * @param {number} factor - The amount to change the node’s opacity by.
   * @param {number} sec - The duration, in seconds, of the animation.
   * @returns {SCNAction} - 
   * @desc When the action executes, the node’s opacity property animates to its new value.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction fadeOpacityBy: -factor duration: sec];
  [SCNAction fadeOpacityBy: -factor duration: sec];
    * @see https://developer.apple.com/documentation/scenekit/scnaction/1523595-fadeopacity
   */


  static fadeOpacityByDuration(factor, sec) {
    //return SCNActionFade.fadeOpacityByDuration(factor, sec)
    throw new Error('not implemented');
  }
  /**
   * Creates an action that adjusts the opacity of a node to a new value.
   * @access public
   * @param {number} opacity - The new opacity value of the node.
   * @param {number} sec - The duration, in seconds, of the animation.
   * @returns {SCNAction} - 
   * @desc When the action executes, the node’s opacity property animates to its new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
   * @see https://developer.apple.com/documentation/scenekit/scnaction/1523875-fadeopacity
   */


  static fadeOpacityToDuration(opacity, sec) {
    //return SCNActionFade.fadeOpacityToDuration(opacity, sec)
    throw new Error('not implemented');
  } // Creating Actions That Change a Node’s Visibility

  /**
   * Creates an action that hides a node.
   * @access public
   * @returns {SCNAction} - 
   * @desc When the action executes, the node’s isHidden property is set to true.This action is reversible; the reverse is equivalent to the unhide() action.
   * @see https://developer.apple.com/documentation/scenekit/scnaction/1523487-hide
   */


  static hide() {
    //return SCNActionHide.hide()
    throw new Error('not implemented');
  }
  /**
   * Creates an action that ensures a node is not hidden.
   * @access public
   * @returns {SCNAction} - 
   * @desc When the action executes, the node’s isHidden property is set to false.This action is reversible; the reverse is equivalent to the hide() action.
   * @see https://developer.apple.com/documentation/scenekit/scnaction/1524205-unhide
   */


  static unhide() {
    //return SCNActionHide.unhide()
    throw new Error('not implemented');
  } // Creating Actions That Remove Nodes from the Scene

  /**
   * Creates an action that removes the node from its parent.
   * @access public
   * @returns {SCNAction} - 
   * @desc When the action executes, the node is immediately removed from its parent.This action is not reversible; the reverse of this action is the same action.
   * @see https://developer.apple.com/documentation/scenekit/scnaction/1522966-removefromparentnode
   */


  static removeFromParentNode() {
    //return SCNActionRemove.removeFromParentNode()
    throw new Error('not implemented');
  } // Creating Actions That Play Audio

  /**
   * Creates an action that plays an audio source.
   * @access public
   * @param {SCNAudioSource} source - The audio source to play.
   * @param {boolean} wait - If true, the duration of this action is the same as the length of the audio playback. If false, the action is considered to have completed immediately.
   * @returns {SCNAction} - 
   * @desc When the action executes, SceneKit plays the audio source on the target node—any positional audio effects are based on the node’s position. For more information about positional audio in SceneKit, see SCNAudioPlayer.This action is not reversible; the reverse of this action is the same action.
   * @see https://developer.apple.com/documentation/scenekit/scnaction/1523651-playaudio
   */


  static playAudioWaitForCompletion(source, wait) {
    //return SCNActionPlaySound.playAudioWaitForCompletion(source, wait)
    throw new Error('not implemented');
  } // Creating Actions That Combine or Repeat Other Actions

  /**
   * Creates an action that runs a collection of actions in parallel.
   * @access public
   * @param {SCNAction[]} actions - An array of SCNAction objects.
   * @returns {SCNAction} - 
   * @desc When the action executes, the actions that make up the group all start immediately and run in parallel. The duration of the group action is the longest duration among the collection of actions. If an action in the group has a duration less than the group’s duration, the action completes and then idles until the group completes the remaining actions. This matters most when creating a repeating action that repeats a group.This action is reversible; it creates a new group action that contains the reverse of each action specified in the group. 
   * @see https://developer.apple.com/documentation/scenekit/scnaction/1522779-group
   */


  static group(actions) {
    //return SCNActionGroup.group(actions)
    throw new Error('not implemented');
  }
  /**
   * Creates an action that runs a collection of actions sequentially.
   * @access public
   * @param {SCNAction[]} actions - An array of SCNAction objects.
   * @returns {SCNAction} - 
   * @desc When the action executes, the first action in the sequence starts and runs to completion. Subsequent actions in the sequence run in a similar fashion until all of the actions in the sequence have executed. The duration of the sequence action is the sum of the durations of the actions in the sequence.This action is reversible; it creates a new sequence action that reverses the order of the actions. Each action in the reversed sequence is itself reversed. For example, the actions reverseSequence and sequenceReverse in the code example below are equivalent:SCNAction *sequence = [SCNAction sequence:@[ actionA, actionB, actionC ]];
  SCNAction *reverseSequence = [SCNAction sequence:@[ [actionC reversedAction],
                                                    [actionB reversedAction],
                                                    [actionA reversedAction] ]];
  SCNAction *sequenceReverse = [sequence reversedAction];
  SCNAction *sequence = [SCNAction sequence:@[ actionA, actionB, actionC ]];
  SCNAction *reverseSequence = [SCNAction sequence:@[ [actionC reversedAction],
                                                    [actionB reversedAction],
                                                    [actionA reversedAction] ]];
  SCNAction *sequenceReverse = [sequence reversedAction];
    * @see https://developer.apple.com/documentation/scenekit/scnaction/1522793-sequence
   */


  static sequence(actions) {
    //return SCNActionSequence.sequence(actions)
    throw new Error('not implemented');
  }
  /**
   * Creates an action that repeats another action a specified number of times.
   * @access public
   * @param {SCNAction} action - The action to be executed.
   * @param {number} count - The number of times to execute the action.
   * @returns {SCNAction} - 
   * @desc When the action executes, the associated action runs to completion and then repeats, until the count is reached.This action is reversible; it creates a new action that is the reverse of the specified action and then repeats it the same number of times.
   * @see https://developer.apple.com/documentation/scenekit/scnaction/1522764-repeat
   */


  static repeat(action, count) {
    //return SCNActionRepeat.repeat(action, count)
    throw new Error('not implemented');
  }
  /**
   * Creates an action that repeats another action forever.
   * @access public
   * @param {SCNAction} action - The action to execute.
   * @returns {SCNAction} - 
   * @desc When the action executes, the associated action runs to completion and then repeats.This action is reversible; it creates a new action that is the reverse of the specified action and then repeats it forever.NoteThe action to be repeated must have a non-instantaneous duration.
   * @see https://developer.apple.com/documentation/scenekit/scnaction/1522908-repeatforever
   */


  static repeatForever(action) {
    //return SCNActionRepeat.repeatForever(action)
    throw new Error('not implemented');
  } // Creating Actions That Add Delays to Action Sequences

  /**
   * Creates an action that idles for a specified period of time.
   * @access public
   * @param {number} sec - The amount of time to wait.
   * @returns {SCNAction} - 
   * @desc When the action executes, the action waits for the specified amount of time and then ends. This is typically used as part of a sequence of actions to insert a delay between two other actions. You might also use it in conjunction with the runAction(_:completionHandler:) method to trigger code that needs to run at a later time.This action is not reversible; the reverse of this action is the same action.
   * @see https://developer.apple.com/documentation/scenekit/scnaction/1523915-wait
   */


  static waitDuration(sec) {
    //return SCNActionWait.waitDuration(sec)
    throw new Error('not implemented');
  }
  /**
   * Creates an action that idles for a randomized period of time.
   * @access public
   * @param {number} sec - The average amount of time to wait.
   * @param {number} durationRange - The range of possible values for the duration.
   * @returns {SCNAction} - 
   * @desc When the action executes, the action waits for the specified amount of time and then ends. This is typically used as part of a sequence of actions to insert a delay between two other actions. However, you might also use it in conjunction with the runAction(_:completionHandler:) method to trigger code that needs to run at a later time.Each time the action is executed, the action computes a new random value for the duration. The duration may vary in either direction by up to half of the value of the durationRange parameter.This action is not reversible; the reverse of this action is the same action.
   * @see https://developer.apple.com/documentation/scenekit/scnaction/1523086-wait
   */


  static waitDurationWithRange(sec, durationRange) {
    //return SCNActionWait.waitDurationWithRange(sec, durationRange)
    throw new Error('not implemented');
  } // Creating Custom Actions

  /**
   * Creates an action that executes a block.
   * @access public
   * @param {function(arg1: SCNNode): void} block - The block to run. The block takes a single parameter:nodeThe node on which the action is running.
   * @returns {SCNAction} - 
   * @desc When the action executes, SceneKit calls the block. This action takes place instantaneously.This action is not reversible; the reverse action executes the same block.
   * @see https://developer.apple.com/documentation/scenekit/scnaction/1523637-run
   */


  static run(block) {
    //return SCNActionRunBlock.run(block)
    throw new Error('not implemented');
  }
  /**
   * Creates an action that executes a block periodically over a specified duration.
   * @access public
   * @param {number} seconds - The duration of the action, in seconds.
   * @param {function(arg1: SCNNode, arg2: number): void} block - The block to run. The block takes the following parameters:nodeThe node on which the action is running.elapsedTimeThe amount of time that has passed since the action began executing.
   * @returns {SCNAction} - 
   * @desc When the action executes, SceneKit calls the block repeatedly until the action’s duration expires. For each call, SceneKit computes the elapsed time and passes it to the block.This action is not reversible; the reverse action executes the same block.
   * @see https://developer.apple.com/documentation/scenekit/scnaction/1523692-customaction
   */


  static customActionDurationAction(seconds, block) {
    //return SCNActionCustom.customActionDurationAction(seconds, block)
    throw new Error('not implemented');
  }
  /**
   * Creates an action that executes a JavaScript script periodically over a specified duration.
   * @access public
   * @param {string} script - A string containing JavaScript source code.
   * @param {number} seconds - The duration of the action, in seconds.
   * @returns {SCNAction} - 
   * @desc SceneKit exposes its classes, methods, and functions in the JavaScript context that runs the script—see the SCNJavaScript.h header file for details.When the action executes, SceneKit runs the script repeatedly until the action’s duration expires. Each time SceneKit runs the script, it computes the elapsed time since the action began executing (as a fraction of the action’s duration between 0.0 and 1.0) and makes it available to the script as a variable named elapsedTime. The script can also reference the SCNNode object running the action as a variable named node.This action is not reversible; the reverse action executes the same script.
   * @see https://developer.apple.com/documentation/scenekit/scnaction/1523984-javascriptaction
   */


  static javaScriptActionWithScriptDuration(script, seconds) {
    //return SCNActionJavaScript.javaScriptActionWithScriptDuration(script, seconds)
    throw new Error('not implemented');
  } // Reversing an Action

  /**
   * Creates an action that reverses the behavior of another action.
   * @access public
   * @returns {SCNAction} - 
   * @desc This method always returns an action object; however, not all actions are reversible. When reversed, some actions return an object that either does nothing or performs the same action as the original action. For details on how an action is reversed, see the description of the class method used to create that action.
   * @see https://developer.apple.com/documentation/scenekit/scnaction/1522815-reversed
   */


  reversed() {
    return null;
  }
  /**
   * @access public
   * @returns {SCNAction} -
   */


  copy() {
    const action = super.copy();
    action._beginTime = this._beginTime;
    action._duration = this._duration;
    action._speed = this.speed;
    action._timingMode = this.timingMode;
    action._timingFunction = this.timingFunction;
    action._finished = this._finished; //action._isRunning = this._isRunning
    //action._pausedTime = this._pausedTime
    //action._completionHandler = this._completionHandler

    return action;
  }

  get _actionStartTime() {
    return this.__actionStartTime;
  }

  set _actionStartTime(newValue) {
    this.__actionStartTime = newValue;
  }

  get duration() {
    return this._duration;
  }

  set duration(newValue) {
    this._duration = newValue;
  }

  get speed() {
    return this._speed;
  }

  set speed(newValue) {
    this._speed = newValue;
  }

  get timingMode() {
    return this._timingMode;
  }

  set timingMode(newValue) {
    this._timingMode = newValue;
  }

  get timingFunction() {
    return this._timingFunction;
  }

  set timingFunction(newValue) {
    this._timingFunction = newValue;
  }
  /**
   * apply action to the given node.
   * @access private
   * @param {Object} obj - target object to apply this action.
   * @param {number} time - active time
   * @param {boolean} [needTimeConversion = true] -
   * @returns {void}
   */


  _applyAction(obj, time, needTimeConversion = true) {
    const t = this._getTime(time, needTimeConversion); //this._handleEvents(obj, t)

  }

  _getTime(time, needTimeConversion) {
    const t = this.__getTime(time, needTimeConversion);

    if (this._timingMode === SCNActionTimingMode.easeIn) {
      return CAMediaTimingFunction.functionWithName(kCAMediaTimingFunctionEaseIn)._getValueAtTime(t);
    } else if (this._timingMode === SCNActionTimingMode.easeOut) {
      return CAMediaTimingFunction.functionWithName(kCAMediaTimingFunctionEaseOut)._getValueAtTime(t);
    } else if (this._timingMode === SCNActionTimingMode.easeInEaseOut) {
      return CAMediaTimingFunction.functionWithName(kCAMediaTimingFunctionEaseInEaseOut)._getValueAtTime(t);
    }

    return t;
  }

  __getTime(time, needTimeConversion) {
    if (!needTimeConversion) {
      if (time >= 1.0 && !this._finished) {
        this._finished = true;
      }

      return time;
    }

    const baseTime = this._basetimeFromTime(time);

    if (this.timingFunction === null) {
      return baseTime;
    }

    return this.timingFunction._getValueAtTime(baseTime);
  }
  /**
   * convert parent time to base time
   * @access private
   * @param {number} time - parent time
   * @returns {number} - animation base time for the current frame (0-1 or null).
   */


  _basetimeFromTime(time) {
    const activeTime = time - this._actionStartTime;
    return this._basetimeFromActivetime(activeTime);
  }
  /**
   * convert parent time to active time
   * @access private
   * @param {number} time - parent time
   * @returns {number} - animation active time for the current frame.
   */


  _activetimeFromTime(time) {
    return time - this._actionStartTime;
  }
  /**
   * convert active time to base time
   * @access private
   * @param {number} time - active time
   * @returns {number} - animation base time for the current frame (0-1 or null).
   */


  _basetimeFromActivetime(time) {
    const dt = time - this._beginTime;

    if (this.speed === 0) {
      return 0;
    }

    if (this._duration === 0) {
      return dt / Math.abs(this.speed);
    }

    let duration = this._duration / Math.abs(this.speed);

    if (duration === 0) {
      duration = 0.25;
    }

    if (dt >= duration) {
      // the action is over.
      if (!this._finished) {
        this._finished = true;
      }
    }

    return dt / duration;
  }
  /**
   * @access private
   * @param {Object} from -
   * @param {Object} to -
   * @param {number} t -
   * @returns {Object} -
   */


  _lerp(from, to, t) {
    if (t === null) {
      // the action is over.
      return to;
    }

    if (_InstanceOf(from, SCNVector4)) {
      // TODO: slerp for Quaternion
      return from.lerp(to, t);
    } else if (_InstanceOf(from, SCNVector3)) {
      return from.lerp(to, t);
    } else if (_InstanceOf(from, CGSize)) {
      return from.lerp(to, t);
    } else if (_InstanceOf(from, CGPoint)) {
      return from.lerp(to, t);
    } else if (_InstanceOf(from, CGRect)) {
      return from.lerp(to, t);
    } else if (_InstanceOf(from, SKColor)) {
      return from._lerp(to, t);
    }

    return from + (to - from) * t;
  }
  /**
   * @access private
   * @param {Object} from -
   * @param {Object} to -
   * @param {number} t -
   * @returns {Object} -
   */


  _slerp(from, to, t) {
    if (!_InstanceOf(from, SCNVector4)) {
      throw new Error('SCNAction._slerp: object is not SCNVector4');
    }

    return from.slerp(to, t);
  }

  _resetFinished() {
    this._finished = false;
  }

}

/**
 * Methods for running actions on nodes.
 * @interface
 * @see https://developer.apple.com/documentation/scenekit/scnactionable
 */

class SCNActionable {
  /**
   * constructor
   * @access public
   * @constructor
   */
  constructor() {
    // Inspecting a Node’s Running Actions
    this._hasActions = false;
    this._actionKeys = null;
  } // Running Actions

  /**
   * Required. Adds an action to the list of actions executed by the node.
   * @access public
   * @param {SCNAction} action - The action to be performed.
   * @returns {void}
   * @desc SceneKit begins running a newly added action when it prepares to render the next frame.
   * @see https://developer.apple.com/documentation/scenekit/scnactionable/1523164-runaction
   */


  runAction(action) {}
  /**
   * Required. Adds an action to the list of actions executed by the node. SceneKit calls the specified block when the action completes.
   * @access public
   * @param {SCNAction} action - The action to be performed.
   * @param {?function(): void} [block = null] - A completion block that SceneKit calls when the action completes.
   * @returns {void}
   * @desc The new action is processed the next time SceneKit prepares to render a frame.SceneKit calls your block after the action’s duration is complete. For example, in a game you could use this method to show a Game Over message after performing a fade-out action on a node that displays a player character.
   * @see https://developer.apple.com/documentation/scenekit/scnactionable/1524219-runaction
   */


  runActionCompletionHandler(action, block = null) {}
  /**
   * Required. Adds an identifiable action to the list of actions executed by the node.
   * @access public
   * @param {SCNAction} action - The action to be performed.
   * @param {?string} key - A unique key used to identify the action.
   * @returns {void}
   * @desc This method is identical to runAction(_:), but the action is stored and identified so that you can retrieve or cancel it later. If an action using the same key is already running, SceneKit removes it before adding the new action.
   * @see https://developer.apple.com/documentation/scenekit/scnactionable/1524222-runaction
   */


  runActionForKey(action, key) {}
  /**
   * Required. Adds an identifiable action to the list of actions executed by the node. SceneKit calls the specified block when the action completes.
   * @access public
   * @param {SCNAction} action - The action to be performed.
   * @param {?string} key - A unique key used to identify the action.
   * @param {?function(): void} [block = null] - A completion block called when the action completes.
   * @returns {void}
   * @desc This method is identical to runAction(_:completionHandler:), but the action is stored and identified so that you can retrieve or cancel it later. If an action using the same key is already running, SceneKit removes it before adding the new action.SceneKit calls your block after the action’s duration is complete. For example, you can use this method with a wait action to execute some code after a timed delay. If during the delay period you need to prevent the code from running, use the removeAction(forKey:) method to cancel it.
   * @see https://developer.apple.com/documentation/scenekit/scnactionable/1522791-runaction
   */


  runActionForKeyCompletionHandler(action, key, block = null) {} // Inspecting a Node’s Running Actions

  /**
   * Required. Returns an action associated with a specific key.
   * @access public
   * @param {string} key - A string that uniquely identifies a action.
   * @returns {?SCNAction} - 
   * @desc Use this method to retrieve actions you scheduled using the runAction(_:forKey:) or runAction(_:forKey:completionHandler:) method.
   * @see https://developer.apple.com/documentation/scenekit/scnactionable/1523287-action
   */


  actionForKey(key) {
    return null;
  }
  /**
   * Required. A Boolean value that indicates whether the node is currently executing any actions.
   * @type {boolean}
   * @desc This value is true if the node has any executing actions; otherwise the value is false.
   * @see https://developer.apple.com/documentation/scenekit/scnactionable/1523794-hasactions
   */


  get hasActions() {
    return this._hasActions;
  }
  /**
   * Required. The list of keys for which the node has attached actions.
   * @type {string[]}
   * @desc Use this property to list actions you scheduled using the runAction(_:forKey:) or runAction(_:forKey:completionHandler:) method.
   * @see https://developer.apple.com/documentation/scenekit/scnactionable/1523036-actionkeys
   */


  get actionKeys() {
    return this._actionKeys;
  } // Canceling a Node’s Running Actions

  /**
   * Required. Removes an action associated with a specific key.
   * @access public
   * @param {string} key - A string that uniquely identifies a action.
   * @returns {void}
   * @desc If the node is currently running an action that matches the key, SceneKit removes that action from the node, skipping any remaining animation it would perform but keeping any changes already made to the node.Use this method to cancel actions you scheduled using the runAction(_:forKey:) or runAction(_:forKey:completionHandler:) method.
   * @see https://developer.apple.com/documentation/scenekit/scnactionable/1523617-removeaction
   */


  removeActionForKey(key) {}
  /**
   * Required. Ends and removes all actions from the node.
   * @access public
   * @returns {void}
   * @desc When SceneKit removes an action from a node, it skips any remaining animation the action would perform. However, any changes the action has already made to the node’s state remain in effect.
   * @see https://developer.apple.com/documentation/scenekit/scnactionable/1524181-removeallactions
   */


  removeAllActions() {}

}

class SCNActionCustom extends SCNAction {
  static get _propTypes() {
    return {
      _actions: 'NSArray',
      _finished: 'boolean',
      _duration: 'float',
      _timingMode: 'integer',
      _beginTime: 'float',
      _isRunning: 'boolean',
      _pausedTime: 'float'
    };
  }
  /**
   * constructor
   * @access public
   * @constructor
   */


  constructor() {
    super();
    this._actions = [];
    this._finished = false;
    this._duration = 0;
    this._timingMode = SCNActionTimingMode.linear;
    this._beginTime = 0;
    this._isRunning = false;
    this._pausedTime = 0;
  }

}

class SCNActionFade extends SCNAction {
  static get _propTypes() {
    return {
      _actions: 'NSArray',
      _finished: 'boolean',
      _duration: 'float',
      _timingMode: 'integer',
      _beginTime: 'float',
      _isRunning: 'boolean',
      _pausedTime: 'float',
      name: ['string', null]
    };
  }
  /**
   * constructor
   * @access public
   * @constructor
   */


  constructor() {
    super();
    this._actions = [];
    this._finished = false;
    this._duration = 0;
    this._timingMode = SCNActionTimingMode.linear;
    this._beginTime = 0;
    this._isRunning = false;
    this._pausedTime = 0;
    this._toValue = null;
    this._byValue = null;
  }
  /**
   * Creates an action that changes the opacity of the node to 1.0.
   * @access public
   * @param {number} sec - The duration, in seconds, of the animation.
   * @returns {SCNAction} - 
   * @desc When the action executes, the node’s opacity property animates from its current value to 1.0.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction fadeOutWithDuration: sec];
  [SCNAction fadeOutWithDuration: sec];
    * @see https://developer.apple.com/documentation/scenekit/scnaction/1522777-fadein
   */


  static fadeInDuration(sec) {
    const action = new SCNActionFade();
    action._toValue = 1;
    action._duration = sec;
    return action;
  }
  /**
   * Creates an action that changes the opacity of the node to 0.0.
   * @access public
   * @param {number} sec - The duration, in seconds, of the animation.
   * @returns {SCNAction} - 
   * @desc When the action executes, the node’s opacity property animates from its current value to 0.0.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction fadeInWithDuration: sec];
  [SCNAction fadeInWithDuration: sec];
    * @see https://developer.apple.com/documentation/scenekit/scnaction/1523922-fadeout
   */


  static fadeOutDuration(sec) {
    const action = new SCNActionFade();
    action._toValue = 0;
    action._duration = sec;
    return action;
  }
  /**
   * Creates an action that adjusts the opacity of a node by a relative value.
   * @access public
   * @param {number} factor - The amount to change the node’s opacity by.
   * @param {number} sec - The duration, in seconds, of the animation.
   * @returns {SCNAction} - 
   * @desc When the action executes, the node’s opacity property animates to its new value.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction fadeOpacityBy: -factor duration: sec];
  [SCNAction fadeOpacityBy: -factor duration: sec];
    * @see https://developer.apple.com/documentation/scenekit/scnaction/1523595-fadeopacity
   */


  static fadeOpacityByDuration(factor, sec) {
    const action = new SCNActionFade();
    action._byValue = factor;
    action._duration = sec;
    return action;
  }
  /**
   * Creates an action that adjusts the opacity of a node to a new value.
   * @access public
   * @param {number} opacity - The new opacity value of the node.
   * @param {number} sec - The duration, in seconds, of the animation.
   * @returns {SCNAction} - 
   * @desc When the action executes, the node’s opacity property animates to its new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
   * @see https://developer.apple.com/documentation/scenekit/scnaction/1523875-fadeopacity
   */


  static fadeOpacityToDuration(opacity, sec) {
    const action = new SCNActionFade();
    action._toValue = opacity;
    action._duration = sec;
    return action;
  }
  /**
   * @access public
   * @returns {SCNActionFade} -
   */


  copy() {
    const action = super.copy();
    action._toValue = this._toValue;
    action._byValue = this._byValue;
    action._duration = this._duration;
    return action;
  }
  /**
   * apply action to the given node.
   * @access private
   * @param {Object} obj - target object to apply this action.
   * @param {number} time - active time
   * @param {boolean} [needTimeConversion = true] -
   * @returns {void}
   */


  _applyAction(obj, time, needTimeConversion = true) {
    const t = this._getTime(time, needTimeConversion);

    if (!_InstanceOf(obj, SCNNode)) {
      throw new Error(`unsupported class for SCNActionFade: ${obj.constructor.name}`);
    }

    const baseValue = obj._opacity;
    let toValue = 0;

    if (this._toValue !== null) {
      toValue = this._toValue;
    } else if (this._byValue !== null) {
      toValue = baseValue + this._byValue;
    } else {
      throw new Error('both toValue and byValue are null');
    }

    const value = this._lerp(baseValue, toValue, t); //console.warn(`opacity time: ${time}, t: ${t}, base: ${baseValue}, to: ${toValue}, val: ${value}`)


    obj.presentation._opacity = value;

    if (this._finished) {
      obj._opacity = toValue;
    }
  }

}
SCNAction.fadeInDuration = SCNActionFade.fadeInDuration;
SCNAction.fadeOutDuration = SCNActionFade.fadeOutDuration;
SCNAction.fadeOpacityByDuration = SCNActionFade.fadeOpacityByDuration;
SCNAction.fadeOpacityToDuration = SCNActionFade.fadeOpacityToDuration;

class SCNActionGroup extends SCNAction {
  static get _propTypes() {
    return {
      _actions: 'NSArray',
      _finished: 'boolean',
      _duration: 'float',
      _timingMode: 'integer',
      _beginTime: 'float',
      _isRunning: 'boolean',
      _pausedTime: 'float',
      name: ['string', null]
    };
  }
  /**
   * constructor
   * @access public
   * @constructor
   */


  constructor() {
    super();
    this._actions = [];
  }
  /**
   * Creates an action that runs a collection of actions in parallel.
   * @access public
   * @param {SCNAction[]} actions - An array of SCNAction objects.
   * @returns {SCNAction} - 
   * @desc When the action executes, the actions that make up the group all start immediately and run in parallel. The duration of the group action is the longest duration among the collection of actions. If an action in the group has a duration less than the group’s duration, the action completes and then idles until the group completes the remaining actions. This matters most when creating a repeating action that repeats a group.This action is reversible; it creates a new group action that contains the reverse of each action specified in the group. 
   * @see https://developer.apple.com/documentation/scenekit/scnaction/1522779-group
   */


  static group(actions) {
    const action = new SCNActionGroup();
    action._actions = actions;
    return action;
  }
  /**
   * @access public
   * @returns {SCNActionGroup} -
   */


  copy() {
    const action = super.copy();
    action._actions = [];

    this._actions.forEach(act => {
      action._actions.push(act.copy());
    });

    return action;
  }

  get duration() {
    let d = 0;

    this._actions.forEach(act => {
      if (d < act.duration) {
        d = act.duration;
      }
    });

    return d;
  }
  /**
   * apply action to the given node.
   * @access private
   * @param {Object} obj - target object to apply this action.
   * @param {number} time - active time
   * @param {boolean} [needTimeConversion = true] -
   * @returns {void}
   */


  _applyAction(obj, time, needTimeConversion = true) {
    //const dt = this._getTime(time, needTimeConversion) * this.duration
    //this._actions.forEach((action) => {
    //  if(!action._finished){
    //    action._applyAction(obj, dt, false)
    //  }
    //})
    const duration = this._activetimeFromTime(time);

    let finished = true;

    this._actions.forEach(action => {
      if (!action._finished) {
        action._applyAction(obj, duration, needTimeConversion);

        if (!action._finished) {
          finished = false;
        }
      }
    });

    this._finished = finished;
  }

  _resetFinished() {
    this._actions.forEach(action => {
      action._resetFinished();
    });

    this._finished = false;
  }

}
SCNAction.group = SCNActionGroup.group;

class SCNActionHide extends SCNAction {
  static get _propTypes() {
    return {
      _actions: 'NSArray',
      _finished: 'boolean',
      _duration: 'float',
      _timingMode: 'integer',
      _beginTime: 'float',
      _isRunning: 'boolean',
      _pausedTime: 'float',
      name: ['string', null]
    };
  }
  /**
   * constructor
   * @access public
   * @constructor
   */


  constructor() {
    super();
    this._actions = [];
    this._finished = false;
    this._duration = 0;
    this._timingMode = SCNActionTimingMode.linear;
    this._beginTime = 0;
    this._isRunning = false;
    this._pausedTime = 0;
  }

}

class SCNActionJavaScript extends SCNAction {
  static get _propTypes() {
    return {
      _actions: 'NSArray',
      _finished: 'boolean',
      _duration: 'float',
      _timingMode: 'integer',
      _beginTime: 'float',
      _isRunning: 'boolean',
      _pausedTime: 'float'
    };
  }
  /**
   * constructor
   * @access public
   * @constructor
   */


  constructor() {
    super();
    this._actions = [];
    this._finished = false;
    this._duration = 0;
    this._timingMode = SCNActionTimingMode.linear;
    this._beginTime = 0;
    this._isRunning = false;
    this._pausedTime = 0;
  }

}

class SCNActionMove extends SCNAction {
  static get _propTypes() {
    return {
      _actions: 'NSArray',
      _finished: 'boolean',
      _duration: 'float',
      _timingMode: 'integer',
      _beginTime: 'float',
      _isRunning: 'boolean',
      _pausedTime: 'float'
    };
  }
  /**
   * constructor
   * @access public
   * @constructor
   */


  constructor() {
    super();
    this._actions = [];
    this._finished = false;
    this._duration = 0;
    this._timingMode = SCNActionTimingMode.linear;
    this._beginTime = 0;
    this._isRunning = false;
    this._pausedTime = 0;
    this._toValue = null;
    this._byValue = null;
  }
  /**
   * Creates an action that moves a node relative to its current position.
   * @access public
   * @param {number} deltaX - The distance to move the node in the X direction of its parent node’s local coordinate space.
   * @param {number} deltaY - The distance to move the node in the Y direction of its parent node’s local coordinate space.
   * @param {number} deltaZ - The distance to move the node in the Z direction of its parent node’s local coordinate space.
   * @param {number} duration - The duration, in seconds, of the animation.
   * @returns {SCNAction} - 
   * @desc When the action executes, the node’s position property animates from its current position to its new position.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction moveByX: -deltaX y: -deltaY z: -deltaZ duration: duration];
  [SCNAction moveByX: -deltaX y: -deltaY z: -deltaZ duration: duration];
    * @see https://developer.apple.com/documentation/scenekit/scnaction/1523238-moveby
   */


  static moveByXYZ(deltaX, deltaY, deltaZ, duration) {
    const action = new SCNActionMove();
    action._byValue = new SCNVector3(deltaX, deltaY, deltaZ);
    action._duration = duration;
    return action;
  }
  /**
   * Creates an action that moves a node relative to its current position.
   * @access public
   * @param {SCNVector3} delta - A vector that describes the change to be applied to the node’s position.
   * @param {number} duration - The duration, in seconds, of the animation.
   * @returns {SCNAction} - 
   * @desc When the action executes, the node’s position property animates from its current position to its new position.This action is reversible; the reverse is created as if the following code had been executed:SCNVector3 reverseDelta = SCNVector3Make(-delta.x, -delta.y, -delta.z);
  [SCNAction moveBy: reverseDelta duration: duration];
  SCNVector3 reverseDelta = SCNVector3Make(-delta.x, -delta.y, -delta.z);
  [SCNAction moveBy: reverseDelta duration: duration];
    * @see https://developer.apple.com/documentation/scenekit/scnaction/1522605-move
   */


  static moveBy(delta, duration) {
    const action = new SCNActionMove();
    action._byValue = delta._copy();
    action._duration = duration;
    return action;
  }
  /**
   * Creates an action that moves a node to a new position.
   * @access public
   * @param {SCNVector3} location - The coordinates for the node’s new position in its parent node’s local coordinate space.
   * @param {number} duration - The duration, in seconds, of the animation.
   * @returns {SCNAction} - 
   * @desc When the action executes, the node’s position property animates from its current position to its new position.This action is not reversible; the reverse of this action has the same duration but does not move the node.
   * @see https://developer.apple.com/documentation/scenekit/scnaction/1522826-move
   */


  static moveTo(location, duration) {
    const action = new SCNActionMove();
    action._toValue = location._copy();
    action._duration = duration;
    return action;
  } // Reversing an Action

  /**
   * Creates an action that reverses the behavior of another action.
   * @access public
   * @returns {SCNAction} - 
   * @desc This method always returns an action object; however, not all actions are reversible. When reversed, some actions return an object that either does nothing or performs the same action as the original action. For details on how an action is reversed, see the description of the class method used to create that action.
   * @see https://developer.apple.com/documentation/scenekit/scnaction/1522815-reversed
   */


  reversed() {
    const action = this.copy();

    if (action._toValue) {
      action._toValue = null;
      action._byValue = new SCNVector3(0, 0, 0);
    } else if (this._byValue) {
      action._byValue = this._byValue.mul(-1);
    }

    return action;
  }
  /**
   * @access public
   * @returns {SCNActionMove} -
   */


  copy() {
    const action = super.copy();
    action._toValue = this._toValue ? this._toValue._copy() : null;
    action._byValue = this._byValue ? this._byValue._copy() : null;
    return action;
  }
  /**
   * apply action to the given node.
   * @access private
   * @param {Object} obj - target object to apply this action.
   * @param {number} time - active time
   * @param {boolean} [needTimeConversion = true] -
   * @returns {void}
   */


  _applyAction(obj, time, needTimeConversion = true) {
    const t = this._getTime(time, needTimeConversion);

    if (!_InstanceOf(obj, SCNNode)) {
      throw new Error(`unsupported class for SCNActionMove: ${obj.constructor.name}`);
    }

    const baseValue = obj.position;
    let toValue = null;

    if (this._toValue !== null) {
      toValue = this._toValue;
    } else if (this._byValue !== null) {
      toValue = baseValue.add(this._byValue);
    } else {
      throw new Error('both toValue and byValue are null');
    }

    const value = this._lerp(baseValue, toValue, t);

    obj.presentation.position = value;

    if (this._finished) {
      obj.position = toValue;
    }
  }

}
SCNAction.moveByXYZ = SCNActionMove.moveByXYZ;
SCNAction.moveBy = SCNActionMove.moveBy;
SCNAction.moveTo = SCNActionMove.moveTo;

class SCNActionPerformSelector extends SCNAction {
  static get _propTypes() {
    return {
      _actions: 'NSArray',
      _finished: 'boolean',
      _duration: 'float',
      _timingMode: 'integer',
      _beginTime: 'float',
      _isRunning: 'boolean',
      _pausedTime: 'float'
    };
  }
  /**
   * constructor
   * @access public
   * @constructor
   */


  constructor() {
    super();
    this._actions = [];
    this._finished = false;
    this._duration = 0;
    this._timingMode = SCNActionTimingMode.linear;
    this._beginTime = 0;
    this._isRunning = false;
    this._pausedTime = 0;
  }

}

class SCNActionPlaySound extends SCNAction {
  static get _propTypes() {
    return {
      _actions: 'NSArray',
      _finished: 'boolean',
      _duration: 'float',
      _timingMode: 'integer',
      _beginTime: 'float',
      _isRunning: 'boolean',
      _pausedTime: 'float',
      name: ['string', null]
    };
  }
  /**
   * constructor
   * @access public
   * @constructor
   */


  constructor() {
    super();
    this._actions = [];
    this._finished = false;
    this._duration = 0;
    this._timingMode = SCNActionTimingMode.linear;
    this._beginTime = 0;
    this._isRunning = false;
    this._pausedTime = 0;
    this._source = null;
    this._wait = false;
  }
  /**
   * Creates an action that plays an audio source.
   * @access public
   * @param {SCNAudioSource} source - The audio source to play.
   * @param {boolean} wait - If true, the duration of this action is the same as the length of the audio playback. If false, the action is considered to have completed immediately.
   * @returns {SCNAction} - 
   * @desc When the action executes, SceneKit plays the audio source on the target node—any positional audio effects are based on the node’s position. For more information about positional audio in SceneKit, see SCNAudioPlayer.This action is not reversible; the reverse of this action is the same action.
   * @see https://developer.apple.com/documentation/scenekit/scnaction/1523651-playaudio
   */


  static playAudioWaitForCompletion(source, wait) {
    const action = new SCNActionPlaySound();
    action._source = source;
    action._wait = wait;
    return action;
  }
  /**
   * @access public
   * @returns {SCNActionPlaySound} -
   */


  copy() {
    const action = super.copy();
    action._source = this._source;
    action._wait = this._wait;
    return action;
  }
  /**
   * apply action to the given node.
   * @access private
   * @param {Object} obj - target object to apply this action.
   * @param {number} time - active time
   * @param {boolean} [needTimeConversion = true] -
   * @returns {void}
   */


  _applyAction(obj, time, needTimeConversion = true) {
    if (!this._isRunning) {
      this._source._play();

      this._isRunning = true;
    }

    if (this._duration <= 0 || this._source._duration > 0) {
      this._duration = this._source._duration;
    }

    const t = this._getTime(time, needTimeConversion);

    if (!this._wait) {
      this._finished = true;
    } else if (!this._source.loops && t >= 1) {
      this._finished = true;
    } else {
      this._finished = false;
    }
  }

}
SCNAction.playAudioWaitForCompletion = SCNActionPlaySound.playAudioWaitForCompletion;

class SCNActionReference extends SCNAction {
  static get _propTypes() {
    return {
      _actions: 'NSArray',
      _finished: 'boolean',
      _duration: 'float',
      _timingMode: 'integer',
      _beginTime: 'float',
      _isRunning: 'boolean',
      _pausedTime: 'float'
    };
  }
  /**
   * constructor
   * @access public
   * @constructor
   */


  constructor() {
    super();
    this._actions = [];
    this._finished = false;
    this._duration = 0;
    this._timingMode = SCNActionTimingMode.linear;
    this._beginTime = 0;
    this._isRunning = false;
    this._pausedTime = 0;
  }

}

class SCNActionRemove extends SCNAction {
  static get _propTypes() {
    return {
      _actions: 'NSArray',
      _finished: 'boolean',
      _duration: 'float',
      _timingMode: 'integer',
      _beginTime: 'float',
      _isRunning: 'boolean',
      _pausedTime: 'float'
    };
  }
  /**
   * constructor
   * @access public
   * @constructor
   */


  constructor() {
    super();
    this._actions = [];
    this._finished = false;
    this._duration = 0;
    this._timingMode = SCNActionTimingMode.linear;
    this._beginTime = 0;
    this._isRunning = false;
    this._pausedTime = 0;
  }
  /**
   * Creates an action that removes the node from its parent.
   * @access public
   * @returns {SCNAction} - 
   * @desc When the action executes, the node is immediately removed from its parent.This action is not reversible; the reverse of this action is the same action.
   * @see https://developer.apple.com/documentation/scenekit/scnaction/1522966-removefromparentnode
   */


  static removeFromParentNode() {
    const action = new SCNActionRemove();
    return action;
  }
  /**
   * @access public
   * @returns {SCNActionRotate} -
   */


  copy() {
    const action = super.copy();
    return action;
  }
  /**
   * apply action to the given node.
   * @access private
   * @param {Object} obj - target object to apply this action.
   * @param {number} time - active time
   * @param {boolean} [needTimeConversion = true] -
   * @returns {void}
   */


  _applyAction(obj, time, needTimeConversion = true) {
    if (!_InstanceOf(obj, SCNNode)) {
      throw new Error(`unsupported class for SCNActionRemove: ${obj.constructor.name}`);
    }

    obj.removeFromParentNode();
    this._finished = true;
  }

}
SCNAction.removeFromParentNode = SCNActionRemove.removeFromParentNode;

class SCNActionRepeat extends SCNAction {
  static get _propTypes() {
    return {
      _timesToRepeat: 'float',
      _finished: 'boolean',
      _duration: 'float',
      _timingMode: 'integer',
      _beginTime: 'float',
      _isRunning: 'boolean',
      _repeatedAction: 'SCNAction',
      _forever: 'boolean',
      _timesRepeated: 'integer',
      _pausedTime: 'float',
      name: ['string', null]
    };
  }
  /**
   * constructor
   * @access public
   * @constructor
   */


  constructor() {
    super();
    this._timesToRepeat = 0;
    this._repeatedAction = null;
    this._forever = false;
    this._timesRepeated = 0;
    this._finished = false;
    this._duration = 0;
    this._timingMode = SCNActionTimingMode.linear;
    this._beginTime = 0;
    this._isRunning = false;
    this._pausedTime = 0;
  }
  /**
   * Creates an action that repeats another action a specified number of times.
   * @access public
   * @param {SCNAction} action - The action to be executed.
   * @param {number} count - The number of times to execute the action.
   * @returns {SCNAction} - 
   * @desc When the action executes, the associated action runs to completion and then repeats, until the count is reached.This action is reversible; it creates a new action that is the reverse of the specified action and then repeats it the same number of times.
   * @see https://developer.apple.com/documentation/scenekit/scnaction/1522764-repeat
   */


  static repeat(action, count) {
    const _action = new SCNActionRepeat();

    _action._repeatedAction = action;
    _action._duration = action.duration;
    _action._timesToRepeat = count;
    _action._forever = count === Infinity;
    return _action;
  }
  /**
   * Creates an action that repeats another action forever.
   * @access public
   * @param {SCNAction} action - The action to execute.
   * @returns {SCNAction} - 
   * @desc When the action executes, the associated action runs to completion and then repeats.This action is reversible; it creates a new action that is the reverse of the specified action and then repeats it forever.NoteThe action to be repeated must have a non-instantaneous duration.
   * @see https://developer.apple.com/documentation/scenekit/scnaction/1522908-repeatforever
   */


  static repeatForever(action) {
    return this.repeat(action, Infinity);
  }
  /**
   * @access public
   * @returns {SCNActionRepeat} -
   */


  copy() {
    const action = super.copy();
    action._timesToRepeat = this._timesToRepeat;
    action._repeatedAction = this._repeatedAction.copy();
    action._forever = this._forever;
    action._timesRepeated = this._timesRepeated;
    return action;
  }

  _getTime(time, needTimeConversion) {
    if (!needTimeConversion) {
      return time;
    }

    const baseTime = this._basetimeFromTime(time);

    if (this.timingFunction === null) {
      return baseTime;
    }

    const n = Math.floor(baseTime);

    const t = this.timingFunction._getValueAtTime(baseTime - n);

    return n + t;
  }
  /**
   * apply action to the given node.
   * @access private
   * @param {Object} obj - target object to apply this action.
   * @param {number} time - active time
   * @param {boolean} [needTimeConversion = true] -
   * @returns {void}
   */


  _applyAction(obj, time, needTimeConversion = true) {
    const dt = this._getTime(time, needTimeConversion);

    const timesRepeated = Math.floor(dt);

    while (timesRepeated > this._timesRepeated) {
      this._timesRepeated += 1;

      this._repeatedAction._applyAction(obj, 1.0, false);

      if (!this._forever && this._timesRepeated >= this._timesToRepeat) {
        this._finished = true;
        return;
      }

      this._repeatedAction._resetFinished();
    }

    let t = dt - this._timesRepeated;

    this._repeatedAction._applyAction(obj, t, false);

    this._finished = false;
  }

  get duration() {
    if (this._forever) {
      return Infinity;
    }

    return this._repeatedAction.duration * this._timesToRepeat;
  }

  _resetFinished() {
    this._repeatedAction._resetFinished();

    this._timesRepeated = 0;
    this._finished = false;
  }

}
SCNAction.repeat = SCNActionRepeat.repeat;
SCNAction.repeatForever = SCNActionRepeat.repeatForever;

class SCNActionRotate extends SCNAction {
  static get _propTypes() {
    return {
      _rotX: 'float',
      _rotY: 'float',
      _rotZ: 'float',
      _lastRotX: 'float',
      _lastRotY: 'float',
      _lastRotZ: 'float',
      _axisRot: 'SCNVector4',
      _isRelative: 'boolean',
      _isReversed: 'boolean',
      _isUnitArc: 'boolean',
      _isAxisAngle: 'boolean',
      _isRunning: 'boolean',
      _finished: 'boolean',
      _duration: 'float',
      _pausedTime: 'float',
      _timingMode: 'integer',
      _beginTime: 'float',
      name: ['string', null]
    };
  }
  /**
   * constructor
   * @access public
   * @constructor
   */


  constructor() {
    super();
    this._rotX = 0;
    this._rotY = 0;
    this._rotZ = 0;
    this._lastRotX = 0;
    this._lastRotY = 0;
    this._lastRotZ = 0;
    this._axisRot = new SCNVector4();
    this._isRelative = false;
    this._isReversed = false;
    this._isUnitArc = false;
    this._isAxisAngle = false;
    this._isRunning = false;
    this._finished = false;
    this._duration = 0;
    this._pausedTime = 0;
    this._timingMode = SCNActionTimingMode.linear;
    this._beginTime = 0;
  }
  /**
   * Creates an action that rotates the node in each of the three principal axes by angles relative to its current orientation.
   * @access public
   * @param {number} xAngle - The amount to rotate the node counterclockwise around the x-axis of its local coordinate space, in radians.
   * @param {number} yAngle - The amount to rotate the node counterclockwise around the y-axis of its local coordinate space, in radians.
   * @param {number} zAngle - The amount to rotate the node counterclockwise around the z-axis of its local coordinate space, in radians.
   * @param {number} duration - The duration, in seconds, of the animation.
   * @returns {SCNAction} - 
   * @desc When the action executes, the node’s rotation property animates to the new angle.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction rotateByX: -xAngle y: -yAngle z: -zAngle duration: duration];
  [SCNAction rotateByX: -xAngle y: -yAngle z: -zAngle duration: duration];
    * @see https://developer.apple.com/documentation/scenekit/scnaction/1523522-rotateby
   */


  static rotateByXYZ(xAngle, yAngle, zAngle, duration) {
    const action = new SCNActionRotate(); // TODO: Do research the reason why I need to turn around X and Y axes.

    action._rotX = -xAngle;
    action._rotY = -yAngle;
    action._rotZ = zAngle;
    action._duration = duration;
    action._isRelative = true;
    return action;
  }
  /**
   * Creates an action that rotates the node to absolute angles in each of the three principal axes.
   * @access public
   * @param {number} xAngle - The amount to rotate the node counterclockwise around the x-axis of its local coordinate space, in radians.
   * @param {number} yAngle - The amount to rotate the node counterclockwise around the y-axis of its local coordinate space, in radians.
   * @param {number} zAngle - The amount to rotate the node counterclockwise around the z-axis of its local coordinate space, in radians.
   * @param {number} duration - The duration, in seconds, of the animation.
   * @returns {SCNAction} - 
   * @desc When the action executes, the node’s rotation property animates to the new angle. Calling this method is equivalent to calling rotateTo(x:y:z:duration:usesShortestUnitArc:) and passing false for the shortestUnitArc parameter.This action is not reversible; the reverse of this action has the same duration but does not change anything.
   * @see https://developer.apple.com/documentation/scenekit/scnaction/1524044-rotateto
   */


  static rotateToXYZ(xAngle, yAngle, zAngle, duration) {
    const action = new SCNActionRotate();
    action._rotX = xAngle;
    action._rotY = yAngle;
    action._rotZ = zAngle;
    action._duration = duration;
    return action;
  }
  /**
   * Creates an action that rotates the node to absolute angles in each of the three principal axes.
   * @access public
   * @param {number} xAngle - The amount to rotate the node counterclockwise around the x-axis of its local coordinate space, in radians.
   * @param {number} yAngle - The amount to rotate the node counterclockwise around the y-axis of its local coordinate space, in radians.
   * @param {number} zAngle - The amount to rotate the node counterclockwise around the z-axis of its local coordinate space, in radians.
   * @param {number} duration - The duration, in seconds, of the animation.
   * @param {boolean} shortestUnitArc - If false (the default), the animation interpolates each component of the node’s rotation between its current value and the new value. If true, the animation makes the most direct rotation possible from the node’s current orientation to the new orientation.
   * @returns {SCNAction} - 
   * @desc When the action executes, the node’s rotation property animates to the new angle.This action is not reversible; the reverse of this action has the same duration but does not change anything.
   * @see https://developer.apple.com/documentation/scenekit/scnaction/1522808-rotateto
   */


  static rotateToXYZUsesShortestUnitArc(xAngle, yAngle, zAngle, duration, shortestUnitArc) {
    const action = new SCNActionRotate();
    action._rotX = xAngle;
    action._rotY = yAngle;
    action._rotZ = zAngle;
    action._duration = duration;
    action._isUnitArc = shortestUnitArc;
    return action;
  }
  /**
   * Creates an action that rotates the node by an angle around a specified axis.
   * @access public
   * @param {number} angle - The amount to rotate the node counterclockwise around the specified axis, in radians.
   * @param {SCNVector3} axis - A vector in the node’s local coordinate space whose direction specifies the axis of rotation.
   * @param {number} duration - The duration, in seconds, of the animation.
   * @returns {SCNAction} - 
   * @desc When the action executes, the node’s rotation property animates to the new angle.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction rotateByAngle: -angle aroundAxis: axis duration: sec];
  [SCNAction rotateByAngle: -angle aroundAxis: axis duration: sec];
    * @see https://developer.apple.com/documentation/scenekit/scnaction/1523805-rotate
   */


  static rotateByAround(angle, axis, duration) {
    const action = new SCNActionRotate();
    action._axisRot.w = angle;
    action._axisRot.x = axis.x;
    action._axisRot.y = axis.y;
    action._axisRot.z = axis.z;
    action._duration = duration;
    action._isRelative = true;
    action._isAxisAngle = true;
    return action;
  }
  /**
   * Creates an action that rotates the node to an absolute angle around a specified axis.
   * @access public
   * @param {SCNVector4} axisAngle - A four-component vector whose first three components are a vector in the node’s local coordinate space specifying an axis and whose fourth component is the amount to rotate the node counterclockwise around that axis, in radians.
   * @param {number} duration - The duration, in seconds, of the animation.
   * @returns {SCNAction} - 
   * @desc When the action executes, the node’s rotation property animates to the new angle.This action is not reversible; the reverse of this action has the same duration but does not change anything.
   * @see https://developer.apple.com/documentation/scenekit/scnaction/1524191-rotate
   */


  static rotateToAxisAngle(axisAngle, duration) {
    const action = new SCNActionRotate();
    action._axisRot = axisAngle;
    action._duration = duration;
    action._isAxisAngle = true;
    return action;
  }
  /**
   * @access public
   * @returns {SCNActionRotate} -
   */


  copy() {
    const action = super.copy();
    action._rotX = this._rotX;
    action._rotY = this._rotY;
    action._rotZ = this._rotZ;
    action._lastRotX = this._lastRotX;
    action._lastRotY = this._lastRotY;
    action._lastRotZ = this._lastRotZ;
    action._axisRot = this._axisRot;
    action._isRelative = this._isRelative;
    action._isReveresed = this._isReversed;
    action._isUnitArc = this._isUnitArc;
    action._isAxisAngle = this._isAxisAngle;
    action._isRunning = this._isRunning;
    action._finished = this._finished;
    action._duration = this._duration;
    action._pausedTime = this._pausedTime;
    action._timingMode = this._timingMode;
    return action;
  }
  /**
   * apply action to the given node.
   * @access private
   * @param {Object} obj - target object to apply this action.
   * @param {number} time - active time
   * @param {boolean} [needTimeConversion = true] -
   * @returns {void}
   */


  _applyAction(obj, time, needTimeConversion = true) {
    if (!_InstanceOf(obj, SCNNode)) {
      throw new Error(`unsupported class for SCNActionRotate: ${obj.constructor.name}`);
    }

    const t = this._getTime(time, needTimeConversion); //console.warn(`SCNActionRotate._applyAction t: ${t}`)


    if (this._isAxisAngle) {
      // rotation
      const baseValue = obj.rotation;
      let toValue = this._axisRot;

      if (this._isRelative) {
        const baseQuat = baseValue.rotationToQuat;
        const byQuat = this._axisRot.rotationToQuat;
        toValue = baseQuat.cross(byQuat).quatToRotation;
      }

      if (this._isUnitArc) {
        const value = this._slerp(baseValue.rotationToQuat(), toValue.rotationToQuat(), t);

        obj.presentation.orientation = value;
      } else {
        const value = this._lerp(baseValue, toValue, t);

        obj.presentation.rotation = value;
      }

      if (this._finished) {
        obj.rotation = toValue;
      }
    } else {
      // eulerAngles
      let toValue = new SCNVector3(this._rotX, this._rotY, this._rotZ);
      let value = null;

      if (this._isRelative) {
        const baseValue = obj.orientation;
        value = baseValue.cross(toValue.mul(t).eulerAnglesToQuat());
        obj.presentation.orientation = value;
      } else if (this._isUnitArc) {
        const baseValue = obj.orientation;
        value = this._slerp(baseValue, toValue.eulerAnglesToQuat(), t);
        obj.presentation.orientation = value;
      } else {
        const baseValue = obj.eulerAngles;
        value = this._lerp(baseValue, toValue, t);
        obj.presentation.eulerAngles = value;
      } //obj.presentation.eulerAngles = value


      if (this._finished) {
        if (this._isRelative) {
          toValue = obj.orientation.cross(toValue.eulerAnglesToQuat());
          obj.orientation = toValue;
        } else {
          obj.eulerAngles = toValue;
        }
      }
    }
  }

}
SCNAction.rotateByXYZ = SCNActionRotate.rotateByXYZ;
SCNAction.rotateToXYZ = SCNActionRotate.rotateToXYZ;
SCNAction.rotateToXYZUsesShortestUnitArc = SCNActionRotate.rotateToXYZUsesShortestUnitArc;
SCNAction.rotateByAround = SCNActionRotate.rotateByAround;
SCNAction.rotateToAxisAngle = SCNActionRotate.rotateToAxisAngle;

class SCNActionRunAction extends SCNAction {
  static get _propTypes() {
    return {
      _actions: 'NSArray',
      _finished: 'boolean',
      _duration: 'float',
      _timingMode: 'integer',
      _beginTime: 'float',
      _isRunning: 'boolean',
      _pausedTime: 'float'
    };
  }
  /**
   * constructor
   * @access public
   * @constructor
   */


  constructor() {
    super();
    this._actions = [];
    this._finished = false;
    this._duration = 0;
    this._timingMode = SCNActionTimingMode.linear;
    this._beginTime = 0;
    this._isRunning = false;
    this._pausedTime = 0;
  }

}

class SCNActionRunBlock extends SCNAction {
  static get _propTypes() {
    return {
      _actions: 'NSArray',
      _finished: 'boolean',
      _duration: 'float',
      _timingMode: 'integer',
      _beginTime: 'float',
      _isRunning: 'boolean',
      _pausedTime: 'float',
      name: ['string', null]
    };
  }
  /**
   * constructor
   * @access public
   * @constructor
   */


  constructor() {
    super();
    this._actions = [];
    this._finished = false;
    this._duration = 0;
    this._timingMode = SCNActionTimingMode.linear;
    this._beginTime = 0;
    this._isRunning = false;
    this._pausedTime = 0;
  }
  /**
   * @access public
   * @returns {SCNActionFade} -
   */


  copy() {
    const action = super.copy();
    action._block = this._block;
    return action;
  }
  /**
   * Creates an action that executes a block.
   * @access public
   * @param {function(arg1: SCNNode): void} block - The block to run. The block takes a single parameter:nodeThe node on which the action is running.
   * @returns {SCNAction} - 
   * @desc When the action executes, SceneKit calls the block. This action takes place instantaneously.This action is not reversible; the reverse action executes the same block.
   * @see https://developer.apple.com/documentation/scenekit/scnaction/1523637-run
   */


  static run(block) {
    const action = new SCNActionRunBlock();
    action._block = block;
    return action;
  }
  /**
   * apply action to the given node.
   * @access private
   * @param {Object} obj - target object to apply this action.
   * @param {number} time - active time
   * @param {boolean} [needTimeConversion = true] -
   * @returns {void}
   */


  _applyAction(obj, time, needTimeConversion = true) {
    this._block(obj);

    this._finished = true;
  }

}
SCNAction.run = SCNActionRunBlock.run;

class SCNActionScale extends SCNAction {
  static get _propTypes() {
    return {
      _actions: 'NSArray',
      _finished: 'boolean',
      _duration: 'float',
      _timingMode: 'integer',
      _beginTime: 'float',
      _isRunning: 'boolean',
      _pausedTime: 'float'
    };
  }
  /**
   * constructor
   * @access public
   * @constructor
   */


  constructor() {
    super();
    this._actions = [];
    this._finished = false;
    this._duration = 0;
    this._timingMode = SCNActionTimingMode.linear;
    this._beginTime = 0;
    this._isRunning = false;
    this._pausedTime = 0;
  }

}

class SCNActionSequence extends SCNAction {
  static get _propTypes() {
    return {
      _actions: 'NSArray',
      _finished: 'boolean',
      '_mycaction->_animIndex': ['integer', '_animIndex'],
      _duration: 'float',
      _timingMode: 'integer',
      _beginTime: 'float',
      _isRunning: 'boolean',
      _pausedTime: 'float',
      name: ['string', null]
    };
  }
  /**
   * Creates an action that runs a collection of actions sequentially.
   * @access public
   * @constructor
   * @param {SCNAction[]} actions - An array of SCNAction objects.
   * @desc When the action executes, the first action in the sequence starts and runs to completion. Subsequent actions in the sequence run in a similar fashion until all of the actions in the sequence have executed. The duration of the sequence action is the sum of the durations of the actions in the sequence.This action is reversible; it creates a new sequence action that reverses the order of the actions. Each action in the reversed sequence is itself reversed. For example, the actions reverseSequence and sequenceReverse in the code example below are equivalent:SCNAction *sequence = [SCNAction sequence:@[ actionA, actionB, actionC ]];
  SCNAction *reverseSequence = [SCNAction sequence:@[ [actionC reversedAction],
                                                    [actionB reversedAction],
                                                    [actionA reversedAction] ]];
  SCNAction *sequenceReverse = [sequence reversedAction];
  SCNAction *sequence = [SCNAction sequence:@[ actionA, actionB, actionC ]];
  SCNAction *reverseSequence = [SCNAction sequence:@[ [actionC reversedAction],
                                                    [actionB reversedAction],
                                                    [actionA reversedAction] ]];
  SCNAction *sequenceReverse = [sequence reversedAction];
    * @see https://developer.apple.com/documentation/scenekit/scnaction/1522793-sequence
   */


  constructor() {
    super();
    this._actions = [];
    this._finished = false;
    this._animIndex = 0;
    this._duration = 0;
    this._timingMode = SCNActionTimingMode.linear;
    this._beginTime = 0;
    this._isRunning = false;
    this._pausedTime = 0;
  }
  /**
   * Creates an action that runs a collection of actions sequentially.
   * @access public
   * @param {SCNAction[]} actions - An array of SCNAction objects.
   * @returns {SCNAction} - 
   * @desc When the action executes, the first action in the sequence starts and runs to completion. Subsequent actions in the sequence run in a similar fashion until all of the actions in the sequence have executed. The duration of the sequence action is the sum of the durations of the actions in the sequence.This action is reversible; it creates a new sequence action that reverses the order of the actions. Each action in the reversed sequence is itself reversed. For example, the actions reverseSequence and sequenceReverse in the code example below are equivalent:SCNAction *sequence = [SCNAction sequence:@[ actionA, actionB, actionC ]];
  SCNAction *reverseSequence = [SCNAction sequence:@[ [actionC reversedAction],
                                                    [actionB reversedAction],
                                                    [actionA reversedAction] ]];
  SCNAction *sequenceReverse = [sequence reversedAction];
  SCNAction *sequence = [SCNAction sequence:@[ actionA, actionB, actionC ]];
  SCNAction *reverseSequence = [SCNAction sequence:@[ [actionC reversedAction],
                                                    [actionB reversedAction],
                                                    [actionA reversedAction] ]];
  SCNAction *sequenceReverse = [sequence reversedAction];
    * @see https://developer.apple.com/documentation/scenekit/scnaction/1522793-sequence
   */


  static sequence(actions) {
    const action = new SCNActionSequence();
    action._actions = actions;
    action._duration = 0;
    return action;
  }

  get duration() {
    let d = 0;

    this._actions.forEach(act => {
      if (act.speed > 0) {
        d += act.duration / act.speed;
      }
    });

    return d;
  }
  /**
   * @access public
   * @returns {SCNActionSequence} -
   */


  copy() {
    const action = super.copy();
    action._actions = this._actions.slice(0);
    action._animIndex = this._animIndex;
    return action;
  }
  /**
   * apply action to the given node.
   * @access private
   * @param {Object} obj - target object to apply this action.
   * @param {number} time - active time
   * @param {boolean} [needTimeConversion = true] -
   * @returns {void}
   */


  _applyAction(obj, time, needTimeConversion = true) {
    const total = this.duration;
    let duration = 0;

    if (total <= 0 || total === Infinity) {
      duration = this._activetimeFromTime(time);
    } else {
      duration = this._getTime(time, needTimeConversion) * total;
    }

    for (let i = 0; i < this._animIndex; i++) {
      duration -= this._actions[i].duration / this._actions[i].speed;
    }

    for (; this._animIndex < this._actions.length; this._animIndex++) {
      const action = this._actions[this._animIndex]; //action._applyAction(obj, duration, needTimeConversion)

      action._applyAction(obj, duration, true);

      duration -= action.duration / action.speed;

      if (duration < 0) {
        break;
      }
    }

    if (this._animIndex >= this._actions.length) {
      this._finished = true;
    }
  }

  _resetFinished() {
    this._actions.forEach(action => {
      action._resetFinished();
    });

    this._finished = false;
    this._animIndex = 0;
  }

}
SCNAction.sequence = SCNActionSequence.sequence;

/**
 * The signature for a block that manages animation timing, used by the timingFunction property.
 * @type {function(time: number): number}
 * @param {number} time - A fraction of the action’s The input value for the timing function, as determined by the timingMode property and the action’s current progress.
 * @returns {number} -
 * @desc Your block must return a floating-point value between 0.0 and 1.0, where 0.0 represents the starting state of the action’s animation and 1.0 represents the end state.
 * @see https://developer.apple.com/documentation/scenekit/scnactiontimingfunction
 */

const SCNActionTimingFunction = time => {};

class SCNActionWait extends SCNAction {
  static get _propTypes() {
    return {
      _actions: 'NSArray',
      _finished: 'boolean',
      _duration: 'float',
      _timingMode: 'integer',
      _beginTime: 'float',
      _isRunning: 'boolean',
      _pausedTime: 'float',
      name: ['string', null]
    };
  }
  /**
   * constructor
   * @access public
   * @constructor
   */


  constructor() {
    super();
    this._actions = [];
    this._finished = false;
    this._duration = 0;
    this._timingMode = SCNActionTimingMode.linear;
    this._beginTime = 0;
    this._isRunning = false;
    this._pausedTime = 0;
  }
  /**
   * Creates an action that idles for a specified period of time.
   * @access public
   * @param {number} sec - The amount of time to wait.
   * @returns {SCNAction} - 
   * @desc When the action executes, the action waits for the specified amount of time and then ends. This is typically used as part of a sequence of actions to insert a delay between two other actions. You might also use it in conjunction with the runAction(_:completionHandler:) method to trigger code that needs to run at a later time.This action is not reversible; the reverse of this action is the same action.
   * @see https://developer.apple.com/documentation/scenekit/scnaction/1523915-wait
   */


  static waitDuration(sec) {
    const action = new SCNActionWait();
    action._duration = sec;
    return action;
  }
  /**
   * Creates an action that idles for a randomized period of time.
   * @access public
   * @param {number} sec - The average amount of time to wait.
   * @param {number} durationRange - The range of possible values for the duration.
   * @returns {SCNAction} - 
   * @desc When the action executes, the action waits for the specified amount of time and then ends. This is typically used as part of a sequence of actions to insert a delay between two other actions. However, you might also use it in conjunction with the runAction(_:completionHandler:) method to trigger code that needs to run at a later time.Each time the action is executed, the action computes a new random value for the duration. The duration may vary in either direction by up to half of the value of the durationRange parameter.This action is not reversible; the reverse of this action is the same action.
   * @see https://developer.apple.com/documentation/scenekit/scnaction/1523086-wait
   */


  static waitDurationWithRange(sec, durationRange) {
    const duration = Math.max(0, sec + (Math.random() - 0.5) * durationRange);
    const action = new SCNActionWait();
    action._duration = duration;
    return action;
  }

}
SCNAction.waitDuration = SCNActionWait.waitDuration;
SCNAction.waitDurationWithRange = SCNActionWait.waitDurationWithRange;

/**
 * The common interface for attaching animations to nodes, geometries, materials, and other SceneKit objects.
 * @interface
 * @see https://developer.apple.com/documentation/scenekit/scnanimatable
 */

class SCNAnimatable {
  /**
   * constructor
   * @access public
   * @returns {void}
   */
  init() {
    // Managing Animations
    this._animationKeys = null;
  } // Managing Animations

  /**
   * Required. Adds an animation object for the specified key.
   * @access public
   * @param {CAAnimation} animation - The animation object to be added.
   * @param {?string} key - An string identifying the animation for later retrieval. You may pass nil if you don’t need to reference the animation later.
   * @returns {void}
   * @desc Newly added animations begin executing after the current run loop cycle ends.SceneKit does not define any requirements for the contents of the key parameter—it need only be unique among the keys for other animations you add. If you add an animation with an existing key, this method overwrites the existing animation.
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523386-addanimation
   */


  addAnimationForKey(animation, key) {}
  /**
   * Required. Returns the animation with the specified key.
   * @access public
   * @param {string} key - A string identifying a previously added animation.
   * @returns {?CAAnimation} - 
   * @desc Attempting to modify any properties of the returned object results in undefined behavior.
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1524020-animation
   */


  animationForKey(key) {
    return null;
  }
  /**
   * Required. Removes all the animations currently attached to the object.
   * @access public
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1522762-removeallanimations
   */


  removeAllAnimations() {}
  /**
   * Required. Removes the animation attached to the object with the specified key.
   * @access public
   * @param {string} key - A string identifying an attached animation to remove.
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1522880-removeanimation
   */


  removeAnimationForKey(key) {}
  /**
   * Required. Removes the animation attached to the object with the specified key, smoothly transitioning out of the animation’s effect.
   * @access public
   * @param {string} key - A string identifying an attached animation to remove.
   * @param {number} duration - The duration for transitioning out of the animation’s effect before it is removed.
   * @returns {void}
   * @desc Use this method to create smooth transitions between the effects of multiple animations. For example, the geometry loaded from a scene file for a game character may have associated animations for player actions such as walking and jumping. When the player lands from a jump, you remove the jump animation so the character continues walking. If you use the removeAnimation(forKey:) method to remove the jump animation, SceneKit abruptly switches from the current frame of the jump animation to the current frame of the walk animation. If you use the removeAnimation(forKey:fadeOutDuration:) method instead, SceneKit plays both animations at once during that duration and interpolates vertex positions from one animation to the other, creating a smooth transition.
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1522841-removeanimation
   */


  removeAnimationForKeyFadeOutDuration(key, duration) {}
  /**
   * Required. An array containing the keys of all animations currently attached to the object.
   * @type {string[]}
   * @desc This array contains all keys for which animations are attached to the object, or is empty if there are no attached animations. The ordering of animation keys in the array is arbitrary.
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523610-animationkeys
   */


  get animationKeys() {
    return this._animationKeys;
  } // Pausing and Resuming Animations

  /**
   * Required. Pauses the animation attached to the object with the specified key.
   * @access public
   * @param {string} key - A string identifying an attached animation.
   * @returns {void}
   * @desc This method has no effect if no animation is attached to the object with the specified key.
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523592-pauseanimation
   */


  pauseAnimationForKey(key) {}
  /**
   * Required. Resumes a previously paused animation attached to the object with the specified key.
   * @access public
   * @param {string} key - A string identifying an attached animation.
   * @returns {void}
   * @desc This method has no effect if no animation is attached to the object with the specified key or if the specified animation is not currently paused.
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523332-resumeanimation
   */


  resumeAnimationForKey(key) {}
  /**
   * Required. Returns a Boolean value indicating whether the animation attached to the object with the specified key is paused.
   * @access public
   * @param {string} key - A string identifying an attached animation.
   * @returns {boolean} - 
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523703-isanimationpaused
   */


  isAnimationPausedForKey(key) {
    return false;
  } // Instance Methods

  /**
   * Required. 
   * @access public
   * @param {number} speed - 
   * @param {string} key - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1778343-setanimationspeed
   */


  setAnimationSpeedForKey(speed, key) {}

}

//import SCNTimingFunction from './SCNTimingFunction'

/**
 * 
 * @access public
 * @extends {NSObject}
 * @implements {SCNAnimationProtocol}
 * @see https://developer.apple.com/documentation/scenekit/scnanimation
 */

class SCNAnimation extends NSObject {
  // Initializers

  /**
   * 
   * @access public
   * @param {CAAnimation} caAnimation - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnanimation/2866056-init
   */
  constructor(caAnimation) {
    super(); // Instance Properties

    /**
     * 
     * @type {?SCNAnimationDidStartBlock}
     * @see https://developer.apple.com/documentation/scenekit/scnanimation/2866063-animationdidstart
     */

    this.animationDidStart = null;
    /**
     * 
     * @type {?SCNAnimationDidStopBlock}
     * @see https://developer.apple.com/documentation/scenekit/scnanimation/2866040-animationdidstop
     */

    this.animationDidStop = null;
    /**
     * 
     * @type {?SCNAnimationEvent[]}
     * @see https://developer.apple.com/documentation/scenekit/scnanimation/2866038-animationevents
     */

    this.animationEvents = null;
    /**
     * 
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnanimation/2878140-autoreverses
     */

    this.autoreverses = false;
    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnanimation/2881689-blendinduration
     */

    this.blendInDuration = 0;
    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnanimation/2881690-blendoutduration
     */

    this.blendOutDuration = 0;
    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnanimation/2866057-duration
     */

    this.duration = 0;
    /**
     * 
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnanimation/2878138-fillsbackward
     */

    this.fillsBackward = false;
    /**
     * 
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnanimation/2878132-fillsforward
     */

    this.fillsForward = false;
    /**
     * 
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnanimation/2866062-isadditive
     */

    this.isAdditive = false;
    /**
     * 
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnanimation/2878139-isappliedoncompletion
     */

    this.isAppliedOnCompletion = false;
    /**
     * 
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnanimation/2866047-iscumulative
     */

    this.isCumulative = false;
    /**
     * 
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnanimation/2878126-isremovedoncompletion
     */

    this.isRemovedOnCompletion = false;
    /**
     * 
     * @type {?string}
     * @see https://developer.apple.com/documentation/scenekit/scnanimation/2878148-keypath
     */

    this.keyPath = null;
    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnanimation/2878146-repeatcount
     */

    this.repeatCount = 0;
    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnanimation/2878135-startdelay
     */

    this.startDelay = 0;
    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnanimation/2878147-timeoffset
     */

    this.timeOffset = 0;
    /**
     * 
     * @type {SCNTimingFunction}
     * @see https://developer.apple.com/documentation/scenekit/scnanimation/2878143-timingfunction
     */

    this.timingFunction = null;
    /**
     * 
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnanimation/2878127-usesscenetimebase
     */

    this.usesSceneTimeBase = false;
    /**
     * @access private
     * @type {CAAnimation}
     */

    this._animation = caAnimation;
  }
  /**
   * 
   * @access public
   * @param {string} animationUrl - 
   * @returns {SCNAnimation} -
   * @see https://developer.apple.com/documentation/scenekit/scnanimation/2866053-init
   */


  static animationWithContentsOf(animationUrl) {} // TODO: implement

  /**
   * 
   * @access public
   * @param {string} animationName - 
   * @returns {SCNAnimation} -
   * @see https://developer.apple.com/documentation/scenekit/scnanimation/2866042-init
   */


  static animationNamed(animationName) {// TODO: implement
  }

}

/**
 * A container for a closure to be executed at a specific time during playback of an animation.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/scenekit/scnanimationevent
 */

class SCNAnimationEvent extends NSObject {
  // Creating an Animation Event

  /**
   * Creates an animation event.
   * @access public
   * @param {number} time - A number between 0.0 and 1.0 specifying the relative time for triggering the event.
   * @param {SCNAnimationEventBlock} eventBlock - A block to call at the specified time.
   * @constructor
   * @desc The time parameter is relative to the duration of the animation the event is attached to. For example, an event with a time of 0.5 triggers when the animation is halfway complete, and an event with a time of 1.0 triggers when the animation ends.
   * @see https://developer.apple.com/documentation/scenekit/scnanimationevent/1524004-init
   */
  constructor(time, eventBlock) {
    super();
    this._time = time;
    this._eventBlock = eventBlock;
  }

  static eventWithTimeEventBlock(time, eventBlock) {
    return new SCNAnimationEvent(time, eventBlock);
  }

}

/**
 * Signature for the block called when an animation event triggers.
 * @type {function(animation: CAAnimation, animatedObject: Object, playingBackward: boolean): void}
 * @param {CAAnimation} animation - The animation triggering the animation event.
 * @param {Object} animatedObject - The Scene Kit object affected by the animation.
 * @param {boolean} playingBackward - true if the animation is playing in reverse; otherwise, false.
 * @returns {void}
 * @see https://developer.apple.com/documentation/scenekit/scnanimationeventblock
 */

const SCNAnimationEventBlock = (animation, animatedObject, playingBackward) => {};

/**
 * 
 * @access public
 * @extends {NSObject}
 * @implements {SCNAnimatable}
 * @see https://developer.apple.com/documentation/scenekit/scnanimationplayer
 */

class SCNAnimationPlayer extends NSObject {
  static get _propTypes() {
    return {
      speed: 'float',
      weight: ['float', '_weight'],
      paused: 'boolean'
    };
  } // Initializers

  /**
   * 
   * @access public
   * @constructor
   * @param {SCNAnimation} animation - 
   * @see https://developer.apple.com/documentation/scenekit/scnanimationplayer/2866046-init
   */


  constructor(animation) {
    super(); // Instance Properties

    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnanimationplayer/2881688-blendfactor
     */

    this.blendFactor = 0;
    /**
     * 
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnanimationplayer/2866058-paused
     */

    this.paused = false;
    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnanimationplayer/2866041-speed
     */

    this.speed = 0;
    /**
     * @access private
     * @type {number}
     */

    this._weight = 0;
    /**
     * @access private
     * @type {SCNAnimation}
     */

    this._animation = animation;
  } // Instance Properties

  /**
   * 
   * @type {SCNAnimation}
   * @desc 
   * @see https://developer.apple.com/documentation/scenekit/scnanimationplayer/2866065-animation
   */


  get animation() {
    return this._animation;
  } // Instance Methods

  /**
   * 
   * @access public
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnanimationplayer/2866049-play
   */


  play() {}
  /**
   * 
   * @access public
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnanimationplayer/2866055-stop
   */


  stop() {}
  /**
   * 
   * @access public
   * @param {number} duration - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnanimationplayer/2887037-stop
   */


  stopWithBlendOutDuration(duration) {}

}

/**
 * Modes for antialiased rendering of the view’s scene, used by the SCNView property.
 * @typedef {Object} SCNAntialiasingMode
 * @property {number} none - Disables antialiased rendering.
 * @property {number} multisampling2X - Enables multisample antialiasing, with two samples per screen pixel.
 * @property {number} multisampling4X - Enables multisample antialiasing, with four samples per screen pixel.
 * @property {number} multisampling8X - Enables multisample antialiasing, with eight samples per screen pixel.
 * @property {number} multisampling16X - Enables multisample antialiasing, with sixteen samples per screen pixel.
 * @see https://developer.apple.com/documentation/scenekit/scnantialiasingmode
 */

const SCNAntialiasingMode = {
  none: 0,
  multisampling2X: 1,
  multisampling4X: 2,
  multisampling8X: 3,
  multisampling16X: 4
};

/**
 * A controller for playback of a positional audio source in a SceneKit scene.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/scenekit/scnaudioplayer
 */

class SCNAudioPlayer extends NSObject {
  // Creating an Audio Player

  /**
   * Initializes an audio player for playing the specified simple audio source.
   * @access public
   * @constructor
   * @param {SCNAudioSource} source - An audio source object.
   * @desc Using this initializer is typically not necessary. Instead, call the audioPlayerWithSource: method, which returns a cached audio player object if one for the specified audio source has already been created and is available for use.
   * @see https://developer.apple.com/documentation/scenekit/scnaudioplayer/1522736-init
   */
  constructor(source) {
    super(); // Working with Audio Sources

    this._audioSource = source;
    this._audioNode = new AVAudioMixerNode();
    this._audioNode._gainNode = source._gainNode; // Responding to Playback

    /**
     * A block called by SceneKit when playback of the player’s audio source is about to begin.
     * @type {?function(): void}
     * @see https://developer.apple.com/documentation/scenekit/scnaudioplayer/1524115-willstartplayback
     */

    this.willStartPlayback = null;
    /**
     * A block called by SceneKit when playback of the player’s audio source has completed.
     * @type {?function(): void}
     * @see https://developer.apple.com/documentation/scenekit/scnaudioplayer/1522818-didfinishplayback
     */

    this.didFinishPlayback = null;
  }
  /**
   * Initializes an audio player for playing the specified AVFoundation audio node.
   * @access public
   * @param {AVAudioNode} audioNode - An audio node object.
   * @returns {void}
   * @desc Using this initializer is typically not necessary. Instead, call the audioPlayerWithAVAudioNode: method, which returns a cached audio player object if one for the specified AVAudioNode object has already been created and is available for use.
   * @see https://developer.apple.com/documentation/scenekit/scnaudioplayer/1523010-init
   */


  initAvAudioNode(audioNode) {
    // Working with Audio Sources
    this._audioSource = null;
    this._audioNode = null; // Responding to Playback

    /**
     * A block called by SceneKit when playback of the player’s audio source is about to begin.
     * @type {?function(): void}
     * @see https://developer.apple.com/documentation/scenekit/scnaudioplayer/1524115-willstartplayback
     */

    this.willStartPlayback = null;
    /**
     * A block called by SceneKit when playback of the player’s audio source has completed.
     * @type {?function(): void}
     * @see https://developer.apple.com/documentation/scenekit/scnaudioplayer/1522818-didfinishplayback
     */

    this.didFinishPlayback = null;
  } // Working with Audio Sources

  /**
   * The source of audio played by this player.
   * @type {?SCNAudioSource}
   * @desc An SCNAudioSource object represents a distinct source of audio—for example, a sound file—that can be reused and shared by many player objects. Use a player’s audio source to configure the default values for playback parameters such as volume and reverb. To vary those parameters in real time during playback, use the audioNode property to work with the underlying AVAudioNode object.If the player was created with the audioPlayerWithAVAudioNode: method, this property’s value is nil.
   * @see https://developer.apple.com/documentation/scenekit/scnaudioplayer/1523059-audiosource
   */


  get audioSource() {
    return this._audioSource;
  }
  /**
   * The audio node SceneKit uses for mixing audio from this player.
   * @type {?AVAudioNode}
   * @desc SceneKit uses this AVAudioNode object to perform 3D positional mixing during playback. Use this object to vary parameters such as volume and reverb in real time during playback. To set default values for those parameters, use the audioSource property.
   * @see https://developer.apple.com/documentation/scenekit/scnaudioplayer/1522747-audionode
   */


  get audioNode() {
    return this._audioNode;
  }

  _play() {
    this._audioSource._play();
  }

  _stop() {
    this._audioSource._stop();
  }
  /**
   * @access private
   * @returns {Promise} -
   */


  _getLoadedPromise() {
    if (this._audioSource) {
      return this._audioSource._getLoadedPromise();
    }

    return Promise.resolve();
  }
  /**
   * @access public
   * @type {Promise} -
   */


  get didLoad() {
    return this._getLoadedPromise();
  }

}

/*global AudioContext*/

let _AudioContext = () => {};

if (typeof AudioContext !== 'undefined') {
  _AudioContext = AudioContext;
} else {
  console.error('error: AudioContext is not supported');
}

const _context = new _AudioContext();
/**
 * A simple, reusable audio source—music or sound effects loaded from a file—for use in positional audio playback.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/scenekit/scnaudiosource
 */


class SCNAudioSource extends NSObject {
  // Creating an Audio Source

  /**
   * Returns the audio source associated with the specified filename.
   * @access public
   * @param {string} fileName - The name of an audio file. If this filename has not been previously requested, the method looks for an audio file with the specified name in the application’s main bundle.
   * @returns {void}
   * @desc This method looks in the system caches for an audio source with the specified name and returns that object if it exists. If a matching audio source is not already in the cache, this method locates the audio file with the specified name in the application’s main bundle, then creates a new audio source and caches it for reuse.
   * @see https://developer.apple.com/documentation/scenekit/scnaudiosource/1524138-init
   */
  static sourceNamed(fileName) {
    return new SCNAudioSource(fileName);
  }
  /**
   * Initializes an audio source from an audio file in the application’s main bundle.
   * @access public
   * @param {string} name - The name of an audio file in the application’s main bundle.
   * @returns {void}
   * @desc Calling this method is equivalent to using the Bundle class to locate an audio file in the application’s main bundle and then passing the resulting URL to the init(url:) method.
   * @see https://developer.apple.com/documentation/scenekit/scnaudiosource/1524225-init
   */


  static sourceWithFileNamed(name) {
    return new SCNAudioSource(name);
  }
  /**
   * Initializes an audio source from the specified audio file.
   * @access public
   * @constructor
   * @param {string} url - A URL locating an audio file.
   * @see https://developer.apple.com/documentation/scenekit/scnaudiosource/1523264-init
   */


  constructor(url) {
    super(); // Controlling 3D Audio Spatialization

    /**
     * A Boolean value that determines whether audio from this source uses 3D positional mixing.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnaudiosource/1524185-ispositional
     */

    this.isPositional = false; // Setting Default Playback Parameters

    /**
     * The default playback volume for the audio source.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnaudiosource/1524106-volume
     */
    //this.volume = 0

    /**
     * The default playback rate for the audio source.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnaudiosource/1524189-rate
     */

    this.rate = 0;
    /**
     * The default blend of blend of unmodified and reverb-processed (also called dry and wet) audio for playback of the audio source.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnaudiosource/1523450-reverbblend
     */

    this.reverbBlend = 0;
    /**
     * A Boolean value that determines whether the audio source should play repeatedly.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnaudiosource/1524183-loops
     */
    //this.loops = false

    /**
     * A Boolean value that determines whether the audio source should stream content from its source URL when playing.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnaudiosource/1523475-shouldstream
     */

    this.shouldStream = false;
    this._loading = false;
    this._loadedPromise = new Promise((resolve, reject) => {
      this._resolve = resolve;
      this._reject = reject;
    });
    this._url = url;
    this._buffer = null;
    this._gainNode = _context.createGain();
    this._loops = false;
    this._source = null; //this._source = _context.createBufferSource()
    //this._source.connect(this._gainNode)
    //this._gainNode.connect(_context.destination)
  }
  /**
   * The default playback volume for the audio source.
   * @type {number}
   * @see https://developer.apple.com/documentation/scenekit/scnaudiosource/1524106-volume
   */


  get volume() {
    return this._gainNode.gain.value;
  }

  set volume(newValue) {
    this._gainNode.gain.value = newValue;
  }
  /**
   * A Boolean value that determines whether the audio source should play repeatedly.
   * @type {boolean}
   * @see https://developer.apple.com/documentation/scenekit/scnaudiosource/1524183-loops
   */


  get loops() {
    return this._loops;
  }

  set loops(newValue) {
    this._loops = newValue;

    if (this._source !== null) {
      this._source.loop = newValue;
    }
  } // Preloading Audio Data

  /**
   * Loads audio data from the source and prepares it for playing.
   * @access public
   * @returns {void}
   * @desc This method reads audio data from the source file (specified when initializing the audio source) and performs any decompression necessary to prepare for playing audio. Use this method to control when your app or game incurs the run-time performance cost of such work—for example, you can load all audio source before starting a game level, instead of suffering a frame rate drop upon playing a new audio source during gameplay.This method has no effect if the shouldStream property’s value is true.
   * @see https://developer.apple.com/documentation/scenekit/scnaudiosource/1523399-load
   */


  load() {
    if (this._loading) {
      return;
    }

    this._loading = true;

    const promise = _AjaxRequest.get(this._url, {
      responseType: 'arraybuffer'
    }).then(data => {
      _context.decodeAudioData(data, buffer => {
        this._buffer = buffer;

        this._resolve();
      });
    });
  }

  _play(when = 0) {
    this.load();

    this._loadedPromise.then(() => {
      this._source = _context.createBufferSource();
      this._source.buffer = this._buffer;

      this._source.connect(this._gainNode);

      this._gainNode.connect(_context.destination);

      this._source.loop = this._loops;

      this._source.start(when);
    });
  }

  _stop(when = 0) {
    if (this._source) {
      this._source.stop(when);

      this._source = null;
    }
  }

  get _duration() {
    if (this._buffer) {
      return this._buffer.duration;
    }

    return null;
  }
  /**
   * @access private
   * @returns {Promise} -
   */


  _getLoadedPromise() {
    if (this._loadedPromise) {
      return this._loadedPromise;
    }

    return Promise.resolve();
  }
  /**
   * @access public
   * @type {Promise} -
   */


  get didLoad() {
    return this._getLoadedPromise();
  }

}

/**
 * Options for locking the orientation of nodes affected by a billboard constraint.
 * @access public
 * @see https://developer.apple.com/documentation/scenekit/scnbillboardaxis
 */

class SCNBillboardAxis {
  // Constants

  /**
   * Align an affected node such that its x-axis is always parallel to that of the view, leaving it free to rotate otherwise.
   * @type {SCNBillboardAxis}
   * @desc 
   * @see https://developer.apple.com/documentation/scenekit/scnbillboardaxis/1468664-x
   */
  get X() {
    return this._X;
  }
  /**
   * Align an affected node such that its y-axis is always parallel to that of the view, leaving it free to rotate otherwise.
   * @type {SCNBillboardAxis}
   * @desc 
   * @see https://developer.apple.com/documentation/scenekit/scnbillboardaxis/1468668-y
   */


  get Y() {
    return this._Y;
  }
  /**
   * Align an affected node such that its z-axis is always perpendicular to the viewing plane, leaving it free to rotate otherwise.
   * @type {SCNBillboardAxis}
   * @desc 
   * @see https://developer.apple.com/documentation/scenekit/scnbillboardaxis/1468647-z
   */


  get Z() {
    return this._Z;
  }
  /**
   * Align an affected node such that its orientation always matches that of the view.
   * @type {SCNBillboardAxis}
   * @desc This is the default option for newly created billboard constraints.
   * @see https://developer.apple.com/documentation/scenekit/scnbillboardaxis/1468666-all
   */


  get all() {
    return this._all;
  } // Initializers

  /**
   * 
   * @access public
   * @constructor
   * @param {number} rawValue - 
   * @see https://developer.apple.com/documentation/scenekit/scnbillboardaxis/1524212-init
   */


  constructor(rawValue) {
    // Constants
    this._X = null;
    this._Y = null;
    this._Z = null;
    this._all = null;
  }

}

/**
 * A constraint that orients a node to always point toward the current camera.
 * @access public
 * @extends {SCNConstraint}
 * @see https://developer.apple.com/documentation/scenekit/scnbillboardconstraint
 */

class SCNBillboardConstraint extends SCNConstraint {
  /**
   * constructor
   * @access public
   * @constructor
   */
  constructor() {
    super(); // Working with a Constraint’s Degrees of Freedom

    /**
     * An option that specifies which degrees of freedom the constraint affects.
     * @type {SCNBillboardAxis}
     * @see https://developer.apple.com/documentation/scenekit/scnbillboardconstraint/1468685-freeaxes
     */

    this.freeAxes = null;
  }

}

//import SCNRenderer from './SCNRenderer'

/**
 * The signature for a block called for binding or unbinding a GLSL symbol in a custom program.
 * @type {function(programID: number, location: number, renderedNode: ?SCNNode, renderer: SCNRenderer): void}
 * @param {number} programID - The OpenGL program identifier for the current SCNProgram instance, as used by OpenGL functions such as glValidateProgram.
 * @param {number} location - The OpenGL location index for the symbol to be bound or unbound, as used by OpenGL functions such as glUniform.
 * @param {?SCNNode} renderedNode - The SCNNode object being rendered.
 * @param {SCNRenderer} renderer - The SCNRenderer object responsible for rendering.
 * @returns {void}
 * @desc Call handleBinding(ofSymbol:handler:) or handleUnbinding(ofSymbol:handler:) to associate a handler block with a GLSL symbol for a SceneKit geometry or material.
 * @see https://developer.apple.com/documentation/scenekit/scnbindingblock
 */

const SCNBindingBlock = (programID, location, renderedNode, renderer) => {};

/**
 * Properties for measuring an object's location and size, expressed as either a box or a sphere.
 * @interface
 * @see https://developer.apple.com/documentation/scenekit/scnboundingvolume
 */

class SCNBoundingVolume {
  /**
   * constructor
   * @access public
   * @constructor
   */
  constructor() {
    // Working with Bounding Volumes

    /**
     * The minimum and maximum corner points of the object’s bounding box.
     * @type {{min: SCNVector3, max: SCNVector3}}
     * @see https://developer.apple.com/documentation/scenekit/scnboundingvolume/2034705-boundingbox
     */
    this.boundingBox = null;
    this._boundingSphere = null;
  } // Working with Bounding Volumes

  /**
   * The center point and radius of the object’s bounding sphere.
   * @type {{center: SCNVector3, radius: number}}
   * @desc Scene Kit defines a bounding sphere in the local coordinate space using a center point and a radius. For example, if a node’s bounding sphere has the center point {3, 1, 4} and radius 2.0, all points in the vertex data of node’s geometry (and any geometry attached to its child nodes) lie within 2.0 units of the center point.The coordinates provided when reading this property are valid only if the object has a volume to be measured. For a geometry containing no vertex data or a node containing no geometry (and whose child nodes, if any, contain no geometry), the values center and radius are both zero.
   * @see https://developer.apple.com/documentation/scenekit/scnboundingvolume/2034707-boundingsphere
   */


  get boundingSphere() {
    return this._boundingSphere;
  }

}

//import SCNNode from './SCNNode'
//import SCNShadable from './SCNShadable'
//import SCNRenderer from './SCNRenderer'

/**
 * A block SceneKit calls at render time for working with buffers in a Metal shader, used by the handleBinding(ofBufferNamed:frequency:handler:) method.
 * @type {function(buffer: SCNBufferStream, node: SCNNode, shadable: SCNShadable, renderer: SCNRenderer): void}
 * @param {SCNBufferStream} buffer - An object that provides write access to the buffer. Use the writeBytes(_:count:) method on this object to write data for use by the shader.
 * @param {SCNNode} node - The node to be rendered using the shader program.
 * @param {SCNShadable} shadable - The material or geometry to be rendered using the shader program.
 * @param {SCNRenderer} renderer - The view (or other SceneKit renderer) responsible for rendering.
 * @returns {void}
 * @see https://developer.apple.com/documentation/scenekit/scnbufferbindingblock
 */

const SCNBufferBindingBlock = (buffer, node, shadable, renderer) => {};

/**
 * Options for how often SceneKit should execute the binding handler you provide with the handleBinding(ofBufferNamed:frequency:handler:) method.
 * @typedef {Object} SCNBufferFrequency
 * @property {number} perFrame - Execute the binding handler once for each frame to be rendered using the shader.
 * @property {number} perNode - Execute the binding handler once for each frame, for each node to be rendered using the shader.
 * @property {number} perShadable - Execute the binding handler once for each frame, for each node, for each material or geometry to be rendered using the shader.
 * @see https://developer.apple.com/documentation/scenekit/scnbufferfrequency
 */

const SCNBufferFrequency = {
  perFrame: 0,
  perNode: 1,
  perShadable: 2
};

/**
 * An object that manages a Metal buffer used by a custom shader program. 
 * @interface
 * @see https://developer.apple.com/documentation/scenekit/scnbufferstream
 */

class SCNBufferStream {
  /**
   * constructor
   * @access public
   * @constructor
   */
  //constructor() {
  //}
  // Writing Data to a Buffer

  /**
   * Required. Copies the specified data bytes into the underlying Metal buffer for use by a shader.
   * @access public
   * @param {Object} bytes - The memory address from which to copy data.
   * @param {number} length - The number of bytes to copy into the Metal buffer.
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnbufferstream/1523175-writebytes
   */
  writeBytesCount(bytes, length) {}

}

/**
 * 
 * @typedef {Object} SCNCameraProjectionDirection
 * @property {number} horizontal - 
 * @property {number} vertical - 
 * @see https://developer.apple.com/documentation/scenekit/scncameraprojectiondirection
 */

const SCNCameraProjectionDirection = {
  horizontal: 0,
  vertical: 1
};

/**
 * A set of camera attributes that can be attached to a node to provide a point of view for displaying the scene.
 * @access public
 * @extends {NSObject}
 * @implements {SCNAnimatable}
 * @implements {SCNTechniqueSupport}
 * @see https://developer.apple.com/documentation/scenekit/scncamera
 */

class SCNCamera extends NSObject {
  static get _propTypes() {
    return {
      name: 'string',
      zNear: 'float',
      zFar: 'float',
      yFov: 'float',
      xFov: 'float',
      fov: ['float', null],
      // TODO: implement
      automaticallyAdjustsZRange: 'boolean',
      usesOrthographicProjection: 'boolean',
      orthographicScale: 'float',
      projectionDirection: 'integer',
      categoryBitMask: 'integer',
      focalDistance: 'float',
      focalSize: 'float',
      focalBlurRadius: 'float',
      aperture: 'float',
      motionBlurIntensity: 'float',
      wantsHDR: 'boolean',
      exposureOffset: 'float',
      averageGray: 'float',
      whitePoint: 'float',
      minimumExposure: 'float',
      maximumExposure: 'float',
      wantsExposureAdaptation: 'boolean',
      exposureAdaptationDarkeningSpeedFactor: 'float',
      exposureAdaptationBrighteningSpeedFactor: 'float',
      exposureAdaptationDuration: ['float', null],
      exposureAdaptationHistogramRangeHighProbability: ['float', null],
      exposureAdaptationHistogramRangeLowProbability: ['float', null],
      exposureAdaptationMode: ['integer', null],
      contrast: 'float',
      saturation: 'float',
      //_colorGrading: 'SCNMaterialProperty',
      bloomIntensity: 'float',
      bloomThreshold: 'float',
      bloomBlurRadius: 'float',
      colorFringeIntensity: 'float',
      colorFringeStrength: 'float',
      vignettingIntensity: 'float',
      vignettingPower: 'float',
      //projectionTransform: 'SCNMatrix4'
      bladeCount: ['integer', 'apertureBladeCount'],
      fStop: 'float',
      focalBlurSampleCount: 'integer',
      focusDistance: 'float',
      screenSpaceAmbientOcclusionBias: 'float',
      screenSpaceAmbientOcclusionDepthThreshold: 'float',
      screenSpaceAmbientOcclusionIntensity: 'float',
      screenSpaceAmbientOcclusionNormalThreshold: 'float',
      screenSpaceAmbientOcclusionRadius: 'float',
      sensorSize: ['float', 'sensorHeight'],
      // TODO: check if it is correct
      entityID: ['string', '_entityID'],
      screenSpaceAmbientOcclusionSampleCount: ['integer', null],
      screenSpaceAmbientOcclusionDownSample: ['integer', null],
      dofIntensity: ['float', null],
      fillMode: ['integer', null]
    };
  }
  /**
   * constructor
   * @access public
   * @returns {void}
   */


  constructor() {
    super(); // Managing Camera Attributes

    /**
     * A name associated with the camera object.
     * @type {?string}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1436623-name
     */

    this.name = null; // Adjusting Camera Perspective

    /**
     * The camera's near depth limit. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1436592-znear
     */

    this.zNear = 1.0;
    /**
     * The camera’s far depth limit. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1436596-zfar
     */

    this.zFar = 100.0;
    /**
     * The camera’s field of view, in degrees, on the vertical axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1436598-yfov
     */

    this.yFov = 0;
    /**
     * The camera's field of view, in degrees, on the horizontal axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1436608-xfov
     */

    this.xFov = 0;
    /**
     * A Boolean value that determines whether the camera automatically adjusts its zNear and zFar depth limits.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1436610-automaticallyadjustszrange
     */

    this.automaticallyAdjustsZRange = false; // Managing the Camera Projection

    /**
     * A Boolean value that determines whether the camera uses an orthographic projection.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1436621-usesorthographicprojection
     */

    this.usesOrthographicProjection = false;
    /**
     * Specifies the camera’s magnification factor when using an orthographic projection.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1436612-orthographicscale
     */

    this.orthographicScale = 1.0;
    /**
     *
     * @type {SCNCameraProjectionDirection}
     * @see
     */

    this.projectionDirection = SCNCameraProjectionDirection.horizontal; // Choosing Nodes to Be Visible to the Camera

    /**
     * A mask that defines which categories this camera belongs to.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1436625-categorybitmask
     */

    this.categoryBitMask = -1; // Adding Depth of Field and Blur Effects

    /**
     * The distance from the camera at which objects appear in sharp focus. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1436600-focaldistance
     */

    this.focalDistance = 10.0;
    /**
     * The width of the distance range at which objects appear in sharp focus. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1436604-focalsize
     */

    this.focalSize = 0.0;
    /**
     * The maximum amount of blurring, in pixels, applied to areas outside the camera’s depth of field. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1436606-focalblurradius
     */

    this.focalBlurRadius = 0.0;
    /**
     * A factor that determines the transition between in-focus and out-of-focus areas. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1436594-aperture
     */

    this.aperture = 0.125;
    /**
     * A factor that determines the intensity of motion blur effects. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1644099-motionblurintensity
     */

    this.motionBlurIntensity = 0.0; // Adding High Dynamic Range Effects

    /**
     * A Boolean value that determines whether SceneKit applies High Dynamic Range (HDR) postprocessing effects to a scene.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1644101-wantshdr
     */

    this.wantsHDR = false;
    /**
     * A logarithmic bias that adjusts the results of SceneKit’s tone mapping operation, brightening or darkening the visible scene.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1644105-exposureoffset
     */

    this.exposureOffset = 0;
    /**
     * The luminance level to use as the midpoint of a tone mapping curve.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1644097-averagegray
     */

    this.averageGray = 0.18;
    /**
     * The luminance level to use as the upper end of a tone mapping curve.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1644110-whitepoint
     */

    this.whitePoint = 1.0;
    /**
     * The minimum exposure value to use in tone mapping.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1644103-minimumexposure
     */

    this.minimumExposure = -15.0;
    /**
     * The minimum exposure value to use in tone mapping.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1644120-maximumexposure
     */

    this.maximumExposure = 15.0; // Adding Automatic HDR Exposure Adaptation

    /**
     * A Boolean value that determines whether SceneKit automatically adjusts the exposure level.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1644117-wantsexposureadaptation
     */

    this.wantsExposureAdaptation = false;
    /**
     * The relative duration of automatically animated exposure transitions from dark to bright areas.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1644093-exposureadaptationbrighteningspe
     */

    this.exposureAdaptationBrighteningSpeedFactor = 0.4;
    /**
     * The relative duration of automatically animated exposure transitions from bright to dark areas.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1644094-exposureadaptationdarkeningspeed
     */

    this.exposureAdaptationDarkeningSpeedFactor = 0.6; // Adjusting Rendered Colors

    /**
     * An adjustment factor to apply to the overall visual contrast of the rendered scene.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1644112-contrast
     */

    this.contrast = 0.0;
    /**
     * An adjustment factor to apply to the overall color saturation of the rendered scene.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1644100-saturation
     */

    this.saturation = 1.0;
    this._colorGrading = new SCNMaterialProperty(); // Adding Stylistic Visual Effects

    /**
     * The magnitude of bloom effect to apply to highlights in the rendered scene. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1644104-bloomintensity
     */

    this.bloomIntensity = 0.0;
    /**
     * The brightness threshold at which to apply a bloom effect to highlights in the rendered scene. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1644098-bloomthreshold
     */

    this.bloomThreshold = 0.5;
    /**
     * The radius, in pixels, for the blurring portion of the bloom effect applied to highlights in the rendered scene. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1644096-bloomblurradius
     */

    this.bloomBlurRadius = 4.0;
    /**
     * The blend factor for fading the color fringing effect applied to the rendered scene.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1644108-colorfringeintensity
     */

    this.colorFringeIntensity = 1.0;
    /**
     * The magnitude of color fringing effect to apply to the rendered scene.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1644113-colorfringestrength
     */

    this.colorFringeStrength = 0.0;
    /**
     * The magnitude of vignette (darkening around edges) effect to apply to the rendered scene.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1644106-vignettingintensity
     */

    this.vignettingIntensity = 1.0;
    /**
     * The amount of the rendered scene to darken with a vignette effect.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1644118-vignettingpower
     */

    this.vignettingPower = 0.0; // Instance Properties

    /**
     * 
     * @type {SCNMatrix4}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1690501-projectiontransform
     */

    this.projectionTransform = null;
    /**
     * @access private
     * @type {?string}
     */

    this._entityID = null;
    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/2867484-aperturebladecount
     */

    this.apertureBladeCount = 0; // TODO: check the default value

    /**
     *
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/2867490-fstop
     */

    this.fStop = 0.0; // TODO: check the default value

    /**
     *
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/2867510-fieldofview
     */

    this.fieldOfView = 0.0; // TODO: check the default value

    /**
     *
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/2872999-focalblursamplecount
     */

    this.focalBlurSampleCount = 0; // TODO: check the default value

    /**
     *
     * @type {number}
     * @see
     */

    this.focalLength = 0.0; // TODO:

    /**
     *
     * @type {number}
     * @see
     */

    this.focalDistance = 0.0; // TODO:

    /**
     *
     * @type {number}
     * @see
     */

    this.screenSpaceAmbientOcclusionBias = 0.0; // TODO:

    /**
     *
     * @type {number}
     * @see
     */

    this.screenSpaceAmbientOcclusionDepthThreshold = 0.0; // TODO:

    /**
     *
     * @type {number}
     * @see
     */

    this.screenSpaceAmbientOcclusionIntensity = 0.0; // TODO:

    /**
     *
     * @type {number}
     * @see
     */

    this.screenSpaceAmbientOcclusionNormalThreshold = 0.0; // TODO:

    /**
     *
     * @type {number}
     * @see
     */

    this.screenSpaceAmbientOcclusionRadius = 0.0; // TODO:

    /**
     *
     * @type {number}
     * @see
     */

    this.sensorHeight = 0.0; // TODO:

    /**
     *
     * @type {boolean}
     * @see
     */

    this.wantsDepthOfField = false; // TODO:
  } // Creating a Camera

  /**
   * Creates a camera from the specified Model I/O camera object.
   * @access public
   * @param {MDLCamera} mdlCamera - A Model I/O camera object.
   * @returns {void}
   * @desc The Model I/O framework provides universal support for import, export, description, and processing of several 3D asset file formats and related resources. (For details, see Model I/O.) The MDLCamera class is a generic description of a viewpoint on a scene, supporting a superset of the attributes described by the SCNCamera class.
   * @see https://developer.apple.com/documentation/scenekit/scncamera/1419839-init
   */


  init(mdlCamera) {} // Adjusting Rendered Colors

  /**
   * A texture for applying color grading effects to the entire rendered scene.
   * @type {SCNMaterialProperty}
   * @desc The contents value for this material property must be a 3D color lookup table, or a 2D texture image that represents such a table arranged in a horizontal strip. A lookup table is a cube of color values: the red, green, and blue components of an input color map to the x, y, and z coordinates of a location in that cube, and at that location in the cube is a corresponding output color. You can provide data in this cubic format as a Metal texture with the type3D texture type.The 2D representation of a 3D color cube is an arrangement of slices: for example, a 16 x 16 x 16 color cube becomes a horizontal strip of 16 squares, each 16 x 16 pixels (that is, a 256 x 16 image). Each square contains a gradation of red and green components, and together the 16 squares form a gradation for the blue component. To provide a 2D representation of a color cube, set this material property’s contents value to an image.By using a color table, you can easily create custom color effects that apply to an entire rendered scene:Create a basic color table image such as Figure 1, where the color value for each R, G, and B coordinate in the cube is the corresponding RGB color.Figure 1 Basic color table imageUse an image editor to create the color effect you want using some other image—such as a screenshot of your game. Apply only effects that affect pixel colors without modifying pixel positions. (For example, you can use hue/saturation, color curves, or color matrix filters, but not blur or distort filters.)Figure 2 Creating a color grading effectApply the same color effect you created in step 2 to your basic color table image. You can even perform these steps together: paste the basic color table into your game screenshot, apply an effect to the combined picture, then crop the picture to just the modified color table. Figure 2 shows an example effect.Assign your customized color table image (such as the example in Figure 3) to this property. When rendering, SceneKit looks up the RGB values for each pixel in the rendered scene, and displays the corresponding color values from the color table.Figure 3 Custom color table image for color gradingBasic color table imageCreating a color grading effectCustom color table image for color grading
   * @see https://developer.apple.com/documentation/scenekit/scncamera/1644114-colorgrading
   */


  get colorGrading() {
    return this._colorGrading;
  }
  /**
   * @access private
   * @param {CGRect} viewRect -
   * @returns {void}
   */


  _updateProjectionTransform(viewRect) {
    const m = new SCNMatrix4();
    const left = viewRect.minX;
    const right = viewRect.maxX;
    const top = viewRect.maxY;
    const bottom = viewRect.minY;
    const aspect = viewRect.size.width / viewRect.size.height;

    if (this.usesOrthographicProjection) {
      //this.orthographicScale
      m.m11 = 2 / (right - left);
      m.m12 = 0;
      m.m13 = 0;
      m.m14 = 0;
      m.m21 = 0;
      m.m22 = 2 / (top - bottom);
      m.m23 = 0;
      m.m24 = 0;
      m.m31 = 0;
      m.m32 = 0;
      m.m33 = -2 / (this.zFar - this.zNear);
      m.m34 = 0;
      m.m41 = -(right + left) / (right - left);
      m.m42 = -(top + bottom) / (top - bottom);
      m.m43 = -(this.zFar + this.zNear) / (this.zFar - this.zNear);
      m.m44 = 1;
    } else {
      // perspective
      //this.yFov
      //this.xFov
      //this.automaticallyAdjustsZRange
      let m11 = 1;
      let m22 = 1;

      if (this.yFov <= 0 && this.xFov <= 0) {
        const cot = 1.0 / Math.tan(Math.PI / 6.0);
        m11 = cot / aspect;
        m22 = cot;
      } else if (this.yFov <= 0) {
        const cot = 1.0 / Math.tan(this.xFov * Math.PI / 360.0);
        m11 = cot;
        m22 = cot * aspect;
      } else if (this.xFov <= 0) {
        const cot = 1.0 / Math.tan(this.yFov * Math.PI / 360.0);
        m11 = cot / aspect;
        m22 = cot;
      } else {
        // FIXME: compare xFov to yFov
        const cot = 1.0 / Math.tan(this.yFov * Math.PI / 360.0);
        m11 = cot / aspect;
        m22 = cot;
      }

      m.m11 = m11;
      m.m12 = 0;
      m.m13 = 0;
      m.m14 = 0;
      m.m21 = 0;
      m.m22 = m22;
      m.m23 = 0;
      m.m24 = 0;
      m.m31 = 0;
      m.m32 = 0;
      m.m33 = -(this.zFar + this.zNear) / (this.zFar - this.zNear);
      m.m34 = -1;
      m.m41 = 0;
      m.m42 = 0;
      m.m43 = -2 * this.zFar * this.zNear / (this.zFar - this.zNear);
      m.m44 = 0;
    }

    this.projectionTransform = m;
  }

}

/**
 * Options for which edges of an extruded shape are chamfered, used by the chamferMode property.
 * @typedef {Object} SCNChamferMode
 * @property {number} both - Apply a chamfer to both front and back edges of the extruded shape.
 * @property {number} front - Apply a chamfer to only the front edge of the extruded shape.
 * @property {number} back - Apply a chamfer to only the back edge of the extruded shape.
 * @see https://developer.apple.com/documentation/scenekit/scnchamfermode
 */

const SCNChamferMode = {
  both: 0,
  front: 1,
  back: 2
};

/**
 * A right circular cone or frustum geometry.
 * @access public
 * @extends {SCNGeometry}
 * @see https://developer.apple.com/documentation/scenekit/scncone
 */

class SCNCone extends SCNGeometry {
  // Creating a Cone

  /**
   * Creates a cone geometry with the given top radius, bottom radius, and height.
   * @constructor
   * @access public
   * @param {number} topRadius - The radius of the cone’s top, forming a circle in the x- and z-axis dimensions of its local coordinate space.
   * @param {number} bottomRadius - The radius of the cone’s base, forming a circle in the x- and z-axis dimensions of its local coordinate space.
   * @param {number} height - The height of the cone along the y-axis of its local coordinate space.
   * @desc The cone is centered in its local coordinate system. For example, if you create a cone whose bottom radius is 5.0, top radius is 0.0, and height is 10.0, its apex is at the point {0, 5.0, 0}, and its base lies in the plane whose y-coordinate is -5.0, extending from -5.0 to 5.0 along both the x- and z-axes.Pass zero for topRadius or bottomRadius or parameter to create a cone whose sides taper to a single point, or a different value to create a frustum with a circular top.
   * @see https://developer.apple.com/documentation/scenekit/scncone/1522863-init
   */
  constructor(topRadius = 0.0, bottomRadius = 0.5, height = 1.0) {
    super([], []); // Adjusting a Cone’s Dimensions

    /**
     * The radius of the cone’s circular top. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncone/1524240-topradius
     */

    this.topRadius = topRadius;
    /**
     * The radius of the cone’s circular base. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncone/1523198-bottomradius
     */

    this.bottomRadius = bottomRadius;
    /**
     * The extent of the cylinder along its y-axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncone/1523219-height
     */

    this.height = height; // Adjusting Geometric Detail

    /**
     * The number of subdivisions around the circumference of the cone. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncone/1523942-radialsegmentcount
     */

    this.radialSegmentCount = 48;
    /**
     * The number of subdivisions in the sides of the cone along its y-axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncone/1524113-heightsegmentcount
     */

    this.heightSegmentCount = 1;

    this._createGeometry();

    this.materials.push(new SCNMaterial());
  }

  _createGeometry() {
    const sourceData = [];
    const top = this.height * 0.5;
    const bottom = -this.height * 0.5;
    const sideData = [];
    const bottomData = [];
    const rStep = 2.0 * Math.PI / this.radialSegmentCount;
    const tStep = 1.0 / this.radialSegmentCount;

    for (let i = 0; i <= this.radialSegmentCount; i++) {
      const x = -Math.sin(rStep * i);
      const z = -Math.cos(rStep * i);
      const tvx = x * this.topRadius;
      const tvz = z * this.topRadius;
      const bvx = x * this.bottomRadius;
      const bvz = z * this.bottomRadius; // vertex

      sideData.push(bvx, bottom, bvz);
      bottomData.push(-bvx, bottom, bvz); // normal

      sideData.push(x, 0, z);
      bottomData.push(0, -1, 0); // texcoord

      const tx = tStep * i;
      sideData.push(tx, 1.0);
      const ttx = (1 + Math.cos(i * rStep)) * 0.5;
      const tty = (1 + Math.sin(i * rStep)) * 0.5;
      bottomData.push(ttx, tty); // vertex

      sideData.push(tvx, top, tvz);
      bottomData.push(0, bottom, 0); // normal

      sideData.push(x, 0, z);
      bottomData.push(0, -1, 0); // texcoord

      sideData.push(tx, 0.0);
      bottomData.push(0.5, 0.5);
    }

    sourceData.push(...sideData, ...bottomData);
    const vectorCount = (this.radialSegmentCount + 1) * 4; // TODO: use heightSegmentCount

    const vertexSource = new SCNGeometrySource(sourceData, // data
    SCNGeometrySource.Semantic.vertex, // semantic
    vectorCount, // vectorCount
    true, // floatComponents
    3, // componentsPerVector
    4, // bytesPerComponent
    0, // offset
    32 // sride
    );
    const normalSource = new SCNGeometrySource(sourceData, // data
    SCNGeometrySource.Semantic.normal, // semantic
    vectorCount, // vectorCount
    true, // floatComponents
    3, // componentsPerVector
    4, // bytesPerComponent
    12, // offset
    32 // stride
    );
    const texcoordSource = new SCNGeometrySource(sourceData, // data
    SCNGeometrySource.Semantic.texcoord, // semantic
    vectorCount, // vectorCount
    true, // floatComponents
    2, // componentsPerVector
    4, // bytesPerComponent
    24, // offset
    32 // stride
    );
    const elements = [];
    const indexData0 = [];
    const indexData1 = [];
    const offset1 = (this.radialSegmentCount + 1) * 2;

    for (let i = 0; i < this.radialSegmentCount; i++) {
      const base0 = i * 2;
      indexData0.push(base0, base0 + 2, base0 + 3);
      const base1 = offset1 + base0;
      indexData1.push(base1, base1 + 2, base1 + 3);
    }

    elements.push(new SCNGeometryElement(indexData0, SCNGeometryPrimitiveType.triangles));
    elements.push(new SCNGeometryElement(indexData1, SCNGeometryPrimitiveType.triangles));
    this._geometryElements = elements;
    this._geometrySources = [vertexSource, normalSource, texcoordSource];
    this.boundingBox = {
      min: new SCNVector3(-this.radius, bottom, -this.radius),
      max: new SCNVector3(this.radius, top, this.radius)
    };
  }

}

/**
 * A right circular cylinder geometry.
 * @access public
 * @extends {SCNGeometry}
 * @see https://developer.apple.com/documentation/scenekit/scncylinder
 */

class SCNCylinder extends SCNGeometry {
  static get _propTypes() {
    return {
      $constructor: (propNames, propValues) => {
        const cylinder = new SCNCylinder(propValues.cylinderradius, propValues.cylinderheight);
        cylinder.radialSegmentCount = propValues.cylinderradialSegmentCount;
        cylinder.heightSegmentCount = propValues.cylinderheightSegmentCount;
        cylinder.materials = propValues.materials;
        cylinder.tessellator = propValues.tessellator;
        cylinder.subdivisionLevel = propValues.subdivisionLevel;
        return cylinder;
      },
      name: ['string', null],
      cylinderradius: ['float', null],
      cylinderheight: ['float', null],
      cylinderradialSegmentCount: ['integer', null],
      cylinderheightSegmentCount: ['integer', null],
      cylinderradialSpan: ['float', null],
      cylinderprimitiveType: ['integer', null],
      materials: ['NSArray', null],
      tessellator: ['SCNGeometryTessellator', null],
      subdivisionLevel: ['integer', null],
      subdivisionSettings: ['bytes', null],
      wantsAdaptiveSubdivision: ['boolean', null]
    };
  } // Creating a Cylinder

  /**
   * Creates a cylinder geometry with the specified radius and height.
   * @access public
   * @constructor
   * @param {number} radius - The radius of the cylinder’s circular cross section in the x- and z-axis dimensions of its local coordinate space.
   * @param {number} height - The height of the cylinder along the y-axis of its local coordinate space.
   * @desc The cylinder is centered in its local coordinate system. For example, if you create a cylinder whose radius is 5.0 and height is 10.0, its circular cross section extends from -5.0 to 5.0 along the x- and z-axes, and the y-coordinates of its base and top are -5.0 and 5.0, respectively.
   * @see https://developer.apple.com/documentation/scenekit/scncylinder/1523685-init
   */


  constructor(radius = 0.5, height = 1.0) {
    super([], []); // Adjusting a Cylinder’s Dimensions

    /**
     * The radius of the cylinder’s circular cross section. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncylinder/1522674-radius
     */

    this.radius = radius;
    /**
     * The extent of the cylinder along its y-axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncylinder/1523678-height
     */

    this.height = height; // Adjusting Geometric Detail

    /**
     * The number of subdivisions around the circumference of the cylinder. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncylinder/1524002-radialsegmentcount
     */

    this.radialSegmentCount = 48;
    /**
     * The number of subdivisions in the sides of the cylinder along its y-axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncylinder/1523330-heightsegmentcount
     */

    this.heightSegmentCount = 1;

    this._createGeometry();

    this.materials.push(new SCNMaterial());
  }

  _createGeometry() {
    const sourceData = [];
    const top = this.height * 0.5;
    const bottom = -this.height * 0.5;
    const sideData = [];
    const topData = [];
    const bottomData = [];
    const rStep = 2.0 * Math.PI / this.radialSegmentCount;
    const tStep = 1.0 / this.radialSegmentCount;

    for (let i = 0; i <= this.radialSegmentCount; i++) {
      const x = -Math.sin(rStep * i);
      const z = -Math.cos(rStep * i);
      const vx = x * this.radius;
      const vz = z * this.radius; // vertex

      sideData.push(vx, bottom, vz);
      topData.push(vx, top, vz);
      bottomData.push(-vx, bottom, vz); // normal

      sideData.push(x, 0, z);
      topData.push(0, 1, 0);
      bottomData.push(0, -1, 0); // texcoord

      const tx = tStep * i;
      sideData.push(tx, 1.0);
      const ttx = (1 + Math.cos(i * rStep)) * 0.5;
      const tty = (1 + Math.sin(i * rStep)) * 0.5;
      topData.push(ttx, tty);
      bottomData.push(ttx, tty); // vertex

      sideData.push(vx, top, vz);
      topData.push(0, top, 0);
      bottomData.push(0, bottom, 0); // normal

      sideData.push(x, 0, z);
      topData.push(0, 1, 0);
      bottomData.push(0, -1, 0); // texcoord

      sideData.push(tx, 0.0);
      topData.push(0.5, 0.5);
      bottomData.push(0.5, 0.5);
    }

    sourceData.push(...sideData, ...topData, ...bottomData);
    const vectorCount = (this.radialSegmentCount + 1) * 6;
    const vertexSource = new SCNGeometrySource(sourceData, // data
    SCNGeometrySource.Semantic.vertex, // semantic
    vectorCount, // vectorCount
    true, // floatComponents
    3, // componentsPerVector
    4, // bytesPerComponent
    0, // offset
    32 // sride
    );
    const normalSource = new SCNGeometrySource(sourceData, // data
    SCNGeometrySource.Semantic.normal, // semantic
    vectorCount, // vectorCount
    true, // floatComponents
    3, // componentsPerVector
    4, // bytesPerComponent
    12, // offset
    32 // stride
    );
    const texcoordSource = new SCNGeometrySource(sourceData, // data
    SCNGeometrySource.Semantic.texcoord, // semantic
    vectorCount, // vectorCount
    true, // floatComponents
    2, // componentsPerVector
    4, // bytesPerComponent
    24, // offset
    32 // stride
    );
    const elements = [];
    const indexData0 = [];
    const indexData1 = [];
    const indexData2 = [];
    const offset1 = (this.radialSegmentCount + 1) * 2;
    const offset2 = (this.radialSegmentCount + 1) * 4;

    for (let i = 0; i < this.radialSegmentCount; i++) {
      const base0 = i * 2;
      indexData0.push(base0, base0 + 3, base0 + 1);
      indexData0.push(base0, base0 + 2, base0 + 3);
      const base1 = offset1 + base0;
      indexData1.push(base1, base1 + 2, base1 + 3);
      const base2 = offset2 + base0;
      indexData2.push(base2, base2 + 2, base2 + 3);
    }

    elements.push(new SCNGeometryElement(indexData0, SCNGeometryPrimitiveType.triangles));
    elements.push(new SCNGeometryElement(indexData1, SCNGeometryPrimitiveType.triangles));
    elements.push(new SCNGeometryElement(indexData2, SCNGeometryPrimitiveType.triangles));
    this._geometryElements = elements;
    this._geometrySources = [vertexSource, normalSource, texcoordSource];
    this.boundingBox = {
      min: new SCNVector3(-this.radius, bottom, -this.radius),
      max: new SCNVector3(this.radius, top, this.radius)
    };
  }

  _updateBoundingBoxForSkinner(skinner = null) {
    if (skinner === null) {
      return this.boundingBox;
    }

    return super._updateBoundingBoxForSkinner(skinner);
  }

}

/**
 * Options for drawing overlays with SceneKit content that can aid in debugging, used with the debugOptions property.
 * @access public
 * @see https://developer.apple.com/documentation/scenekit/scndebugoptions
 */

class SCNDebugOptions {
  // Constants

  /**
   * Display the physics shapes for any nodes with attached SCNPhysicsBody objects.
   * @type {SCNDebugOptions}
   * @desc 
   * @see https://developer.apple.com/documentation/scenekit/scndebugoptions/1522896-showphysicsshapes
   */
  get showPhysicsShapes() {
    return this._showPhysicsShapes;
  }
  /**
   * Display the bounding boxes for any nodes with content.
   * @type {SCNDebugOptions}
   * @desc 
   * @see https://developer.apple.com/documentation/scenekit/scndebugoptions/1523258-showboundingboxes
   */


  get showBoundingBoxes() {
    return this._showBoundingBoxes;
  }
  /**
   * Display the locations of each SCNLight object in the scene.
   * @type {SCNDebugOptions}
   * @desc 
   * @see https://developer.apple.com/documentation/scenekit/scndebugoptions/1522606-showlightinfluences
   */


  get showLightInfluences() {
    return this._showLightInfluences;
  }
  /**
   * Display the regions affected by each SCNLight object in the scene.
   * @type {SCNDebugOptions}
   * @desc Only lights whose type is omni or spot have an area of effect; directional and ambient lights affect the entire scene.
   * @see https://developer.apple.com/documentation/scenekit/scndebugoptions/1522894-showlightextents
   */


  get showLightExtents() {
    return this._showLightExtents;
  }
  /**
   * Display the regions affected by each SCNPhysicsField object in the scene.
   * @type {SCNDebugOptions}
   * @desc 
   * @see https://developer.apple.com/documentation/scenekit/scndebugoptions/1523589-showphysicsfields
   */


  get showPhysicsFields() {
    return this._showPhysicsFields;
  }
  /**
   * Display geometries in the scene with wireframe rendering.
   * @type {SCNDebugOptions}
   * @desc When this option is enabled, SceneKit still renders scene geometry with all associated materials, then overlays a wireframe rendering of the same geometry. You can use this option, for example, to debug material rendering issues.
   * @see https://developer.apple.com/documentation/scenekit/scndebugoptions/1523384-showwireframe
   */


  get showWireframe() {
    return this._showWireframe;
  } // Initializers

  /**
   * 
   * @access public
   * @param {number} rawValue - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scndebugoptions/1523870-init
   */


  init(rawValue) {
    // Constants
    this._showPhysicsShapes = null;
    this._showBoundingBoxes = null;
    this._showLightInfluences = null;
    this._showLightExtents = null;
    this._showPhysicsFields = null;
    this._showWireframe = null;
  }

}

/**
 * 
 * @access public
 * @extends {SCNConstraint}
 * @see https://developer.apple.com/documentation/scenekit/scndistanceconstraint
 */

class SCNDistanceConstraint extends SCNConstraint {
  /**
   * constructor
   * @access public
   * @constructor
   */
  constructor() {
    super(); // Instance Properties

    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scndistanceconstraint/2873358-maximumdistance
     */

    this.maximumDistance = 0;
    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scndistanceconstraint/2873385-minimumdistance
     */

    this.minimumDistance = 0;
    /**
     * 
     * @type {?SCNNode}
     * @see https://developer.apple.com/documentation/scenekit/scndistanceconstraint/2873381-target
     */

    this.target = null;
  } // Initializers

  /**
   * 
   * @access public
   * @param {?SCNNode} target - 
   * @returns {SCNDistanceConstraint}
   * @see https://developer.apple.com/documentation/scenekit/scndistanceconstraint/2873360-init
   */


  static constraintWithTarget(target) {
    const constraint = new SCNDistanceConstraint(); // TODO: implement

    return constraint;
  }

}

/**
 * The signature for a block that SceneKit calls to determine the effect of a custom field on an object.
 * @type {function(position: SCNVector3, velocity: SCNVector3, mass: number, charge: number, time: number): SCNVector3}
 * @param {SCNVector3} position - The position of the object affected by the field, in the local coordinate space of the node containing the field.
 * @param {SCNVector3} velocity - The velocity of the object affected by the field, relative to the local coordinate space of the node containing the field.
 * @param {number} mass - The mass of the object affected by the field. (See the mass property for physics bodies and the particleMass property for particle systems.) 
 * @param {number} charge - The electrical charge of the object affected by the field. (See the charge property for physics bodies and the particleCharge property for particle systems.)
 * @param {number} time - The elapsed time, in seconds, since the last simulation step.
 * @returns {SCNVector3} -
 * @desc Your block uses these parameters to compute and return an SCNVector3 force vector, which SceneKit then applies to the object affected by the field.
 * @see https://developer.apple.com/documentation/scenekit/scnfieldforceevaluator
 */

const SCNFieldForceEvaluator = (position, velocity, mass, charge, time) => {};

/**
 * An infinite plane that can optionally display a reflection of the scene above it.
 * @access public
 * @extends {SCNGeometry}
 * @see https://developer.apple.com/documentation/scenekit/scnfloor
 */

class SCNFloor extends SCNGeometry {
  /**
   * constructor
   * @constructor
   * @access public
   */
  constructor() {
    super([], []); // Adding Reflections to a Floor

    /**
     * The intensity of the scene’s reflection on the floor. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnfloor/1524175-reflectivity
     */

    this.reflectivity = 0.25;
    /**
     * The distance from the floor at which scene contents are no longer reflected. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnfloor/1522781-reflectionfalloffend
     */

    this.reflectionFalloffEnd = 0.0;
    /**
     * The distance from the floor at which scene contents are reflected at full intensity. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnfloor/1524237-reflectionfalloffstart
     */

    this.reflectionFalloffStart = 0.0;
    /**
     * The resolution scale factor of the offscreen buffer that SceneKit uses to render reflections.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnfloor/1522809-reflectionresolutionscalefactor
     */

    this.reflectionResolutionScaleFactor = 1.0; // Instance Properties

    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnfloor/2091890-length
     */

    this.length = 2.0;
    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnfloor/1845281-reflectioncategorybitmask
     */

    this.reflectionCategoryBitMask = -1;
    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnfloor/1845280-width
     */

    this.width = 2.0;

    this._createGeometry();

    this.materials.push(new SCNMaterial());
  }

  _createGeometry() {
    const sourceData = [];
    const indexData = [];
    const segmentCount = 10;
    const xStep = this.width / segmentCount;
    const yStep = -this.length / segmentCount;
    const txStep = 1.0 / segmentCount;
    const tyStep = -1.0 / segmentCount;
    let y = this.length * 0.5;
    let ty = 1.0;

    for (let h = 0; h <= segmentCount; h++) {
      let x = -this.width * 0.5;
      let tx = 0.0;

      for (let w = 0; w <= segmentCount; w++) {
        // vector
        sourceData.push(x, y, 0); // normal

        sourceData.push(0, 0, 1); // texcoord

        sourceData.push(tx, ty);
        x += xStep;
        tx += txStep;
      }

      y += yStep;
      ty += tyStep;
    }

    const offset = segmentCount + 1;

    for (let i = 0; i < segmentCount; i++) {
      const base0 = i * 11;

      for (let j = 0; j < segmentCount; j++) {
        const base = base0 + j;
        const i2 = base + offset;
        indexData.push(base, base + 1, i2 + 1);
        indexData.push(base, i2 + 1, i2);
      }
    }

    const vectorCount = (segmentCount + 1) * (segmentCount + 1);
    const vertexSource = new SCNGeometrySource(sourceData, // data
    SCNGeometrySource.Semantic.vertex, // semantic
    vectorCount, // vectorCount
    true, // floatComponents
    3, // componentsPerVector
    4, // bytesPerComponent
    0, // offset
    32 // sride
    );
    const normalSource = new SCNGeometrySource(sourceData, // data
    SCNGeometrySource.Semantic.normal, // semantic
    vectorCount, // vectorCount
    true, // floatComponents
    3, // componentsPerVector
    4, // bytesPerComponent
    12, // offset
    32 // stride
    );
    const texcoordSource = new SCNGeometrySource(sourceData, // data
    SCNGeometrySource.Semantic.texcoord, // semantic
    vectorCount, // vectorCount
    true, // floatComponents
    2, // componentsPerVector
    4, // bytesPerComponent
    24, // offset
    32 // stride
    );
    const element = new SCNGeometryElement(indexData, SCNGeometryPrimitiveType.triangles);
    this._geometryElements = [element];
    this._geometrySources = [vertexSource, normalSource, texcoordSource];
    this.boundingBox = {
      min: new SCNVector3(-this.width * 0.5, -this.length * 0.5, 0),
      max: new SCNVector3(this.width * 0.5, this.length * 0.5, 0)
    };
  }

}

/**
 * 
 * @typedef {Object} SCNTessellationSmoothingMode
 * @property {number} none - 
 * @property {number} phong - 
 * @property {number} pnTriangles - 
 * @see https://developer.apple.com/documentation/scenekit/scntessellationsmoothingmode
 */

const SCNTessellationSmoothingMode = {
  none: 0,
  phong: 1,
  pnTriangles: 2
};

/**
 * 
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/scenekit/scngeometrytessellator
 */

class SCNGeometryTessellator extends NSObject {
  /**
   * constructor
   * @constructor
   * @access public
   */
  constructor() {
    super(); // Instance Properties

    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scngeometrytessellator/2889886-edgetessellationfactor
     */

    this.edgeTessellationFactor = 0;
    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scngeometrytessellator/2889878-insidetessellationfactor
     */

    this.insideTessellationFactor = 0;
    /**
     * 
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scngeometrytessellator/2889881-isadaptive
     */

    this.isAdaptive = false;
    /**
     * 
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scngeometrytessellator/2889879-isscreenspace
     */

    this.isScreenSpace = false;
    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scngeometrytessellator/2889888-maximumedgelength
     */

    this.maximumEdgeLength = 0;
    /**
     * 
     * @type {SCNTessellationSmoothingMode}
     * @see https://developer.apple.com/documentation/scenekit/scngeometrytessellator/2889889-smoothingmode
     */

    this.smoothingMode = SCNTessellationSmoothingMode.none;
    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scngeometrytessellator/2889887-tessellationfactorscale
     */

    this.tessellationFactorScale = 0;
    /**
     * 
     * @type {MTLTessellationPartitionMode}
     * @see https://developer.apple.com/documentation/scenekit/scngeometrytessellator/2889882-tessellationpartitionmode
     */

    this.tessellationPartitionMode = MTLTessellationPartitionMode.none;
  }

}

/**
 * 
 * @typedef {Object} SCNHitTestOption
 * @property {string} backFaceCulling - An option to ignore faces not oriented toward the camera.
 * @property {string} boundingBoxOnly - An option to search for objects by bounding box only.
 * @property {string} categoryBitMask - 
 * @property {string} clipToZRange - An option to search for objects only within the depth range of the current point of view.
 * @property {string} firstFoundOnly - An option to return only the first object found.
 * @property {string} ignoreChildNodes - An option to ignore child nodes when searching.
 * @property {string} ignoreHiddenNodes - An option to ignore hidden nodes when searching.
 * @property {string} rootNode - The root of the node hierarchy to be searched.
 * @property {string} sortResults - An option to sort the results of a hit-test.
 * @see https://developer.apple.com/documentation/scenekit/scnhittestoption
 */

const SCNHitTestOption = {
  backFaceCulling: 'kHitTestBackFaceCulling',
  boundingBoxOnly: 'kHitTestBoundingBoxOnly',
  categoryBitMask: 'kHitTestCategoryBitMask',
  clipToZRange: 'kHitTestClipToZRange',
  firstFoundOnly: 'kHitTestFirstFoundOnly',
  ignoreChildNodes: 'kHitTestIgnoreChildNodes',
  ignoreHiddenNodes: 'kHitTestSkipHiddenNode',
  rootNode: 'kHitTestRootNode',
  sortResults: 'kHitTestSortResults'
};

//import SCNVector3 from './SCNVector3'

/**
 * A constraint that applies inverse kinematics to make a chain of nodes “reach” toward a target point.
 * @access public
 * @extends {SCNConstraint}
 * @see https://developer.apple.com/documentation/scenekit/scnikconstraint
 */

class SCNIKConstraint extends SCNConstraint {
  // Creating an Inverse Kinematics Constraint

  /**
   * Initializes an inverse kinematics constraint whose chain of nodes begins with the specified node.
   * @access public
   * @param {SCNNode} chainRootNode - 
   * @returns {void}
   * @desc The root node is the highest node in the hierarchy moved by the constraint. For example, a robot arm may have two arm segments and a hand connected to a body. The upper arm is a child node of the body, the lower arm is a child node of the upper arm, and the hand is a child node of the lower arm. In this case, the upper arm is the chain root node, because the body should not move to follow the hand.The node you apply the constraint to (using that node’s constraints property) is the end effector of the chain—the lowest node in the hierarchy. When you set the constraint’s targetPosition property, SceneKit attempts to move this node toward the target point by rotating it relative to its parent node (and rotating its parent and ancestor nodes, up the chain ending with the chainRoot node). Continuing the above example, the end effector of the robot arm is its hand.
   * @see https://developer.apple.com/documentation/scenekit/scnikconstraint/1468694-init
   */
  init(chainRootNode) {
    // Adjusting the Constraint’s Limits of Motion
    this._chainRootNode = null; // Applying Inverse Kinematics to the Constrained Node

    /**
     * The desired position for the constrained node, in the scene’s world coordinate space. Animatable.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnikconstraint/1468651-targetposition
     */

    this.targetPosition = null;
  }
  /**
   * Creates an inverse kinematics constraint whose chain of nodes begins with the specified node.
   * @access public
   * @param {SCNNode} chainRootNode - 
   * @returns {SCNIKConstraint} - 
   * @desc The root node is the highest node in the hierarchy moved by the constraint. For example, a robot arm may have two arm segments and a hand connected to a body. The upper arm is a child node of the body, the lower arm is a child node of the upper arm, and the hand is a child node of the lower arm. In this case, the upper arm is the chain root node, because the body should not move to follow the hand.The node you apply the constraint to (using that node’s constraints property) is the end effector of the chain—the lowest node in the hierarchy. When you set the constraint’s targetPosition property, SceneKit attempts to move this node toward the target point by rotating it relative to its parent node (and rotating its parent and ancestor nodes, up the chain ending with the chainRoot node). Continuing the above example, the end effector of the robot arm is its hand.
   * @see https://developer.apple.com/documentation/scenekit/scnikconstraint/1468653-inversekinematicsconstraint
   */


  static inverseKinematicsConstraint(chainRootNode) {
    return null;
  } // Adjusting the Constraint’s Limits of Motion

  /**
   * Returns the rotation limit, in degrees, for the specified node.
   * @access public
   * @param {SCNNode} node - A node affected by the constraint—either the node whose constraints property references the constraint or one of that node’s parent or ancestor nodes, up to the node specified by the constraint’s chainRootNode property.
   * @returns {number} - 
   * @desc When SceneKit evaluates the IK constraint, it checks the target orientations of each node in the chain relative to their initial orientations (as of when the constraint was applied to a node). For each node in the chain, SceneKit limits the rotation (in any direction) between the initial and target orientations to the value returned by this method.The default rotation limit for each joint is 180 degrees in either direction, allowing unconstrained rotation.
   * @see https://developer.apple.com/documentation/scenekit/scnikconstraint/1468681-maxallowedrotationangle
   */


  maxAllowedRotationAngleForJoint(node) {
    return 0;
  }
  /**
   * Sets the rotation limit, in degrees, for the specified node.
   * @access public
   * @param {number} angle - The maximum rotation, in degrees, that SceneKit should apply to the specified node when evaluating the constraint.
   * @param {SCNNode} node - A node affected by the constraint—either the node whose constraints property references the constraint, or one of that node’s parent or ancestor nodes up to the node specified by the constraint’s chainRootNode property.
   * @returns {void}
   * @desc When SceneKit evaluates the IK constraint, it checks the target orientations of each node in the chain relative to their initial orientations (as of when the constraint was applied to a node). For each node in the chain, SceneKit limits the rotation (in any direction) between the initial and target orientations to the angle value specified with this method.The default rotation limit for each joint is 180 degrees in either direction, allowing unconstrained rotation.
   * @see https://developer.apple.com/documentation/scenekit/scnikconstraint/1468649-setmaxallowedrotationangle
   */


  setMaxAllowedRotationAngleForJoint(angle, node) {}
  /**
   * The parent node of the hierarchy affected by the constraint.
   * @type {SCNNode}
   * @desc The root node is the highest node in the hierarchy moved by the constraint. For example, a robot arm may have two arm segments and a hand connected to a body. The upper arm is a child node of the body, the lower arm is a child node of the upper arm, and the hand is a child node of the lower arm. In this case, the upper arm is the chain root node, because the body should not move to follow the hand.
   * @see https://developer.apple.com/documentation/scenekit/scnikconstraint/1468690-chainrootnode
   */


  get chainRootNode() {
    return this._chainRootNode;
  }

}

/**
 * A Core Animation layer that renders a SceneKit scene as its content.
 * @access public
 * @see https://developer.apple.com/documentation/scenekit/scnlayer
 */

class SCNLayer {
  /**
   * constructor
   * @access public
   * @constructor
   */
  constructor() {
    // Specifying a Scene

    /**
     * The scene to be displayed in the layer.
     * @type {?SCNScene}
     * @see https://developer.apple.com/documentation/scenekit/scnlayer/1393188-scene
     */
    this.scene = null;
  }

}

/**
 * An object that defines alternate resolutions for a geometry that SceneKit can automatically substitute to improve rendering performance.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/scenekit/scnlevelofdetail
 */

class SCNLevelOfDetail extends NSObject {
  static get _propTypes() {
    return {
      mode: ['integer', null],
      threshold: ['float', null]
    };
  }
  /**
   * constructor
   * @access public
   * @constructor
   */


  constructor() {
    super(); // Inspecting a Level of Detail

    this._geometry = null;
    this._screenSpaceRadius = 0;
    this._worldSpaceDistance = 0;
  } // Creating a Level of Detail

  /**
   * Creates a level of detail with the specified geometry and threshold pixel radius.
   * @access public
   * @param {?SCNGeometry} geometry - The geometry to render for this level of detail.
   * @param {number} radius - The maximum radius (in pixels) of the geometry’s bounding sphere for this level of detail to appear.
   * @returns {void}
   * @desc When rendering a geometry with associated levels of detail, SceneKit calculates the radius in pixels of the circle covered by a geometry’s bounding sphere, then renders the geometry for the SCNLevelOfDetail object with the largest radius parameter smaller than that circle.If you pass nil for the geometry parameter, SceneKit renders no geometry for the level of detail. Creating a level-of-detail object with no geometry allows you to skip rendering costs entirely for an object when it would appear very far away or very small.
   * @see https://developer.apple.com/documentation/scenekit/scnlevelofdetail/1523557-init
   */


  initScreenSpaceRadius(geometry, radius) {}
  /**
   * Creates a level of detail with the specified geometry and threshold camera distance.
   * @access public
   * @param {?SCNGeometry} geometry - The geometry to render for this level of detail, or nil if SceneKit should render no geometry at this level of detail.
   * @param {number} distance - The minimum distance from the current point of view for this level of detail to appear.
   * @returns {void}
   * @desc When rendering a geometry with associated levels of detail, SceneKit calculates the distance from the current point of view to the geometry’s parent node, then renders the geometry for the SCNLevelOfDetail object with the smallest distance parameter greater than that distance.If you pass nil for the geometry parameter, SceneKit renders no geometry for the level of detail. Creating a level-of-detail object with no geometry allows you to skip rendering costs entirely for an object when it would appear very far away or very small.
   * @see https://developer.apple.com/documentation/scenekit/scnlevelofdetail/1522802-init
   */


  initWorldSpaceDistance(geometry, distance) {} // Inspecting a Level of Detail

  /**
   * The geometry associated with this level of detail.
   * @type {?SCNGeometry}
   * @desc SceneKit renders this geometry instead of the original geometry when the level of detail is appropriate. Generally, levels of detail with larger worldSpaceDistance values or smaller screenSpaceRadius values should contain less complex geometries.If the value of this property is nil, SceneKit renders no geometry at this level of detail.
   * @see https://developer.apple.com/documentation/scenekit/scnlevelofdetail/1522819-geometry
   */


  get geometry() {
    return this._geometry;
  }
  /**
   * The maximum radius (in pixels) of the geometry’s bounding sphere for this level of detail to appear.
   * @type {number}
   * @desc When rendering a geometry with associated levels of detail, SceneKit calculates the radius in pixels of the circle covered by a geometry’s bounding sphere, then renders the geometry for the SCNLevelOfDetail object with the smallest radius parameter larger than that circle.
   * @see https://developer.apple.com/documentation/scenekit/scnlevelofdetail/1523554-screenspaceradius
   */


  get screenSpaceRadius() {
    return this._screenSpaceRadius;
  }
  /**
   * The minimum distance from the current point of view for this level of detail to appear.
   * @type {number}
   * @desc When rendering a geometry with associated levels of detail, SceneKit calculates the distance from the current point of view to the geometry’s parent node, then renders the geometry for the SCNLevelOfDetail object with the largest distance parameter less than that distance.
   * @see https://developer.apple.com/documentation/scenekit/scnlevelofdetail/1524159-worldspacedistance
   */


  get worldSpaceDistance() {
    return this._worldSpaceDistance;
  }

}

const _LightType = {
  IES: 'ies',
  ambient: 'ambient',
  directional: 'directional',
  omni: 'omni',
  probe: 'probe',
  spot: 'spot'
  /**
   * A light source that can be attached to a node to illuminate the scene.
   * @access public
   * @extends {NSObject}
   * @implements {SCNAnimatable}
   * @implements {SCNTechniqueSupport}
   * @see https://developer.apple.com/documentation/scenekit/scnlight
   */

};
class SCNLight extends NSObject {
  static get _propTypes() {
    return {
      type: 'string',
      color: 'plist',
      temperature: 'float',
      intensity: 'float',
      name: 'string',
      attenuationStartDistance: 'float',
      attenuationEndDistance: 'float',
      attenuationFalloffExponent: 'float',
      spotInnerAngle: 'float',
      spotOuterAngle: 'float',
      gobo: ['SCNMaterialProperty', '_gobo'],
      castsShadow: 'boolean',
      shadowRadius: 'float',
      shadowColor: 'plist',
      shadowMapSize: 'CGSize',
      shadowSampleCount: 'integer',
      shadowMode: 'integer',
      shadowBias: 'float',
      orthographicScale: 'float',
      zFar: 'float',
      zNear: 'float',
      lightCategoryBitMask: ['integer', 'categoryBitMask'],
      automaticallyAdjustsShadowProjection: 'boolean',
      forcesBackFaceCasters: 'boolean',
      maximumShadowDistance: 'float',
      sampleDistributedShadowMaps: 'boolean',
      shadowCascadeCount: 'integer',
      shadowCascadeSplittingFactor: 'float',
      entityID: ['string', '_entityID'],
      version: ['float', null],
      spotFallOffExponent: ['float', null],
      usesDeferredShadows: ['boolean', null],
      usesModulatedMode: ['boolean', null],
      shouldBakeIndirectLighting: ['boolean', null],
      shouldBakeDirectLighting: ['boolean', null],
      baked: ['boolean', null],
      goboProjectShadows: ['boolean', null],
      shadowSampleCount2: ['integer', null],
      sphericalHarmonics: ['NSMutableData', null],
      autoShadowProjection: ['boolean', null]
    };
  } // Creating a Light

  /**
   * Creates a light from the specified Model I/O light object.
   * @access public
   * @constructor
   * @param {?MDLLight} [mdlLight = null] - A Model I/O light object.
   * @desc The Model I/O framework provides universal support for import, export, description, and processing of several 3D asset file formats and related resources. (For details, see Model I/O.) The MDLLight class is a generic description of a light source in a scene, supporting a superset of the attributes described by the SCNLight class.
   * @see https://developer.apple.com/documentation/scenekit/scnlight/1419849-init
   */


  constructor(mdlLight = null) {
    super(); // Modifying a Light’s Appearance

    /**
     * A constant identifying the general behavior of the light.
     * @type {SCNLight.LightType}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1522919-type
     */

    this.type = _LightType.omni;
    /**
     * The color of the light. Animatable.
     * @type {SKColor}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1523627-color
     */

    this.color = new SKColor(1, 1, 1, 1);
    /**
     * The color temperature, in degrees Kelvin, of the light source. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1640545-temperature
     */

    this.temperature = 6500.0;
    /**
     * The luminous flux, in lumens, or total brightness of the light. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1640548-intensity
     */

    this.intensity = 1000.0; // Managing Light Attributes

    /**
     * A name associated with the light.
     * @type {?string}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1522839-name
     */

    this.name = null; // Managing Light Attenuation

    /**
     * The distance from the light at which its intensity begins to diminish. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1524223-attenuationstartdistance
     */

    this.attenuationStartDistance = 0;
    /**
     * The distance from the light at which its intensity is completely diminished. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1524140-attenuationenddistance
     */

    this.attenuationEndDistance = 0;
    /**
     * The transition curve for the light’s intensity between its attenuation start and end distances. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1522879-attenuationfalloffexponent
     */

    this.attenuationFalloffExponent = 0; // Managing Spotlight Extent

    /**
     * The angle, in degrees, of the area fully lit by a spotlight. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1522797-spotinnerangle
     */

    this.spotInnerAngle = 0;
    /**
     * The angle, in degrees, of the area partially lit by a spotlight. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1523382-spotouterangle
     */

    this.spotOuterAngle = 45.0;
    this._gobo = new SCNMaterialProperty(); // Managing Shadows Cast by the Light

    /**
     * A Boolean value that determines whether the light casts shadows.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1523816-castsshadow
     */

    this.castsShadow = false;
    /**
     * A number that specifies the amount of blurring around the edges of shadows cast by the light. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1523724-shadowradius
     */

    this.shadowRadius = 3.0;
    /**
     * The color of shadows cast by the light. Animatable.
     * @type {SKColor}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1522864-shadowcolor
     */

    this.shadowColor = new SKColor(0, 0, 0, 1);
    /**
     * The size of the shadow map image that SceneKit renders when creating shadows.
     * @type {CGSize}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1524127-shadowmapsize
     */

    this.shadowMapSize = new CGSize(0, 0);
    /**
     * The number of samples from the shadow map that SceneKit uses to render each pixel.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1523300-shadowsamplecount
     */

    this.shadowSampleCount = 0;
    /**
     * The mode SceneKit uses to render shadows.
     * @type {SCNShadowMode}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1522847-shadowmode
     */

    this.shadowMode = null;
    /**
     * The amount of correction to apply to the shadow to prevent rendering artifacts.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1522849-shadowbias
     */

    this.shadowBias = 1.0;
    /**
     * The orthographic scale SceneKit uses when rendering the shadow map for a directional light.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1523951-orthographicscale
     */

    this.orthographicScale = 1.0;
    /**
     * The maximum distance between the light and a visible surface for casting shadows.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1522845-zfar
     */

    this.zFar = 100.0;
    /**
     * The minimum distance between the light and a visible surface for casting shadows. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1522630-znear
     */

    this.zNear = 1.0; // Choosing Nodes to be Illuminated by the Light

    /**
     * A mask that defines which categories this light belongs to.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1523669-categorybitmask
     */

    this.categoryBitMask = -1; // Managing Photometric Lights

    /**
     * The URL for a file that contains photometry data describing the intended appearance of the light.
     * @type {?string}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1640546-iesprofileurl
     */

    this.iesProfileURL = null;
    /**
     * @access private
     * @type {?string}
     */

    this._entityID = null;
    this._context = null;
    this._shadowFrameBuffer = null;
    this._shadowDepthBuffer = null;
    this._shadowDepthTexture = null;
    this._projectionTransform = null;
    /**
     * 
     * @type {boolean}
     * @see
     */

    this.automaticallyAdjustsShadowProjection = false;
    /**
     * 
     * @type {boolean}
     * @see
     */

    this.forcesBackFaceCasters = false;
    /**
     *
     * @type {number}
     * @see
     */

    this.maximumShadowDistance = 0.0;
    /**
     *
     * @type {boolean}
     * @see
     */

    this.sampleDistributedShadowMaps = false;
    /**
     *
     * @type {number}
     * @see
     */

    this.shadowCascadeCount = 1;
    /**
     *
     * @type {number}
     * @see
     */

    this.shadowCascadeSplittingFactor = 1.0;
  } // Managing Light Attributes

  /**
   * Returns the value of a lighting attribute.
   * @deprecated
   * @access public
   * @param {string} key - A constant specifying a lighting attribute. See Lighting Attribute Keys for available keys and their possible values.
   * @returns {?Object} - 
   * @desc A light’s type property determines its set of available attributes.You can also get the values of lighting attributes using Key-value coding. The key path for each lighting attribute is listed in Lighting Attribute Keys.
   * @see https://developer.apple.com/documentation/scenekit/scnlight/1523345-attribute
   */


  attributeForKey(key) {
    return null;
  }
  /**
   * Sets the value for a lighting attribute.
   * @deprecated
   * @access public
   * @param {?Object} attribute - The value for the lighting attribute.
   * @param {string} key - A constant specifying a lighting attribute. See Lighting Attribute Keys for available keys and their possible values.
   * @returns {void}
   * @desc A light’s type property determines its set of available attributes.You can also set or animate changes to the values of lighting attributes using Key-value coding. The key path for each lighting attribute is listed in Lighting Attribute Keys.
   * @see https://developer.apple.com/documentation/scenekit/scnlight/1523148-setattribute
   */


  setAttributeForKey(attribute, key) {} // Managing Spotlight Extent

  /**
   * An image or other visual content affecting the shape and color of a light’s illuminated area.
   * @type {?SCNMaterialProperty}
   * @desc In photographic and stage lighting terminology, a gobo (also known as a flag or cookie) is a stencil, gel, or other object placed just in front of a light source, shaping or coloring the beam of light.You alter the appearance of a spotlight by changing the contents property of the object permanently assigned to this property. As with other material properties, you can use a color or image, or a Core Animation layer containing animated content, as a lighting gobo.This property applies only to lights whose type property is spot.
   * @see https://developer.apple.com/documentation/scenekit/scnlight/1523524-gobo
   */


  get gobo() {
    return this._gobo;
  } // Structures

  /**
   * @type {Object} LightType
   * @property {string} IES A light source whose shape, direction, and intensity of illumination is determined by a photometric profile.
   * @property {string} ambient A light that illuminates all objects in the scene from all directions.
   * @property {string} directional A light source with a uniform direction and constant intensity.
   * @property {string} omni An omnidirectional light, also known as a point light. 
   * @property {string} probe A sample of the environment around a point in a scene to be used in environment-based lighting.
   * @property {string} spot A light source that illuminates a cone-shaped area.
   * @see https://developer.apple.com/documentation/scenekit/scnlight.lighttype
   */


  static get LightType() {
    return _LightType;
  }

  get _shadowMapWidth() {
    if (this.shadowMapSize.width > 0) {
      return this.shadowMapSize.width;
    } // FIXME: adjust shadowMapSize


    return 2048;
  }

  get _shadowMapHeight() {
    if (this.shadowMapSize.height > 0) {
      return this.shadowMapSize.height;
    } // FIXME: adjust shadowMapSize


    return 2048;
  }

  _getDepthBufferForContext(context) {
    if (this._shadowFrameBuffer && this._context === context) {
      return this._shadowFrameBuffer;
    }

    this._context = context;
    const gl = context;
    const width = this._shadowMapWidth;
    const height = this._shadowMapHeight;
    this._shadowFrameBuffer = gl.createFramebuffer();
    this._shadowDepthBuffer = gl.createRenderbuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._shadowFrameBuffer);
    gl.bindRenderbuffer(gl.RENDERBUFFER, this._shadowDepthBuffer);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this._shadowDepthBuffer);
    this._shadowDepthTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, this._shadowDepthTexture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.generateMipmap(gl.TEXTURE_2D);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._shadowDepthTexture, 0);
    gl.drawBuffers([gl.COLOR_ATTACHMENT0]);
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    return this._shadowFrameBuffer;
  }
  /**
   * @access private
   * @param {CGRect} viewRect -
   * @returns {void}
   */


  _updateProjectionTransform() {
    const m = new SCNMatrix4();
    const right = this._shadowMapWidth;
    const bottom = this._shadowMapHeight;
    const aspect = this._shadowMapWidth / this._shadowMapHeight;

    if (this.type === _LightType.directional) {
      // orthographic
      // FIXME: use orthographicScale, adjust x/y scale automatically
      //m.m11 = 2 / (right - left)
      m.m11 = 0.1; //m.m11 = 2 / (right - left)

      m.m12 = 0;
      m.m13 = 0;
      m.m14 = 0;
      m.m21 = 0; //m.m22 = 2 / (top - bottom)

      m.m22 = 0.1;
      m.m23 = 0;
      m.m24 = 0;
      m.m31 = 0;
      m.m32 = 0;
      m.m33 = -2 / (this.zFar - this.zNear); //m.m33 = -1 / (this.zFar - this.zNear)

      m.m34 = 0;
      m.m41 = 0;
      m.m42 = 0;
      m.m43 = -(this.zFar + this.zNear) / (this.zFar - this.zNear); //m.m43 = -this.zFar / (this.zFar - this.zNear)

      m.m44 = 1;
    } else {
      // perspective
      let m11 = 1;
      let m22 = 1;

      if (this.yFov <= 0 && this.xFov <= 0) {
        const cot = 1.0 / Math.tan(Math.PI / 6.0);
        m11 = cot / aspect;
        m22 = cot;
      } else if (this.yFov <= 0) {
        const cot = 1.0 / Math.tan(this.xFov * Math.PI / 360.0);
        m11 = cot;
        m22 = cot * aspect;
      } else if (this.xFov <= 0) {
        const cot = 1.0 / Math.tan(this.yFov * Math.PI / 360.0);
        m11 = cot / aspect;
        m22 = cot;
      } else {
        // FIXME: compare xFov to yFov
        const cot = 1.0 / Math.tan(this.yFov * Math.PI / 360.0);
        m11 = cot / aspect;
        m22 = cot;
      }

      m.m11 = m11;
      m.m12 = 0;
      m.m13 = 0;
      m.m14 = 0;
      m.m21 = 0;
      m.m22 = m22;
      m.m23 = 0;
      m.m24 = 0;
      m.m31 = 0;
      m.m32 = 0;
      m.m33 = -(this.zFar + this.zNear) / (this.zFar - this.zNear);
      m.m34 = -1;
      m.m41 = 0;
      m.m42 = 0;
      m.m43 = -2 * this.zFar * this.zNear / (this.zFar - this.zNear);
      m.m44 = 0;
    }

    this._projectionTransform = m;
  }

}

/**
 * A constraint that orients a node to always point toward a specified other node. 
 * @access public
 * @extends {SCNConstraint}
 * @see https://developer.apple.com/documentation/scenekit/scnlookatconstraint
 */

class SCNLookAtConstraint extends SCNConstraint {
  /**
   * constructor
   * @access public
   * @constructor
   */
  constructor() {
    super(); // Modifying a Constraint

    /**
     * A Boolean value that specifies whether constrained nodes are allowed to rotate.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnlookatconstraint/1468675-isgimballockenabled
     */

    this.isGimbalLockEnabled = false;
    /**
     * The node toward which constrained nodes will point after being reoriented.
     * @type {?SCNNode}
     * @see https://developer.apple.com/documentation/scenekit/scnlookatconstraint/1468677-target
     */

    this.target = null; // Instance Properties

    /**
     * 
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnlookatconstraint/2867570-localfront
     */

    this.localFront = null;
    /**
     * 
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnlookatconstraint/2867488-targetoffset
     */

    this.targetOffset = null;
    /**
     * 
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnlookatconstraint/2902240-worldup
     */

    this.worldUp = null;
  } // Creating a Look-At Constraint

  /**
   * Creates a look-at constraint for a specified target node.
   * @access public
   * @param {?SCNNode} target - The node that constrained nodes will be reoriented to point toward.
   * @returns {void}
   * @desc To attach constraints to an SCNNode object, use its constraints property.
   * @see https://developer.apple.com/documentation/scenekit/scnlookatconstraint/1468683-init
   */


  static constraintWithTarget(target) {
    const constraint = new SCNLookAtConstraint(); // TODO: implement

    return constraint;
  }

}

/**
 * Returns a Boolean value that indicates whether the corresponding elements of two matrices are equal.
 * @access public
 * @param {SCNMatrix4} a - 
 * @param {SCNMatrix4} b - 
 * @returns {boolean} - 
 * @desc This function performs a numeric (not bitwise) comparison of each pair of elements.
 * @see https://developer.apple.com/documentation/scenekit/1409665-scnmatrix4equaltomatrix4
 */

const SCNMatrix4EqualToMatrix4 = function (a, b) {
  if (!_InstanceOf(a, SCNMatrix4)) {
    return false;
  }

  return a.equalTo(b);
};

//import GLKMatrix4 from '../undefined/GLKMatrix4'

/**
 * Returns a SceneKit matrix corresponding to a GLKit matrix.
 * @access public
 * @param {GLKMatrix4} mat - A GLKit matrix.
 * @returns {SCNMatrix4} - 
 * @see https://developer.apple.com/documentation/scenekit/1409699-scnmatrix4fromglkmatrix4
 */

const SCNMatrix4FromGLKMatrix4 = function (mat) {
  return null;
};

/**
 * 
 * @access public
 * @param {number[][]} m - 
 * @returns {SCNMatrix4} - 
 * @see https://developer.apple.com/documentation/scenekit/1522632-scnmatrix4frommat4
 */

const SCNMatrix4FromMat4 = function (m) {
  return null;
};

/**
 * Returns the inverse of the specified matrix.
 * @access public
 * @param {SCNMatrix4} m - 
 * @returns {SCNMatrix4} - 
 * @see https://developer.apple.com/documentation/scenekit/1409682-scnmatrix4invert
 */

const SCNMatrix4Invert = function (m) {
  return m.invert();
};

const _identity = new SCNMatrix4();
/**
 * Returns a Boolean value that indicates whether the specified matrix is equal to the identity matrix.
 * @access public
 * @param {SCNMatrix4} m - 
 * @returns {boolean} - 
 * @see https://developer.apple.com/documentation/scenekit/1409715-scnmatrix4isidentity
 */


const SCNMatrix4IsIdentity = function (m) {
  return m.isIdentity();
};

/**
 * Returns a matrix describing a rotation transformation.
 * @access public
 * @param {number} angle - The amount of rotation, in radians, measured counterclockwise around the rotation axis.
 * @param {number} x - The x-component of the rotation axis.
 * @param {number} y - The y-component of the rotation axis.
 * @param {number} z - The z-component of the rotation axis.
 * @returns {SCNMatrix4} - 
 * @see https://developer.apple.com/documentation/scenekit/1409686-scnmatrix4makerotation
 */

const SCNMatrix4MakeRotation = function (angle, x, y, z) {
  const c = Math.cos(angle);
  const s = Math.sin(angle);
  const v = new SCNVector3(x, y, z);
  const m = new SCNMatrix4();
  const nx = v.x;
  const ny = v.y;
  const nz = v.z;
  m.m11 = nx * nx * (1.0 - c) + c;
  m.m12 = nx * ny * (1.0 - c) - nz * s;
  m.m13 = nx * nz * (1.0 - c) + ny * s;
  m.m14 = 0.0;
  m.m21 = ny * nx * (1.0 - c) + nz * s;
  m.m22 = ny * ny * (1.0 - c) + c;
  m.m23 = ny * nz * (1.0 - c) - nx * s;
  m.m24 = 0.0;
  m.m31 = nz * nx * (1.0 - c) - ny * s;
  m.m32 = nz * ny * (1.0 - c) + nx * s;
  m.m33 = nz * nz * (1.0 - c) + c;
  m.m34 = 0.0;
  m.m41 = 0.0;
  m.m42 = 0.0;
  m.m43 = 0.0;
  m.m44 = 1.0;
  return m;
};

/**
 * Returns a matrix describing a scale transformation.
 * @access public
 * @param {number} sx - The scale factor in the x-axis direction.
 * @param {number} sy - The scale factor in the y-axis direction.
 * @param {number} sz - The scale factor in the z-axis direction.
 * @returns {SCNMatrix4} - 
 * @see https://developer.apple.com/documentation/scenekit/1409681-scnmatrix4makescale
 */

const SCNMatrix4MakeScale = function (sx, sy, sz) {
  return new SCNMatrix4(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1);
};

/**
 * Returns the product of two matrices.
 * @access public
 * @param {SCNMatrix4} a - 
 * @param {SCNMatrix4} b - 
 * @returns {SCNMatrix4} - 
 * @desc Matrix multiplication is not commutative. As a transformation, the result of multiplying a matrix A by a matrix B is the transformation represented by B followed by the transformation represented by A.
 * @see https://developer.apple.com/documentation/scenekit/1409697-scnmatrix4mult
 */

const SCNMatrix4Mult = function (a, b) {
  return a.mult(b);
};

/**
 * Returns a new matrix created by concatenating the specified matrix with a rotation transformation.
 * @access public
 * @param {SCNMatrix4} m - 
 * @param {number} angle - The amount of rotation, in radians, measured counterclockwise around the rotation axis.
 * @param {number} x - The x-component of the rotation axis.
 * @param {number} y - The y-component of the rotation axis.
 * @param {number} z - The z-component of the rotation axis.
 * @returns {SCNMatrix4} - 
 * @desc The resulting transformation consists of the specified rotation followed by the transformation represented by the mat parameter.
 * @see https://developer.apple.com/documentation/scenekit/1409659-scnmatrix4rotate
 */

const SCNMatrix4Rotate = function (m, angle, x, y, z) {
  return m.rotation(x, y, z, angle);
};

/**
 * Returns a new matrix created by concatenating the specified matrix with a scale transformation.
 * @access public
 * @param {SCNMatrix4} m - 
 * @param {number} sx - 
 * @param {number} sy - 
 * @param {number} sz - 
 * @returns {SCNMatrix4} - 
 * @desc The resulting transformation consists of the specified scale followed by the transformation represented by the mat parameter.
 * @see https://developer.apple.com/documentation/scenekit/1409653-scnmatrix4scale
 */

const SCNMatrix4Scale = function (m, sx, sy, sz) {
  return m.mult(SCNMatrix4MakeScale(sx, sy, sz));
};

//import SCNMatrix4 from './SCNMatrix4'

/**
 * Returns a GLKit matrix corresponding to a SceneKit matrix.
 * @access public
 * @param {SCNMatrix4} mat - A SceneKit matrix.
 * @returns {GLKMatrix4} - 
 * @see https://developer.apple.com/documentation/scenekit/1409703-scnmatrix4toglkmatrix4
 */

const SCNMatrix4ToGLKMatrix4 = function (mat) {
  return null;
};

/**
 * @access public
 * @type {function}
 * @param {SCNMatrix4} m - 
 * @returns {number[][]} - 
 * @see https://developer.apple.com/documentation/scenekit/1523928-scnmatrix4tomat4
 */

const SCNMatrix4ToMat4 = function (m) {
  return null;
};

/**
 * Returns a new matrix created by concatenating the specified matrix with a translation transformation.
 * @access public
 * @param {SCNMatrix4} m - 
 * @param {number} tx - 
 * @param {number} ty - 
 * @param {number} tz - 
 * @returns {SCNMatrix4} - 
 * @desc The resulting transformation consists of the specified translation followed by the transformation represented by the mat parameter.
 * @see https://developer.apple.com/documentation/scenekit/1409717-scnmatrix4translate
 */

const SCNMatrix4Translate = function (m, tx, ty, tz) {
  return m.mult(SCNMatrix4MakeTranslation(tx, ty, tz));
};

/**
 * The interpolation formulas for blending between target geometries.
 * @typedef {Object} SCNMorpherCalculationMode
 * @property {number} normalized - Target weights must be in the range between 0.0 and 1.0, and the contribution of the base geometry to the morphed surface is related to the sum of target weights. This is the default mode.
 * @property {number} additive - Target weights may take on any value, and weighted contributions for each target are added to the base geometry,
 * @see https://developer.apple.com/documentation/scenekit/scnmorphercalculationmode
 */

const SCNMorpherCalculationMode = {
  normalized: 0,
  additive: 1
};

const _weightsPattern = new RegExp(/^weights\[(\d+)\]$/);
/**
 * An object that manages smooth transitions between a node's base geometry and one or more target geometries.
 * @access public
 * @extends {NSObject}
 * @implements {SCNAnimatable}
 * @see https://developer.apple.com/documentation/scenekit/scnmorpher
 */


class SCNMorpher extends NSObject {
  static get _propTypes() {
    return {
      calculationMode: 'integer',
      shouldMorphNormals: ['boolean', null],
      targets: 'NSArray',
      useSparseTargets: ['boolean', null],
      weights: ['NSArray', '_weights']
    };
  }
  /**
   * constructor
   * @access public
   * @constructor
   */


  constructor() {
    super(); // Specifying Morph Targets

    /**
     * The array of target geometries to morph between.
     * @type {SCNGeometry[]}
     * @see https://developer.apple.com/documentation/scenekit/scnmorpher/1523572-targets
     */

    this.targets = [];
    /**
     * @type {number[]}
     */

    this._weights = []; // Changing Interpolation Mode

    /**
     * The interpolation formula for blending between target geometries.
     * @type {SCNMorpherCalculationMode}
     * @see https://developer.apple.com/documentation/scenekit/scnmorpher/1523754-calculationmode
     */

    this.calculationMode = SCNMorpherCalculationMode.normalized;
  } // Blending between Morph Targets

  /**
   * Returns the weight value for the specified target index.
   * @access public
   * @param {number} targetIndex - The index of a geometry in the morpher’s targets array.
   * @returns {number} - 
   * @desc Target geometries and their weights determine the current form of the surface produced by the morpher. For example, if a morpher has one target whose weight is 0.5, the form of the resulting surface will be halfway between those of the base geometry and the target geometry.
   * @see https://developer.apple.com/documentation/scenekit/scnmorpher/1522940-weight
   */


  weightForTargetAt(targetIndex) {
    return this._weights[targetIndex];
  }
  /**
   * Specifies a weight value at a specified target index.
   * @access public
   * @param {number} weight - A number specifying the contribution of the target geometry to the blended surface, generally between 0.0 and 1.0.
   * @param {number} targetIndex - The index of a geometry in the morpher’s targets array.
   * @returns {void}
   * @desc Target geometries and their weights determine the current form of the surface produced by the morpher. For example, if a morpher has one target whose weight is 0.5, the form of the resulting surface will be halfway between those of the base geometry and the target geometry.You can also animate weights implicitly or explicitly using the keypath weights[index], where index corresponds to the targetIndex parameter of this method.
   * @see https://developer.apple.com/documentation/scenekit/scnmorpher/1522886-setweight
   */


  setWeightForTargetAt(weight, targetIndex) {
    this._weights[targetIndex] = weight;
  }

  setValueForKey(value, key) {
    //console.log(`SCNMorpher.setValueForKey: ${key}: ${value}`)
    const weightsMatch = key.match(_weightsPattern);

    if (weightsMatch !== null) {
      if (weightsMatch.length > 1) {
        const index = weightsMatch[1]; //if(typeof this._weights[index] !== 'undefined'){

        this._weights[index] = value; //}
      }

      return;
    }

    super.setValueForKey(value, key);
  }
  /*
  setValueForKeyPath(value, keyPath) {
    console.log(`SCNMorpher.setValueForKeyPath: ${keyPath}: ${value}`)
    const paths = keyPath.split('.')
    const key = paths.shift()
    const restPath = paths.join('.')
     const weightsMatch = key.match(_weightsPattern)
    if(weightsMatch !== null){
      if(weightsMatch.length > 1){
        //const targetIndex = this.targets.findIndex((target) => target.name === restPath)
        //if(targetIndex >= 0){
        //  this._weights[targetIndex] = value
        //}
        const index = weightsMatch[1]
        if(typeof this._weights[index] !== 'undefined'){
          console.log(`_weights[ ${index} ] = ${value}`)
          this._weights[index] = value
        }
      }
    }else{
      super.setValueForKeyPath(value, keyPath)
    }
  }
  */

  /**
   * @access private
   * @param {SCNNode} node -
   * @returns {void}
   */


  _morph(node) {
    //console.log(`SCNMorpher._morph ${node.name}`)
    const p = node.presentation;

    if (node.geometry === null || p === null || p.geometry === null) {
      // data is not ready
      return;
    }

    const pg = p.geometry;
    const pm = p.morpher;
    const totalWeightForSemantic = new Map(); // reset presentation geometry

    node.geometry.geometrySources.forEach(source => {
      // FIXME: copy more than 1 source.
      const pSource = pg.getGeometrySourcesForSemantic(source.semantic)[0];
      pSource.fill(0); //newData.set(source.semantic, Array(source._data.length).fill(0))

      totalWeightForSemantic.set(source.semantic, 0.0);
    }); // should I morph elements?
    //node.geometry.geometryElements().forEach((element) => {
    //})

    const targetCount = pm.targets.length; //console.log(`targetCount: ${targetCount}`)

    for (let i = 0; i < targetCount; i++) {
      const target = pm.targets[i];
      const weight = pm._weights[i];

      if (weight === 0 || typeof weight === 'undefined') {
        continue;
      } //console.log(`morph ${target.name} weight ${weight}`)


      target.geometrySources.forEach(source => {
        const pSource = pg.getGeometrySourcesForSemantic(source.semantic)[0];

        if (typeof pSource === 'undefined') {
          return;
        }

        totalWeightForSemantic.set(source.semantic, totalWeightForSemantic.get(source.semantic) + weight); // FIXME: don't access private properties

        let srcIndex = source._dataOffset / source._bytesPerComponent;
        const srcStride = source._dataStride / source._bytesPerComponent;
        let dstIndex = pSource._dataOffset / pSource._bytesPerComponent;
        const dstStride = pSource._dataStride / pSource._bytesPerComponent;
        const componentCount = source._componentsPerVector;
        const vectorCount = source._vectorCount;

        if (typeof source._firstIndex === 'undefined') {
          // find first and last vector index
          let index = srcIndex;

          for (let j = 0; j < vectorCount; j++) {
            if (typeof source._data[index] !== 'undefined' && source._data[index] !== 0) {
              source._firstIndex = j;
              break;
            }

            index += srcStride;
          }

          index = srcIndex + srcStride * (vectorCount - 1);

          for (let j = vectorCount - 1; j >= 0; j--) {
            if (typeof source._data[index] !== 'undefined' && source._data[index] !== 0) {
              source._lastIndex = j;
              break;
            }

            index -= srcStride;
          }
        }

        srcIndex += srcStride * source._firstIndex;
        dstIndex += dstStride * source._firstIndex;

        for (let j = source._firstIndex; j <= source._lastIndex; j++) {
          for (let k = 0; k < componentCount; k++) {
            const s = source._data[srcIndex + k];

            if (s) {
              pSource._data[dstIndex + k] += s * weight;
            }
          }

          srcIndex += srcStride;
          dstIndex += dstStride;
        }
      });
    } //console.log(`node.geometry.geometrySources.length: ${node.geometry.geometrySources.length}`)


    node.geometry.geometrySources.forEach(source => {
      //console.log(`add baseGeometry`)
      // FIXME: copy more than 1 source.
      const pSource = pg.getGeometrySourcesForSemantic(source.semantic)[0];
      let srcIndex = source._dataOffset / source._bytesPerComponent;
      const srcStride = source._dataStride / source._bytesPerComponent;
      let dstIndex = pSource._dataOffset / pSource._bytesPerComponent;
      const dstStride = pSource._dataStride / pSource._bytesPerComponent;
      const componentCount = source._componentsPerVector;
      const vectorCount = source._vectorCount;

      if (p.calculationMode === SCNMorpherCalculationMode.normalized) {
        const weight = 1.0 - totalWeightForSemantic.get(source.semantic); // FIXME: don't access private properties

        for (let i = 0; i < vectorCount; i++) {
          for (let j = 0; j < componentCount; j++) {
            pSource._data[dstIndex + j] += source._data[srcIndex + j] * weight;
          }

          srcIndex += srcStride;
          dstIndex += dstStride;
        }
      } else {
        //console.log(`additive: vector: ${vectorCount}, component: ${componentCount}`)
        // calculationMode: additive
        // FIXME: don't access private properties
        for (let i = 0; i < vectorCount; i++) {
          for (let j = 0; j < componentCount; j++) {
            pSource._data[dstIndex + j] += source._data[srcIndex + j];
          }

          srcIndex += srcStride;
          dstIndex += dstStride;
        }
      }
    }); // TODO: needs to update normal vector?
    //console.log(`_morph done`)
  }
  /**
   * @access private
   * @returns {SCNMorpher} -
   */


  _copy() {
    const morpher = new SCNMorpher();
    morpher.targets = this.targets.slice(0);
    morpher._weights = this._weights.slice(0);
    morpher.calculationMode = this.calculationMode;
    return morpher;
  }

}

//import SCNRenderer from './SCNRenderer'

/**
 * Methods you can implement to use your own custom Metal or OpenGL drawing code to render content for a node. 
 * @interface
 * @see https://developer.apple.com/documentation/scenekit/scnnoderendererdelegate
 */

class SCNNodeRendererDelegate {
  /**
   * constructor
   * @access public
   * @constructor
   */
  //construtor() {
  //}
  // Customizing the Rendering of a Node

  /**
   * Tells the delegate to perform rendering for a node.
   * @access public
   * @param {SCNNode} node - The node to render.
   * @param {SCNRenderer} renderer - The SceneKit object (such as an SCNView instance) responsible for rendering the scene. 
   * @param {Map<string, Object>} _arguments - 
   * @returns {void}
   * @desc Implement this method to perform custom rendering for a node. You should only execute Metal or OpenGL drawing commands (and any setup required to perform them) in this method—the results of modifying SceneKit objects in this method are undefined.To render using Metal, use the renderer parameter to retrieve the scene renderer’s currentRenderCommandEncoder object and encode your own drawing commands. If you need to reference other Metal state, see the properties listed in SCNSceneRenderer.To render using OpenGL, simply call the relevant OpenGL drawing commands—SceneKit automatically makes its OpenGL context the current context before calling this method. If you need to reference the OpenGL context being rendered into, examine the context property of the renderer parameter.You must draw using the appropriate graphics technology for the view currently being rendered. Use the renderingAPI property of the renderer object to determine whether Metal or OpenGL is in use. 
   * @see https://developer.apple.com/documentation/scenekit/scnnoderendererdelegate/1407993-rendernode
   */
  renderNode(node, renderer, _arguments) {}

}

/**
 * Options for the initial direction of each emitted particle, used by the birthDirection property.
 * @typedef {Object} SCNParticleBirthDirection
 * @property {number} constant - The emitting direction is the same for all particles.
 * @property {number} surfaceNormal - The emitting direction for each particle is along the surface normal vector at the point where the particle is emitted.
 * @property {number} random - SceneKit randomizes the emitting direction for each particle.
 * @see https://developer.apple.com/documentation/scenekit/scnparticlebirthdirection
 */

const SCNParticleBirthDirection = {
  constant: 0,
  surfaceNormal: 1,
  random: 2
};

/**
 * Options for the initial location of each emitted particle, used by the birthLocation property.
 * @typedef {Object} SCNParticleBirthLocation
 * @property {number} surface - New particles can be created at any location on the surface of the emitter shape.
 * @property {number} volume - New particles can be created at any location within the volume of the emitter shape.
 * @property {number} vertex - New particles can be created at only at the locations of the vertices in the emitter shape.
 * @see https://developer.apple.com/documentation/scenekit/scnparticlebirthlocation
 */

const SCNParticleBirthLocation = {
  surface: 0,
  volume: 1,
  vertex: 2
};

/**
 * Options for combining source and destination pixel colors when compositing particles during rendering, used by the blendMode property.
 * @typedef {Object} SCNParticleBlendMode
 * @property {number} additive - The source and destination colors are added together.
 * @property {number} subtract - The source color is subtracted from the destination color.
 * @property {number} multiply - The source color is multiplied by the destination color.
 * @property {number} screen - The source color is added to the destination color times the inverted source color.
 * @property {number} alpha - The source and destination colors are blended by multiplying the source alpha value.
 * @property {number} replace - The source color replaces the destination color.
 * @see https://developer.apple.com/documentation/scenekit/scnparticleblendmode
 */

const SCNParticleBlendMode = {
  additive: 0,
  subtract: 1,
  multiply: 2,
  screen: 3,
  alpha: 4,
  replace: 5
};

/**
 * Significant events in the life spans of simulate particles, used by the handle(_:forProperties:handler:) method.
 * @typedef {Object} SCNParticleEvent
 * @property {number} birth - Occurs when new particles spawn.
 * @property {number} death - Occurs when particles reach the end of their life span.
 * @property {number} collision - Occurs when particles collide with scene geometry.
 * @see https://developer.apple.com/documentation/scenekit/scnparticleevent
 */

const SCNParticleEvent = {
  birth: 0,
  death: 1,
  collision: 2
};

/**
 * The signature for blocks called by SceneKit in response to significant events during particle simulation, used by the handle(_:forProperties:handler:) method.
 * @type {function(data: UnsafeMutablePointer<UnsafeMutableRawPointer>, dataStride: UnsafeMutablePointer<Int>, indices: ?UnsafeMutablePointer<UInt32>, count: number): void}
 * @param {UnsafeMutablePointer<UnsafeMutableRawPointer>} data - An array of floating-point values containing stripes of property data for the system’s particles. The width and format of each data stripe depend on the properties you specify when calling the handle(_:forProperties:handler:) method.
 * @param {UnsafeMutablePointer<Int>} dataStride - An array identifying the offset, in bytes, of each property’s value in the data stripe for each particle. The order of offsets in this array corresponds to the order of the properties array you specify when calling the handle(_:forProperties:handler:) method.
 * @param {?UnsafeMutablePointer<UInt32>} indices - An array in which each element is an index that identifies (in the data array) the data stripe for each particle affected by the event that caused SceneKit to call the handler block.When SceneKit calls your handler block for the birth event, you need not use this parameter—at that time, the affected particles are indexed from 0 to the count parameter’s value.
 * @param {number} count - The number of particles affected by the current event.
 * @returns {void}
 * @desc Use this block to change properties of individual particles when they are spawned, when they collide with scene geometry, or when they die (that is, reach the end of their life spans and are removed from the scene). The following example illustrates setting up a handler block for particle collision events:[system handleEvent:SCNParticleEventCollision
      forProperties:@[SCNParticlePropertyAngle,
                      SCNParticlePropertyRotationAxis,
                      SCNParticlePropertyContactNormal]
          withBlock:^(void **data, size_t *dataStride, uint32_t *indices, NSInteger count) {
              // For each particle affected by the collision event,
              // calculate pointers in the data to each property's value.
              for (NSInteger i = 0; i < count; ++i) {
                  // SCNParticlePropertyAngle (float)
                  float *angle = (float *)((char *)data[0] + dataStride[0] * indices[i]);
                  // angle[0] is the particle's rotation angle in radians.
 
                  // SCNParticlePropertyRotationAxis (float3)
                  float *axis = (float *)((char *)data[1] + dataStride[1] * indices[i]);
                  // axis[0..2] are the xyz components of the particle's rotation axis.
 
                  // SCNParticlePropertyContactNormal (float3)
                  float *norm = (float *)((char *)data[2] + dataStride[2] * indices[i]);
                  // norm[0..2] are the xyz components of the contact normal vector.
 
                  // Now, use the norm vector to rotate the particle's axis/angle (not shown).
              }
          }];

 * @see https://developer.apple.com/documentation/scenekit/scnparticleeventblock
 */

const SCNParticleEventBlock = (data, dataStride, indices, count) => {};

/**
 * Options for animating each particle with a sequence of images, used by the imageSequenceAnimationMode property.
 * @typedef {Object} SCNParticleImageSequenceAnimationMode
 * @property {number} repeat - The animation loops after displaying all of its images.
 * @property {number} clamp - The animation stops after displaying all of its images.
 * @property {number} autoReverse - After the animation displays all of its images, it plays again in reverse order.
 * @see https://developer.apple.com/documentation/scenekit/scnparticleimagesequenceanimationmode
 */

const SCNParticleImageSequenceAnimationMode = {
  repeat: 0,
  clamp: 1,
  autoReverse: 2
};

/**
 * Options for the input value of the property controller’s animation, used by the inputMode property.
 * @typedef {Object} SCNParticleInputMode
 * @property {number} overLife - The controller’s effect on a particle property is a function of the time since the particle’s birth.
 * @property {number} overDistance - The controller’s effect on a particle property is a function of the particle’s distance from the position of a specified node.
 * @property {number} overOtherProperty - The controller’s effect on a particle property is a function of another of the particle’s properties.
 * @see https://developer.apple.com/documentation/scenekit/scnparticleinputmode
 */

const SCNParticleInputMode = {
  overLife: 0,
  overDistance: 1,
  overOtherProperty: 2
};

/**
 * The signature for blocks called by SceneKit to modify particle properties on each frame of simulation, used by the addModifier(forProperties:at:modifier:) method.
 * @type {function(data: UnsafeMutablePointer<UnsafeMutableRawPointer>, dataStride: UnsafeMutablePointer<Int>, start: number, end: number, deltaTime: number): void}
 * @param {UnsafeMutablePointer<UnsafeMutableRawPointer>} data - An array of floating-point values containing stripes of property data for the system’s particles. The width and format of each data stripe depend on the properties you specify when calling the addModifier(forProperties:at:modifier:) method.
 * @param {UnsafeMutablePointer<Int>} dataStride - An array identifying the offset, in bytes, of each property’s value in the data stripe for each particle. The order of offsets in this array corresponds to the order of the properties array you specify when calling the addModifier(forProperties:at:modifier:) method.
 * @param {number} start - The index of the first particle’s data stripe in the data array.
 * @param {number} end - The index of the last particle’s data stripe in the data array.
 * @param {number} deltaTime - The elapsed time, in seconds, since the last frame of simulation.
 * @returns {void}
 * @desc Use this block to change properties of individual particles on each frame of simulation.ImportantRunning your own code to update particle properties every frame can have a severe impact on rendering performance. If the behavior over time that you want for your particle system can be described more declaratively, use the propertyControllers property and SCNParticlePropertyController class instead. If you need to change particle properties only at certain times (rather than continuously), add a handler block for an event using the handle(_:forProperties:handler:) method.The following example illustrates setting up a modifier block that alters particle’s position and velocity:[system addModifierForProperties:@[SCNParticlePropertyPosition,
                                   SCNParticlePropertyVelocity]
                         atStage:SCNParticleModifierStagePostDynamics
                       withBlock:^(void **data, size_t *dataStride, NSInteger start, NSInteger end, float deltaTime) {
                           // For each particle to be processed,
                           // calculate pointers in the data to each property's value:
                           for (NSInteger i = start; i < end; ++i) {
                               // SCNParticlePropertyPosition (float3)
                               float *pos = (float *)((char *)data[0] + dataStride[0] * i);
                               // pos[0..2] are the xyz components of the particle's position.
 
                               // SCNParticlePropertyVelocity (float3)
                               float *vel = (float *)((char *)data[1] + dataStride[1] * i);
                               // vel[0..2] are the xyz components of the particle's position.
 
                               // Now, compute a new position and velocity (not shown).
                           }
                       }];

 * @see https://developer.apple.com/documentation/scenekit/scnparticlemodifierblock
 */

const SCNParticleModifierBlock = (data, dataStride, start, end, deltaTime) => {};

/**
 * Stages of SceneKit’s particle simulation process into which you can insert modifier blocks, used by the addModifier(forProperties:at:modifier:) method.
 * @typedef {Object} SCNParticleModifierStage
 * @property {number} preDynamics - The stage before SceneKit simulates the motion of particles.
 * @property {number} postDynamics - The stage after SceneKit simulates the motion of particles.
 * @property {number} preCollision - The stage before SceneKit simulates the results of collisions between particles and scene geometry.
 * @property {number} postCollision - The stage after SceneKit simulates the results of collisions between particles and scene geometry.
 * @see https://developer.apple.com/documentation/scenekit/scnparticlemodifierstage
 */

const SCNParticleModifierStage = {
  preDynamics: 0,
  postDynamics: 1,
  preCollision: 2,
  postCollision: 3
};

/**
 * Options for restricting the orientation of particles, used by the orientationMode property.
 * @typedef {Object} SCNParticleOrientationMode
 * @property {number} billboardScreenAligned - Each particle’s orientation is always fixed with respect to the point of view camera.
 * @property {number} billboardViewAligned - Each particle always faces the point of view camera (but may rotate about an axis parallel to the view direction).
 * @property {number} free - Particle orientations are not restricted; they may rotate freely in all axes.
 * @property {number} billboardYAligned - The y-axis direction of each particle is always fixed with respect to the point of view camera.
 * @see https://developer.apple.com/documentation/scenekit/scnparticleorientationmode
 */

const SCNParticleOrientationMode = {
  billboardScreenAligned: 0,
  billboardViewAligned: 1,
  free: 2,
  billboardYAligned: 3
};

/**
 * An animation for a single property of the individual particles rendered by a particle system.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/scenekit/scnparticlepropertycontroller
 */

class SCNParticlePropertyController extends NSObject {
  static get _propTypes() {
    return {
      animation: ['NSMutableDictionary', (obj, anim) => {
        obj.animation = SCNNode._loadAnimationData(anim, null);
      }],
      inputMode: 'integer',
      inputBias: 'float',
      inputScale: 'float',
      inputOrigin: 'SCNNode' // inputProperty: 'string' ?

    };
  } // Creating a Property Controller

  /**
   * Creates a particle property controller with the specified Core Animation animation.
   * @access public
   * @constructor
   * @param {CAAnimation} animation - A Core Animation object specifying the behavior of the property animation. Must not be nil.You can use different CAAnimation subclasses to animate effects in different ways. For example, a CABasicAnimation instance transitions a property from one value to another, and a CAKeyframeAnimation instance transitions a property through a series of values. You use properties of the animation object to define its timing curve, repeat mode, and other options.SceneKit ignores the keyPath, duration, and repeatCount properties of this animation object.
   * @desc To set up a particle property animation:Create a CAAnimation object defining how a property of each particle in the system changes over time.Create a particle property controller using the init(animation:) method.Attach the property controller to a particle system using the propertyControllers dictionary, choosing a key listed in Particle Property Keys to identify the particle property it animates.For example, the following code sets up a controller to animate particle sizes:// 1. Create and configure an animation object.
  CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];
  animation.values = @[ @0.1, @1.0, @3.0, @0.5 ];
  // 2. Create a property controller from the animation object.
  SCNParticlePropertyController *controller =
    [SCNParticlePropertyController controllerWithAnimation:animation];
  // 3. Assign the controller to a particle system, associating it with a particle property.
  particleSystem.propertyControllers = @{ SCNParticlePropertySize: controller };
  // 1. Create and configure an animation object.
  CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];
  animation.values = @[ @0.1, @1.0, @3.0, @0.5 ];
  // 2. Create a property controller from the animation object.
  SCNParticlePropertyController *controller =
    [SCNParticlePropertyController controllerWithAnimation:animation];
  // 3. Assign the controller to a particle system, associating it with a particle property.
  particleSystem.propertyControllers = @{ SCNParticlePropertySize: controller };
    * @see https://developer.apple.com/documentation/scenekit/scnparticlepropertycontroller/1523579-init
   */


  constructor(animation) {
    super(); // Managing the Controller’s Animation

    /**
     * The Core Animation object defining the behavior of the property animation.
     * @type {CAAnimation}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlepropertycontroller/1523707-animation
     */

    this.animation = animation;
    /**
     * The mode that determines input values for the property controller’s animation.
     * @type {SCNParticleInputMode}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlepropertycontroller/1522852-inputmode
     */

    this.inputMode = null;
    /**
     * An offset to add to the input value of the controller’s animation.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlepropertycontroller/1523994-inputbias
     */

    this.inputBias = 0;
    /**
     * A factor for multiplying the input value of the controller’s animation. 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlepropertycontroller/1522903-inputscale
     */

    this.inputScale = 0;
    /**
     * A node whose distance to each particle provides input values for the controller’s animation.
     * @type {?SCNNode}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlepropertycontroller/1522895-inputorigin
     */

    this.inputOrigin = null;
    /**
     * A particle property that provides input values for this property controller’s animation.
     * @type {?SCNParticleSystem.ParticleProperty}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlepropertycontroller/1522973-inputproperty
     */

    this.inputProperty = null;
  }

}

/**
 * Options for the rendering order of particles, used by the sortingMode property.
 * @typedef {Object} SCNParticleSortingMode
 * @property {number} none - Particles are not sorted; they may be rendered in any order.
 * @property {number} projectedDepth - Particles farther from the point of view (as measured using projected depth) are rendered before closer particles.
 * @property {number} distance - Particles farther from the point of view (as measured using distance from the camera in scene space) are rendered before closer particles.
 * @property {number} oldestFirst - Particles emitted earlier are rendered before particles emitted more recently.
 * @property {number} youngestFirst - Particles emitted more recently are rendered before particles emitted earlier.
 * @see https://developer.apple.com/documentation/scenekit/scnparticlesortingmode
 */

const SCNParticleSortingMode = {
  none: 0,
  projectedDepth: 1,
  distance: 2,
  oldestFirst: 3,
  youngestFirst: 4
};

const _ParticleProperty = {
  angle: 'Angle',
  angularVelocity: 'AngularVelocity',
  bounce: 'Bounce',
  charge: 'Charge',
  color: 'Color',
  contactNormal: 'ContactNormal',
  contactPoint: 'ContactPoint',
  frame: 'Frame',
  frameRate: 'FrameRate',
  friction: 'Friction',
  life: 'Life',
  opacity: 'Opacity',
  position: 'Position',
  rotationAxis: 'RotationAxis',
  size: 'Size',
  velocity: 'Velocity'
};

class _Particle extends NSObject {
  /**
   * @access public
   * @constructor
   */
  constructor() {
    super();
    /**
     * @type {SCNVector3}
     */

    this.position = null;
    /**
     * @type {SCNVector3}
     */

    this.axis = null;
    /**
     * @type {number}
     */

    this.angle = 0;
    /**
     * @type {number}
     */

    this.size = 1;
    this.baseSize = 1;
    /**
     * @type {SKColor}
     */

    this.color = null;
    /**
     * @type {SCNVector3}
     */

    this.velocity = null;
    /**
     * @type {number}
     */

    this.angularVelocity = 0;
    /**
     * @type {SCNVector3}
     */

    this.acceleration = null;
    /**
     * @type {number}
     */

    this.birthTime = 0;
    /**
     * @type {number}
     */

    this.lifeSpan = 0;
    /**
     * @type {number}
     */

    this.imageFrameRate = 0;
    /**
     * @type {number}
     */

    this.initialImageFrame = 0;
    /**
     * @type {number}
     */

    this.texLeft = 0;
    /**
     * @type {number}
     */

    this.texRight = 0;
    /**
     * @type {number}
     */

    this.texTop = 0;
    /**
     * @type {number}
     */

    this.texBottom = 0;
    this._maxParticleIndex = 0;
  }
  /**
   * @access public
   * @returns {number[]} -
   */


  floatArray() {
    const baseArray = [...this.position.floatArray(), ...this.velocity.floatArray(), ...this.axis.floatArray(), this.angle, ...this.color.floatArray(), this.size];
    return [...baseArray, -1.0, -1.0, this.texLeft, this.texTop, ...baseArray, 1.0, -1.0, this.texRight, this.texTop, ...baseArray, -1.0, 1.0, this.texLeft, this.texBottom, ...baseArray, 1.0, 1.0, this.texRight, this.texBottom];
  }

  valueForKeyPath(keyPath) {
    if (keyPath === 'size') {
      return this.baseSize;
    }

    return super.valueForKeyPath(keyPath);
  }
  /**
   * @access public
   * @returns {Float32Array} -
   */


  float32Array() {
    return new Float32Array(this.floatArray());
  }

}
/**
 * Manages the animation and rendering of a system of small image sprites, or particles, using a high-level simulation whose general behavior you specify.
 * @access public
 * @extends {NSObject}
 * @implements {SCNAnimatable}
 * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem
 */


class SCNParticleSystem extends NSObject {
  static get _propTypes() {
    return {
      emissionDuration: 'float',
      emissionDurationVariation: 'float',
      idleDuration: 'float',
      idleDurationVariation: 'float',
      loops: 'boolean',
      warmupDuration: 'float',
      birthRate: ['float', '_birthRate'],
      birthRateVariation: 'float',
      emitterShape: 'SCNGeometry',
      birthLocation: 'integer',
      birthDirection: 'integer',
      emittingDirection: 'SCNVector3',
      spreadingAngle: 'float',
      particleAngle: 'float',
      particleAngleVariation: 'float',
      particleVelocity: 'float',
      particleVelocityVariation: 'float',
      particleAngularVelocity: 'float',
      particleAngularVelocityVariation: 'float',
      particleLifeSpan: 'float',
      particleLifeSpanVariation: 'float',
      particleSize: 'float',
      particleSizeVariation: 'float',
      particleColor: 'plist',
      particleColorVariation: 'SCNVector4',
      particleImage: ['NSMutableDictionary', (obj, dict, key, coder) => {
        let path = '';

        if (typeof dict.path !== 'undefined') {
          path = dict.path;
        } else if (typeof dict.URL !== 'undefined') {
          path = dict.URL;
        }

        obj._loadParticleImage(path, coder._directoryPath);
      }],
      fresnelExponent: 'float',
      stretchFactor: 'float',
      imageSequenceRowCount: 'integer',
      imageSequenceColumnCount: 'integer',
      imageSequenceInitialFrame: 'float',
      imageSequenceInitialFrameVariation: 'float',
      imageSequenceFrameRate: 'float',
      imageSequenceFrameRateVariation: 'float',
      imageSequenceAnimationMode: 'integer',
      affectedByGravity: ['boolean', 'isAffectedByGravity'],
      affectedByPhysicsFields: ['boolean', 'isAffectedByPhysicsFields'],
      colliderNodes: 'NSArray',
      particleDiesOnCollision: 'boolean',
      acceleration: 'SCNVector3',
      dampingFactor: 'float',
      particleMass: 'float',
      particleMassVariation: 'float',
      particleCharge: 'float',
      particleChargeVariation: 'float',
      particleBounce: 'float',
      particleBounceVariation: 'float',
      particleFriction: 'float',
      particleFrictionVariation: 'float',
      systemSpawnedOnCollision: 'SCNParticleSystem',
      systemSpawnedOnDying: 'SCNParticleSystem',
      systemSpawnedOnLiving: 'SCNParticleSystem',
      blendMode: 'integer',
      orientationMode: 'integer',
      sortingMode: 'integer',
      lightingEnabled: ['boolean', 'isLightingEnabled'],
      blackPassEnabled: ['boolean', 'isBlackPassEnabled'],
      isLocal: 'boolean',
      speedFactor: 'float',
      propertyControllers: ['NSMutableDictionary', (obj, dict) => {
        Object.keys(_ParticleProperty).forEach(key => {
          const d = dict[_ParticleProperty[key]];

          if (typeof d !== 'undefined') {
            d.animation.keyPath = key; //console.error(`SCNParticleSystem key: ${key}, ${d.animation.className}`)

            if (key === 'size') {
              d.animation._isMultiplicative = true;
            }
          }
        });
        obj.propertyControllers = dict;
      }],
      seed: ['integer', null],
      softParticlesEnabled: ['boolean', null],
      fixedTimeStep: ['float', null],
      renderingMode: ['integer', null],
      physicsCollisionsEnabled: ['boolean', null],
      orientationDirection: ['SCNVector3', null],
      particleIntensity: ['float', null],
      particleIntensityVariation: ['float', null]
    };
  }
  /**
   * constructor
   * @access public
   * @constructor
   * @param {string} name - The name of a particle system file in the app’s bundle resources directory, with or without the .scnp extension.
   * @param {?string} directory - The subdirectory path in the app’s bundle resources directory.
   */


  constructor(name = null, directory = null) {
    super(); // Managing Particle Emission Timing

    /**
     * The duration, in seconds, over which the system spawns new particles. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523998-emissionduration
     */

    this.emissionDuration = 1.0;
    /**
     * The range, in seconds, of randomized emission duration values. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523842-emissiondurationvariation
     */

    this.emissionDurationVariation = 0.0;
    /**
     * The duration, in seconds, of periods when the system emits no particles. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522998-idleduration
     */

    this.idleDuration = 0.0;
    /**
     * The range, in seconds, of randomized idle duration values. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523018-idledurationvariation
     */

    this.idleDurationVariation = 0.0;
    /**
     * A Boolean value that determines whether the system repeats its emission and idle periods.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522618-loops
     */

    this.loops = true;
    /**
     * The duration, in seconds, for which particles are spawned before the system is first rendered. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522597-warmupduration
     */

    this.warmupDuration = 0.0;
    /**
     * The number of particles spawned during each emission period. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522857-birthrate
     */

    this._birthRate = 0.0;
    /**
     * The range of randomized particle birth rate values. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1524147-birthratevariation
     */

    this.birthRateVariation = 0.0; // Managing Particle Emission Locations

    /**
     * The shape of the region of space where the system spawns new particles.
     * @type {?SCNGeometry}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522737-emittershape
     */

    this.emitterShape = null;
    /**
     * The possible locations for newly spawned particles, relative to the emitter shape.
     * @type {SCNParticleBirthLocation}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522899-birthlocation
     */

    this.birthLocation = SCNParticleBirthLocation.surface;
    /**
     * The possible initial directions for newly spawned particles, relative to the emitter shape.
     * @type {SCNParticleBirthDirection}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523361-birthdirection
     */

    this.birthDirection = SCNParticleBirthDirection.constant;
    /**
     * The initial direction for newly spawned particles. Animatable.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523600-emittingdirection
     */

    this.emittingDirection = new SCNVector3(0, 1, 0);
    /**
     * The range, in degrees, of randomized initial particle directions. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522862-spreadingangle
     */

    this.spreadingAngle = 0.0; // Managing Particle Motion

    /**
     * The rotation angle, in degrees, of newly spawned particles. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523896-particleangle
     */

    this.particleAngle = 0.0;
    /**
     * The range, in degrees of randomized initial particle angles. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522828-particleanglevariation
     */

    this.particleAngleVariation = 0.0;
    /**
     * The initial speed, in units per second, for newly spawned particles. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523946-particlevelocity
     */

    this.particleVelocity = 0.0;
    /**
     * The range, in units per second, of randomized initial particle speeds. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1524157-particlevelocityvariation
     */

    this.particleVelocityVariation = 0.0;
    /**
     * The initial spin rate, in degrees per second, of newly spawned particles. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522757-particleangularvelocity
     */

    this.particleAngularVelocity = 0.0;
    /**
     * The range, in degrees per second, of randomized initial angular velocities for particles. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523590-particleangularvelocityvariation
     */

    this.particleAngularVelocityVariation = 0.0;
    /**
     * The duration, in seconds, for which each particle is rendered before being removed from the scene. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523575-particlelifespan
     */

    this.particleLifeSpan = 1.0;
    /**
     * The range, in seconds, of randomized particle life spans. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523567-particlelifespanvariation
     */

    this.particleLifeSpanVariation = 0.0; // Specifying Particle Appearance

    /**
     * The rendered size, in units of the scene’s world coordinate space, of the particle image. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523508-particlesize
     */

    this.particleSize = 1.0;
    /**
     * The range of randomized particle sizes. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522716-particlesizevariation
     */

    this.particleSizeVariation = 0.0;
    /**
     * The color of newly spawned particles. Animatable.
     * @type {SKColor}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523248-particlecolor
     */

    this.particleColor = SKColor.white;
    /**
     * The ranges of randomized particle color components. Animatable.
     * @type {SCNVector4}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523639-particlecolorvariation
     */

    this.particleColorVariation = new SCNVector4(0, 0, 0, 0);
    /**
     * The texture image SceneKit uses to render each particle.
     * @type {?Object}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1524153-particleimage
     */

    this.particleImage = null;
    /**
     * The reflectivity exponent SceneKit uses when rendering the particle’s image as a cube map. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523317-fresnelexponent
     */

    this.fresnelExponent = 0.0;
    /**
     * A multiplier for stretching particle images along their direction of motion. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523338-stretchfactor
     */

    this.stretchFactor = 0.0; // Animating Particle Images

    /**
     * The number of rows for treating the particle image as a grid of animation frames.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523340-imagesequencerowcount
     */

    this.imageSequenceRowCount = 1;
    /**
     * The number of columns for treating the particle image as a grid of animation frames.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523462-imagesequencecolumncount
     */

    this.imageSequenceColumnCount = 1;
    /**
     * The index of the first frame in a particle image animation. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523511-imagesequenceinitialframe
     */

    this.imageSequenceInitialFrame = 0.0;
    /**
     * The range of randomized initial frames for particle image animation. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523821-imagesequenceinitialframevariati
     */

    this.imageSequenceInitialFrameVariation = 0.0;
    /**
     * The rate, in frames per second, of particle image animation. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1524075-imagesequenceframerate
     */

    this.imageSequenceFrameRate = 0.0;
    /**
     * The range, in frames per second, of randomized frame rates for particle image animation. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523667-imagesequenceframeratevariation
     */

    this.imageSequenceFrameRateVariation = 0.0;
    /**
     * The animation mode for particle image animation.
     * @type {SCNParticleImageSequenceAnimationMode}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522816-imagesequenceanimationmode
     */

    this.imageSequenceAnimationMode = SCNParticleImageSequenceAnimationMode.repeat; // Simulating Physics for Particles

    /**
     * A Boolean value that determines whether gravity, as defined by the scene’s physics simulation, affects the motion of particles.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523452-isaffectedbygravity
     */

    this.isAffectedByGravity = false;
    /**
     * A Boolean value that determines whether physics fields in the scene affect the motion of particles.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523353-isaffectedbyphysicsfields
     */

    this.isAffectedByPhysicsFields = false;
    /**
     * The nodes whose geometry the system’s particles can collide with.
     * @type {?SCNNode[]}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523516-collidernodes
     */

    this.colliderNodes = null;
    /**
     * A Boolean value that determines whether particles are removed from the scene upon colliding with another object.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523357-particlediesoncollision
     */

    this.particleDiesOnCollision = false;
    /**
     * The constant acceleration vector, in units per second per second, applied to all particles in the system. Animatable.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522766-acceleration
     */

    this.acceleration = new SCNVector3(0, 0, 0);
    /**
     * A factor that slows particles relative to their velocity. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522931-dampingfactor
     */

    this.dampingFactor = 0.0;
    /**
     * The mass, in kilograms, of each particle in the system. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522607-particlemass
     */

    this.particleMass = 1.0;
    /**
     * The range, in kilograms, of randomized particle masses. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523408-particlemassvariation
     */

    this.particleMassVariation = 0.0;
    /**
     * The electric charge, in coulombs, of each particle in the system. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523156-particlecharge
     */

    this.particleCharge = 0.0;
    /**
     * The range, in coulombs, of randomized particle charges. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523377-particlechargevariation
     */

    this.particleChargeVariation = 0.0;
    /**
     * The restitution coefficient of each particle in the system. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522637-particlebounce
     */

    this.particleBounce = 0.7;
    /**
     * The range of randomized restitution coefficients for particles. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522662-particlebouncevariation
     */

    this.particleBounceVariation = 0.0;
    /**
     * The friction coefficient of each particle in the system. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1524010-particlefriction
     */

    this.particleFriction = 1.0;
    /**
     * The range of randomized friction coefficients for particles. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522868-particlefrictionvariation
     */

    this.particleFrictionVariation = 0.0; // Spawning Additional Particle Systems

    /**
     * Another particle system to be added to the scene when a particle collides with scene geometry.
     * @type {?SCNParticleSystem}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1524068-systemspawnedoncollision
     */

    this.systemSpawnedOnCollision = null;
    /**
     * Another particle system to be added to the scene when a particle dies.
     * @type {?SCNParticleSystem}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1524091-systemspawnedondying
     */

    this.systemSpawnedOnDying = null;
    /**
     * Another particle system to be added to the scene for each living particle in the system.
     * @type {?SCNParticleSystem}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522751-systemspawnedonliving
     */

    this.systemSpawnedOnLiving = null; // Managing Particle Rendering

    /**
     * The blending mode for compositing particle images into the rendered scene.
     * @type {SCNParticleBlendMode}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523728-blendmode
     */

    this.blendMode = SCNParticleBlendMode.additive;
    /**
     * The mode defining whether and how particles may rotate.
     * @type {SCNParticleOrientationMode}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523131-orientationmode
     */

    this.orientationMode = SCNParticleOrientationMode.billboardScreenAligned;
    /**
     * The mode defining the order in which SceneKit renders the system’s particles.
     * @type {SCNParticleSortingMode}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522795-sortingmode
     */

    this.sortingMode = SCNParticleSortingMode.none;
    /**
     * A Boolean value that determines whether SceneKit applies lighting to particle images when rendering.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522794-islightingenabled
     */

    this.isLightingEnabled = false;
    /**
     * A Boolean value that determines whether SceneKit renders particles in black before rendering the particle image.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523901-isblackpassenabled
     */

    this.isBlackPassEnabled = false; // Controlling Particle Simulation

    /**
     * A Boolean value that specifies whether the particle simulation runs in the local coordinate space of the node containing it.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522855-islocal
     */

    this.isLocal = false;
    /**
     * A multiplier for the speed at which SceneKit runs the particle simulation. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522988-speedfactor
     */

    this.speedFactor = 1.0; // Modifying Particles Over Time

    /**
     * A dictionary that optionally associates particle properties with objects that animate a property’s value for each particle.
     * @type {?Map<SCNParticleSystem.ParticleProperty, SCNParticlePropertyController>}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522775-propertycontrollers
     */

    this.propertyControllers = null;
    this._program = null;
    this._vertexArray = null;
    this._vertexBuffer = null;
    this._indexBuffer = null;
    this._particles = [];
    this._glIndexSize = null;
    this._particleTexture = null;
    this._finished = false;
    this._startTime = null;
    this._prevTime = 0;
    this._nextBirthTime = 0;
    this._emissionEndTime = 0;
    this._idleEndTime = 0;
    this._numImages = null;
    this._imageWidth = null;
    this._imageHeight = null;
    this.__presentation = null; ///////////////////
    // SCNAnimatable //
    ///////////////////

    /**
     * @access private
     * @type {SCNOrderedDictionary}
     */

    this._animations = new SCNOrderedDictionary();
    /**
     * @access private
     * @type {Promise}
     */

    this._loadedPromise = null;
  } // Creating a Particle System

  /**
   * Loads a particle system from a file in the app’s bundle resources.
   * @access public
   * @param {string} name - The name of a particle system file in the app’s bundle resources directory, with or without the .scnp extension.
   * @param {?string} directory - The subdirectory path in the app’s bundle resources directory.
   * @returns {void}
   * @desc A SceneKit particle file created by Xcode contains an archived SCNParticleSystem instance, so you can also use the NSKeyedArchiver and NSKeyedUnarchiver classes to write and read particle files.
   * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522772-init
   */


  static systemNamedInDirectory(name, directory = null) {
    //const system = new SCNParticleSystem(name, directory)
    if (name !== null) {
      let path = name;

      if (directory !== null) {
        path = `${directory}/${name}`;
      }

      return _BinaryRequest.get(path).then(data => {
        const system = NSKeyedUnarchiver.unarchiveObjectWithData(data, path);

        if (!_InstanceOf(system, SCNParticleSystem)) {
          throw new Error(`file ${path} is not an instance of SCNParticleSystem`);
        } // FIXME: wait for images


        system._loadedPromise = Promise.resolve(system);
        return system;
      });
    }

    return null;
  } // Controlling Particle Simulation

  /**
   * Returns the particle system to its initial state.
   * @access public
   * @returns {void}
   * @desc Calling this method removes all currently live particles from the scene.
   * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522968-reset
   */


  reset() {
    this._finished = false;
    this._startTime = null;
    this._prevTime = 0;
    this._nextBirthTime = 0;
    this._emissionEndTime = 0;
    this._idleEndTime = 0;
    this._particles = [];
  } // Modifying Particles in Response to Particle System Events

  /**
   * Adds a block that modifies particle properties, to be executed at a specified event in the lifetimes of particles in the system.
   * @access public
   * @param {SCNParticleEvent} event - The event at which to call the block. See SCNParticleEvent for allowed values.
   * @param {SCNParticleSystem.ParticleProperty[]} properties - An array containing one or more of the constants listed in Particle Property Keys, each of which specifies a property of the appearance or behaviors of particles in the particle system.
   * @param {SCNParticleEventBlock} block - A SCNParticleEventBlock block to be called every time SceneKit renders a frame. In this block you can modify the properties of particles in the system.
   * @returns {void}
   * @desc By associating a block with one or more particle properties, you can run arbitrary code that modifies those properties when a significant event in the particle simulation occurs for one or more particles. For example, you can use the following code with a confetti effect to randomly switch between two distinct colors for each spawned particle:[system handleEvent:SCNParticleEventBirth
      forProperties:@[SCNParticlePropertyColor]
          withBlock:^(void **data, size_t *dataStride, uint32_t *indices , NSInteger count) {
              for (NSInteger i = 0; i < count; ++i) {
                  float *color = (float *)((char *)data[0] + dataStride[0] * i);
                  if (rand() & 0x1) { // Switch the green and red color components.
                      color[0] = color[1];
                      color[1] = 0;
                  }
              }
          }];
  [system handleEvent:SCNParticleEventBirth
      forProperties:@[SCNParticlePropertyColor]
          withBlock:^(void **data, size_t *dataStride, uint32_t *indices , NSInteger count) {
              for (NSInteger i = 0; i < count; ++i) {
                  float *color = (float *)((char *)data[0] + dataStride[0] * i);
                  if (rand() & 0x1) { // Switch the green and red color components.
                      color[0] = color[1];
                      color[1] = 0;
                  }
              }
          }];
    * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523251-handle
   */


  handleForPropertiesHandler(event, properties, block) {} // Modifying Particles Over Time

  /**
   * Adds a block that modifies particle properties, to be executed each time SceneKit renders a frame.
   * @access public
   * @param {SCNParticleSystem.ParticleProperty[]} properties - An array containing one or more of the constants listed in Particle Property Keys, each of which specifies a property of the appearance or behaviors of particles in the particle system.
   * @param {SCNParticleModifierStage} stage - The stage of SceneKit’s particle simulation during which to call the block. See SCNParticleModifierStage for allowed values.
   * @param {SCNParticleModifierBlock} block - A SCNParticleModifierBlock block to be called every time SceneKit renders a frame. In this block you can modify the properties of all particles in the system.
   * @returns {void}
   * @desc By associating a block with one or more particle properties, you can run arbitrary code that modifies those properties during each frame of animation. This option provides maximum flexibility for changing the appearance or behavior of particles over time. ImportantRunning your own code to update particle properties every frame can have a severe impact on rendering performance. If the behavior over time that you want for your particle system can be described more declaratively, use the propertyControllers property and SCNParticlePropertyController class instead. If you need to change particle properties only at certain times (rather than continuously), add a handler block for an event using the handle(_:forProperties:handler:) method.
   * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522635-addmodifier
   */


  addModifierForPropertiesAtModifier(properties, stage, block) {}
  /**
   * Removes particle modifier blocks for the specified stage of the particle simulation.
   * @access public
   * @param {SCNParticleModifierStage} stage - The stage of SceneKit’s particle simulation during which to call the block. See SCNParticleModifierStage for allowed values.
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1524077-removemodifiers
   */


  removeModifiersAt(stage) {}
  /**
   * Removes all particle modifier blocks associated with the particle system.
   * @access public
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523614-removeallmodifiers
   */


  removeAllModifiers() {} // Structures

  /**
   * @type {Object} ParticleProperty
   * @property {string} angle The rotation angle, in radians, of the particle about its axis.
   * @property {string} angularVelocity The particle’s angular velocity (or rate of spin), in radians per second.
   * @property {string} bounce The particle’s restitution coefficient.
   * @property {string} charge The particle’s electric charge, in coulombs.
   * @property {string} color The particle’s tint color, as a vector of red, green, blue, and alpha component values.
   * @property {string} contactNormal The normal vector, in scene coordinate space, of a collision between a particle and a geometry in the scene.
   * @property {string} contactPoint The location, in scene coordinate space, of a collision between a particle and a geometry in the scene.
   * @property {string} frame The current frame index of the particle’s image animation.
   * @property {string} frameRate The rate, in frames per second, of the particle’s image animation.
   * @property {string} friction The particle’s friction coefficient.
   * @property {string} life The remaining time in the particle’s life span, in seconds.
   * @property {string} opacity The particle’s opacity (or alpha value).
   * @property {string} position The particle’s position vector in scene coordinate space.
   * @property {string} rotationAxis The particle’s axis of rotation, expressed as a vector in the particle’s local coordinate space.
   * @property {string} size The width and height of the rendered particle image, in units of scene coordinate space.
   * @property {string} velocity The particle’s velocity vector in units (of scene coordinate space) per second.
   * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem.particleproperty
   */


  static get ParticleProperty() {
    return _ParticleProperty;
  }
  /**
   * @access private
   * @param {string} path -
   * @param {string} directoryPath -
   * @returns {Image} -
   */


  _loadParticleImage(path, directoryPath) {
    const image = new Image(); // TODO: check option if it allows cross-domain.

    image.crossOrigin = 'anonymous';
    let __path = path;

    if (__path.indexOf('file:///') === 0) {
      __path = __path.slice(8);
    } // TODO: load OpenEXR File


    __path = __path.replace(/\.exr$/, '.png');
    this._loadedPromise = new Promise((resolve, reject) => {
      const paths = __path.split('/');

      let pathCount = 1;

      let _path = directoryPath + paths.slice(-pathCount).join('/');

      image.onload = () => {
        this.particleImage = image;
        resolve();
      };

      image.onerror = () => {
        pathCount += 1;

        if (pathCount > paths.length) {
          // try the root path
          image.onerror = () => {
            // give up
            reject();
          };

          image.src = __path;
        } else {
          // retry
          _path = directoryPath + paths.slice(-pathCount).join('/');
          image.src = _path;
        }
      };

      image.src = _path;
    });
    return image;
  }

  _initializeVAO(gl, program) {
    if (this._vertexArray !== null) {
      return;
    }

    this._vertexArray = gl.createVertexArray();
    gl.bindVertexArray(this._vertexArray);
    this._vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer); // prepare vertex array data
    // TODO: retain attribute locations

    const positionLoc = gl.getAttribLocation(program, 'position');
    const velocityLoc = gl.getAttribLocation(program, 'velocity');
    const rotationLoc = gl.getAttribLocation(program, 'rotation');
    const colorLoc = gl.getAttribLocation(program, 'color');
    const sizeLoc = gl.getAttribLocation(program, 'size'); //const lifeLoc = gl.getAttribLocation(program, 'life')

    const cornerLoc = gl.getAttribLocation(program, 'corner');
    const texcoordLoc = gl.getAttribLocation(program, 'texcoord'); // vertexAttribPointer(ulong idx, long size, ulong type, bool norm, long stride, ulong offset)

    const stride = 76;
    gl.enableVertexAttribArray(positionLoc);
    gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, stride, 0);
    gl.enableVertexAttribArray(velocityLoc);
    gl.vertexAttribPointer(velocityLoc, 3, gl.FLOAT, false, stride, 12);
    gl.enableVertexAttribArray(rotationLoc);
    gl.vertexAttribPointer(rotationLoc, 4, gl.FLOAT, false, stride, 24);
    gl.enableVertexAttribArray(colorLoc);
    gl.vertexAttribPointer(colorLoc, 4, gl.FLOAT, false, stride, 40);
    gl.enableVertexAttribArray(sizeLoc);
    gl.vertexAttribPointer(sizeLoc, 1, gl.FLOAT, false, stride, 56);
    gl.enableVertexAttribArray(cornerLoc);
    gl.vertexAttribPointer(cornerLoc, 2, gl.FLOAT, false, stride, 60);
    gl.enableVertexAttribArray(texcoordLoc);
    gl.vertexAttribPointer(texcoordLoc, 2, gl.FLOAT, false, stride, 68);
    /*
    const arr = []
    this._particles.forEach((particle) => {
      arr.push(...particle.floatArray())
    })
    const particleData = new Float32Array(arr)
    gl.bufferData(gl.ARRAY_BUFFER, particleData, gl.DYNAMIC_DRAW)
    */

    const len = this._maxParticles + 5;

    this._updateIndexBuffer(gl, len); // initialize parameters


    this._numImages = this.imageSequenceRowCount * this.imageSequenceColumnCount;
    this._imageWidth = 1.0 / this.imageSequenceColumnCount;
    this._imageHeight = 1.0 / this.imageSequenceRowCount;
  }

  _updateIndexBuffer(context, length) {
    const gl = context;
    const indexData = [];
    let index = 0;

    for (let i = 0; i < length; i++) {
      indexData.push(index + 0);
      indexData.push(index + 3);
      indexData.push(index + 2);
      indexData.push(index + 0);
      indexData.push(index + 1);
      indexData.push(index + 3);
      index += 4;
    }

    let glIndexData = null;

    if (index < 256) {
      glIndexData = new Uint8Array(indexData);
      this._glIndexSize = gl.UNSIGNED_BYTE;
    } else if (index < 65536) {
      glIndexData = new Uint16Array(indexData);
      this._glIndexSize = gl.UNSIGNED_SHORT;
    } else {
      glIndexData = new Uint32Array(indexData);
      this._glIndexSize = gl.UNSIGNED_INT;
    }

    if (this._indexBuffer === null) {
      this._indexBuffer = gl.createBuffer();
    }

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, glIndexData, gl.STATIC_DRAW);
    this._maxParticleIndex = length;
  }
  /**
   * @access private
   * @param {number} birthTime -
   * @param {SCNVector3} position -
   * @param {SCNVector4} orientation -
   * @returns {_Particle} -
   */
  //_createParticle(birthTime, position, orientation) {


  _createParticle(birthTime, transform) {
    const p = new _Particle();
    const position = transform.getTranslation();
    const velocity = this.particleVelocity + this.particleVelocityVariation * (Math.random() - 0.5);
    const spreadingAngle = this.spreadingAngle / 180.0 * Math.PI * Math.random();
    const spreadingAngleRot = 2.0 * Math.PI * Math.random();
    const angleMat = SCNMatrix4.matrixWithRotation(this._normal.x, this._normal.y, this._normal.z, spreadingAngle);
    const rotMat = SCNMatrix4.matrixWithRotation(this._direction.x, this._direction.y, this._direction.z, spreadingAngleRot); // emitterShape, birthLocation, emittingDirection, spreadingAngle, particleAngle/Variation, particleVelocity

    if (this.emitterShape === null) {
      p.position = position;
      p.velocity = new SCNVector3(0, 0, velocity); // TODO: use spreadingAngle
    } else if (this.birthLocation === SCNParticleBirthLocation.surface) {
      let pVec = null;
      let vVec = null;

      switch (this.emitterShape.className) {
        case 'SCNBox':
          {
            const rnd = Math.random();
            const rnd1 = Math.random() - 0.5;
            const rnd2 = Math.random() - 0.5;
            const w = this.emitterShape.width;
            const h = this.emitterShape.height;
            const l = this.emitterShape.length;
            const rx = h * l;
            const ry = l * w;
            const rz = w * h;
            const r = 1.0 / (rx + ry + rz);
            const tx = rx * r;
            const ty = ry * r;
            const tz = rz * r; // TODO: chamferRadius

            if (rnd < tx * 0.5) {
              // right
              pVec = new SCNVector3(w * 0.5, h * rnd1, l * rnd2);
              vVec = new SCNVector3(1, 0, 0);
            } else if (rnd < tx) {
              // left
              pVec = new SCNVector3(-w * 0.5, h * rnd1, l * rnd2);
              vVec = new SCNVector3(-1, 0, 0);
            } else if (rnd < tx + ty * 0.5) {
              // top
              pVec = new SCNVector3(w * rnd1, h * 0.5, l * rnd2);
              vVec = new SCNVector3(0, 1, 0);
            } else if (rnd < tx + ty) {
              // bottom
              pVec = new SCNVector3(w * rnd1, -h * 0.5, l * rnd2);
              vVec = new SCNVector3(0, -1, 0);
            } else if (rnd < tx + ty + tz * 0.5) {
              // front
              pVec = new SCNVector3(w * rnd1, h * rnd2, l * 0.5);
              vVec = new SCNVector3(0, 0, 1);
            } else {
              // back
              pVec = new SCNVector3(w * rnd1, h * rnd2, -l * 0.5);
              vVec = new SCNVector3(0, 0, -1);
            }

            break;
          }

        case 'SCNSphere':
          {
            const v = new SCNVector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
            pVec = v.mul(this.emitterShape.radius);
            vVec = v;
            break;
          }

        case 'SCNPlane':
          {
            pVec = new SCNVector3((Math.random() - 0.5) * this.emitterShape.width, (Math.random() - 0.5) * this.emitterShape.height, 0.0);
            vVec = new SCNVector3(0, 0, 1);
            break;
          }

        case 'SCNCylinder':
          {
            const y = (Math.random() - 0.5) * this.emitterShape.height;
            const r = Math.random() * Math.PI * 2.0;
            const x = Math.sin(r);
            const z = Math.cos(r);
            pVec = new SCNVector3(x * this.emitterShape.radius, y, z * this.emitterShape.radius);
            vVec = new SCNVector3(x, 0, z);
            break;
          }

        case 'SCNGeometry':
          {
            const element = this.emitterShape.geometryElementAtIndex(0);
            const vertexSrc = this.emitterShape.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.vertex)[0];
            const normalSrc = this.emitterShape.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.normal)[0];
            const elemIndex = Math.floor(Math.random() * element.primitiveCount);

            const indices = element._indexAt(elemIndex);

            const vertices = indices.map(index => vertexSrc._scnVectorAt(index));
            const normals = indices.map(index => normalSrc._scnVectorAt(index));
            const pos = vertices[0].add(vertices[1]).add(vertices[2]).mul(1 / 3);
            const nom = normals[0].add(normals[1]).add(normals[2]).normalize();
            pVec = pos;
            vVec = nom;
            break;
          }

        default:
          // TODO: implement
          throw new Error(`surface emitter for ${this.emitterShape.className} is not implemented`);
      }

      pVec = pVec.rotate(transform);
      p.position = position.add(pVec);

      if (this.birthDirection === SCNParticleBirthDirection.surfaceNormal) {
        p.velocity = vVec.rotate(transform).normalize().mul(velocity);
      }
    } else if (this.birthLocation === SCNParticleBirthLocation.volume) {
      let pVec = null;

      switch (this.emitterShape.className) {
        case 'SCNBox':
          {
            const x = (Math.random() - 0.5) * this.emitterShape.width;
            const y = (Math.random() - 0.5) * this.emitterShape.height;
            const z = (Math.random() - 0.5) * this.emitterShape.length;
            pVec = new SCNVector3(x, y, z);
            break;
          }

        case 'SCNSphere':
          {
            const r = Math.random() * this.emitterShape.radius;
            const s = Math.random() * Math.PI;
            const t = Math.random() * Math.PI * 2.0;
            const rsins = r * Math.sin(s);
            const x = rsins * Math.cos(t);
            const y = rsins * Math.sin(t);
            const z = r * Math.cos(s);
            pVec = new SCNVector3(x, y, z);
            break;
          }

        default:
          // TODO: implement
          throw new Error(`volume emitter for ${this.emitterShape.className} is not implemented`);
      }

      pVec = pVec.rotate(transform);
      p.position = position.add(pVec);

      if (this.birthDirection === SCNParticleBirthDirection.surfaceNormal) {
        throw new Error('combination of birthLocation=volume and birthDirection=surfaceNormal is not implemented.');
      }
    } else {
      // TODO: implement
      throw new Error(`birthLocation ${this.birthLocation} is not implemented.`);
    }

    if (this.orientationMode === SCNParticleOrientationMode.billboardScreenAligned) {
      p.axis = new SCNVector3(0, 0, 1);
    } else {
      p.axis = new SCNVector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
    }

    p.angle = (this.particleAngle + this.particleAngleVariation * (Math.random() - 0.5)) / 180.0 * Math.PI;
    p.size = this.particleSize + this.particleSizeVariation * (Math.random() - 0.5);
    p.baseSize = p.size;
    p.color = this._createColor();

    switch (this.birthDirection) {
      case SCNParticleBirthDirection.constant:
        {
          p.velocity = this._direction.rotate(angleMat).rotate(rotMat).rotate(transform).mul(velocity);
          break;
        }

      case SCNParticleBirthDirection.surfaceNormal:
        {
          break;
        }

      case SCNParticleBirthDirection.random:
        {
          const rndAngle = 2.0 * Math.PI * Math.random();
          const rndMat = SCNMatrix4.matrixWithRotation(this._normal.x, this._normal.y, this._normal.z, rndAngle);
          p.velocity = this._direction.rotate(rndMat).rotate(rotMat).rotate(transform).mul(velocity);
          break;
        }

      default:
        {
          throw new Error(`unknown birth direction: ${this.birthDirection}`);
        }
    }

    p.angularVelocity = (this.particleAngularVelocity + this.particleAngularVelocityVariation * (Math.random() - 0.5)) / 180.0 * Math.PI;
    p.acceleration = this.acceleration._copy();
    p.birthTime = birthTime;
    p.lifeSpan = this.particleLifeSpan + this.particleLifeSpanVariation * (Math.random() * 2.0 - 1.0);
    p.imageFrameRate = this.imageSequenceFrameRate + this.imageSequenceFrameRateVariation * (Math.random() - 0.5);

    if (p.imageFrameRate < 0) {
      p.imageFrameRate = 0;
    }

    const numImages = this.imageSequenceRowCount * this.imageSequenceColumnCount;
    p.initialImageFrame = (this.imageSequenceInitialFrame + this.imageSequenceInitialFrameVariation * (Math.random() - 0.5)) % numImages;

    if (p.initialImageFrame < 0) {
      p.initialImageFrame += numImages;
    }

    return p;
  }
  /**
   * @access private
   * @param {SCNMatrix4} transform -
   * @param {?SCNVector3} gravity -
   * @param {number} currentTime -
   * @returns {void}
   */


  _updateParticles(transform, gravity, currentTime) {
    if (this._prevTime <= 0) {
      this._prevTime = currentTime;
      this._nextBirthTime = currentTime;
      this._startTime = currentTime;
      this._direction = this.emittingDirection.normalize();
      const u = new SCNVector3(this._direction.z, this._direction.x, this._direction.y);
      this._normal = this._direction.cross(u);

      this._updateEndTime();
    } // generate particles


    if (this._presentation._birthRate + this.birthRateVariation > 0) {
      while (this._nextBirthTime <= currentTime) {
        const p = this._createParticle(this._nextBirthTime, transform);

        this._particles.push(p);

        let rate = this._presentation._birthRate + this.birthRateVariation * (Math.random() - 0.5);

        if (rate < 0.0000001) {
          rate = 0.0000001;
        }

        this._nextBirthTime += 1.0 / rate;

        if (this._nextBirthTime > this._emissionEndTime) {
          this._nextBirthTime = this._idleEndTime;

          if (!this.loops) {
            this._finished = true;
          }

          this._updateEndTime();
        }
      }
    }

    const dt = (currentTime - this._prevTime) * this.speedFactor;
    let damping = 1;

    if (this.dampingFactor > 0) {
      damping = Math.pow((100 - this.dampingFactor) * 0.01, dt * 60.0);
    }

    this._particles.forEach(p => {
      let _dt = dt;
      const pdt = (currentTime - p.birthTime) * this.speedFactor;

      if (p.birthTime > this._prevTime) {
        _dt = pdt;
      }

      const t = pdt / p.lifeSpan;
      p.life = t;

      if (t > 1) {
        return;
      }

      let acceleration = p.acceleration;

      if (gravity !== null && this.isAffectedByGravity) {
        acceleration = acceleration.add(gravity);
      } //p.position.x += (0.5 * acceleration.x * dt + p.velocity.x) * dt
      //p.position.y += (0.5 * acceleration.y * dt + p.velocity.y) * dt
      //p.position.z += (0.5 * acceleration.z * dt + p.velocity.z) * dt
      //p.velocity.x += acceleration.x * dt
      //p.velocity.y += acceleration.y * dt
      //p.velocity.z += acceleration.z * dt


      p.angle += p.angularVelocity * _dt;
      p.velocity.x = (p.velocity.x + acceleration.x * _dt) * damping;
      p.velocity.y = (p.velocity.y + acceleration.y * _dt) * damping;
      p.velocity.z = (p.velocity.z + acceleration.z * _dt) * damping;
      p.position.x += p.velocity.x * _dt;
      p.position.y += p.velocity.y * _dt;
      p.position.z += p.velocity.z * _dt;

      if (this.propertyControllers !== null) {
        Object.keys(this.propertyControllers).forEach(key => {
          this.propertyControllers[key].animation._applyAnimation(p, t, false); // should I use p.life instead of t?

        });
      }

      const frame = p.initialImageFrame + p.imageFrameRate * pdt;
      let imageFrame = 0;

      switch (this.imageSequenceAnimationMode) {
        case SCNParticleImageSequenceAnimationMode.repeat:
          {
            imageFrame = Math.floor(frame % this._numImages);
            break;
          }

        case SCNParticleImageSequenceAnimationMode.clamp:
          {
            let fr = Math.floor(frame % this._numImages);

            if (fr >= this._numImages - 1) {
              imageFrame = this._numImages - 1;
            } else {
              imageFrame = fr;
            }

            break;
          }

        case SCNParticleImageSequenceAnimationMode.autoReverse:
          {
            let fr = Math.floor(frame % (this._numImages * 2 - 2));

            if (fr >= this._numImages) {
              fr = this._numImages * 2 - 2 - fr;
            }

            imageFrame = fr;
            break;
          }

        default:
          throw new Error('unknown SCNParticleImageSequenceAnimationMode: ' + this.imageSequenceAnimationMode);
      }

      const imageY = Math.floor(imageFrame / this.imageSequenceRowCount);
      const imageX = imageFrame % this.imageSequenceColumnCount;
      p.texLeft = imageX * this._imageWidth;
      p.texTop = (imageY + 1) * this._imageHeight;
      p.texRight = (imageX + 1) * this._imageWidth;
      p.texBottom = imageY * this._imageHeight;
    });

    this._particles = this._particles.filter(p => {
      return p.life <= 1;
    });
    this._prevTime = currentTime;
  }

  _updateEndTime() {
    const startTime = this._idleEndTime === 0 ? this._startTime : this._idleEndTime;
    let emissionDuration = this.emissionDuration + (Math.random() - 0.5) * this.emissionDurationVariation;

    if (emissionDuration < 0) {
      emissionDuration = 0;
    }

    this._emissionEndTime = startTime + emissionDuration;
    let idleDuration = this.idleDuration + (Math.random() - 0.5) * this.idleDurationVariation;

    if (idleDuration < 0) {
      idleDuration = 0;
    }

    this._idleEndTime = this._emissionEndTime + idleDuration;
  }
  /**
   * @access private
   * @param {WebGLRenderingContext} gl -
   * @param {WebGLProgram} program -
   * @returns {void}
   */


  _bufferMaterialData(gl, program) {
    // particleTexture
    if (this._particleTexture === null && this.particleImage !== null) {
      this._particleTexture = this._createTexture(gl, this.particleImage);
    }

    if (this._particleTexture !== null) {
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, this._particleTexture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    }

    gl.uniform1i(gl.getUniformLocation(program, 'orientationMode'), this.orientationMode);
    gl.uniform1f(gl.getUniformLocation(program, 'stretchFactor'), this.stretchFactor); // buffer particle data

    gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this._particleData, gl.DYNAMIC_DRAW);

    if (this._particles.length > this._maxParticleIndex) {
      this._updateIndexBuffer(gl, this._particles.length + 10);
    }

    const blendFuncSrc = [gl.ONE, // additive
    gl.ZERO, // subtract
    gl.ZERO, // multiply
    gl.SRC_ALPHA, // screen
    gl.SRC_ALPHA, // alpha
    gl.ONE // replace
    ];
    const blendFuncDst = [gl.ONE, // additive
    gl.ONE_MINUS_SRC_COLOR, // subtract
    gl.SRC_COLOR, // multiply
    gl.ONE, // screen
    gl.ONE_MINUS_SRC_ALPHA, // alpha
    gl.ZERO // replace
    ];
    gl.blendFunc(blendFuncSrc[this.blendMode], blendFuncDst[this.blendMode]);
  }

  _createTexture(gl, image) {
    const texture = gl.createTexture();
    const canvas = document.createElement('canvas');
    canvas.width = image.naturalWidth;
    canvas.height = image.naturalHeight; //console.warn(`image size: ${image.naturalWidth} ${image.naturalHeight}`)

    canvas.getContext('2d').drawImage(image, 0, 0);
    gl.bindTexture(gl.TEXTURE_2D, texture); // texImage2D(target, level, internalformat, width, height, border, format, type, source)
    // Safari complains that 'source' is not ArrayBufferView type, but WebGL2 should accept HTMLCanvasElement.

    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, image.width, image.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
    gl.generateMipmap(gl.TEXTURE_2D);
    gl.bindTexture(gl.TEXTURE_2D, null);
    return texture;
  }
  /**
   * @access private
   * @returns {SKColor} -
   */


  _createColor() {
    const hsb = this._rgb2hsb(this.particleColor); // Hue
    //hsb.x = (hsb.x + this.particleColorVariation.x * (Math.random() - 0.5)) % 360.0


    hsb.x = (hsb.x + this.particleColorVariation.x * (Math.random() * 2.0 - 1.0)) % 360.0;

    if (hsb.x < 0) {
      hsb.x += 360.0;
    } // Saturation


    hsb.y = Math.max(0, Math.min(1.0, hsb.y + this.particleColorVariation.y * (Math.random() - 0.5))); // Brightness

    hsb.z = Math.max(0, Math.min(1.0, hsb.z + this.particleColorVariation.z * (Math.random() - 0.5))); // Alpha

    hsb.w = Math.max(0, Math.min(1.0, hsb.w + this.particleColorVariation.w * (Math.random() - 0.5)));
    return this._hsb2rgb(hsb);
  }
  /**
   * @access private
   * @param {SKColor} rgb -
   * @returns {SCNVector4} -
   */


  _rgb2hsb(rgb) {
    const hsb = new SCNVector4();
    const min = Math.min(rgb.red, Math.min(rgb.green, rgb.blue));
    const max = Math.max(rgb.red, Math.max(rgb.green, rgb.blue));
    const delta = max - min;
    hsb.w = rgb.alpha;
    hsb.z = max;

    if (hsb.z === 0) {
      hsb.x = 0;
      hsb.y = 0;
      return hsb;
    }

    hsb.y = delta / max;

    if (hsb.y === 0) {
      hsb.x = 0;
      return hsb;
    }

    if (max === rgb.red) {
      hsb.x = (60.0 * (rgb.green - rgb.blue) / delta + 360.0) % 360.0;
    } else if (max === rgb.green) {
      hsb.x = 60.0 * (rgb.blue - rgb.red) / delta + 120.0;
    } else {
      hsb.x = 60.0 * (rgb.red - rgb.green) / delta + 240.0;
    }

    return hsb;
  }
  /**
   * @access private
   * @param {SCNVector4} hsb -
   * @returns {SKColor} -
   */


  _hsb2rgb(hsb) {
    //const rgb = new SKColor(0, 0, 0, hsb.w)
    if (hsb.y === 0) {
      //rgb.red = hsb.z
      //rgb.green = hsb.z
      //rgb.blue = hsb.z
      return new SKColor(hsb.z, hsb.z, hsb.z, hsb.w);
    }

    const region = Math.floor(hsb.x / 60.0);
    /*
    const c = hsb.z * hsb.y
    const x = c * (region % 2)
    const m = hsb.z - c
     let r = 0
    let g = 0
    let b = 0
    switch(region){
      case 0:
        r = c
        g = x
        break
      case 1:
        r = x
        g = c
        break
      case 2:
        g = c
        b = x
        break
      case 3:
        g = x
        b = c
        break
      case 4:
        r = x
        b = c
        break
      default:
        r = c
        b = x
        break
    }
    rgb.red = r + m
    rgb.green = g + m
    rgb.blue = b + m
    
    return rgb
    */

    const v = hsb.z;
    const f = hsb.x / 60.0 - region;
    const m = v * (1.0 - hsb.y);
    const n = v * (1.0 - hsb.y * f);
    const k = v * (1.0 - hsb.y * (1.0 - f));

    switch (region) {
      case 0:
        return new SKColor(v, k, m, hsb.w);

      case 1:
        return new SKColor(n, v, m, hsb.w);

      case 2:
        return new SKColor(m, v, k, hsb.w);

      case 3:
        return new SKColor(m, n, v, hsb.w);

      case 4:
        return new SKColor(k, m, v, hsb.w);

      default:
        return new SKColor(v, m, n, hsb.w);
    }
  }

  get _particleData() {
    const arr = [];

    this._particles.forEach(particle => {
      arr.push(...particle.floatArray());
    });

    return new Float32Array(arr);
  }

  get _maxParticles() {
    const maxRate = this._birthRate + this.birthRateVariation * 0.5;
    const maxLifeSpan = this.particleLifeSpan + this.particleLifeSpanVariation * 0.5;
    return Math.ceil(maxRate * maxLifeSpan);
  }

  _copy() {
    const s = new SCNParticleSystem();
    const params = ['_birthRate' // TODO: add other parameters... 
    ];

    for (const param of params) {
      s[param] = this[param];
    }

    return s;
  }

  _createPresentation() {
    if (this.__presentation) {
      return this.__presentation;
    }

    const s = this._copy();

    this.__presentation = s;
    return s;
  } /// Animatable parameters

  /**
   * The number of particles spawned during each emission period. Animatable.
   * @type {number}
   * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522857-birthrate
   */


  get birthRate() {
    return this._birthRate;
  }

  set birthRate(newValue) {
    const oldValue = this._birthRate;
    this._birthRate = newValue;

    SCNTransaction._addChange(this, '_birthRate', oldValue, newValue);
  } ///////////////////
  // SCNAnimatable //
  ///////////////////
  // Managing Animations

  /**
   * Required. Adds an animation object for the specified key.
   * @access public
   * @param {CAAnimation} animation - The animation object to be added.
   * @param {?string} key - An string identifying the animation for later retrieval. You may pass nil if you don’t need to reference the animation later.
   * @returns {void}
   * @desc Newly added animations begin executing after the current run loop cycle ends.SceneKit does not define any requirements for the contents of the key parameter—it need only be unique among the keys for other animations you add. If you add an animation with an existing key, this method overwrites the existing animation.
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523386-addanimation
   */


  addAnimationForKey(animation, key) {
    if (typeof key === 'undefined' || key === null) {
      key = Symbol();
    }

    const anim = animation.copy(); // FIXME: use current frame time

    anim._animationStartTime = Date.now() * 0.001;

    this._animations.set(key, anim);
  }
  /**
   * Required. Returns the animation with the specified key.
   * @access public
   * @param {string} key - A string identifying a previously added animation.
   * @returns {?CAAnimation} - 
   * @desc Attempting to modify any properties of the returned object results in undefined behavior.
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1524020-animation
   */


  animationForKey(key) {
    return this._animations.get(key);
  }
  /**
   * Required. Removes all the animations currently attached to the object.
   * @access public
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1522762-removeallanimations
   */


  removeAllAnimations() {
    // TODO: stop animations
    this._animations.clear();
  }
  /**
   * Required. Removes the animation attached to the object with the specified key.
   * @access public
   * @param {string} key - A string identifying an attached animation to remove.
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1522880-removeanimation
   */


  removeAnimationForKey(key) {
    this._animations.delete(key);

    this._copyTransformToPresentationRecursive();
  }
  /**
   * Required. Removes the animation attached to the object with the specified key, smoothly transitioning out of the animation’s effect.
   * @access public
   * @param {string} key - A string identifying an attached animation to remove.
   * @param {number} duration - The duration for transitioning out of the animation’s effect before it is removed.
   * @returns {void}
   * @desc Use this method to create smooth transitions between the effects of multiple animations. For example, the geometry loaded from a scene file for a game character may have associated animations for player actions such as walking and jumping. When the player lands from a jump, you remove the jump animation so the character continues walking. If you use the removeAnimation(forKey:) method to remove the jump animation, SceneKit abruptly switches from the current frame of the jump animation to the current frame of the walk animation. If you use the removeAnimation(forKey:fadeOutDuration:) method instead, SceneKit plays both animations at once during that duration and interpolates vertex positions from one animation to the other, creating a smooth transition.
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1522841-removeanimation
   */


  removeAnimationForKeyFadeOutDuration(key, duration) {
    // FIXME: use fadeout duration
    this.removeAnimationForKey(key);
  }
  /**
   * Required. An array containing the keys of all animations currently attached to the object.
   * @type {string[]}
   * @desc This array contains all keys for which animations are attached to the object, or is empty if there are no attached animations. The ordering of animation keys in the array is arbitrary.
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523610-animationkeys
   */


  get animationKeys() {
    const keys = [];

    for (const key of this._animations.keys()) {
      keys.push(key);
    }

    return keys;
  } // Pausing and Resuming Animations

  /**
   * Required. Pauses the animation attached to the object with the specified key.
   * @access public
   * @param {string} key - A string identifying an attached animation.
   * @returns {void}
   * @desc This method has no effect if no animation is attached to the object with the specified key.
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523592-pauseanimation
   */


  pauseAnimationForKey(key) {}
  /**
   * Required. Resumes a previously paused animation attached to the object with the specified key.
   * @access public
   * @param {string} key - A string identifying an attached animation.
   * @returns {void}
   * @desc This method has no effect if no animation is attached to the object with the specified key or if the specified animation is not currently paused.
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523332-resumeanimation
   */


  resumeAnimationForKey(key) {}
  /**
   * Required. Returns a Boolean value indicating whether the animation attached to the object with the specified key is paused.
   * @access public
   * @param {string} key - A string identifying an attached animation.
   * @returns {boolean} - 
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523703-isanimationpaused
   */


  isAnimationPausedForKey(key) {
    return false;
  } // Instance Methods

  /**
   * Required. 
   * @access public
   * @param {number} speed - 
   * @param {string} key - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1778343-setanimationspeed
   */


  setAnimationSpeedForKey(speed, key) {}

  valueForKeyPath(keyPath, usePresentation = true) {
    const target = usePresentation && this._presentation ? this._presentation : this;
    const paths = keyPath.split('.');
    const key = paths[0];
    const key2 = paths[1];

    if (key === '_birthRate') {
      return target[key];
    }

    return super.valueForKeyPath(keyPath, usePresentation);
  }

  setValueForKeyPath(value, keyPath) {
    const target = this._presentation ? this._presentation : this;
    const paths = keyPath.split('.');
    const key = paths.shift();
    const restPath = paths.join('.');

    if (key === '_birthRate') {
      target[key] = value;
      return;
    }

    super.setValueForKeyPath(value, keyPath);
  }

  get _presentation() {
    return this.__presentation ? this.__presentation : this;
  }
  /**
   * @access private
   * @returns {Promise} -
   */


  _getLoadedPromise() {
    if (this._loadedPromise) {
      return this._loadedPromise;
    }

    return Promise.resolve();
  }
  /**
   * @access public
   * @returns {Promise} -
   */


  get didLoad() {
    return this._getLoadedPromise();
  }

}

/**
 * The abstract superclass for joints, vehicle simulations, and other high-level behaviors that incorporate multiple physics bodies.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/scenekit/scnphysicsbehavior
 */

class SCNPhysicsBehavior extends NSObject {
  /**
   * constructor
   * @access public
   * @constructor
   */
  //construtor() {
  //}
}

//import SCNVector3 from './SCNVector3'

/**
 * A physics behavior that connects two physics bodies and allows them to pivot around each other in any direction.
 * @access public
 * @extends {SCNPhysicsBehavior}
 * @see https://developer.apple.com/documentation/scenekit/scnphysicsballsocketjoint
 */

class SCNPhysicsBallSocketJoint extends SCNPhysicsBehavior {
  // Creating a Ball and Socket Joint

  /**
   * Creates a ball and socket joint connecting two physics bodies.
   * @access public
   * @constructor
   * @param {SCNPhysicsBody} bodyA - The first physics body to be connected by the joint.
   * @param {SCNVector3} anchorA - The point at which the joint connects, relative to the node containing the first body.
   * @param {SCNPhysicsBody} bodyB - The second physics body to be connected by the joint.
   * @param {SCNVector3} anchorB - The point at which the joint connects, relative to the node containing the second body.
   * @desc For a behavior to take effect, add it to the physics simulation by calling the addBehavior(_:) method on your scene’s SCNPhysicsWorld object. The physics bodies constrained by the joint must be attached to nodes in the scene.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsballsocketjoint/1387926-init
   */
  constructor(bodyA, anchorA, bodyB, anchorB) {
    super(); // Managing the Characteristics of a Ball and Socket Joint

    /**
     * The point at which the joint connects, relative to the node containing the first body.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsballsocketjoint/1387956-anchora
     */

    this.anchorA = null;
    /**
     * The point at which the joint connects, relative to the node containing the second body.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsballsocketjoint/1387965-anchorb
     */

    this.anchorB = null;
    this._bodyA = null;
    this._bodyB = null;
  } // Managing the Characteristics of a Ball and Socket Joint

  /**
   * The first physics body connected by the joint.
   * @type {SCNPhysicsBody}
   * @desc 
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsballsocketjoint/1387981-bodya
   */


  get bodyA() {
    return this._bodyA;
  }
  /**
   * The second physics body connected by the joint.
   * @type {?SCNPhysicsBody}
   * @desc This property’s value is nil if the joint was created using the init(body:anchor:) method.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsballsocketjoint/1387902-bodyb
   */


  get bodyB() {
    return this._bodyB;
  }

}

/**
 * A set of physics simulation attributes attached to a scene graph node. 
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody
 */

class SCNPhysicsBody extends NSObject {
  static get _propTypes() {
    return {
      physicsShape: 'SCNPhysicsShape',
      type: 'integer',
      velocityFactor: 'SCNVector3',
      angularVelocityFactor: 'SCNVector3',
      ignoreGravity: ['boolean', (obj, value) => {
        obj.isAffectedByGravity = !value;
      }],
      mass: 'float',
      charge: 'float',
      friction: 'float',
      rollingFriction: 'float',
      restitution: 'float',
      damping: 'float',
      angularDamping: 'float',
      momentOfInertia: 'SCNVector3',
      explicitMomentOfInertia: ['boolean', (obj, value) => {
        obj.usesDefaultMomentOfInertia = !value;
      }],
      categoryBitMask: 'integer',
      contactTestBitMask: 'integer',
      collisionBitMask: 'integer',
      velocity: 'SCNVector3',
      angularVelocity: 'SCNVector4',
      allowsResting: 'boolean',
      isDefaultShape: ['boolean', null]
    };
  } // Creating Physics Bodies

  /**
   * Creates a physics body with the specified type and shape.
   * @access public
   * @constructor
   * @param {SCNPhysicsBodyType} type - A constant that determines how a body responds to forces and collisions. See SCNPhysicsBodyType.
   * @param {?SCNPhysicsShape} shape - A physics shape defining the volume of the body for collision detection purposes.
   * @desc For the body to participate in collision detection or respond to forces, you must attach it to the physicsBody property of an SCNNode object in a scene.If you pass nil for the shape parameter, SceneKit automatically creates a physics shape for the body when you attach it to a node, based on that node’s geometry property. To create a physics shape that’s based on the geometries of a node and its hierarchy of children, or to control the level of detail in a physics shape, create the physics shape manually using an SCNPhysicsShape class method.NoteFor nodes containing custom geometry, the physics shape SceneKit automatically creates is a rough approximation of the geometry. This approximation, or convex hull, provides a compromise between accuracy and performance in collision detection. For the best collision detection performance, create an SCNPhysicsShape instance based on a basic geometry class (SCNBox, SCNSphere, SCNPyramid, SCNCone, SCNCylinder, or SCNCapsule).
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514797-init
   */


  constructor(type = SCNPhysicsBodyType.static, shape = null) {
    super(); // Defining How Forces Affect a Physics Body

    /**
     * An object that defines the solid volume of the physics body for use in collision detection.
     * @type {?SCNPhysicsShape}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514789-physicsshape
     */

    this.physicsShape = shape;
    /**
     * A constant that determines how the physics body responds to forces and collisions.
     * @type {SCNPhysicsBodyType}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514787-type
     */

    this.type = type;
    /**
     * A multiplier affecting how SceneKit applies translations computed by the physics simulation to the node containing the physics body.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514753-velocityfactor
     */

    this.velocityFactor = new SCNVector3(0, 0, 0);
    /**
     * A multiplier affecting how SceneKit applies rotations computed by the physics simulation to the node containing the physics body.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514748-angularvelocityfactor
     */

    this.angularVelocityFactor = new SCNVector3(0, 0, 0);
    /**
     * A Boolean value that determines whether the constant gravity of a scene accelerates the body.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514738-isaffectedbygravity
     */

    this.isAffectedByGravity = true; // Defining a Body’s Physical Properties

    /**
     * The mass of the body, in kilograms.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514755-mass
     */

    this.mass = 0;
    /**
     * The electric charge of the body, in coulombs.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514786-charge
     */

    this.charge = 0;
    /**
     * The body’s resistance to sliding motion.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514794-friction
     */

    this.friction = 0;
    /**
     * The body’s resistance to rolling motion.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514737-rollingfriction
     */

    this.rollingFriction = 0;
    /**
     * A factor that determines how much kinetic energy the body loses or gains in collisions.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514740-restitution
     */

    this.restitution = 0;
    /**
     * A factor that reduces the body’s linear velocity.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514763-damping
     */

    this.damping = 0;
    /**
     * A factor that reduces the body’s angular velocity.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514792-angulardamping
     */

    this.angularDamping = 0;
    /**
     * The body’s moment of inertia, expressed in the local coordinate system of the node that contains the body.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514777-momentofinertia
     */

    this.momentOfInertia = new SCNVector3(0, 0, 0);
    /**
     * A Boolean value that determines whether SceneKit automatically calculates the body’s moment of inertia or allows setting a custom value.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514761-usesdefaultmomentofinertia
     */

    this.usesDefaultMomentOfInertia = true; // Working with Contacts and Collisions

    /**
     * A mask that defines which categories this physics body belongs to.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514768-categorybitmask
     */

    this.categoryBitMask = 0;
    /**
     * A mask that defines which categories of bodies cause intersection notifications with this physics body.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514746-contacttestbitmask
     */

    this.contactTestBitMask = 0;
    /**
     * A mask that defines which categories of physics bodies can collide with this physics body.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514772-collisionbitmask
     */

    this.collisionBitMask = 0; // Managing a Body’s Motion

    /**
     * A vector describing both the current speed (in meters per second) and direction of motion of the physics body.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514757-velocity
     */

    this.velocity = new SCNVector3(0, 0, 0);
    /**
     * A vector describing both the current rotation axis and rotational speed (in radians per second) of the physics body.
     * @type {SCNVector4}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514770-angularvelocity
     */

    this.angularVelocity = new SCNVector4(0, 0, 0, 0);
    /**
     * A Boolean value that specifies whether SceneKit can automatically mark the physics body at rest.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514742-allowsresting
     */

    this.allowsResting = false;
    this._isResting = false;
    this._node = null;
    this._btRigidBody = null;

    this._updateRigidBody();

    this._position = null;
    this._radius = null;
    this._transform = null;
    this._invTransform = null;
    this._shape = null;
    this._prevPosition = null;
    this._positionDiff = new SCNVector3();
  }
  /**
   * Creates a physics body that is unaffected by forces or collisions and that cannot move.
   * @access public
   * @returns {SCNPhysicsBody} - 
   * @desc Use static bodies to construct fixtures in your scene that other bodies need to collide with but that do not themselves move, such as floors, walls, and terrain.For the body to participate in collision detection or respond to forces, you must attach it to the physicsBody property of an SCNNode object in a scene.SceneKit automatically creates a physics shape for the body when you attach it to a node, based on that node’s geometry property. To create a physics shape that’s based on the geometries of a node and its hierarchy of children, or to control the level of detail in a physics shape, create the physics shape manually using an SCNPhysicsShape class method.NoteFor nodes containing custom geometry, the physics shape SceneKit automatically creates is a rough approximation of the geometry. This approximation, or convex hull, provides a compromise between accuracy and performance in collision detection. For the best collision detection performance, create an SCNPhysicsShape instance based on a basic geometry class (SCNBox, SCNSphere, SCNPyramid, SCNCone, SCNCylinder, or SCNCapsule).
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514791-static
   */


  static static() {
    return new SCNPhysicsBody(SCNPhysicsBodyType.static);
  }
  /**
   * Creates a physics body that can be affected by forces and collisions.
   * @access public
   * @returns {SCNPhysicsBody} - 
   * @desc Use dynamic bodies for the elements of your scene that are moved by the physics simulation.For the body to participate in collision detection or respond to forces, you must attach it to the physicsBody property of an SCNNode object in a scene.SceneKit automatically creates a physics shape for the body when you attach it to a node, based on that node’s geometry property. To create a physics shape that’s based on the geometries of a node and its hierarchy of children, or to control the level of detail in a physics shape, create the physics shape manually using an SCNPhysicsShape class method.NoteFor nodes containing custom geometry, the physics shape SceneKit automatically creates is a rough approximation of the geometry. This approximation, or convex hull, provides a compromise between accuracy and performance in collision detection. For the best collision detection performance, create an SCNPhysicsShape instance based on a basic geometry class (SCNBox, SCNSphere, SCNPyramid, SCNCone, SCNCylinder, or SCNCapsule).
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514766-dynamic
   */


  static dynamic() {
    return new SCNPhysicsBody(SCNPhysicsBodyType.dynamic);
  }
  /**
   * Creates a physics body that is unaffected by forces or collisions but that can cause collisions affecting other bodies when moved.
   * @access public
   * @returns {SCNPhysicsBody} - 
   * @desc Use kinematic bodies for scene elements that you want to control directly but whose movement manipulates other elements. For example, to allow the user to push objects around with a finger, you might create a kinematic body and attach it to an invisible node that you move follow touch events. (In macOS, use the same technique to allow the user to move objects with the mouse pointer.)For the body to participate in collision detection or respond to forces, you must attach it to the physicsBody property of an SCNNode object in a scene.SceneKit automatically creates a physics shape for the body when you attach it to a node, based on that node’s geometry property. To create a physics shape that’s based on the geometries of a node and its hierarchy of children, or to control the level of detail in a physics shape, create the physics shape manually using an SCNPhysicsShape class method.NoteFor nodes containing custom geometry, the physics shape SceneKit automatically creates is a rough approximation of the geometry. This approximation, or convex hull, provides a compromise between accuracy and performance in collision detection. For the best collision detection performance, create an SCNPhysicsShape instance based on a basic geometry class (SCNBox, SCNSphere, SCNPyramid, SCNCone, SCNCylinder, or SCNCapsule).
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514776-kinematic
   */


  static kinematic() {
    return new SCNPhysicsBody(SCNPhysicsBodyType.kinematic);
  } // Applying Forces, Impulses, and Torques

  /**
   * Applies a force or impulse to the body at its center of mass.
   * @access public
   * @param {SCNVector3} direction - The direction and magnitude of the force (in newtons) or of the impulse (in newton-seconds).
   * @param {boolean} impulse - true to apply an instantaneous change in momentum; false to apply a force that affects the body at the end of the simulation step.
   * @returns {void}
   * @desc Applying a force or impulse to a body imparts a linear acceleration proportional to its mass.The impulse parameter determines how this method contributes to the physics simulation:If you specify true, SceneKit treats the direction parameter as an impulse, measured in newton-seconds, and accelerates the physics body immediately. Use this option to simulate instantaneous effects such as launching a projectile.If you specify false, SceneKit treats the direction parameter as a force, measured in newtons. At the end of each simulation step (by default, a step occurs once for each frame in the rendering loop), SceneKit sums all forces applied to the physics body during that step and accelerates the body according to the net effect of those forces. Use this option when you want to simulate continuous forces on the body by calling applyForce(_:asImpulse:) on each simulation step.NoteThe impulse parameter effectively changes the unit of magnitude. A value that results in a certain acceleration when applied continuously on each frame of the simulation results in much less acceleration if applied only during a single frame.As with all physical quantities in SceneKit, you need not use realistic force measurements in your app—the effects of the physics simulation depend on the relative differences between forces, not on their absolute values. You may use whatever values produce the behavior or gameplay you’re looking for as long as you use them consistently.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514801-applyforce
   */


  applyForceAsImpulse(direction, impulse) {}
  /**
   * Applies a force or impulse to the body at a specific point.
   * @access public
   * @param {SCNVector3} direction - The direction and magnitude of the force (in newtons) or of the impulse (in newton-seconds).
   * @param {SCNVector3} position - The point on the body where the force or impulse should be applied, in the local coordinate system of the SCNNode object containing the physics body.
   * @param {boolean} impulse - true to apply an instantaneous change in momentum; false to apply a force that affects the body at the end of the simulation step.
   * @returns {void}
   * @desc Applying a force or impulse to a body at a position other than its center of mass may impart both linear and angular acceleration, depending on how the body is situated in the physics world and the other forces acting upon it.The impulse parameter determines how this method contributes to the physics simulation:If you specify true, SceneKit treats the direction parameter as an impulse, measured in newton-seconds, and accelerates the physics body immediately. Use this option to simulate instantaneous effects such as launching a projectile.If you specify false, SceneKit treats the direction parameter as a force, measured in newtons. At the end of each simulation step (by default, a step occurs once for each frame in the rendering loop), SceneKit sums all forces applied to the physics body during that step and accelerates the body according to the net effect of those forces. Use this option when you want to simulate continuous forces on the body by calling applyForce(_:at:asImpulse:) on each simulation step.NoteThe impulse parameter effectively changes the unit of magnitude. A value that results in a certain acceleration when applied continuously on each frame of the simulation results in much less acceleration if applied only during a single frame.As with all physical quantities in SceneKit, you need not use realistic force measurements in your app—the effects of the physics simulation depend on the relative differences between forces, not on their absolute values. You may use whatever values produce the behavior or gameplay you’re looking for as long as you use them consistently.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514750-applyforce
   */


  applyForceAtAsImpulse(direction, position, impulse) {}
  /**
   * Applies a net torque or a change in angular momentum to the body.
   * @access public
   * @param {SCNVector4} torque - The direction and magnitude of the torque (in newton-meters) or of the change of angular momentum (in newton-meter-seconds), relative to the world coordinate space of the scene. 
   * @param {boolean} impulse - true to apply an instantaneous change in angular momentum; false to apply a torque that affects the body at the end of the simulation step.
   * @returns {void}
   * @desc Applying a torque to a body changes its angular velocity by an amount related to its mass and shape, rotating it without affecting its linear acceleration. Each component of the torque vector relates to rotation about the corresponding axis in the local coordinate system of the SCNNode object containing the physics body. For example, applying a torque of {0.0, 0.0, 1.0} causes a node to spin counterclockwise around the world-space z-axis.The impulse parameter determines how this method contributes to the physics simulation:If you specify true, SceneKit treats the direction parameter as an instantaneous change in angular momentum, measured in newton-meter-seconds.If you specify false, SceneKit treats the direction parameter as a torque, measured in newton-meters. At the end of each simulation step (by default, a step occurs once for each frame in the rendering loop), SceneKit sums all forces and torques applied to the physics body during that step and accelerates the body according to the net effect of those forces and torques. Use this option when you want to simulate gradual acceleration by calling applyTorque(_:asImpulse:) on each simulation step.NoteThe impulse parameter effectively changes the unit of magnitude. A value that results in a certain acceleration when applied continuously on each frame of the simulation results in much less acceleration if applied only during a single frame.As with all physical quantities in SceneKit, you need not use realistic force and torque measurements in your app—the effects of the physics simulation depend on the relative differences between forces, not on their absolute values. You may use whatever values produce the behavior or gameplay you’re looking for as long as you use them consistently.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514752-applytorque
   */


  applyTorqueAsImpulse(torque, impulse) {}
  /**
   * Cancels all continuous forces and torques acting on the physics body during the current simulation step.
   * @access public
   * @returns {void}
   * @desc When you pass false for the impulse parameter in the applyForce(_:asImpulse:), applyForce(_:at:asImpulse:), or applyTorque(_:asImpulse:) method, SceneKit waits until the end of the current simulation step before applying its effect. At that time, SceneKit sums all forces and torques applied during that simulation step and changes the velocity or angular velocity of the body according to the net effect of those forces and torques.Call clearAllForces() to cancel any forces and torques previously applied during the current simulation step.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514735-clearallforces
   */


  clearAllForces() {} // Managing a Body’s Motion

  /**
   * A Boolean value that indicates whether the physics body is at rest.
   * @type {boolean}
   * @desc This property’s default value is false, but SceneKit’s physics simulation may automatically set it to true if the body is not moving and not affected by any forces. A resting body does not participate in the simulation until another body collides with it or you change its position or velocity or apply a force to it.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514795-isresting
   */


  get isResting() {
    return this._isResting;
  } // Synchronizing a Physics Body with its Node

  /**
   * Updates the position and orientation of a body in the physics simulation to match that of the node to which the body is attached.
   * @access public
   * @returns {void}
   * @desc If you change the position or orientation of a node with an attached static or dynamic physics body, call this method afterward to ensure that the physics simulation incorporates the change. You need not call this method for kinematic bodies.Note that dynamic and physics bodies are designed to be moved only by the physics simulation or not at all. You may use this method to move them regardless of this restriction, but at a cost to performance.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514782-resettransform
   */


  resetTransform() {
    this._resetTransform(true);
  }

  _resetTransform(updateWorldTransform = false) {
    if (this._node !== null) {
      if (updateWorldTransform) {
        this._node._updateWorldTransform();
      }

      if (this._node._presentation) {
        this._transform = this._node._presentation._worldTransform;
      } else {
        this._transform = this._node._worldTransform;
      }
    }

    this._radius = 0;

    if (!this.physicsShape && this._node && this._node.geometry) {
      this.physicsShape = new SCNPhysicsShape(this._node.geometry);
    }

    if (this.physicsShape) {
      if (!this.physicsShape._sourceObject) {
        this.physicsShape._setSourceObject(this._node);
      }

      if (!this.physicsShape._sourceGeometry) {
        this.physicsShape._setSourceObject(this._sourceObject);
      }

      if (!this.physicsShape._shape) {
        this.physicsShape._createShape();
      }

      const center = this.physicsShape._center;
      this._transform = this._transform.translation(center.x, center.y, center.z);

      if (this.physicsShape._shape) {
        this._radius = this.physicsShape._shape.getBoundingSphere().radius;
      }
    }

    this._position = this._transform.getTranslation();
    this._invTransform = this._transform.invert();
  }
  /**
   * @access private
   * @returns {void}
   */


  _updateRigidBody() {
    if (this._btRigidBody !== null) ; //Ammo.destroy(this._btRigidBody)
    //this._btRigidBody = this._createRigidBody()

  }
  /**
   * @access private
   * @returns {Ammo.btRigidBody} -
   * @desc call Ammo.destroy(rigidBody) after using it.
   */


  _createRigidBody() {//let btTransform = null
    //if(this.physicsShape === null){
    //  return null
    //}
    //if(this._node !== null){
    //  btTransform = this._node._createBtTransform()
    //}else{
    //  btTransform = new Ammo.btTransform()
    //  btTransform.setIdentity()
    //}
    //const btShape = this.physicsShape._createBtCollisionShape()
    //const inertia = this.momentOfInertia._createBtVector3()
    //const info = new Ammo.btRigidBodyConstructionInfo(btTransform, btShape, inertia)
    //const rigidBody = new Ammo.btRigidBody(info)
    //return rigidBody
  }

  _execDestroy() {} //if(this.physicsShape !== null){
  //  this.physicsShape._destroy()
  //  this.physicsShape = null
  //}
  //if(this._btRigidBody !== null){
  //  Ammo.destroy(this._btRigidBody)
  //  this._btRigidBody = null
  //}
  // FIXME: use physics library


  _getPosition() {
    let pos = new SCNVector3(0, 0, 0);

    if (this._node !== null) {
      pos = this._node._worldTranslation;
    }

    if (this.physicsShape !== null && this.physicsShape._sourceGeometry !== null) {
      const c = this.physicsShape._sourceGeometry.getBoundingSphere().center;

      pos = pos.add(c);
    }

    return pos;
  }

  _getRadius() {
    if (this.physicsShape === null || this.physicsShape._sourceGeometry === null) {
      return 0;
    }

    return this.physicsShape._sourceGeometry.getBoundingSphere().radius;
  }

}

/**
 * Default values for a physics body’s categoryBitMask and collisionBitMask properties.
 * @access public
 * @see https://developer.apple.com/documentation/scenekit/scnphysicscollisioncategory
 */

class SCNPhysicsCollisionCategory {
  // Constants

  /**
   * The default categoryBitMask value for dynamic and kinematic bodies.
   * @type {SCNPhysicsCollisionCategory}
   * @desc 
   * @see https://developer.apple.com/documentation/scenekit/scnphysicscollisioncategory/1514799-default
   */
  get default() {
    return this._default;
  }
  /**
   * The default categoryBitMask value for static bodies.
   * @type {SCNPhysicsCollisionCategory}
   * @desc 
   * @see https://developer.apple.com/documentation/scenekit/scnphysicscollisioncategory/1514778-static
   */


  get static() {
    return this._static;
  }
  /**
   * This is the default value for a physics body’s collisionBitMask property.
   * @type {SCNPhysicsCollisionCategory}
   * @desc With this collision mask, a physics body can collide with all other physics bodies.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicscollisioncategory/1514784-all
   */


  get all() {
    return this._all;
  } // Initializers

  /**
   * 
   * @access public
   * @param {number} rawValue - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnphysicscollisioncategory/1523649-init
   */


  init(rawValue) {
    // Constants
    this._default = null;
    this._static = null;
    this._all = null;
  }

}

//import SCNPhysicsContact from './SCNPhysicsContact'

/**
 * Methods you can implement to respond when a contact or collision occurs between two physics bodies in a scene.
 * @interface
 * @see https://developer.apple.com/documentation/scenekit/scnphysicscontactdelegate
 */

class SCNPhysicsContactDelegate {
  /**
   * constructor
   * @access public
   * @constructor
   */
  //construtor() {
  //}
  // Responding to Contact Events

  /**
   * Tells the delegate that two bodies have come into contact.
   * @access public
   * @param {SCNPhysicsWorld} world - The physics world that is processing the contact.
   * @param {SCNPhysicsContact} contact - An object that describes the contact.
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnphysicscontactdelegate/1512835-physicsworld
   */
  physicsWorldDidBegin(world, contact) {}
  /**
   * Tells the delegate that new information is available about an ongoing contact.
   * @access public
   * @param {SCNPhysicsWorld} world - The physics world that is processing the contact.
   * @param {SCNPhysicsContact} contact - An object that describes the contact.
   * @returns {void}
   * @desc SceneKit calls this method on each step of the physics simulation (see the timeStep property) if information about the contact changes—for example, if two bodies are sliding against one another.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicscontactdelegate/1512865-physicsworld
   */


  physicsWorldDidUpdate(world, contact) {}
  /**
   * Tells the delegate that a contact has ended.
   * @access public
   * @param {SCNPhysicsWorld} world - The physics world that is processing the contact.
   * @param {SCNPhysicsContact} contact - An object that describes the contact.
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnphysicscontactdelegate/1512883-physicsworld
   */


  physicsWorldDidEnd(world, contact) {}

}

//import SCNVector3 from './SCNVector3'
//import SCNPhysicsFieldScope from './SCNPhysicsFieldScope'

/**
 * An object that applies forces, such as gravitation, electromagnetism, and turbulence, to physics bodies within a certain area of effect. 
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield
 */

class SCNPhysicsField extends NSObject {
  /**
   * constructor
   * @access public
   * @constructor
   */
  constructor() {
    super(); // Specifying a Field’s Area of Effect

    /**
     * A location marking the end of the field’s area of effect.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388138-halfextent
     */

    this.halfExtent = null;
    /**
     * The area affected by the field, either inside or outside its region.
     * @type {SCNPhysicsFieldScope}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388136-scope
     */

    this.scope = null;
    /**
     * A Boolean value that determines whether the field’s area of effect is shaped like a box or ellipsoid.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388158-usesellipsoidalextent
     */

    this.usesEllipsoidalExtent = false;
    /**
     * The offset of the field’s center within its area of effect.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388154-offset
     */

    this.offset = null;
    /**
     * The field’s directional axis.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388128-direction
     */

    this.direction = null; // Specifying a Field’s Behavior

    /**
     * A multiplier for the force that the field applies to objects in its area of effect.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388132-strength
     */

    this.strength = 0;
    /**
     * An exponent that determines how the field’s strength diminishes with distance.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388146-falloffexponent
     */

    this.falloffExponent = 0;
    /**
     * The minimum value for distance-based effects.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388148-minimumdistance
     */

    this.minimumDistance = 0;
    /**
     * A Boolean value that determines whether the field’s effect is enabled.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388117-isactive
     */

    this.isActive = false;
    /**
     * A Boolean value that determines whether the field overrides other fields whose areas of effect it overlaps.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388126-isexclusive
     */

    this.isExclusive = false; // Choosing Physics Bodies to Be Affected by the Field

    /**
     * A mask that defines which categories this physics field belongs to.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388119-categorybitmask
     */

    this.categoryBitMask = 0;
  } // Creating Physics Fields

  /**
   * Creates a field that slows any object in its area of effect with a force proportional to the object’s velocity.
   * @access public
   * @returns {SCNPhysicsField} - 
   * @desc Like the damping and angularDamping properties of a physics body, drag fields can simulate effects such as fluid friction or air resistance. Unlike those properties, drag fields can simulate different intensities of fluid friction in different areas of your scene. For example, you can use a drag field to represent underwater areas.The default falloffExponent value for a drag field is 0.0, indicating that the field’s effect is constant throughout its area of effect.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388164-drag
   */


  static drag() {
    return null;
  }
  /**
   * Creates a field whose forces circulate around an axis.
   * @access public
   * @returns {SCNPhysicsField} - 
   * @desc The force on an object in a vortex field is tangential to the line from the object’s position to the field’s axis and proportional to the object’s mass. (The field’s axis is a line that is parallel to its direction vector and that passes through its center. For details, see the offset property.) For example, when a vortex field’s area of effect contains many objects, the resulting scene resembles a tornado: The objects simultaneously revolve around and fly away from the field’s center.By default, a vortex circulates counterclockwise relative to its direction vector. To make it circulate clockwise, set the field’s strength property to a negative value.The default falloffExponent value for a vortex field is 0.0, indicating that the field’s effect is constant throughout its area of effect.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388160-vortex
   */


  static vortex() {
    return null;
  }
  /**
   * Creates a field that accelerates objects toward its center.
   * @access public
   * @returns {SCNPhysicsField} - 
   * @desc Because the force of gravity on an object is proportional to the object’s mass, this force accelerates all objects at the same distance from the field’s center by the same amount. The field’s strength property measures this acceleration in meters per second per second.By default, a radial gravity field attracts objects toward its center. To make it repel objects instead, set the field’s strength property to a negative value.The default falloffExponent value for a radial gravity field is 2.0, indicating that the field’s effect diminishes with the square of distance from its center.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388115-radialgravity
   */


  static radialGravity() {
    return null;
  }
  /**
   * Creates a field that accelerates objects in a specific direction.
   * @access public
   * @returns {SCNPhysicsField} - 
   * @desc Because the force of gravity on an object is proportional to the object’s mass, this force accelerates all objects in the field’s area of affect by the same amount. The field’s strength property measures this acceleration in meters per second per second.By default, a linear gravity field accelerates objects in along its direction vector. To make it accelerate objects in the opposite direction, set the field’s strength property to a negative value.The default falloffExponent value for a linear gravity field is 0.0, indicating that the field’s effect is constant throughout its area of effect.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388130-lineargravity
   */


  static linearGravity() {
    return null;
  }
  /**
   * Creates a field that applies random forces to objects in its area of effect.
   * @access public
   * @param {number} smoothness - The amount of randomness in the field. A value of 0.0 specifies maximum noise, and a value of 1.0 specifies no noise at all.
   * @param {number} speed - The field’s variation over time. Specify 0.0 for a static field.
   * @returns {SCNPhysicsField} - 
   * @desc Use this field type to simulate effects involving random motion, such as fireflies or gently falling snow.In calculating the direction and strength of the field’s effect on an object, SceneKit uses a Perlin simplex noise function. This function produces a velocity field that varies over time.The default falloffExponent value for a noise field is 0.0, indicating that the field’s effect is constant throughout its area of effect. This field type ignores the field’s direction property.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388150-noisefield
   */


  static noiseFieldAnimationSpeed(smoothness, speed) {
    return null;
  }
  /**
   * Creates a field that applies random forces to objects in its area of effect, with magnitudes proportional to those objects’ velocities.
   * @access public
   * @param {number} smoothness - The amount of randomness in the field. A value of 0.0 specifies maximum noise, and a value of 1.0 specifies no noise at all.
   * @param {number} speed - The field’s variation over time. Specify 0.0 for a static field.
   * @returns {SCNPhysicsField} - 
   * @desc Like a noise field, a turbulence field applies forces in random directions to the objects that it affects. Unlike a noise field, a turbulence field applies a force whose magnitude is proportional to the speed of each affected object. For example, an object passing through a noise field shakes as it travels through the field, but an object passing through a turbulence field shakes more violently the faster it travels. The field’s strength property scales the magnitude of the turbulence effect.The default falloffExponent value for a turbulence field is 0.0, indicating that the field’s effect is constant throughout its area of effect.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388162-turbulencefield
   */


  static turbulenceFieldAnimationSpeed(smoothness, speed) {
    return null;
  }
  /**
   * Creates a field that pulls objects toward its center with a spring-like force.
   * @access public
   * @returns {SCNPhysicsField} - 
   * @desc The force a spring field applies to objects in its area of effect is linearly proportional to the distance from the object to the center of the field. (That is, the field behaves according to Hooke’s Law of real-world spring forces.) An object placed at the center of the field and moved away will oscillate around the center, with a period of oscillation that is proportional to the object’s mass. The field’s strength property scales the magnitude of the spring effect—a larger strength simulates a stiffer spring.The default falloffExponent value for a spring field is 1.0, indicating that the field’s effect diminishes linearly with distance from its center.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388134-spring
   */


  static spring() {
    return null;
  }
  /**
   * Creates a field that attracts or repels objects based on their electrical charge and on their distance from the field’s center.
   * @access public
   * @returns {SCNPhysicsField} - 
   * @desc Use this field type to make objects behave differently from one another when they enter a region, or to make an object's behavior different from its mass-based behavior. An electric field behaves according to the first part of the Lorentz force equation modeling real-world electromagnetic forces—the field applies a force whose magnitude is proportional to electric charge and distance.By default, physics bodies and particle systems have no electric charge, so they are unaffected by electric and magnetic fields. Use the charge property of a physics body or the particleCharge property of a particle system to add charge-based behavior.When the field’s strength value is positive (the default), it attracts bodies whose charge is negative and repels bodies whose charge is positive. To reverse this behavior, set the field’s strength property to a negative value.The default falloffExponent value for an electric field is 2.0, indicating that the field’s effect diminishes with the square of its distance from its center.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388152-electric
   */


  static electric() {
    return null;
  }
  /**
   * Creates a field that attracts or repels objects based on their electrical charge, velocity, and distance from the field’s axis.
   * @access public
   * @returns {SCNPhysicsField} - 
   * @desc Use this field type to make objects behave differently from one another when they enter a region, or to make an object's behavior different from its mass based behavior. A magnetic field behaves according to the second part of the Lorentz force equation modeling real-world electromagnetic forces—the field applies a force determined by the cross product of an object’s velocity vector and the magnetic field vector at the object’s location, with magnitude proportional to the object’s electric charge. By default, physics bodies and particle systems have no electric charge, so they are unaffected by electric and magnetic fields. Use the charge property of a physics body or the particleCharge property of a particle system to add charge-based behavior.When the field’s strength value is positive (the default), the magnetic field vectors circulate counterclockwise relative to the field’s direction vector. (That is, the magnetic field models a real-world magnetic field created by current in a wire oriented in the field’s direction.) To make field vectors circulate clockwise, set the field’s strength property to a negative value.NoteThis SCNPhysicsField option models the real-world physics effect of magnetic fields on moving, electrically charged bodies, not the behavior of permanent magnets or electromagnets. To make objects in your scene simply attract or repel one another, use a different field type. For example, a field created by the radialGravity() method attracts or repels all dynamic bodies near it according to its strength property, and a field created by the electric() method selectively attracts or repels bodies according to their electric charge.The default falloffExponent value for a magnetic field is 2.0, indicating that the field’s effect diminishes with the square of distance from its center.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388168-magnetic
   */


  static magnetic() {
    return null;
  } // Creating Custom Physics Fields

  /**
   * Creates a field that runs the specified block to determine the force a field applies to each object in its area of effect.
   * @access public
   * @param {SCNFieldForceEvaluator} block - A block that SceneKit runs for each object in the field’s area of effect. See SCNFieldForceEvaluator. 
   * @returns {SCNPhysicsField} - 
   * @desc For custom physics fields, SceneKit ignores the direction, strength, falloffExponent, and minimumDistance properties. Instead, SceneKit calls your block to determine the direction and magnitude of force to apply to each physics body or particle in the field’s area of effect.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388140-customfield
   */


  static customFieldEvaluationBlock(block) {
    return null;
  }

}

/**
 * Options for defining the region of space affected by a physics field, used by the scope property.
 * @typedef {Object} SCNPhysicsFieldScope
 * @property {number} insideExtent - The field’s effect applies only to objects within the region of space defined by its position and extent.
 * @property {number} outsideExtent - The field’s effect applies only to objects outside the region of space defined by its position and extent.
 * @see https://developer.apple.com/documentation/scenekit/scnphysicsfieldscope
 */

const SCNPhysicsFieldScope = {
  insideExtent: 0,
  outsideExtent: 1
};

//import SCNVector3 from './SCNVector3'

/**
 * A physics behavior that connects two bodies and allows them to pivot around each other on a single axis.
 * @access public
 * @extends {SCNPhysicsBehavior}
 * @see https://developer.apple.com/documentation/scenekit/scnphysicshingejoint
 */

class SCNPhysicsHingeJoint extends SCNPhysicsBehavior {
  // Creating a Hinge Joint

  /**
   * Creates a hinge joint connecting two physics bodies.
   * @access public
   * @constructor
   * @param {SCNPhysicsBody} bodyA - The first physics body to be connected by the joint.
   * @param {SCNVector3} axisA - The axis that the hinge pivots around, relative to the node containing the first body.
   * @param {SCNVector3} anchorA - The point at which the hinge connects, relative to the node containing the first body.
   * @param {SCNPhysicsBody} bodyB - The second physics body to be connected by the joint.
   * @param {SCNVector3} axisB - The axis that the hinge pivots around, relative to the node containing the second body.
   * @param {SCNVector3} anchorB - The point at which the hinge connects, relative to the node containing the second body.
   * @desc For a behavior to take effect, add it to the physics simulation by calling the addBehavior(_:) method on your scene’s SCNPhysicsWorld object. The physics bodies constrained by the joint must be attached to nodes in the scene.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicshingejoint/1387898-init
   */
  constructor(bodyA, axisA, anchorA, bodyB, axisB, anchorB) {
    super(); // Managing the Characteristics of a Hinge Joint

    /**
     * The axis that the hinge pivots around, relative to the node containing the first body.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicshingejoint/1387888-axisa
     */

    this.axisA = null;
    /**
     * The point at which the hinge connects, relative to the node containing the first body.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicshingejoint/1387936-anchora
     */

    this.anchorA = null;
    /**
     * The axis that the hinge pivots around, relative to the node containing the second body.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicshingejoint/1387914-axisb
     */

    this.axisB = null;
    /**
     * The point at which the hinge connects, relative to the node containing the second body.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicshingejoint/1387979-anchorb
     */

    this.anchorB = null;
    this._bodyA = null;
    this._bodyB = null;
  } // Managing the Characteristics of a Hinge Joint

  /**
   * The first physics body connected by the joint.
   * @type {SCNPhysicsBody}
   * @desc 
   * @see https://developer.apple.com/documentation/scenekit/scnphysicshingejoint/1387973-bodya
   */


  get bodyA() {
    return this._bodyA;
  }
  /**
   * The second physics body connected by the joint.
   * @type {?SCNPhysicsBody}
   * @desc This property’s value is nil if the joint was created using the init(body:axis:anchor:) method.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicshingejoint/1387918-bodyb
   */


  get bodyB() {
    return this._bodyB;
  }

}

/**
 *
 * @access public
 * @extends {SCNPhysicsField}
 *
 */

class SCNPhysicsNoiseField extends SCNPhysicsField {
  /**
   * constructor
   * @access public
   * @constructor
   */
  constructor() {
    super();
    this._smoothness = 0.0;
    this._animationSpeed = 1.0;
  }

}

//import SCNVector3 from './SCNVector3'

/**
 * A physics behavior that connects two bodies and allows them to slide against each other and rotate around their connecting points.
 * @access public
 * @extends {SCNPhysicsBehavior}
 * @see https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint
 */

class SCNPhysicsSliderJoint extends SCNPhysicsBehavior {
  // Creating a Slider Joint

  /**
   * Creates a slider joint connecting two physics bodies.
   * @access public
   * @constructor
   * @param {SCNPhysicsBody} bodyA - The first physics body to be connected by the joint.
   * @param {SCNVector3} axisA - The axis along which the first body can slide, relative to the node containing it.
   * @param {SCNVector3} anchorA - The point at which the joint connects, relative to the node containing the first body.
   * @param {SCNPhysicsBody} bodyB - The second physics body to be connected by the joint.
   * @param {SCNVector3} axisB - The axis along which the second body can slide, relative to the node containing it.
   * @param {SCNVector3} anchorB - The point at which the joint connects, relative to the node containing the second body.
   * @desc This method defines the location where the bodies are pinned together. To define their sliding or rotation motion relative to that point, use the properties listed in Limiting the Motion of a Slider Joint.For a behavior to take effect, add it to the physics simulation by calling the addBehavior(_:) method on your scene’s SCNPhysicsWorld object. The physics bodies constrained by the joint must be attached to nodes in the scene.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387922-init
   */
  constructor(bodyA, axisA, anchorA, bodyB, axisB, anchorB) {
    super(); // Managing the Characteristics of a Slider Joint

    /**
     * The axis along which the first body can slide, relative to the node containing it.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387900-axisa
     */

    this.axisA = null;
    /**
     * The point at which the joint connects, relative to the node containing the first body.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387958-anchora
     */

    this.anchorA = null;
    /**
     * The axis along which the second body can slide, relative to the node containing it.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387948-axisb
     */

    this.axisB = null;
    /**
     * The point at which the joint connects, relative to the node containing the second body.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387916-anchorb
     */

    this.anchorB = null;
    this._bodyA = null;
    this._bodyB = null; // Limiting the Motion of a Slider Joint

    /**
     * The minimum distance between the anchor points of the two bodies, relative to their initial positions.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387920-minimumlinearlimit
     */

    this.minimumLinearLimit = 0;
    /**
     * The maximum distance between the anchor points of the two bodies, relative to their initial positions.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387890-maximumlinearlimit
     */

    this.maximumLinearLimit = 0;
    /**
     * The minimum rotation angle between the two bodies, measured in radians relative to their initial orientations.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387967-minimumangularlimit
     */

    this.minimumAngularLimit = 0;
    /**
     * The maximum rotation angle between the two bodies, measured in radians relative to their initial orientations.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387924-maximumangularlimit
     */

    this.maximumAngularLimit = 0; // Applying Forces and Torques

    /**
     * The velocity at which the joint’s connected bodies should slide.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387938-motortargetlinearvelocity
     */

    this.motorTargetLinearVelocity = 0;
    /**
     * The maximum linear force that the joint can apply to its connected bodies, in newtons.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387954-motormaximumforce
     */

    this.motorMaximumForce = 0;
    /**
     * The angular velocity at which the joint’s connected bodies should rotate around it.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387908-motortargetangularvelocity
     */

    this.motorTargetAngularVelocity = 0;
    /**
     * The maximum torque that the joint can apply to its connected bodies, in newton-meters.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387961-motormaximumtorque
     */

    this.motorMaximumTorque = 0;
  } // Managing the Characteristics of a Slider Joint

  /**
   * The first physics body connected by the joint.
   * @type {SCNPhysicsBody}
   * @desc 
   * @see https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387987-bodya
   */


  get bodyA() {
    return this._bodyA;
  }
  /**
   * The second physics body connected by the joint.
   * @type {?SCNPhysicsBody}
   * @desc This property’s value is nil if the joint was created using the init(body:axis:anchor:) method.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387896-bodyb
   */


  get bodyB() {
    return this._bodyB;
  }

}

/**
 *
 * @access public
 * @extends {SCNPhysicsField}
 *
 */

class SCNPhysicsTurbulenceField extends SCNPhysicsNoiseField {
  static get _propTypes() {
    return {
      halfExtent: 'SCNVector3',
      scope: 'integer',
      // SCNPhysicsFieldScope
      usesEllipsoidalExtent: 'boolean',
      offset: 'SCNVector3',
      // direction: 'SCNVector3',
      strength: 'float',
      falloffExponent: 'float',
      minimumDistance: 'float',
      active: ['boolean', 'isActive'],
      exclusive: ['boolean', 'isExclusive'],
      // categoryBitMask: 'integer',
      smoothness: ['float', '_smoothness'],
      animationSpeed: ['float', '_animationSpeed']
    };
  }
  /**
   * constructor
   * @access public
   * @constructor
   */
  //constructor() {
  //  super()
  //}


}

//import SCNPhysicsVehicleWheel from './SCNPhysicsVehicleWheel'

/**
 * A physics behavior that modifies a physics body to behave like a car, motorcycle, or other wheeled vehicle.
 * @access public
 * @extends {SCNPhysicsBehavior}
 * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehicle
 */

class SCNPhysicsVehicle extends SCNPhysicsBehavior {
  // Creating a Vehicle

  /**
   * Creates a vehicle behavior.
   * @access public
   * @constructor
   * @param {SCNPhysicsBody} chassisBody - A physics body to serve as the vehicle’s chassis.
   * @param {SCNPhysicsVehicleWheel[]} wheels - An array of SCNPhysicsVehicleWheel objects representing the vehicle’s wheels. A vehicle must have at least one wheel.
   * @desc Each object in the wheels array associates a node with the wheel to serve as its visual representation and defines properties for the wheel’s physical characteristics. Each wheel object must reference a unique node, which should be a child of the node containing the physics body used for the vehicle’s chassis. Typically, you load a node hierarchy representing the vehicle and all of its wheels from a scene file and then designate which nodes serve as the body and wheels.For a behavior to take effect, you must add it to the physics simulation by calling the addBehavior(_:) method on your scene’s SCNPhysicsWorld object.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehicle/1387943-init
   */
  constructor(chassisBody, wheels) {
    super(); // Working with a Vehicle’s Physical Characteristics

    this._chassisBody = null;
    this._wheels = null; // Driving a Vehicle

    this._speedInKilometersPerHour = 0;
  } // Working with a Vehicle’s Physical Characteristics

  /**
   * The physics body representing the vehicle’s chassis.
   * @type {SCNPhysicsBody}
   * @desc The vehicle’s chassis must be a dynamic body.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehicle/1387985-chassisbody
   */


  get chassisBody() {
    return this._chassisBody;
  }
  /**
   * An array of SCNPhysicsVehicleWheel objects representing the vehicle’s wheels.
   * @type {SCNPhysicsVehicleWheel[]}
   * @desc You can dynamically change the suspension and traction properties of a wheel connected to the vehicle by using the corresponding SCNPhysicsVehicleWheel object or by using Key-value coding with a keypath of the form wheels[index].propertyName. For example, the following code changes the size of the first wheel attached to the vehicle, simulating a failed tire:SCNPhysicsVehicle *vehicle = [SCNPhysicsVehicle vehicleWithChassisBody:car wheels:wheels];
  [vehicle setValue:@0.1 forKeyPath:@"wheels[0].radius"];
  SCNPhysicsVehicle *vehicle = [SCNPhysicsVehicle vehicleWithChassisBody:car wheels:wheels];
  [vehicle setValue:@0.1 forKeyPath:@"wheels[0].radius"];
    * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehicle/1387906-wheels
   */


  get wheels() {
    return this._wheels;
  } // Driving a Vehicle

  /**
   * Applies a force between the specified wheel and the ground under the vehicle.
   * @access public
   * @param {number} value - The magnitude of the force, in newtons.
   * @param {number} index - The index of the wheel applying the force.
   * @returns {void}
   * @desc Applying a positive force turns the wheel in a direction that would move the vehicle forward; applying a negative force moves the vehicle in reverse.As with all physical quantities in SceneKit, you need not use realistic force measurements in your app—the effects of the physics simulation depend on the relative differences between forces, not on their absolute values. You may use whatever values produce the behavior or gameplay you’re looking for as long as you use them consistently.Calling this method applies a force for one step (or frame) of the physics simulation. To continuously accelerate a vehicle, call this method again on subequent simulation steps (for example, from your scene renderer delegate’s renderer(_:updateAtTime:) method) until the vehicle reaches your desired speed.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehicle/1387963-applyengineforce
   */


  applyEngineForceForWheelAt(value, index) {}
  /**
   * Applies a force between the specified wheel and the ground under the vehicle.
   * @access public
   * @param {number} value - The magnitude of the torque, in newton-meters.
   * @param {number} index - The index of the wheel applying the force.
   * @returns {void}
   * @desc Applying a braking force causes the wheel to slow down regardless of the direction it’s currently spinning in.As with all physical quantities in SceneKit, you need not use realistic force measurements in your app—the effects of the physics simulation depend on the relative differences between forces, not on their absolute values. You may use whatever values produce the behavior or gameplay you’re looking for as long as you use them consistently.Calling this method applies a braking force for one step (or frame) of the physics simulation. To continuously decelerate a vehicle, call this method again on subequent simulation steps (for example, from your scene renderer delegate’s renderer(_:updateAtTime:) method) until the vehicle stops or reaches your desired speed.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehicle/1387894-applybrakingforce
   */


  applyBrakingForceForWheelAt(value, index) {}
  /**
   * Pivots the specified wheel around its steering axis.
   * @access public
   * @param {number} value - The angle to set the wheel at relative to its steering axis, in radians.
   * @param {number} index - The index, in the vehicle’s wheels array, of the wheel to be pivoted.
   * @returns {void}
   * @desc Steering angles are relative to the wheel’s steeringAxis vector. With the default steering axis of {0.0, -1.0, 0.0}, a steering angle of 0.0 represents neutral steering, positive values steer the vehicle to the right, and negative values steer to the left.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehicle/1387952-setsteeringangle
   */


  setSteeringAngleForWheelAt(value, index) {}
  /**
   * The vehicle’s ground speed, in kilometers per hour.
   * @type {number}
   * @desc 
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehicle/1387910-speedinkilometersperhour
   */


  get speedInKilometersPerHour() {
    return this._speedInKilometersPerHour;
  }

}

//import SCNVector3 from './SCNVector3'

/**
 * The appearance and physical characteristics of an individual wheel associated with an physics vehicle behavior.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehiclewheel
 */

class SCNPhysicsVehicleWheel extends NSObject {
  // Creating a Wheel

  /**
   * Creates a wheel object.
   * @access public
   * @constructor
   * @param {SCNNode} node - The node whose contents provide the wheel’s visual representation.
   * @desc The node representing a wheel must be a child of the node whose physics body serves as the chassis of the SCNPhysicsVehicle behavior the wheel is attached to. Each wheel object must reference a unique node. To use the wheel, add it to the vehicle behavior using the addWheel: method.SceneKit uses the node’s bounding box to determine the wheel’s initial size, and it uses the node’s position to determine the where the wheel connects to the vehicle’s chassis. You can change attributes using the radius and connectionPosition properties.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehiclewheel/1387989-init
   */
  constructor(node) {
    super(); // Managing a Wheel’s Connection to a Vehicle

    /**
     * The position of the wheel’s connection to the vehicle’s chassis.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehiclewheel/1387959-connectionposition
     */

    this.connectionPosition = null;
    /**
     * The direction of the axis that the wheel spins around to move the vehicle.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehiclewheel/1387969-axle
     */

    this.axle = null;
    /**
     * The direction of the axis that the wheel pivots around to steer the vehicle.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehiclewheel/1387882-steeringaxis
     */

    this.steeringAxis = null; // Simulating Wheel Size

    /**
     * The radius of the wheel.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehiclewheel/1387991-radius
     */

    this.radius = 0; // Simulating Traction

    /**
     * The traction between the wheel and any surface in contact with it.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehiclewheel/1387904-frictionslip
     */

    this.frictionSlip = 0; // Simulating Suspension

    /**
     * The spring coefficient of the suspension between the vehicle and the wheel.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehiclewheel/1387983-suspensionstiffness
     */

    this.suspensionStiffness = 0;
    /**
     * The coefficient that limits the speed of the suspension returning to its rest length when compressed.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehiclewheel/1387971-suspensioncompression
     */

    this.suspensionCompression = 0;
    /**
     * The damping ratio that limits oscillation in the vehicle’s suspension.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehiclewheel/1387886-suspensiondamping
     */

    this.suspensionDamping = 0;
    /**
     * The maximum distance that the wheel is allowed to move up or down relative to its connection point, in centimeters.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehiclewheel/1387928-maximumsuspensiontravel
     */

    this.maximumSuspensionTravel = 0;
    /**
     * The maximum force of the suspension between the vehicle and the wheel, in newtons.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehiclewheel/1387934-maximumsuspensionforce
     */

    this.maximumSuspensionForce = 0;
    /**
     * The resting length of the suspension, in meters.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehiclewheel/1387880-suspensionrestlength
     */

    this.suspensionRestLength = 0; // Inspecting the Wheel Node

    this._node = null;
  } // Inspecting the Wheel Node

  /**
   * The node providing the wheel’s visual representation.
   * @type {SCNNode}
   * @desc SceneKit automatically rotates and repositions this node in response to the physics simulation.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehiclewheel/1387892-node
   */


  get node() {
    return this._node;
  }

}

/**
 * A rectangular, one-sided plane geometry of specified width and height.
 * @access public
 * @extends {SCNGeometry}
 * @see https://developer.apple.com/documentation/scenekit/scnplane
 */

class SCNPlane extends SCNGeometry {
  static get _propTypes() {
    return {
      width: 'float',
      height: 'float',
      widthSegmentCount: 'integer',
      heightSegmentCount: 'integer',
      cornerRadius: 'float',
      cornerSegmentCount: 'integer',
      materials: 'NSArray',
      tessellator: 'SCNGeometryTessellator',
      wantsAdaptiveSubdivision: 'boolean',
      name: 'string',
      primitiveType: ['integer', null],
      subdivisionLevel: 'integer',
      subdivisionSettings: ['bytes', null]
    };
  } // Creating a Plane

  /**
   * Creates a plane geometry with the specified width and height.
   * @access public
   * @constructor
   * @param {number} width - The width of the plane along the x-axis of its local coordinate space.
   * @param {number} height - The height of the plane along the y-axis of its local coordinate space.
   * @desc The plane is centered in its local coordinate system. For example, if you create a plane whose width and height are both 10.0, it extends from -5.0 to 5.0 along both the x- and y-axes, and the z-coordinate of all points in the plane is zero.
   * @see https://developer.apple.com/documentation/scenekit/scnplane/1523631-init
   */


  constructor(width = 1.0, height = 1.0) {
    super([], []); // Adjusting a Plane’s Dimensions

    /**
     * The extent of the plane along its horizontal axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnplane/1523782-width
     */

    this.width = width;
    /**
     * The extent of the plane along its vertical axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnplane/1522837-height
     */

    this.height = height; // Adjusting Geometric Detail

    /**
     * The number of subdivisions in the plane’s surface along its horizontal axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnplane/1523991-widthsegmentcount
     */

    this.widthSegmentCount = 1;
    /**
     * The number of subdivisions in the plane’s surface along its vertical axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnplane/1522889-heightsegmentcount
     */

    this.heightSegmentCount = 1; // Adding Rounded Corners

    /**
     * The radius of curvature for the plane’s corners. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnplane/1523005-cornerradius
     */

    this.cornerRadius = 0;
    /**
     * The number of line segments used to create each rounded corner of the plane. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnplane/1524234-cornersegmentcount
     */

    this.cornerSegmentCount = 10;

    this._createGeometry();

    this.materials.push(new SCNMaterial());
  }

  _createGeometry() {
    const sourceData = [];
    const indexData = []; // TODO: chamfer

    const wStep = 1.0 / this.widthSegmentCount;

    for (let i = 0; i <= this.heightSegmentCount; i++) {
      const ty = i / this.heightSegmentCount;
      const y = (-0.5 + ty) * this.height;

      for (let j = 0; j <= this.widthSegmentCount; j++) {
        const tx = j / this.widthSegmentCount;
        const x = (-0.5 + tx) * this.width;
        sourceData.push(x, y, 0.0); // position

        sourceData.push(0.0, 0.0, 1.0); // normal

        sourceData.push(tx, 1.0 - ty); // texcoord
      }
    }

    const numSegments = this.widthSegmentCount * this.heightSegmentCount;

    for (let i = 0; i < numSegments; i++) {
      const index = i * 4;
      indexData.push(index, index + 1, index + 3);
      indexData.push(index, index + 3, index + 2);
    }

    const vectorCount = (this.widthSegmentCount + 1) * (this.heightSegmentCount + 1);
    const vertexSource = new SCNGeometrySource(sourceData, // data
    SCNGeometrySource.Semantic.vertex, // semantic
    vectorCount, // vectorCount
    true, // floatComponents
    3, // componentsPerVector
    4, // bytesPerComponent
    0, // offset
    32 // sride
    );
    const normalSource = new SCNGeometrySource(sourceData, // data
    SCNGeometrySource.Semantic.normal, // semantic
    vectorCount, // vectorCount
    true, // floatComponents
    3, // componentsPerVector
    4, // bytesPerComponent
    12, // offset
    32 // stride
    );
    const texcoordSource = new SCNGeometrySource(sourceData, // data
    SCNGeometrySource.Semantic.texcoord, // semantic
    vectorCount, // vectorCount
    true, // floatComponents
    2, // componentsPerVector
    4, // bytesPerComponent
    24, // offset
    32 // stride
    );
    const element = new SCNGeometryElement(indexData, SCNGeometryPrimitiveType.triangles);
    this._geometryElements = [element];
    this._geometrySources = [vertexSource, normalSource, texcoordSource];
    this.boundingBox = {
      min: new SCNVector3(-0.5 * this.width, -0.5 * this.height, 0.0),
      max: new SCNVector3(0.5 * this.width, 0.5 * this.height, 0.0)
    };
  }

}

//import SCNBufferFrequency from './SCNBufferFrequency'
//import SCNBufferBindingBlock from './SCNBufferBindingBlock'

/**
 * A complete Metal or OpenGL shader program that replaces SceneKit's rendering of a geometry or material.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/scenekit/scnprogram
 */

class SCNProgram extends NSObject {
  /**
   * constructor
   * @access public
   * @constructor
   */
  constructor() {
    super(); // Working with OpenGL Shader Source Code

    /**
     * GLSL source code for the program’s vertex shader.
     * @type {?string}
     * @see https://developer.apple.com/documentation/scenekit/scnprogram/1522891-vertexshader
     */

    this.vertexShader = null;
    /**
     * GLSL source code for the program’s fragment shader.
     * @type {?string}
     * @see https://developer.apple.com/documentation/scenekit/scnprogram/1523135-fragmentshader
     */

    this.fragmentShader = null;
    /**
     * GLSL source code for the program’s optional geometry shader.
     * @type {?string}
     * @see https://developer.apple.com/documentation/scenekit/scnprogram/1524049-geometryshader
     */

    this.geometryShader = null;
    /**
     * GLSL source code for the program’s optional tessellation control shader.
     * @type {?string}
     * @see https://developer.apple.com/documentation/scenekit/scnprogram/1523852-tessellationcontrolshader
     */

    this.tessellationControlShader = null;
    /**
     * GLSL source code for the program’s optional tessellation evaluation shader.
     * @type {?string}
     * @see https://developer.apple.com/documentation/scenekit/scnprogram/1523760-tessellationevaluationshader
     */

    this.tessellationEvaluationShader = null; // Providing a Delegate Object

    /**
     * The delegate of the program object.
     * @type {?SCNProgramDelegate}
     * @see https://developer.apple.com/documentation/scenekit/scnprogram/1522611-delegate
     */

    this.delegate = null; // Managing Opacity

    /**
     * A Boolean value that indicates whether fragments rendered by the program are fully opaque.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnprogram/1522844-isopaque
     */

    this.isOpaque = false; // Working With Metal Shaders

    /**
     * The name of the vertex shader function to load from a Metal shader library.
     * @type {?string}
     * @see https://developer.apple.com/documentation/scenekit/scnprogram/1522799-vertexfunctionname
     */

    this.vertexFunctionName = null;
    /**
     * The name of the fragment shader function to load from a Metal shader library.
     * @type {?string}
     * @see https://developer.apple.com/documentation/scenekit/scnprogram/1524012-fragmentfunctionname
     */

    this.fragmentFunctionName = null;
    /**
     * The Metal shader library containing shader functions to be used by this program.
     * @type {?MTLLibrary}
     * @see https://developer.apple.com/documentation/scenekit/scnprogram/1522934-library
     */

    this.library = null;
    /**
     * @access private
     * @type {Map<string, NSObject}}
     */

    this._semantics = new Map();
    /**
     * @access private
     * @type {Map<string, SCNBufferBindingBlock>[]}
     */

    this._bufferBindings = [new Map(), new Map(), new Map()];
    /**
     * @access private
     * @type {boolean}
     */

    this._programCompiled = false;
    this._context = null;
    /**
     * @access private
     * @type {WebGLProgram}
     */

    this._glProgram = null;
    /**
     * @access private
     * @type {WebGLShader}
     */

    this._glVertexShader = null;
    /**
     * @access private
     * @type {WebGLShader}
     */

    this._glFragmentShader = null;
    /**
     * @access private
     * @type {WebGLTexture}
     */

    this._dummyTexture = null;
    /**
     * @access private
     * @type {WebGLTexture}
     */

    this._dummyCubeMapTexture = null;
    /**
     * @access private
     * @type {SCNShadable}
     */

    this._parentObject = null;
  } // Mapping GLSL Symbols to SceneKit Semantics

  /**
   * Associates a SceneKit semantic identifier with the specified GLSL vertex attribute or uniform variable.
   * @access public
   * @param {?string} semantic - A SceneKit semantic identifier. See Geometry Semantic Identifiers and Rendering Transform Keys for possible values.
   * @param {string} symbol - The name declared in the program’s GLSL source code for the vertex attribute or uniform variable to be associated with the semantic.
   * @param {?Map<string, Object>} [options = null] - A dictionary of options affecting the semantic. See Program Semantic Options for applicable keys and values.
   * @returns {void}
   * @desc Use this method to provide inputs managed by SceneKit to your GLSL program.To use vertex attributes provided by SCNGeometry objects, use the constants listed in Geometry Semantic Identifiers.To use the coordinate transformations defined by the scene’s node hierarchy and point-of-view camera, use the constants listed in Rendering Transform Keys.
   * @see https://developer.apple.com/documentation/scenekit/scnprogram/1522730-setsemantic
   */


  setSemanticForSymbol(semantic, symbol, options = null) {
    this._semantics.set(symbol, semantic);
  }
  /**
   * Returns the SceneKit semantic identifiers associated with the specified GLSL vertex attribute or uniform variable.
   * @access public
   * @param {string} symbol - The name declared in the program’s GLSL source code for a vertex attribute or uniform variable semantic.
   * @returns {?string} - 
   * @see https://developer.apple.com/documentation/scenekit/scnprogram/1523350-semantic
   */


  semanticForSymbol(symbol) {
    return this._semantics.set(symbol);
  } // Providing Input for Metal Shaders

  /**
   * Registers a block for SceneKit to call at render time for binding a Metal buffer to the shader program.
   * @access public
   * @param {string} name - The name identifying the buffer in Metal shader source code.
   * @param {SCNBufferFrequency} frequency - An option specifying whether SceneKit calls the block only once per rendered frame or more frequently (for example, once for each object to be rendered).
   * @param {SCNBufferBindingBlock} block - A block to be run when SceneKit prepares for rendering with the Metal shader.
   * @returns {void}
   * @desc Use this method to associate a block with a Metal shader program to handle setup of a buffer used in that shader. SceneKit calls your block before rendering any objects whose program property is set to this SCNProgram object. In the block, use the writeBytes(_:count:) method to provide data for the buffer.  
    * @see https://developer.apple.com/documentation/scenekit/scnprogram/1524047-handlebinding
   */


  handleBindingOfBufferNamedHandler(name, frequency, block) {
    this._bufferBindings[frequency].set(name, block);
  }

  _getGLProgramForContext(context) {
    if (this._context === context) {
      if (this._glProgram) {
        return this._glProgram;
      }
    }

    this._context = context;
    this._glProgram = context.createProgram();
    return this._glProgram;
  }

  _setDummyTextureForContext(context) {
    const gl = context;

    this._createDummyTextureForContext(gl);

    const texNames = [gl.TEXTURE0, gl.TEXTURE1, gl.TEXTURE2, gl.TEXTURE3, gl.TEXTURE4, gl.TEXTURE5, gl.TEXTURE6, gl.TEXTURE7, gl.TEXTURE8, gl.TEXTURE9, gl.TEXTURE10, gl.TEXTURE11];
    const texSymbols = ['u_emissionTexture', 'u_ambientTexture', 'u_diffuseTexture', 'u_specularTexture', 'u_reflectiveTexture', 'u_transparentTexture', 'u_multiplyTexture', 'u_normalTexture', 'u_ambientOcclusionTexture', 'u_selfIlluminationTexture', 'u_metalnessTexture', 'u_roughnessTexture'];
    const isCubeMap = [false, false, false, false, true, false, false, false, false, false, false, false];

    for (let i = 0; i < texNames.length; i++) {
      const texName = texNames[i];
      const symbol = texSymbols[i];
      const loc = gl.getUniformLocation(this._glProgram, symbol);

      if (loc !== null) {
        gl.uniform1i(loc, i);
        gl.activeTexture(texName);

        if (isCubeMap[i]) {
          gl.bindTexture(gl.TEXTURE_CUBE_MAP, this._dummyCubeMapTexture);
        } else {
          gl.bindTexture(gl.TEXTURE_2D, this._dummyTexture);
        }
      }
    }
  }

  _createDummyTextureForContext(context) {
    if (this._dummyTexture !== null) {
      return;
    }

    const gl = context;
    const canvas = document.createElement('canvas');
    canvas.width = 1;
    canvas.height = 1;
    const c = canvas.getContext('2d');
    c.fillStyle = 'rgba(255, 255, 255, 1.0)';
    c.fillRect(0, 0, 1, 1);
    this._dummyTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, this._dummyTexture); // texImage2D(target, level, internalformat, width, height, border, format, type, source)
    // Safari complains that 'source' is not ArrayBufferView type, but WebGL2 should accept HTMLCanvasElement.

    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
    gl.bindTexture(gl.TEXTURE_2D, null);
    this._dummyCubeMapTexture = gl.createTexture();
    const targets = [gl.TEXTURE_CUBE_MAP_POSITIVE_Z, gl.TEXTURE_CUBE_MAP_POSITIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, gl.TEXTURE_CUBE_MAP_NEGATIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, gl.TEXTURE_CUBE_MAP_POSITIVE_Y];
    gl.bindTexture(gl.TEXTURE_CUBE_MAP, this._dummyCubeMapTexture);

    for (let i = 0; i < 6; i++) {
      gl.texImage2D(targets[i], 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
    }

    gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
  }

}

//import SCNRenderer from './SCNRenderer'

/**
 * The interface for tracking errors that occur when compiling shader source code.
 * @interface
 * @see https://developer.apple.com/documentation/scenekit/scnprogramdelegate
 */

class SCNProgramDelegate {
  /**
   * constructor
   * @access public
   * @constructor
   */
  //constructor() {
  //}
  // Handling Shader Compilation Errors

  /**
   * Tells the delegate that an error occurred when compiling GLSL source code.
   * @access public
   * @param {SCNProgram} program - The program that generated the compilation error.
   * @param {Error} error - The compilation error that was raised.
   * @returns {void}
   * @desc Examine the error parameter for details of the compilation error provided by the GLSL compiler.
   * @see https://developer.apple.com/documentation/scenekit/scnprogramdelegate/1523007-program
   */
  programHandleError(program, error) {} // Finding Fragment Opaqueness

  /**
   * Asks the delegate whether fragments rendered by a program are opaque.
   * @deprecated
   * @access public
   * @param {SCNProgram} program - 
   * @returns {boolean} - 
   * @see https://developer.apple.com/documentation/scenekit/scnprogramdelegate/1523068-programisopaque
   */


  programIsOpaque(program) {
    return false;
  } // Binding and Unbinding Values

  /**
   * Invoked on the delegate to let it bind program values and/or associated graphics resources (such as textures) for symbols.
   * @deprecated
   * @access public
   * @param {SCNProgram} program - The SCNProgram object to bind values for.
   * @param {string} symbol - The name of the symbol to bind a value for.
   * @param {number} location - The location of the symbol within the program object to be modified.
   * @param {number} programID - The underlying OpenGL program object in which the binding is made.
   * @param {SCNRenderer} renderer - The renderer that is currently rendering the scene.
   * @returns {boolean} - 
   * @desc If you use the handleBinding(ofSymbol:handler:) method to associate a handler block with a SceneKit object for a symbol, SceneKit will not call the delegate’s program(_:bindValueForSymbol:atLocation:programID:renderer:) method for that symbol when rendering that object.
   * @see https://developer.apple.com/documentation/scenekit/scnprogramdelegate/1524155-program
   */


  programBindValueForSymbolAtLocation(program, symbol, location, programID, renderer) {
    return false;
  }
  /**
   * Invoked on the delegate to let it unbind program values and/or also unbind associated graphic resources (such as textures).
   * @deprecated
   * @access public
   * @param {SCNProgram} program - The SCNProgram object to unbind values for.
   * @param {string} symbol - The name of the symbol to unbind a value for.
   * @param {number} location - The location of the symbol within the program object to be modified.
   * @param {number} programID - The underlying OpenGL program object in which the unbinding is done.
   * @param {SCNRenderer} renderer - The renderer that is currently rendering the scene.
    * @returns {void}
   * @desc If you use the handleUnbinding(ofSymbol:handler:) method to associate a handler block with a SceneKit object for a symbol, SceneKit will not call the delegate’s program(_:unbindValueForSymbol:atLocation:programID:renderer:) method for that symbol when rendering that object.
   * @see https://developer.apple.com/documentation/scenekit/scnprogramdelegate/1523857-program
   */


  programUnbindValueForSymbolAtLocation(program, symbol, location, programID, renderer) {}

}

/**
 * A right rectangular pyramid geometry.
 * @access public
 * @extends {SCNGeometry}
 * @see https://developer.apple.com/documentation/scenekit/scnpyramid
 */

class SCNPyramid extends SCNGeometry {
  // Creating a Pyramid

  /**
   * Creates a pyramid geometry with the specified width, height, and length.
   * @access public
   * @constructor
   * @param {number} width - The width of the pyramid along the x-axis of its local coordinate space.
   * @param {number} height - The height of the pyramid along the y-axis of its local coordinate space.
   * @param {number} length - The length of the pyramid along the z-axis of its local coordinate space.
   * @desc The pyramid’s base is centered in its local coordinate system. For example, if you create a pyramid whose width, height and length are all 10.0, its apex is at the point {0, 10.0, 0}, and its base lies in the plane whose y-coordinate is 0.0, extending from -5.0 to 5.0 along both the x- and z-axes.
   * @see https://developer.apple.com/documentation/scenekit/scnpyramid/1523254-init
   */
  constructor(width = 1.0, height = 1.0, length = 1.0) {
    super([], []); // Adjusting a Pyramid’s Dimensions

    /**
     * The extent of the pyramid along its x-axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnpyramid/1522613-width
     */

    this.width = 1.0;
    /**
     * The extent of the pyramid along its y-axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnpyramid/1522805-height
     */

    this.height = height;
    /**
     * The extent of the pyramid along its z-axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnpyramid/1524203-length
     */

    this.length = length; // For the original SceneKit, the default value is 0.0, but it should be 1.0.
    // Adjusting Geometric Detail

    /**
     * The number of subdivisions in each face of the pyramid along its x-axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnpyramid/1523083-widthsegmentcount
     */

    this.widthSegmentCount = 1;
    /**
     * The number of subdivisions in each face of the pyramid along its y-axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnpyramid/1524059-heightsegmentcount
     */

    this.heightSegmentCount = 1;
    /**
     * The number of subdivisions in each face of the pyramid along its z-axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnpyramid/1524227-lengthsegmentcount
     */

    this.lengthSegmentCount = 1;

    this._createGeometry();

    this.materials.push(new SCNMaterial());
  }

  _createGeometry() {
    const sourceData = []; // TODO: use segment count

    const right = this.width * 0.5;
    const left = -right;
    const front = this.length * 0.5;
    const back = -front;
    const top = this.height;
    const bottom = 0;
    /*
    const nfront = (new SCNVector3(0, front, top)).normalize()
    const nleft = (new SCNVector3(top, left, 0)).normalize()
    const nright = (new SCNVector3(top, right, 0)).normalize()
    const nback = (new SCNVector3(0, back, top)).normalize()
    const tex = [[0.0, 1.0], [0.0, 0.0], [1.0, 1.0], [1.0, 0.0]]
    */
    // front

    sourceData.push(...this._createSideFace(left, front, right, front)); // right

    sourceData.push(...this._createSideFace(right, front, right, back)); // back

    sourceData.push(...this._createSideFace(right, back, left, back)); // left

    sourceData.push(...this._createSideFace(left, back, left, front)); // bottom

    sourceData.push(left, 0, back);
    sourceData.push(0, -1, 0);
    sourceData.push(0.0, 1.0);
    sourceData.push(right, 0, back);
    sourceData.push(0, -1, 0);
    sourceData.push(1.0, 1.0);
    sourceData.push(left, 0, front);
    sourceData.push(0, -1, 0);
    sourceData.push(0.0, 0.0);
    sourceData.push(right, 0, front);
    sourceData.push(0, -1, 0);
    sourceData.push(1.0, 0.0);
    const vectorCount = 20; // TODO: use segmentCount

    const vertexSource = new SCNGeometrySource(sourceData, // data
    SCNGeometrySource.Semantic.vertex, // semantic
    vectorCount, // vectorCount
    true, // floatComponents
    3, // componentsPerVector
    4, // bytesPerComponent
    0, // offset
    32 // sride
    );
    const normalSource = new SCNGeometrySource(sourceData, // data
    SCNGeometrySource.Semantic.normal, // semantic
    vectorCount, // vectorCount
    true, // floatComponents
    3, // componentsPerVector
    4, // bytesPerComponent
    12, // offset
    32 // stride
    );
    const texcoordSource = new SCNGeometrySource(sourceData, // data
    SCNGeometrySource.Semantic.texcoord, // semantic
    vectorCount, // vectorCount
    true, // floatComponents
    2, // componentsPerVector
    4, // bytesPerComponent
    24, // offset
    32 // stride
    );
    const elements = []; // TODO: use segmentCount

    const indexData = [[0, 2, 3], [4, 6, 7], [8, 10, 11], [12, 14, 15], [16, 17, 19, 16, 19, 18]];

    for (let i = 0; i < 5; i++) {
      elements.push(new SCNGeometryElement(indexData[i], SCNGeometryPrimitiveType.triangles));
    }

    this._geometryElements = elements;
    this._geometrySources = [vertexSource, normalSource, texcoordSource];
    this.boundingBox = {
      min: new SCNVector3(left, bottom, back),
      max: new SCNVector3(right, top, front)
    };
  }

  _createSideFace(x0, z0, x1, z1) {
    const top = this.height;
    const data = [];
    let normal = new SCNVector3();

    if (x0 === x1) {
      normal.x = top;
      normal.y = x0;

      if (x0 < 0) {
        normal.x = -normal.x;
        normal.y = -normal.y;
      }
    } else if (z0 === z1) {
      normal.z = top;
      normal.y = z0;

      if (z0 < 0) {
        normal.z = -normal.z;
        normal.y = -normal.y;
      }
    } else {
      throw new Error('position inconsistent');
    }

    normal = normal.normalize(); // left bottom

    data.push(x0, 0, z0);
    data.push(normal.x, normal.y, normal.z);
    data.push(0.0, 1.0); // top

    data.push(0, this.height, 0);
    data.push(normal.x, normal.y, normal.z);
    data.push(0.0, 0.0); // right bottom

    data.push(x1, 0, z1);
    data.push(normal.x, normal.y, normal.z);
    data.push(1.0, 1.0); // top again

    data.push(0, this.height, 0);
    data.push(normal.x, normal.y, normal.z);
    data.push(1.0, 0.0);
    return data;
  }

}

/**
 * A representation of a quaternion.
 * @type {SCNVector4}
 * @desc A quaternion is a mathematical construct useful for describing rotations in three-dimensional space. Although its implementation differs from that of a 4-component vector, you specify a quaternion value using the same fields as an SCNVector4 structure.SceneKit uses unit quaternions (those whose components satisfy the equation x*x + y*y + z*z + w*w == 1) for the orientation property of nodes.
 * @see https://developer.apple.com/documentation/scenekit/scnquaternion
 */

const SCNQuaternion = SCNVector4;

/**
 * Options for when to load the reference node’s content, used by the loadingPolicy property.
 * @typedef {Object} SCNReferenceLoadingPolicy
 * @property {number} immediate - Load the node’s external content immediately when the reference node is unarchived.
 * @property {number} onDemand - Load the node’s external comment only when the load() method is called.
 * @see https://developer.apple.com/documentation/scenekit/scnreferenceloadingpolicy
 */

const SCNReferenceLoadingPolicy = {
  immediate: 0,
  onDemand: 1
};

/**
 * A scene graph node that serves as a placeholder for content to be loaded from a separate scene file. 
 * @access public
 * @extends {SCNNode}
 * @see https://developer.apple.com/documentation/scenekit/scnreferencenode
 */

class SCNReferenceNode extends SCNNode {
  static get _propTypes() {
    return {
      paused: ['boolean', 'isPaused'],
      scale: ['SCNVector3', '_scale'],
      rotation: ['SCNVector4', '_rotation'],
      orientation: ['SCNVector4', (obj, value) => {
        obj.orientation = value;
      }],
      position: ['SCNVector3', '_position'],
      loadingPolicy: 'integer',
      referenceURL: ['NSURL', (obj, value) => {
        obj.referenceURL = value;
        obj.load();
      }],
      opacity: ['float', '_opacity'],
      castsShadow: 'boolean',
      categoryBitMask: 'integer',
      hidden: ['boolean', 'isHidden'],
      name: 'string',
      renderingOrder: 'integer',
      movabilityHint: 'integer',
      clientAttributes: ['NSMutableDictionary', null],
      overrides: ['NSObject', null] // what is this?

    };
  } // Creating a Reference Node

  /**
   * Initializes a node whose content is to be loaded from the referenced URL.
   * @access public
   * @constructor
   * @param {string} referenceURL - The URL to a scene file from which to load the node’s content.
   * @desc Using this initializer does not load the node’s content. To load content from the referenced URL, use the load() method.
   * @see https://developer.apple.com/documentation/scenekit/scnreferencenode/1523967-init
   */


  constructor(referenceURL) {
    super();
    /**
     * @access private
     * @type {boolean}
     */

    this._isLoading = false;
    /**
     * @access private
     * @type {boolean}
     */

    this._isLoaded = false; // Loading and Unloading a Reference Node’s Content

    /**
     * An option for whether to load the node’s content automatically.
     * @type {SCNReferenceLoadingPolicy}
     * @see https://developer.apple.com/documentation/scenekit/scnreferencenode/1522996-loadingpolicy
     */

    this.loadingPolicy = null;
    /**
     * The URL to a scene file from which to load content for the reference node.
     * @type {string}
     * @see https://developer.apple.com/documentation/scenekit/scnreferencenode/1522733-referenceurl
     */

    this._referenceURL = referenceURL;
    this._scene = null;

    if (referenceURL) {
      this.load();
    }
    /**
     * @access private
     * @type {Promise}
     */


    this._loadedPromise = null;
  } // Loading and Unloading a Reference Node’s Content

  /**
   * Loads content into the node from its referenced external scene file.
   * @access public
   * @returns {void}
   * @desc When SceneKit loads the referenced scene file, all children of the scene file’s root node become children of the reference node.If the node has already been loaded (either automatically, according to the loadingPolicy property, or through a previous call to this method), calling this method has no effect.
   * @see https://developer.apple.com/documentation/scenekit/scnreferencenode/1523204-load
   */


  load() {
    if (this._isLoaded || this._isLoading) {
      return;
    }

    if (!this._referenceURL) {
      return;
    }

    this._isLoading = true;
    const promise = new Promise((resolve, reject) => {
      const scene = new SCNScene(this._referenceURL, null);
      scene.didLoad.then(() => {
        scene.rootNode.name = 'referenceRoot';
        super.addChildNode(scene.rootNode);
        this._scene = scene;
        this._isLoaded = true;
        this._isLoading = false;
        resolve();
      }).catch(() => {
        reject();
      });
    });
    this._loadedPromise = promise.then(() => this._scene.didLoad);
  }
  /**
   * Removes the node’s children and marks the node as not loaded.
   * @access public
   * @returns {void}
   * @desc Calling this method does not necessarily unload any content associated with the node’s child nodes from memory—it merely removes them from the scene graph. The unlinked nodes and their content are then subject to normal object memory management rules. Under ARC, those objects are deallocated if and only if they are not referenced from elsewhere in your program.
   * @see https://developer.apple.com/documentation/scenekit/scnreferencenode/1523566-unload
   */


  unload() {
    if (!this._isLoaded) {
      return;
    }

    this.childNodes.forEach(child => {
      child.removeFromParentNode();
    });
    this._isLoaded = false;
    this._loadedPromise = null;
  }
  /**
   * A Boolean value that indicates whether the reference node has already loaded its content.
   * @type {boolean}
   * @desc 
   * @see https://developer.apple.com/documentation/scenekit/scnreferencenode/1523906-isloaded
   */


  get isLoaded() {
    return this._isLoaded;
  } // Initializers

  /**
   * 
   * @access public
   * @param {NSCoder} aDecoder - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnreferencenode/1524061-init
   */


  initCoder(aDecoder) {}

  get referenceURL() {
    return this._referenceURL;
  }

  set referenceURL(newValue) {
    this.unload();
    this._referenceURL = newValue;

    if (this.loadingPolicy === SCNReferenceLoadingPolicy.immediate) {
      this.load();
    }
  }

  addChildNode(child) {
    throw new Error('cannot add a child node to SCNReferenceNode');
  }

  insertChildNodeAt(child, index) {
    throw new Error('cannot add a child node to SCNReferenceNode');
  }

  replaceChildNodeWith(oldChild, newChild) {
    throw new Error('cannot add a child node to SCNReferenceNode');
  }

  get childNodes() {
    // FIXME: needs synchronous loading
    if (!this._isLoaded) {
      this.load();
    }

    return this._childNodes.slice(0);
  }
  /**
   * @access private
   * @returns {Promise} -
   */


  _getLoadedPromise() {
    if (this._loadedPromise) {
      return this._loadedPromise;
    }

    this.load();
    return this._loadedPromise;
  }
  /**
   * @access public
   * @type {Promise} -
   */


  get didLoad() {
    return this._getLoadedPromise();
  }

}

/**
 * The modes that describe how the source and destination pixel colors are used to calculate the new destination color.
 * @typedef {Object} SKBlendMode
 * @property {number} alpha - The source and destination colors are blended by multiplying the source alpha value.
 * @property {number} add - The source and destination colors are added together.
 * @property {number} subtract - The source color is subtracted from the destination color.
 * @property {number} multiply - The source color is multiplied by the destination color.
 * @property {number} multiplyX2 - The source color is multiplied by the destination color and then doubled.
 * @property {number} screen - The source color is added to the destination color times the inverted source color.
 * @property {number} replace - The source color replaces the destination color.
 * @see https://developer.apple.com/documentation/spritekit/skblendmode
 */

const SKBlendMode = {
  alpha: 0,
  add: 1,
  subtract: 2,
  multiply: 3,
  multiplyX2: 4,
  screen: 5,
  replace: 6
};

//import SKScene from './SKScene'
//import SKAction from './SKAction'
//import SKPhysicsBody from './SKPhysicsBody'
//import GKPolygonObstacle from '../undefined/GKPolygonObstacle'
//import GKEntity from '../undefined/GKEntity'
//import NSMutableDictionary from '../undefined/NSMutableDictionary'
//import SKConstraint from './SKConstraint'
//import SKReachConstraints from './SKReachConstraints'
//import NSCoder from '../undefined/NSCoder'
//import SKAttributeValue from './SKAttributeValue'

/**
 * The SKNode class is the fundamental building block of most SpriteKit content. 
 * @access public
 * @extends {NSObject}
 * @implements {UIFocusItem}
 * @see https://developer.apple.com/documentation/spritekit/sknode
 */

class SKNode extends NSObject {
  // Initializers

  /**
   * 
   * @access public
   * @constructor
   * @see https://developer.apple.com/documentation/spritekit/sknode/1483097-init
   */
  constructor() {
    super(); // Inspecting the Node’s Position

    /**
     * The position of the node in its parent's coordinate system.
     * @type {CGPoint}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483101-position
     */

    this.position = new CGPoint(0, 0);
    /**
     * The height of the node relative to its parent.
     * @type {number}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483107-zposition
     */

    this.zPosition = 0.0;
    this._frame = new CGRect(new CGPoint(0, 0), new CGSize(0, 0)); // Setting a Node’s Scaling and Rotation

    /**
     * A scaling factor that multiplies the width of a node and its children.
     * @type {number}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483087-xscale
     */

    this.xScale = 1.0;
    /**
     * A scaling factor that multiplies the height of a node and its children.
     * @type {number}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483046-yscale
     */

    this.yScale = 1.0;
    /**
     * The Euler rotation about the z axis (in radians).
     * @type {number}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483089-zrotation
     */

    this.zRotation = 0.0; // Inspecting a Node’s Visibility

    /**
     * The transparency value applied to the node’s contents.
     * @type {number}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483023-alpha
     */

    this.alpha = 1.0;
    /**
     * A Boolean value that determines whether a node and its descendants are rendered.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483048-ishidden
     */

    this.isHidden = false; // Determining Whether a Node Supports User Interaction

    /**
     * A Boolean value that indicates whether the node receives touch events.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483109-isuserinteractionenabled
     */

    this.isUserInteractionEnabled = false; // Working with Node Trees

    this._children = [];
    this._parent = null;
    this._scene = null; // Naming Nodes

    /**
     * The node’s assignable name.
     * @type {?string}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483136-name
     */

    this.name = null; // Running Actions

    /**
     * A speed modifier applied to all actions executed by a node and its descendants.
     * @type {number}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483036-speed
     */

    this.speed = 1.0;
    /**
     * A Boolean value that determines whether actions on the node and its descendants are processed.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483113-ispaused
     */

    this.isPaused = false;
    /**
     * @access private
     * @type {Map}
     */

    this._actions = new Map(); // Adding Physics to a Node

    /**
     * The physics body associated with the node.
     * @type {?SKPhysicsBody}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483117-physicsbody
     */

    this.physicsBody = null; // Working with GameplayKit Entities

    /**
     * The GameplayKit entity this node represents.
     * @type {?GKEntity}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1640688-entity
     */
    //this.entity = null
    // Storing Custom Node Data

    /**
     * A dictionary containing arbitrary data.
     * @type {?NSMutableDictionary}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483121-userdata
     */

    this.userData = null; // Constraining a Node’s Behavior Relative to Other Nodes

    /**
     * Specifies the list of constraints to apply to the node.
     * @type {?SKConstraint[]}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483124-constraints
     */

    this.constraints = null;
    /**
     * Specifies the reach constraints to apply to the node when executing a reach action.
     * @type {?SKReachConstraints}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483019-reachconstraints
     */

    this.reachConstraints = null; // Instance Properties

    /**
     * 
     * @type {?Object[]}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1645045-accessibilitychildren
     */

    this.accessibilityChildren = [];
    /**
     * 
     * @type {CGRect}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1645044-accessibilityframe
     */

    this.accessibilityFrame = new CGRect(new CGPoint(0, 0), new CGSize(0, 0));
    /**
     * 
     * @type {?string}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1645041-accessibilityhelp
     */

    this.accessibilityHelp = null;
    /**
     * 
     * @type {?string}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1645039-accessibilitylabel
     */

    this.accessibilityLabel = null;
    /**
     * 
     * @type {?Object}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1645042-accessibilityparent
     */

    this.accessibilityParent = null;
    /**
     * 
     * @type {?string}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1645036-accessibilityrole
     */

    this.accessibilityRole = 'AXImage';
    /**
     * 
     * @type {?string}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1645035-accessibilityroledescription
     */

    this.accessibilityRoleDescription = 'SKNode';
    /**
     * 
     * @type {?string}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1645043-accessibilitysubrole
     */

    this.accessibilitySubrole = null;
    /**
     * The values of each attribute associated with the node's attached shader. 
     * @type {Map<string, SKAttributeValue>}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1644181-attributevalues
     */

    this.attributeValues = new Map();
    /**
     * 
     * @type {boolean}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1645038-isaccessibilityelement
     */

    this.isAccessibilityElement = false;
    /**
     * 
     * @type {boolean}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1645037-isaccessibilityenabled
     */

    this.isAccessibilityEnabled = false;
    /**
     * @type {SKNode}
     * @access private
     */

    this.__presentation = null;
    this._isPresentationInstance = false;
    this._worldPosition = new CGPoint(0, 0);
    this._worldZPosition = 0;
    this._worldXScale = 1;
    this._worldYScale = 1;
    this._worldZRotation = 0;
  }
  /**
   * 
   * @access public
   * @param {NSCoder} aDecoder - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/spritekit/sknode/1483142-init
   */
  //initWithCoder(aDecoder) {
  //}
  // Creating a New Node

  /**
   * Creates a new node by loading an archive file from the game’s main bundle.
   * @access public
   * @param {string} filename - The name of the file, without a file extension. The file must be in the app’s main bundle and have a .sks filename extension.
   * @returns {void}
   * @desc If you call this method on a subclass of the SKScene class and the object in the archive is an SKScene object, the returned object is initialized as if it is a member of the subclass. You use this behavior to create scene layouts in the Xcode Editor and provide custom behaviors in your subclass. 
   * @see https://developer.apple.com/documentation/spritekit/sknode/1483083-init
   */


  static nodeWithFileNamed(filename) {
    const node = new SKNode();
    return node;
  } // Inspecting the Node’s Position

  /**
   * Calculates a rectangle in the parent’s coordinate system that contains the content of the node and all of its descendants. 
   * @access public
   * @returns {CGRect} - 
   * @desc The frame takes into the account the cumulative effect of the xScale, yScale, and zRotation properties of each node in the subtree.Listing 1 shows how calculateAccumulatedFrame() can be used display the bounding box of a shape node. The child node, although smaller than its parent, is rotated by 30° so that its bounds extend beyond its parent's bounds. After childNode has been added to parentNode, a further shape node, boundingBoxNode, is created with its size based on the accumulated frame of parentNode.Listing 1 Displaying the accumulated frame of a shape nodelet parentNode = SKShapeNode(rectOf: CGSize(width: 500, height: 500))
  parentNode.lineWidth = 2
  parentNode.strokeColor = .blue
  parentNode.fillColor = .clear
     
  let childNode = SKShapeNode(rectOf: CGSize(width: 400, height: 400))
  childNode.strokeColor = .red
  childNode.fillColor = .clear
  childNode.zRotation = -CGFloat.pi / 6 // pi / 6 = 30°
     
  parentNode.addChild(childNode)
     
  let boundingBoxNode = SKShapeNode(rectOf: parentNode.calculateAccumulatedFrame().size)
  boundingBoxNode.lineWidth = 1
  boundingBoxNode.strokeColor = .black
  boundingBoxNode.fillColor = .clear
  boundingBoxNode.path = boundingBoxNode.path?.copy(dashingWithPhase: 0,
                                                  lengths: [10,10])
     
  parentNode.addChild(boundingBoxNode)
  Figure 1 shows the result of Listing 1 with parentNode rendered in blue, childNode rendered in red and the boundingBoxNode rendered with a dashed line. Figure 1 Displaying the accumulated frame of a shape nodeDisplaying the accumulated frame of a shape nodelet parentNode = SKShapeNode(rectOf: CGSize(width: 500, height: 500))
  parentNode.lineWidth = 2
  parentNode.strokeColor = .blue
  parentNode.fillColor = .clear
     
  let childNode = SKShapeNode(rectOf: CGSize(width: 400, height: 400))
  childNode.strokeColor = .red
  childNode.fillColor = .clear
  childNode.zRotation = -CGFloat.pi / 6 // pi / 6 = 30°
     
  parentNode.addChild(childNode)
     
  let boundingBoxNode = SKShapeNode(rectOf: parentNode.calculateAccumulatedFrame().size)
  boundingBoxNode.lineWidth = 1
  boundingBoxNode.strokeColor = .black
  boundingBoxNode.fillColor = .clear
  boundingBoxNode.path = boundingBoxNode.path?.copy(dashingWithPhase: 0,
                                                  lengths: [10,10])
     
  parentNode.addChild(boundingBoxNode)
  Displaying the accumulated frame of a shape node
   * @see https://developer.apple.com/documentation/spritekit/sknode/1483066-calculateaccumulatedframe
   */


  calculateAccumulatedFrame() {
    let r = this._frame.copy();

    for (const child of this._children) {
      r = r.union(child.calculateAccumulatedFrame());
    }

    return r;
  }
  /**
   * A rectangle in the parent’s coordinate system that contains the node’s content, ignoring the node’s children.
   * @type {CGRect}
   * @desc The frame is the smallest rectangle that contains the node’s content, taking into account the node’s xScale, yScale, and zRotation properties. Not all nodes contain content of their own.
   * @see https://developer.apple.com/documentation/spritekit/sknode/1483026-frame
   */


  get frame() {
    return this._frame;
  } // Setting a Node’s Scaling and Rotation

  /**
   * Sets the xScale and yScale properties of the node.
   * @access public
   * @param {number} scale - The new value to use for the node’s xScale and yScale properties.
   * @returns {void}
   * @see https://developer.apple.com/documentation/spritekit/sknode/1483126-setscale
   */


  setScale(scale) {
    this.xScale = scale;
    this.yScale = scale;
  } // Working with Node Trees

  /**
   * Adds a node to the end of the receiver’s list of child nodes.
   * @access public
   * @param {SKNode} node - The node to add. The node must not already have a parent.
   * @returns {void}
   * @see https://developer.apple.com/documentation/spritekit/sknode/1483054-addchild
   */


  addChild(node) {
    if (this._children.indexOf(node) >= 0) {
      return;
    }

    node.removeFromParent();

    this._children.push(node);

    node._parent = this;
  }
  /**
   * Inserts a child into a specific position in the receiver’s list of child nodes.
   * @access public
   * @param {SKNode} node - The node to add. The node must not already have a parent.
   * @param {number} index - The position in the array to insert the node.
   * @returns {void}
   * @see https://developer.apple.com/documentation/spritekit/sknode/1483062-insertchild
   */


  insertChildAt(node, index) {
    if (this._children.indexOf(node) >= 0) {
      return;
    }

    node.removeFromParent();

    this._insertObjectInChildrenAtIndex(node, index);

    this._parent = this;
  }
  /**
   * Compares the parameter node to the receiving node.
   * @access public
   * @param {SKNode} node - The node to compare to the receiving node.
   * @returns {boolean} - 
   * @see https://developer.apple.com/documentation/spritekit/sknode/1483078-isequal
   */


  isEqualTo(node) {
    return false;
  }
  /**
   * Moves the node to a new parent node in the scene. 
   * @access public
   * @param {SKNode} parent - An SKNode object to move the receiver to. This node must be in the same scene as the node’s current parent.
   * @returns {void}
   * @desc The node maintains its current position in scene coordinates.
   * @see https://developer.apple.com/documentation/spritekit/sknode/1483021-move
   */


  moveToParent(parent) {
    parent.addChild(this);
  }
  /**
   * Removes the receiving node from its parent.
   * @access public
   * @returns {void}
   * @see https://developer.apple.com/documentation/spritekit/sknode/1483119-removefromparent
   */


  removeFromParent() {
    const parentNode = this._parent;

    if (parentNode === null) {
      return;
    }

    const index = parentNode._children.indexOf(this);

    if (index < 0) {
      return;
    }

    parentNode._removeObjectFromChildrenAtIndex(index);
  }
  /**
   * Removes all of the node’s children.
   * @access public
   * @returns {void}
   * @see https://developer.apple.com/documentation/spritekit/sknode/1483040-removeallchildren
   */


  removeAllChildren() {
    for (const child of this._children) {
      child.removeFromParent();
    }
  }
  /**
   * Removes a list of children from the receiving node.
   * @access public
   * @param {SKNode[]} nodes - An array of SKNode objects that are all children of the receiving node.
   * @returns {void}
   * @see https://developer.apple.com/documentation/spritekit/sknode/1483091-removechildren
   */


  removeChildrenIn(nodes) {
    for (const node of nodes) {
      if (this._children.indexOf(node) >= 0) {
        node.removeFromParent();
      }
    }
  }
  /**
   *
   * @access private
   * @param {number} index -
   * @returns {void}
   */


  _removeObjectFromChildrenAtIndex(index) {
    const arr = this._children.splice(index, 1);

    if (arr.length === 0) {
      return;
    }

    const obj = arr[0];
    obj._parent = null;
  }
  /**
   *
   * @access private
   * @param {SCNNode} object -
   * @param {number} index -
   * @returns {void}
   */


  _insertObjectInChildrenAtIndex(object, index) {
    const length = this._children.length;

    if (index > length) {
      throw new Error(`SKNode.children out of index: ${index} > ${length}`);
    }

    this._children.splice(index, 0, object);
  }
  /**
   * Returns a Boolean value that indicates whether the node is a descendant of the target node.
   * @access public
   * @param {SKNode} parent - An SKNode object to test against.
   * @returns {boolean} - 
   * @see https://developer.apple.com/documentation/spritekit/sknode/1483111-inparenthierarchy
   */


  inParentHierarchy(parent) {
    return false;
  }
  /**
   * The node’s children.
   * @type {SKNode[]}
   * @desc The objects in this array are all SKNode objects.
   * @see https://developer.apple.com/documentation/spritekit/sknode/1483028-children
   */


  get children() {
    return this._children.slice(0);
  }
  /**
   * The node’s parent node.
   * @type {?SKNode}
   * @desc If the node is not in a node tree, the value is nil.
   * @see https://developer.apple.com/documentation/spritekit/sknode/1483080-parent
   */


  get parent() {
    return this._parent;
  }
  /**
   * The scene node that contains the node.
   * @type {?SKScene}
   * @desc If the node is not embedded in a scene, the value is nil.
   * @see https://developer.apple.com/documentation/spritekit/sknode/1483064-scene
   */


  get scene() {
    return this._scene;
  } // Naming Nodes

  /**
   * Searches the children of the receiving node for a node with a specific name.
   * @access public
   * @param {string} name - The name to search for. This may be either the literal name of the node or a customized search string. See Searching the Node Tree.
   * @returns {?SKNode} - 
   * @desc If more than one child share the same name, the first node discovered is returned.
   * @see https://developer.apple.com/documentation/spritekit/sknode/1483060-childnode
   */


  childNodeWithName(name) {
    for (const child of this._children) {
      if (child.name === name) {
        return child;
      }
    }

    return null;
  }
  /**
   * Search the children of the receiving node to perform processing for nodes which share a name.
   * @access public
   * @param {string} name - The name to search for. This may be either the literal name of the node or a customized search string. See Searching the Node Tree.
   * @param {function(arg1: SKNode, arg2: UnsafeMutablePointer<ObjCBool>): void} block - A block to execute on nodes that match the name parameter. The block has the signature (node: SKNode, stop: UnsafeMutablePointer<ObjCBool>).
   * @returns {void}
   * @desc This method enumerates the child array in order, searching for nodes whose names match the search parameter. The block is called once for each node that matches the name parameter.The following code shows how you could enumerate through the child nodes of a scene with a name containing the string yellow. Each matching node is hidden until the enumeration finds a node that also contains the string triangle. When this node is reached, stop is set to true and the processing stops.Listing 1 Enumerating child nodesscene.enumerateChildNodes(withName: "*yellow*") {
    (node, stop) in
    
    node.run(SKAction.hide())
    
    if let name = node.name, name.contains("triangle") {
        stop.initialize(to: true)
    }
  }
  You can also search by class name using enumerateChildNodes(withName:using:). However, for custom classes, you need to specify the fully annotated class name (i.e. the project name followed by the class name). The following code shows a custom class, SpaceshipNode, based on SKSpriteNode, and created in a project named SpaceGame. The first search fails to return an instance of  SpaceshipNode added as a child of parentNode:Listing 2 Enumerating child nodesclass SpaceshipNode: SKSpriteNode {
  }
     
  let parentNode = SKNode()
  let childNode = SpaceshipNode()
  parentNode.addChild(childNode)
     
  parentNode.enumerateChildNodes(withName: "SpaceshipNode") {
    node, _ in
    // Unannotated name, returns no results 
  }
     
  parentNode.enumerateChildNodes(withName: "SpaceGame.SpaceshipNode") {
    node, _ in
    // Annotated name, successfully returns `childNode` 
  }
     
  parentNode.enumerateChildNodes(withName: "SKSpriteNode") {
    node, _ in
    // Superclass name, successfully returns `childNode` 
  }
  Enumerating child nodesscene.enumerateChildNodes(withName: "*yellow*") {
    (node, stop) in
    
    node.run(SKAction.hide())
    
    if let name = node.name, name.contains("triangle") {
        stop.initialize(to: true)
    }
  }
  Enumerating child nodesclass SpaceshipNode: SKSpriteNode {
  }
     
  let parentNode = SKNode()
  let childNode = SpaceshipNode()
  parentNode.addChild(childNode)
     
  parentNode.enumerateChildNodes(withName: "SpaceshipNode") {
    node, _ in
    // Unannotated name, returns no results 
  }
     
  parentNode.enumerateChildNodes(withName: "SpaceGame.SpaceshipNode") {
    node, _ in
    // Annotated name, successfully returns `childNode` 
  }
     
  parentNode.enumerateChildNodes(withName: "SKSpriteNode") {
    node, _ in
    // Superclass name, successfully returns `childNode` 
  }
    * @see https://developer.apple.com/documentation/spritekit/sknode/1483024-enumeratechildnodes
   */


  enumerateChildNodesWithNameUsing(name, block) {} // Running Actions

  /**
   * Adds an action to the list of actions executed by the node.
   * @access public
   * @param {SKAction} action - The action to perform.
   * @returns {void}
   * @desc The new action is processed the next time the scene’s animation loop is processed.
   * @see https://developer.apple.com/documentation/spritekit/sknode/1483093-run
   */


  run(action) {
    this.runWithKey(action, Symbol());
  }
  /**
   * Adds an action to the list of actions executed by the node.
   * @access public
   * @param {SKAction} action - The action to perform.
   * @param {function(): void} block - A completion block called when the action completes.
   * @returns {void}
   * @see https://developer.apple.com/documentation/spritekit/sknode/1483103-run
   */


  runCompletion(action, block) {
    this._runActionForKeyCompletionHandler(action, Symbol(), block);
  }
  /**
   * Adds an identifiable action to the list of actions executed by the node.
   * @access public
   * @param {SKAction} action - The action to perform.
   * @param {string} key - A unique key used to identify the action.
   * @returns {void}
   * @desc This method is identical to run(_:), but the action is stored so that it can be retrieved later. If an action using the same key is already running, it is removed before the new action is added.
   * @see https://developer.apple.com/documentation/spritekit/sknode/1483042-run
   */


  runWithKey(action, key) {
    this._runActionForKeyCompletionHandler(action, key, null);
  }

  _runActionForKeyCompletionHandler(action, key, block) {
    let _key = key;

    if (typeof key === 'undefined' || key === null) {
      _key = Symbol();
    }

    const act = action.copy(); // FIXME: use current frame time

    act._actionStartTime = Date.now() * 0.001;
    act._completionHandler = block;

    this._actions.set(_key, act);
  }
  /**
   * Returns an action associated with a specific key.
   * @access public
   * @param {string} key - A string that uniquely identifies an action.
   * @returns {?SKAction} - 
   * @see https://developer.apple.com/documentation/spritekit/sknode/1483138-action
   */


  actionForKey(key) {
    return this._actions.get(key);
  }
  /**
   * Returns a Boolean value that indicates whether the node is executing actions.
   * @access public
   * @returns {boolean} - 
   * @see https://developer.apple.com/documentation/spritekit/sknode/1483081-hasactions
   */


  hasActions() {
    return this._actions.size > 0;
  }
  /**
   * Ends and removes all actions from the node.
   * @access public
   * @returns {void}
   * @desc When an action is removed from the node, any remaining animation the action would perform is skipped; however, previous changes are not reverted. It is possible that an action may make a final change to the scene when removed; if so, it is documented for the specific action in SKAction.
   * @see https://developer.apple.com/documentation/spritekit/sknode/1483030-removeallactions
   */


  removeAllActions() {
    // TODO: stop actions
    this._actions.clear();
  }
  /**
   * Removes an action associated with a specific key.
   * @access public
   * @param {string} key - A string that uniquely identifies an action.
   * @returns {void}
   * @desc If an action is found that matches the key, it is removed from the node.
   * @see https://developer.apple.com/documentation/spritekit/sknode/1483076-removeaction
   */


  removeActionForKey(key) {
    // TODO: stop action
    this._actions.delete(key);
  } // Converting to and from the Node’s Coordinate System

  /**
   * Converts a point from the coordinate system of another node in the node tree to the coordinate system of this node.
   * @access public
   * @param {CGPoint} point - A point in the other node’s coordinate system.
   * @param {SKNode} node - Another node in the same node tree as this node.
   * @returns {CGPoint} - 
   * @see https://developer.apple.com/documentation/spritekit/sknode/1483058-convert
   */


  convertFrom(point, node) {
    return null;
  }
  /**
   * Converts a point in this node’s coordinate system to the coordinate system of another node in the node tree.
   * @access public
   * @param {CGPoint} point - A point in this node’s coordinate system.
   * @param {SKNode} node - Another node in the same node tree as this node.
   * @returns {CGPoint} - 
   * @see https://developer.apple.com/documentation/spritekit/sknode/1483056-convert
   */


  convertTo(point, node) {
    return null;
  } // Determining If a Point Lies in a Node

  /**
   * Returns a Boolean value that indicates whether a point lies inside the parent’s coordinate system.
   * @access public
   * @param {CGPoint} p - A CGPoint to test against.
   * @returns {boolean} - 
   * @see https://developer.apple.com/documentation/spritekit/sknode/1483044-contains
   */


  contains(p) {
    return false;
  }
  /**
   * Returns the deepest visible descendant that intersects a point.
   * @access public
   * @param {CGPoint} p - A point in the node’s coordinate system.
   * @returns {SKNode} - 
   * @desc A point is considered to be in a node if it lies inside the rectangle returned by the calculateAccumulatedFrame() method.
   * @see https://developer.apple.com/documentation/spritekit/sknode/1483099-atpoint
   */


  atPoint(p) {
    return null;
  }
  /**
   * Returns an array of all visible descendants that intersect a point.
   * @access public
   * @param {CGPoint} p - A point in the node’s coordinate system.
   * @returns {SKNode[]} - 
   * @desc A point is considered to be in a node if it lies inside the rectangle returned by the calculateAccumulatedFrame() method.
   * @see https://developer.apple.com/documentation/spritekit/sknode/1483072-nodes
   */


  nodesAt(p) {
    return null;
  } // Performing Node Intersections

  /**
   * Returns a Boolean value that indicates whether this node intersects the specified node.
   * @access public
   * @param {SKNode} node - Another node in the same node tree.
   * @returns {boolean} - 
   * @desc The two nodes are considered to intersect if their frames intersect. The children of both nodes are ignored in this test.
   * @see https://developer.apple.com/documentation/spritekit/sknode/1483140-intersects
   */


  intersects(node) {
    return false;
  } // Creating GameplayKit Obstacles from a Set of Nodes

  /**
   * Converts each node into an obstacle by transforming its bounds into the scene’s coordinate system.
   * @access public
   * @param {SKNode[]} nodes - An array of SKNode objects.
   * @returns {GKPolygonObstacle[]} - 
   * @desc Use the array of obstacles to create an obstacle graph (GKObstacleGraph) in GameplayKit. See GameplayKit and GameplayKit Programming Guide.
   * @see https://developer.apple.com/documentation/spritekit/sknode/1483132-obstacles
   */


  static obstaclesFromNodeBounds(nodes) {
    return null;
  }
  /**
   * Converts each node into an obstacle by transforming the node’s physics body shape into the scene’s coordinate system.
   * @access public
   * @param {SKNode[]} nodes - An array of SKNode objects.
   * @returns {GKPolygonObstacle[]} - 
   * @desc Use the array of obstacles to create an obstacle graph (GKObstacleGraph) in GameplayKit. See GameplayKit and GameplayKit Programming Guide.
   * @see https://developer.apple.com/documentation/spritekit/sknode/1483085-obstacles
   */


  static obstaclesFromNodePhysicsBodies(nodes) {
    return null;
  }
  /**
   * Converts each node into an obstacle by first transforming the node’s texture into a physics shape and then converting that shape into the scene’s coordinate system.
   * @access public
   * @param {SKNode[]} sprites - An array of SKNode objects.
   * @param {number} accuracy - A floating point value between 0.001 and 1.0, inclusive. Higher values create a more precise (but more complex) representation of the obstacle.
   * @returns {GKPolygonObstacle[]} - 
   * @desc Use the array of obstacles to create an obstacle graph (GKObstacleGraph) in GameplayKit. See GameplayKit and GameplayKit Programming Guide.
   * @see https://developer.apple.com/documentation/spritekit/sknode/1483134-obstacles
   */


  static obstaclesFromSpriteTextures(sprites, accuracy) {
    return null;
  } // Instance Methods

  /**
   * 
   * @access public
   * @param {CGPoint} point - 
   * @returns {?Object} - 
   * @see https://developer.apple.com/documentation/spritekit/sknode/1645040-accessibilityhittest
   */


  accessibilityHitTest(point) {
    return null;
  }
  /**
   * Sets an attribute value for an attached shader
   * @deprecated
   * @access public
   * @param {SKAttributeValue} value - An attribute value object containing the scalar or vector value to set in the attached shader. 
   * @param {string} key - The attribute name.
   * @returns {void}
   * @see https://developer.apple.com/documentation/spritekit/sknode/1644180-setvalue
   */


  setValueForAttribute(value, key) {
    this.attributeValues.set(key, value);
  }
  /**
   * The value of a shader attribute.
   * @deprecated
   * @access public
   * @param {string} key - The attribute name.
   * @returns {?SKAttributeValue} - 
   * @see https://developer.apple.com/documentation/spritekit/sknode/1644182-value
   */


  valueForAttributeNamed(key) {
    return this.attributeValues.get(key);
  }
  /**
   * @type {SKNode}
   */


  get _presentation() {
    return this.__presentation;
  }
  /**
   *
   * @access public
   * @returns {SKNode} -
   */


  copy() {
    const node = super.copy();

    node._copyValue(this);

    return node;
  }

  _copyValue(src) {
    this.position = src.position.copy();
    this.zPosition = src.zPosition;
    this._frame = src._frame;
    this.xScale = src.xScale;
    this.yScale = src.yScale;
    this.zRotation = src.zRotation;
    this.alpha = src.alpha;
    this.isHidden = src.isHidden;
    this.isUserInteractionEnabled = src.isUserInteractionEnabled;
    this.name = src.name;
    this.speed = src.speed;
    this.isPaused = src.isPaused;
    this._actions = new Map(src._actions);
    this.physicsBody = src.physicsBody;
    this.userData = src.userData;
    this.constraints = src.constraints;
    this.reachConstraints = src.reachConstraints;
    this.accessibilityChildren = src.accessibilityChildren;
    this.accessibilityFrame = src.accessibilityFrame.copy();
    this.accessibilityHelp = src.accessibilityHelp;
    this.accessibilityLabel = src.accessibilityLabel;
    this.accessibilityParent = src.accessibilityParent;
    this.accessibilityRole = src.accessibilityRole;
    this.accessibilityRoleDescription = src.accessibilityRoleDescription;
    this.accessibilitySubrole = src.accessibilitySubrole;
    this.attributeValues = new Map(src.attributeValues);
    this.isAccessibilityElement = src.isAccessibilityElement;
    this.isAccessibilityEnabled = src.isAccessibilityEnabled;
  }
  /**
   * @access private
   * @param {WebGLRenderingContext} gl -
   * @returns {void}
   */


  _render(gl) {// nothing to draw
  }

  _copyTransformToPresentation() {
    if (this.__presentation === null) {
      return;
    }

    const p = this.__presentation;
    p.position = this.position;
    p.zPosition = this.zPosition;
    p.xScale = this.xScale;
    p.yScale = this.yScale;
    p.zRotation = this.zRotation;
  }

  _updateWorldTransform() {
    let p = null;
    let pz = 0;

    if (this._parent === null) {
      p = new CGPoint(0, 0);
    } else {
      p = this._parent._worldPosition;
      pz = this._parent._worldZPosition;
    }

    this._worldPosition = this.position.add(p);
    this._worldZPosition = this.zPosition + pz;

    if (this._presentation) {
      let pp = null;
      let ppz = 0;
      let pxScale = 1;
      let pyScale = 1;

      if (this._parent === null) {
        pp = new CGPoint(0, 0);
      } else if (this._parent._presentation === null) {
        pp = this._parent._worldPosition;
        ppz = this._parent._worldZPosition;
        pxScale = this._parent._worldXScale;
        pyScale = this._parent._worldYScale;
      } else {
        pp = this._parent._presentation._worldPosition;
        ppz = this._parent._presentation._worldZPosition;
        pxScale = this._parent._presentation._worldXScale;
        pyScale = this._parent._presentation._worldYScale;
      } //this._presentation._worldPosition = this._presentation.position.add(pp)


      this._presentation._worldPosition.x = pp.x + this._presentation.position.x * pxScale;
      this._presentation._worldPosition.y = pp.y + this._presentation.position.y * pyScale;
      this._presentation._worldZPosition = this._presentation.zPosition + ppz;
      this._presentation._worldXScale = this._presentation.xScale * pxScale;
      this._presentation._worldYScale = this._presentation.yScale * pyScale;
    }

    for (const child of this._children) {
      child._updateWorldTransform();
    }
  }

}

/**
 * Texture filtering modes to use when the texture is drawn in a size other than its native size.
 * @typedef {Object} SKTextureFilteringMode
 * @property {number} nearest - Each pixel is drawn using the nearest point in the texture. This mode is faster, but the results are often pixelated.
 * @property {number} linear - Each pixel is drawn by using a linear filter of multiple texels in the texture. This mode produces higher quality results but may be slower.
 * @see https://developer.apple.com/documentation/spritekit/sktexturefilteringmode
 */

const SKTextureFilteringMode = {
  nearest: 0,
  linear: 1
};

/**
 * A representation of an image for use in SpriteKit.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/spritekit/sktexture
 */

class SKTexture extends NSObject {
  /**
   * constructor
   * @access public
   * @constructor
   */
  constructor() {
    super(); // Inspecting a Texture’s Properties

    /**
     * The filtering mode used when the size of a sprite drawn with the texture is not drawn at the texture’s native size.
     * @type {SKTextureFilteringMode}
     * @see https://developer.apple.com/documentation/spritekit/sktexture/1519659-filteringmode
     */

    this.filteringMode = SKTextureFilteringMode.linear;
    /**
     * A Boolean value that indicates whether the texture attempts to generate mipmaps.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/spritekit/sktexture/1519960-usesmipmaps
     */

    this.usesMipmaps = false; // Instance Properties

    this._customPlaygroundQuickLook = null;
    this._image = null;
    this._glTexture = null;
    this._loadingImagePromise = null;
  } // Creating New Textures from Images

  /**
   * Create a new texture object from an image file stored in the app bundle.
   * @access public
   * @param {string} name - The name of the image file.
   * @returns {void}
   * @desc The new texture object is initialized with the name of the image file and then control returns immediately to your game. Sprite Kit loads and prepares the texture data when it is needed by your game.When loading the texture data, Sprite Kit searches the app bundle for an image file with the specified filename. If a matching image file cannot be found, Sprite Kit searches for the texture in any texture atlases stored in the app bundle. If the specified image does not exist anywhere in the bundle, Sprite Kit creates a placeholder texture image.
   * @see https://developer.apple.com/documentation/spritekit/sktexture/1520086-init
   */


  static textureWithImageNamed(name) {
    const texture = new SKTexture();

    texture._loadImage(name);

    return texture;
  }
  /**
   * Create a new texture object from an image object.
   * @access public
   * @param {Image} image - An image.
   * @returns {void}
   * @desc The image data is copied before control is returned to your game.
   * @see https://developer.apple.com/documentation/spritekit/sktexture/1520136-init
   */


  static textureWithImage(image) {
    const texture = new SKTexture();
    texture._image = image;
    this._loadingImagePromise = Promise.resolve(this);
    return texture;
  }
  /**
   * Create a new texture object from a Quartz 2D image.
   * @access public
   * @param {CGImage} image - A Quartz 2D image (CGImage) object. For more information, see Quartz 2D Programming Guide and CGImage.
   * @returns {void}
   * @desc The image data is copied before control is returned to your game.
   * @see https://developer.apple.com/documentation/spritekit/sktexture/1519576-init
   */


  static textureWithCgImage(image) {
    const texture = new SKTexture();
    texture._image = image;
    this._loadingImagePromise = Promise.resolve(this);
    return texture;
  }
  /**
   * Creates a new texture from a subset of an existing texture.
   * @access public
   * @param {CGRect} rect - A rectangle in the unit coordinate space that specifies the portion of the texture to use.
   * @param {SKTexture} texture - The texture to create the new texture from.
   * @returns {void}
   * @desc The returned texture object shares the same texture data as the original texture object, meaning that only one copy of the texture data is kept in memory.If you call this method on a texture that itself was created using this method, the original texture is used as the source instead. That is, the rectangle is considered to be in the source texture’s coordinate system. To do this, you should use the source texture's textureRect() rather than relying on hard coded {(0,0) (1,1)} as the coordinates.  Listing 1 shows how you can use the source texture's textureRect() to calculate the portion of the texture to use.Listing 1 Creating a texture from a portion of another texture.let originalTexture = SKTexture(imageNamed: "sourceImage.png")
  let rect = CGRect(origin: originalTexture.textureRect().origin,
                  size: CGSize(width: originalTexture.textureRect().midX,
                               height: originalTexture.textureRect().midY))
  let croppedTexture = SKTexture(rect: rect,
                               in: originalTexture)
  In the above example, if originalTexture had a size of (348.0, 282.0) and a textureRect() of {(0,0) (1,1)}, croppedTexture will have a size of (174.0, 141.0) and a textureRect() of {(0,0) (1,1)}. croppedTexture will be a copy of the bottom left quadrant of originalTexture.Creating a texture from a portion of another texture.let originalTexture = SKTexture(imageNamed: "sourceImage.png")
  let rect = CGRect(origin: originalTexture.textureRect().origin,
                  size: CGSize(width: originalTexture.textureRect().midX,
                               height: originalTexture.textureRect().midY))
  let croppedTexture = SKTexture(rect: rect,
                               in: originalTexture)
    * @see https://developer.apple.com/documentation/spritekit/sktexture/1520425-init
   */


  static textureWithRectIn(rect, texture) {
    const texutre = new SKTexture();
    return texture;
  }
  /**
   * Creates a new texture by applying a Core Image filter to an existing texture.
   * @access public
   * @param {CIFilter} filter - A Core Image filter that requires a single inputImage parameter and produces an outputImage parameter.
   * @returns {SKTexture} - 
   * @desc The image data is copied before control is returned to your game.
   * @see https://developer.apple.com/documentation/spritekit/sktexture/1520388-applying
   */


  applying(filter) {
    return null;
  }
  /**
   * Returns the texture’s image data as a Quartz 2D image.
   * @access public
   * @returns {CGImage} - 
   * @see https://developer.apple.com/documentation/spritekit/sktexture/1519755-cgimage
   */


  cgImage() {
    return this._image;
  } // Creating Textures from Raw Pixel Data

  /**
   * Creates a new texture from raw pixel data.
   * @access public
   * @param {Data} pixelData - An NSData object that holds the bitmap data. The pixels must be 32 bpp, 8bpc (unsigned integer) RGBA pixel data. The color components should have been already multiplied by the alpha value.
   * @param {CGSize} size - The size of the new texture in points.
   * @returns {void}
   * @desc The image data is copied before control is returned to your game.Creating textures from raw pixel data is useful if you have a CPU based routine for creating imagery. The following code shows how you can use init(data:size:) to create a texture containing random colors and a solid alpha. The bytes array is populated by iterating over the total number of pixels and adding four UInt8 values for the red, green, blue, and alpha channels.let width = 128
  let height = 128
  let bytes = stride(from: 0, to: width * height, by: 1).flatMap {
    _ in
    return [
        UInt8(drand48() * 255), // red
        UInt8(drand48() * 255), // green
        UInt8(drand48() * 255), // blue
        UInt8(255)              // alpha
    ]
  }
  let data = Data(bytes: bytes)
  let texture = SKTexture(data: data,
                        size: CGSize(width: width, height: height))
  let width = 128
  let height = 128
  let bytes = stride(from: 0, to: width * height, by: 1).flatMap {
    _ in
    return [
        UInt8(drand48() * 255), // red
        UInt8(drand48() * 255), // green
        UInt8(drand48() * 255), // blue
        UInt8(255)              // alpha
    ]
  }
  let data = Data(bytes: bytes)
  let texture = SKTexture(data: data,
                        size: CGSize(width: width, height: height))
    * @see https://developer.apple.com/documentation/spritekit/sktexture/1519962-init
   */


  static textureWithDataSize(pixelData, size) {} // Creating Normal Map Textures

  /**
   * Creates a normal map texture by analyzing the contents of an existing texture.
   * @access public
   * @returns {SKTexture} - 
   * @see https://developer.apple.com/documentation/spritekit/sktexture/1519687-generatingnormalmap
   */


  generatingNormalMap() {
    return null;
  }
  /**
   * Creates a normal map texture by analyzing the contents of an existing texture.
   * @access public
   * @param {number} smoothness - A number between 0.0 and 1.0 indicating how much the texture should be smoothed before the normal map is generated. A value of 0.0 means that the texture is not smoothed at all before being processed.
   * @param {number} contrast - A value used to magnify the effect of the generated normal map. A value of 1.0 indicates no magnification is applied.
   * @returns {SKTexture} - 
   * @see https://developer.apple.com/documentation/spritekit/sktexture/1520441-generatingnormalmap
   */


  generatingNormalMapWithSmoothness(smoothness, contrast) {
    return null;
  } // Creating Noise Textures

  /**
   * Creates a new texture whose contents are procedurally generated directional noise data.
   * @access public
   * @param {number} smoothness - A value that indicates how similar neighboring texels will be in the resulting texture. The value should be between 0.0 and 1.0. A value of 1.0 generates a smooth surface.
   * @param {CGSize} size - The size of the new texture in points.
   * @returns {void}
   * @desc The noise texture is tileable with itself. The RGB values stored in the texture can be used as directional (XYZ) data. The alpha values are also randomized and can be used as magnitude data, if desired.The following code creates three sprite nodes with textures generated by init(vectorNoiseWithSmoothness:size:) with smoothness values of 0.0, 0.5 and 1.0.let columWidth = scene.size.width / 3
  for i in 0...2 {
    
    let size = CGSize(width: ceil(columWidth),
                      height: 0.5 * scene.size.height)
    
    let smoothness = CGFloat(i) / 2
    
    let vectorTexture = SKTexture(vectorNoiseWithSmoothness: smoothness,
                                  size: size)
    
    let sprite = SKSpriteNode(texture: vectorTexture, size: size)
    
    sprite.position = CGPoint(x: CGFloat(i) * columWidth + (columWidth / 2),
                              y: 
  scene.size.height / 2)
     
    scene.addChild(sprite)
  }
  let columWidth = scene.size.width / 3
  for i in 0...2 {
    
    let size = CGSize(width: ceil(columWidth),
                      height: 0.5 * scene.size.height)
    
    let smoothness = CGFloat(i) / 2
    
    let vectorTexture = SKTexture(vectorNoiseWithSmoothness: smoothness,
                                  size: size)
    
    let sprite = SKSpriteNode(texture: vectorTexture, size: size)
    
    sprite.position = CGPoint(x: CGFloat(i) * columWidth + (columWidth / 2),
                              y: 
  scene.size.height / 2)
     
    scene.addChild(sprite)
  }
    * @see https://developer.apple.com/documentation/spritekit/sktexture/1520393-init
   */


  static textureWithVectorNoiseWithSmoothness(smoothness, size) {}
  /**
   * Creates a new texture whose contents are procedurally generated colored noise data.
   * @access public
   * @param {number} smoothness - A value that indicates how similar neighboring texels will be in the resulting texture. The value should be between 0.0 and 1.0. A value of 1.0 generates a smooth surface.
   * @param {CGSize} size - The size of the new texture in points.
   * @param {boolean} grayscale - If true, all four components of each texel will have equal values. If false, all four values are completely randomized.
   * @returns {void}
   * @desc Unlike other textures produced by SpriteKit, the texels are not premultiplied by the alpha value. Your custom shaders should compensate for this as necessary.The following code creates three sprite nodes with textures generated by init(noiseWithSmoothness:size:grayscale:) with smoothness values of 0.0, 0.5 and 1.0.let columWidth = scene.size.width / 3
  for i in 0...2 {
    
    let size = CGSize(width: ceil(columWidth),
                      height: 0.5 * scene.size.height)
    
    let smoothness = CGFloat(i) / 2
    
    let noiseTexture = SKTexture(noiseWithSmoothness: smoothness,
                                  size: size,
                                  grayscale: false)
    
    let sprite = SKSpriteNode(texture: noiseTexture, size: size)
    
    sprite.position = CGPoint(x: CGFloat(i) * columWidth + (columWidth / 2),
                              y: scene.size.height / 2)
    
    scene.addChild(sprite)
  }
  let columWidth = scene.size.width / 3
  for i in 0...2 {
    
    let size = CGSize(width: ceil(columWidth),
                      height: 0.5 * scene.size.height)
    
    let smoothness = CGFloat(i) / 2
    
    let noiseTexture = SKTexture(noiseWithSmoothness: smoothness,
                                  size: size,
                                  grayscale: false)
    
    let sprite = SKSpriteNode(texture: noiseTexture, size: size)
    
    sprite.position = CGPoint(x: CGFloat(i) * columWidth + (columWidth / 2),
                              y: scene.size.height / 2)
    
    scene.addChild(sprite)
  }
    * @see https://developer.apple.com/documentation/spritekit/sktexture/1519971-init
   */


  static textureWithNoiseWithSmoothness(smoothness, size, grayscale) {} // Inspecting a Texture’s Properties

  /**
   * The size of the texture.
   * @access public
   * @returns {CGSize} - 
   * @desc If the texture was created using an image file and that image file hasn’t been loaded, calling this method forces the texture data to be loaded from the file.
   * @see https://developer.apple.com/documentation/spritekit/sktexture/1519772-size
   */


  size() {
    if (this._image === null) {
      return new CGSize(0, 0);
    }

    return new CGSize(this._image.naturalWidth, this._image.naturalHeight);
  }
  /**
   * A rectangle that defines the portion of the texture used to render its image.
   * @access public
   * @returns {CGRect} - 
   * @desc The default value is a rectangle that covers the entire texture (0,0) - (1,1). You cannot set this value directly; to use only a portion of a texture, use the init(rect:in:) method to create a new texture.
   * @see https://developer.apple.com/documentation/spritekit/sktexture/1519707-texturerect
   */


  textureRect() {
    return null;
  } // Preloading the Texture Data

  /**
   * Load the texture data into memory, calling a completion handler after the task completes.
   * @access public
   * @param {function(): void} completionHandler - A block called after the texture data is loaded.
   * @returns {void}
   * @desc SpriteKit creates a background task to load the texture data from the associated file, then returns control to your game. After the texture data is loaded, your completion handler is called. Typically, you use this method when you want to guarantee that a particular texture is in memory before accessing it.If you need to preload multiple textures at once, use the preload(_:withCompletionHandler:) method instead.
   * @see https://developer.apple.com/documentation/spritekit/sktexture/1520172-preload
   */


  preload(completionHandler) {}
  /**
   * Load the texture data of multiple textures into memory.
   * @access public
   * @param {SKTexture[]} textures - An array of SKTexture objects.
   * @param {function(): void} completionHandler - A block called after all of the textures are loaded.
   * @returns {void}
   * @desc SpriteKit creates a background task that loads the texture data for all of the textures in the array, then returns control to your game. Your completion handler is called after all of the textures are loaded.
   * @see https://developer.apple.com/documentation/spritekit/sktexture/1519817-preload
   */


  static preloadWithCompletionHandler(textures, completionHandler) {} // Instance Properties

  /**
   * 
   * @type {PlaygroundQuickLook}
   * @desc 
   * @see https://developer.apple.com/documentation/spritekit/sktexture/1645801-customplaygroundquicklook
   */


  get customPlaygroundQuickLook() {
    return this._customPlaygroundQuickLook;
  }

  _loadImage(path) {
    const image = new Image(); // TODO: check option if it allows cross-domain.

    image.crossOrigin = 'anonymous';
    this._loadingImagePromise = new Promise((resolve, reject) => {
      if (path.indexOf('file:///') === 0) {
        const paths = path.slice(8).split('/');
        let pathCount = 1;

        let _path = paths.slice(-pathCount).join('/');

        image.onload = () => {
          console.info(`image ${_path} onload`);
          this._image = image;
          resolve(this);
        };

        image.onerror = () => {
          pathCount += 1;

          if (pathCount > paths.length) {
            console.error(`image ${path} load error.`);
            reject(this);
          } else {
            // retry
            console.info(`image ${_path} load error.`);
            _path = paths.slice(-pathCount).join('/');
            console.info(`try ${_path}`);
            image.src = _path;
          }
        };
      } else {
        image.onload = () => {
          this._image = image;
          resolve(this);
        };

        image.onerror = () => {
          console.info(`image ${path} load error.`);
          reject(this);
        };

        image.src = path;
      }
    });
  }

  _createTexture(gl) {
    if (this._image === null) {
      return;
    }

    const texture = gl.createTexture();
    const canvas = document.createElement('canvas');
    canvas.width = this._image.naturalWidth;
    canvas.height = this._image.naturalHeight;
    canvas.getContext('2d').drawImage(this._image, 0, 0);
    gl.bindTexture(gl.TEXTURE_2D, texture); // texImage2D(target, level, internalformat, width, height, border, format, type, source)
    // Safari complains that 'source' is not ArrayBufferView type, but WebGL2 should accept HTMLCanvasElement.

    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this._image.width, this._image.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
    gl.generateMipmap(gl.TEXTURE_2D);
    gl.bindTexture(gl.TEXTURE_2D, null);
    this._glTexture = texture;
  }

}

//import SKShader from './SKShader'
//import SKAttributeValue from './SKAttributeValue'
//import NSCoder from '../undefined/NSCoder'

/**
 * @access private
 * @type {string}
 */

const _defaultVertexShader = `#version 300 es
  precision mediump float;

  in vec3 position;
  in vec2 texcoord;

  uniform float screenWidth;
  uniform float screenHeight;

  //out vec3 v_position;
  out vec2 v_texcoord;

  void main() {
    vec3 pos = position;
    pos.x = (pos.x * 2.0 / screenWidth) - 1.0;
    pos.y = (pos.y * 2.0 / screenHeight) - 1.0;
    v_texcoord = texcoord;
    gl_Position = vec4(pos, 1.0);
  }
`;
/**
 * @access private
 * @type {string}
 */

const _defaultFragmentShader = `#version 300 es
  precision mediump float;

  uniform sampler2D spriteTexture;
  uniform float alpha;
  in vec2 v_texcoord;

  out vec4 outColor;

  void main() {
    outColor = texture(spriteTexture, v_texcoord);
    outColor.a *= alpha;
  }
`;
/**
 * A node that draws a rectangular texture, image or color. 
 * @access public
 * @extends {SKNode}
 * @implements {SKWarpable}
 * @see https://developer.apple.com/documentation/spritekit/skspritenode
 */

class SKSpriteNode extends SKNode {
  // Initializing a New Sprite

  /**
   * Initializes a textured sprite using an image file, optionally adding a normal map to simulate 3D lighting.
   * @access public
   * @constructor
   * @param {string} name - The name of an image file stored in the app bundle.
   * @param {boolean} generateNormalMap - If true, a normal map is generated from the image texture without applying any filter to it (SKTextureNormalMapFilteringTypeNone). If false, no normal map is generated (matching the behavior of the spriteNodeWithImageNamed: class method).
   * @desc The normal map is used only when lighting is enabled in the scene. For more information, see Adding Lighting to a Sprite and SKLightNode.
   * @see https://developer.apple.com/documentation/spritekit/skspritenode/1519721-init
   */
  constructor(name = null, generateNormalMap = false) {
    super(); // Inspecting Physical Properties

    /**
     * The dimensions of the sprite, in points.
     * @type {CGSize}
     * @see https://developer.apple.com/documentation/spritekit/skspritenode/1519668-size
     */

    this.size = new CGSize(0, 0);
    /**
     * Defines the point in the sprite that corresponds to the node’s position.
     * @type {CGPoint}
     * @see https://developer.apple.com/documentation/spritekit/skspritenode/1519877-anchorpoint
     */

    this.anchorPoint = new CGPoint(0.5, 0.5); // Inspecting the Sprite’s Texture

    /**
     * The texture used to draw the sprite.
     * @type {?SKTexture}
     * @see https://developer.apple.com/documentation/spritekit/skspritenode/1520011-texture
     */

    this._texture = null;
    /**
     * A property that defines how the texture is applied to the sprite.
     * @type {CGRect}
     * @see https://developer.apple.com/documentation/spritekit/skspritenode/1520119-centerrect
     */

    this.centerRect = new CGRect(new CGPoint(0, 0), new CGSize(1, 1));
    /**
     * A floating-point value that describes how the color is blended with the sprite’s texture.
     * @type {number}
     * @see https://developer.apple.com/documentation/spritekit/skspritenode/1519780-colorblendfactor
     */

    this.colorBlendFactor = 0; // Inspecting Color Properties

    /**
     * The sprite’s color.
     * @type {SKColor}
     * @see https://developer.apple.com/documentation/spritekit/skspritenode/1519639-color
     */

    this.color = new SKColor(1.0, 1.0, 1.0, 0.0); // Blending the Sprite with the Framebuffer

    /**
     * The blend mode used to draw the sprite into the parent’s framebuffer.
     * @type {SKBlendMode}
     * @see https://developer.apple.com/documentation/spritekit/skspritenode/1519931-blendmode
     */

    this.blendMode = SKBlendMode.alpha; // Adding Lighting to a Sprite

    /**
     * A mask that defines how this sprite is lit by light nodes in the scenes.
     * @type {number}
     * @see https://developer.apple.com/documentation/spritekit/skspritenode/1519637-lightingbitmask
     */

    this.lightingBitMask = 0;
    /**
     * A mask that defines which lights add additional shadows to the sprite.
     * @type {number}
     * @see https://developer.apple.com/documentation/spritekit/skspritenode/1519974-shadowedbitmask
     */

    this.shadowedBitMask = 0;
    /**
     * A mask that defines which lights are occluded by this sprite.
     * @type {number}
     * @see https://developer.apple.com/documentation/spritekit/skspritenode/1520325-shadowcastbitmask
     */

    this.shadowCastBitMask = 0;
    /**
     * A texture that specifies the normal map for the sprite.
     * @type {?SKTexture}
     * @see https://developer.apple.com/documentation/spritekit/skspritenode/1519657-normaltexture
     */

    this.normalTexture = null; // Working with Custom Shaders

    /**
     * A property that determines whether the sprite is rendered using a custom shader.
     * @type {?SKShader}
     * @see https://developer.apple.com/documentation/spritekit/skspritenode/1519714-shader
     */

    this.shader = null;
    /**
     * The values of each attribute associated with the node's attached shader.
     * @type {Map<string, SKAttributeValue>}
     * @see https://developer.apple.com/documentation/spritekit/skspritenode/2715845-attributevalues
     */

    this.attributeValues = new Map(); // Instance Properties
    //this._customPlaygroundQuickLook = new PlaygroundQuickLook()

    this._customPlaygroundQuickLook = null;
    /**
     * @access private
     * @type {WebGLProgram}
     */

    this._program = null;
    this._vertexArrayObject = null;
    this._vertexBuffer = null;
    this._indexBuffer = null;
    this._loadingImagePromise = null;

    if (name !== null) {
      this.texture = SKTexture.textureWithImageNamed(name); //if(generateNormalMap){
      //  this.normalTexture = this.texture.generatingNormalMap()
      //}
    }
  }
  /**
   * Initializes a colored sprite node.
   * @access public
   * @param {CGColor} color - The color for the resulting sprite node.
   * @param {CGSize} size - The size of the sprite node in points.
   * @returns {SKSpriteNode} -
   * @desc Although textured nodes are the most common way to use the SKSpriteNode class, you can also create sprite nodes without a texture. The behavior of the class changes when the node lacks a texture:The sprite node that is returned from this method has its texture property set to nil.There is no texture to stretch, so the centerRect parameter is ignored.There is no colorization step; the color property is used as the sprite’s color.The sprite node's alpha component is used to determine how it is blended into the buffer.Listing 1 shows how to create a red sprite node 100 x 100 points in size.Listing 1 Creating a non-textured sprite nodelet node = SKSpriteNode(color: .red,
                        size: CGSize(width: 100, height: 100))
  Creating a non-textured sprite nodelet node = SKSpriteNode(color: .red,
                        size: CGSize(width: 100, height: 100))
    * @see https://developer.apple.com/documentation/spritekit/skspritenode/1519762-init
   */


  static nodeWithColorSize(color, size) {
    const node = new SKSpriteNode();
    node.size = size;
    node.color = color;
    return node;
  }
  /**
   * Initializes a textured sprite using an image file.
   * @access public
   * @param {string} name - The name of an image file stored in the app bundle.
   * @returns {SKSpriteNode} -
   * @desc This method creates a new texture object from the image file and assigns that texture to the texture property, the normalTexture properties is set to nil. The size property of the sprite is set to the dimensions of the image. The color property is set to white with an alpha of zero (1.0,1.0,1.0,0.0).
   * @see https://developer.apple.com/documentation/spritekit/skspritenode/1520391-init
   */


  static nodeWithImageNamed(name) {
    return new SKSpriteNode(name);
  }
  /**
   * Initializes a textured sprite using an image file, optionally adding a normal map to simulate 3D lighting.
   * @access public
   * @param {string} name - The name of an image file stored in the app bundle.
   * @param {boolean} generateNormalMap - If true, a normal map is generated from the image texture without applying any filter to it (SKTextureNormalMapFilteringTypeNone). If false, no normal map is generated (matching the behavior of the spriteNodeWithImageNamed: class method).
   * @returns {SKSpriteNode} -
   * @desc The normal map is used only when lighting is enabled in the scene. For more information, see Adding Lighting to a Sprite and SKLightNode.
   * @see https://developer.apple.com/documentation/spritekit/skspritenode/1519721-init
   */


  static nodeWithImageNamedNormalMapped(name, generateNormalMap) {
    return new SKSpriteNode(name, generateNormalMap);
  } // Inspecting Physical Properties

  /**
   * Scales to sprite node to a specified size. 
   * @access public
   * @param {CGSize} size - 
   * @returns {void}
   * @desc This method works by setting the sprite node's xScale and yScale to achieve the specified size in its parent's coordinate space. 
   * @see https://developer.apple.com/documentation/spritekit/skspritenode/1645445-scale
   */


  scaleTo(size) {} // Working with Custom Shaders

  /**
   * Sets an attribute value for an attached shader.
   * @access public
   * @param {SKAttributeValue} value - An attribute value object containing the scalar or vector value to set in the attached shader.
   * @param {string} key - The attribute name.
   * @returns {void}
   * @see https://developer.apple.com/documentation/spritekit/skspritenode/2715849-setvalue
   */


  setValueForAttribute(value, key) {}
  /**
   * The value of a shader attribute.
   * @access public
   * @param {string} key - The attribute name.
   * @returns {?SKAttributeValue} - 
   * @see https://developer.apple.com/documentation/spritekit/skspritenode/2715846-value
   */


  valueForAttributeNamed(key) {
    return null;
  } // Initializers

  /**
   * 
   * @access public
   * @param {NSCoder} aDecoder - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/spritekit/skspritenode/1520399-init
   */


  initCoder(aDecoder) {} // Instance Properties

  /**
   * A custom playground quick look for this instance.
   * @type {PlaygroundQuickLook}
   * @desc 
   * @see https://developer.apple.com/documentation/spritekit/skspritenode/1645797-customplaygroundquicklook
   */


  get customPlaygroundQuickLook() {
    return this._customPlaygroundQuickLook;
  }
  /**
   * @access private
   * @param {WebGLRenderingContext} gl -
   * @param {CGRect} viewRect -
   * @returns {void}
   */


  _render(gl, viewRect) {
    const p = this.__presentation;

    if (this.texture === null) {
      //if(this.color === null){
      //  return
      //}
      //this.texture = this._createTextureFromColor()
      return;
    }

    if (this.texture._glTexture === null) {
      this.texture._createTexture(gl);

      if (this.texture._glTexture === null) {
        // the texture is not ready
        return;
      }

      this.size = new CGSize(this.texture._image.naturalWidth, this.texture._image.naturalHeight);
      p.size = this.size.copy();
    }

    if (this._program === null) {
      this._program = this._createProgram(gl);
    }

    const program = this._program;
    gl.useProgram(program);

    if (this._vertexArrayObject === null) {
      this._createVertexArrayObject(gl, program);
    }

    gl.bindVertexArray(this._vertexArrayObject);
    gl.uniform1f(gl.getUniformLocation(program, 'screenWidth'), viewRect.size.width);
    gl.uniform1f(gl.getUniformLocation(program, 'screenHeight'), viewRect.size.height);
    gl.uniform1f(gl.getUniformLocation(program, 'alpha'), p.alpha);

    const data = this._createVertexData();

    gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);
    gl.uniform1i(gl.getUniformLocation(program, 'spriteTexture'), 0);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, this.texture._glTexture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_BYTE, 0);
  }

  _createProgram(gl) {
    const program = gl.createProgram();
    const vsText = _defaultVertexShader;
    const fsText = _defaultFragmentShader; // initialize vertex shader

    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, vsText);
    gl.compileShader(vertexShader);

    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      const info = gl.getShaderInfoLog(vertexShader);
      throw new Error(`SKSpriteNode vertex shader compile error: ${info}`);
    } // initialize fragment shader


    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fsText);
    gl.compileShader(fragmentShader);

    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      const info = gl.getShaderInfoLog(fragmentShader);
      throw new Error(`particle fragment shader compile error: ${info}`);
    }

    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader); // link program object

    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      const info = gl.getProgramInfoLog(program);
      throw new Error(`program link error: ${info}`);
    } //gl.useProgram(program)


    return program;
  }
  /**
   * @access private
   * @param {WebGLRenderingContext} gl -
   * @param {WebGLProgram} program -
   * @returns {void}
   */


  _createVertexArrayObject(gl, program) {
    this._vertexArrayObject = gl.createVertexArray();
    gl.bindVertexArray(this._vertexArrayObject);
    this._vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
    const positionLoc = gl.getAttribLocation(program, 'position');
    gl.bindAttribLocation(program, positionLoc, 'position');
    gl.enableVertexAttribArray(positionLoc); // idx, size, type, norm, stride, offset

    gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 20, 0);
    const texcoordLoc = gl.getAttribLocation(program, 'texcoord');
    gl.bindAttribLocation(program, texcoordLoc, 'texcoord');
    gl.enableVertexAttribArray(texcoordLoc); // idx, size, type, norm, stride, offset

    gl.vertexAttribPointer(texcoordLoc, 2, gl.FLOAT, false, 20, 12);
    this._indexBuffer = gl.createBuffer();
    const indexData = new Uint8Array([0, 3, 2, 0, 1, 3]);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexData, gl.STATIC_DRAW);
  }

  _createVertexData() {
    const p = this.__presentation;
    const w = p.size.width * p._worldXScale;
    const h = p.size.height * p._worldYScale;
    const pos = p._worldPosition;
    const zPos = p._worldZPosition;
    const left = pos.x - p.anchorPoint.x * w;
    const right = pos.x + (1.0 - p.anchorPoint.x) * w;
    const top = pos.y + (1.0 - p.anchorPoint.y) * h;
    const bottom = pos.y - p.anchorPoint.y * h;
    const arr = [left, top, zPos, p.centerRect.minX, p.centerRect.minY, right, top, zPos, p.centerRect.maxX, p.centerRect.minY, left, bottom, zPos, p.centerRect.minX, p.centerRect.maxY, right, bottom, zPos, p.centerRect.maxX, p.centerRect.maxY];
    return new Float32Array(arr);
  }

  _copyValue(src) {
    super._copyValue(src);

    this.size = src.size.copy();
    this.anchorPoint = src.anchorPoint.copy();
    this._texture = src._texture ? src._texture : null;
    this.centerRect = src.centerRect.copy();
    this.colorBlendFactor = src.colorBlendFactor;
    this.color = src.color.copy();
    this.blendMode = src.blendMode;
    this.lightingBitMask = src.lightingBitMask;
    this.shadowedBitMask = src.shadowedBitMask;
    this.shadowCastBitMask = src.shadowCastBitMask;
    this.normalTexture = src.normalTexture ? src.normalTexture : null;
    this.shader = src.shader;
    this.attributeValues = src.attributeValues;
    this._customerPlaygroundQuickLook = src._customerPlaygroundQuickLook; // this._program
    // this._vertexArrayObject
    // this._vertexBuffer
    // this._indexBuffer
  }

  get texture() {
    return this._texture;
  }

  set texture(newValue) {
    this._texture = newValue;
    this.size = new CGSize(0, 0);
    this._frame = new CGRect(new CGPoint(0, 0), this.size);

    if (this._texture) {
      this._loadingImagePromise = this._texture._loadingImagePromise.then(texture => {
        if (this._texture === texture) {
          this.size = this._texture.size();
          const x = -this.size.width * this.anchorPoint.x;
          const y = -this.size.height * (1.0 - this.anchorPoint.y);
          this._frame = new CGRect(new CGPoint(x, y), this.size);
        }
      });
    } else {
      this._loadingImagePromise = null;
    }
  }

  _getLoadedPromise() {
    if (this._loadingImagePromise) {
      return this._loadingImagePromise;
    }

    return Promise.resolve();
  }

  get didLoad() {
    return this._getLoadedPromise();
  }

}

const _cameraLoc = 0;
const _materialLoc = 1;
const _lightLoc = 2;
const _scnLightsLoc = 3;
const _fogLoc = 4;
const _shadowTextureBaseIndex = 8;
const _fsDirectionalShadow = `
  //float shadow = convDepth(texture(u_shadowTexture__I__, v_directionalShadowTexcoord[__I__].xy / v_directionalShadowTexcoord[__I__].w));
  //if(v_directionalShadowDepth[__I__].z / v_directionalShadowDepth[__I__].w - 0.0001 > shadow){
  //  _output.color.rgb += material.diffuse.rgb * light.directionalShadow[__I__].shadowColor.rgb;
  //}else{
  //  // diffuse
  //  vec3 lightVec = normalize(v_light[numLights]);
  //  float diffuse = clamp(dot(lightVec, _surface.normal), 0.0f, 1.0f);
  //  _output.color.rgb += light.directionalShadow[__I__].color.rgb * material.diffuse.rgb * diffuse;

  //  // specular
  //  if(diffuse > 0.0f){
  //    vec3 halfVec = normalize(lightVec + _surface.view);
  //    float specular = pow(dot(halfVec, _surface.normal), material.shininess);
  //    _output.color.rgb += specularColor.rgb * specular;
  //  }
  //}

  {
    float shadow = 0.0;
    for(int i=0; i<4; i++){
      float d = convDepth(texture(u_shadowTexture__I__, (v_directionalShadowTexcoord[__I__].xy + poissonDisk[i]/700.0) / v_directionalShadowTexcoord[__I__].w));
      if(v_directionalShadowDepth[__I__].z / v_directionalShadowDepth[__I__].w - 0.0001 > d){
        shadow += 0.25;
      }
    }
    //vec3 shadowColor = material.diffuse.rgb * light.directionalShadow[__I__].shadowColor.rgb;
    vec3 shadowColor = light.directionalShadow[__I__].shadowColor.rgb;
    // diffuse
    vec3 lightVec = normalize(v_light[numLights]);
    float diffuse = clamp(dot(lightVec, _surface.normal), 0.0f, 1.0f);
    vec3 lightDiffuse = light.directionalShadow[__I__].color.rgb * diffuse;
    _lightingContribution.diffuse += shadowColor * shadow + lightDiffuse * (1.0 - shadow);

    // specular
    if(diffuse > 0.0f){
      vec3 halfVec = normalize(lightVec + _surface.view);
      float specular = pow(dot(halfVec, _surface.normal), _surface.shininess);
      // TODO: use intensity
      _lightingContribution.specular += vec3(specular);
    }
    //_output.color.rgb += shadowColor * shadow + lightColor * (1.0 - shadow);
  }

  numLights += 1;
`;
const _defaultCameraDistance = 15;
/**
 * A renderer for displaying SceneKit scene in an an existing Metal workflow or OpenGL context. 
 * @access public
 * @extends {NSObject}
 * @implements {SCNSceneRenderer}
 * @implements {SCNTechniqueSupport}
 * @see https://developer.apple.com/documentation/scenekit/scnrenderer
 */

class SCNRenderer extends NSObject {
  // Creating a Renderer

  /**
   * Creates a renderer with the specified Metal device.
   * @access public
   * @constructor
   * @param {?MTLDevice} device - A Metal device.
   * @param {?Map<AnyHashable, Object>} [options = null] - An optional dictionary for future extensions.
   * @desc Use this initializer to create a SceneKit renderer that draws into the rendering targets your app already uses to draw other content. For the device parameter, pass the MTLDevice object your app uses for drawing. Then, to tell SceneKit to render your content, call the SCNRenderer method, providing a command buffer and render pass descriptor for SceneKit to use in its rendering.
   * @see https://developer.apple.com/documentation/scenekit/scnrenderer/1518404-init
   */
  constructor(device, options = null) {
    super(); // Specifying a Scene

    /**
     * The scene to be rendered.
     * @type {?SCNScene}
     * @see https://developer.apple.com/documentation/scenekit/scnrenderer/1518400-scene
     */

    this.scene = null; // Managing Animation Timing

    this._nextFrameTime = 0;
    /**
     * context to draw frame
     * @type {WebGLRenderingContext}
     */

    this._context = null;
    /**
     *
     * @access private
     * @type {SKColor}
     */

    this._backgroundColor = null; //////////////////////
    // SCNSceneRenderer //
    //////////////////////
    // Managing Scene Display

    /**
     * Required. The node from which the scene’s contents are viewed for rendering.
     * @access private
     * @type {?SCNNode}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523982-pointofview
     */

    this._pointOfView = null;
    /**
     * Required. A Boolean value that determines whether SceneKit automatically adds lights to a scene.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523812-autoenablesdefaultlighting
     */

    this.autoenablesDefaultLighting = false;
    /**
     * Required. A Boolean value that determines whether SceneKit applies jittering to reduce aliasing artifacts.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1524026-isjitteringenabled
     */

    this.isJitteringEnabled = false;
    /**
     * Required. A Boolean value that determines whether SceneKit displays rendering performance statistics in an accessory view.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522763-showsstatistics
     */

    this.showsStatistics = false;
    /**
     * Required. Options for drawing overlay content in a scene that can aid debugging.
     * @type {SCNDebugOptions}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523281-debugoptions
     */

    this.debugOptions = null;
    this._renderingAPI = null; // Managing Scene Animation Timing

    /**
     * Required. The current scene time.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522680-scenetime
     */

    this.sceneTime = 0;
    /**
     * current time in seconds
     * @access private
     * @type {number}
     */

    this._time = 0;
    /**
     * Required. A Boolean value that determines whether the scene is playing.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523401-isplaying
     */

    this.isPlaying = false;
    /**
     * Required. A Boolean value that determines whether SceneKit restarts the scene time after all animations in the scene have played.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522878-loops
     */

    this.loops = false; // Participating in the Scene Rendering Process

    /**
     * Required. A delegate object that receives messages about SceneKit’s rendering process.
     * @type {?SCNSceneRendererDelegate}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522671-delegate
     */

    this.delegate = null; // Customizing Scene Rendering with Metal

    this._currentRenderCommandEncoder = null;
    this._device = null;
    this._commandQueue = null;
    this._colorPixelFormat = null;
    this._depthPixelFormat = null;
    this._stencilPixelFormat = null; // Rendering Sprite Kit Content over a Scene

    /**
     * Required. A Sprite Kit scene to be rendered on top of the SceneKit content.
     * @type {?SKScene}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1524051-overlayskscene
     */

    this.overlaySKScene = null; // Working With Positional Audio

    /**
     * Required. The node representing the listener’s position in the scene for use with positional audio effects.
     * @type {?SCNNode}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523747-audiolistener
     */
    //this.audioListener = null
    //this._audioEnvironmentNode = null
    //this._audioEngine = null
    // Instance Properties

    /**
     * Required. 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522854-currenttime
     */

    this.currentTime = 0;
    /**
     * @access private
     * @type {SCNProgram}
     */

    this.__defaultProgram = null;
    /**
     * @access private
     * @type {SCNProgram}
     */

    this.__defaultPBRProgram = null;
    /**
     * @access private
     * @type {SCNProgram}
     */

    this.__defaultParticleProgram = null;
    /**
     * @access private
     * @type {SCNProgram}
     */

    this.__defaultHitTestProgram = null;
    /**
     * @access private
     * @type {SCNProgram}
     */

    this.__defaultShadowProgram = null;
    this._location = new Map();
    this._defaultCameraPosNode = new SCNNode();
    this._defaultCameraRotNode = new SCNNode();
    this._defaultCameraNode = new SCNNode();
    this._defaultCameraNode.name = 'kSCNFreeViewCameraName';
    const camera = new SCNCamera();
    camera.name = 'kSCNFreeViewCameraNameCamera';
    this._defaultCameraNode.camera = camera;
    this._defaultCameraNode.position = new SCNVector3(0, 0, _defaultCameraDistance);
    this._defaultCameraNode._presentation = this._defaultCameraNode.copy();

    this._defaultCameraPosNode.addChildNode(this._defaultCameraRotNode);

    this._defaultCameraPosNode._presentation = this._defaultCameraPosNode.copy();

    this._defaultCameraRotNode.addChildNode(this._defaultCameraNode);

    this._defaultCameraRotNode._presentation = this._defaultCameraRotNode.copy();
    this._defaultLightNode = new SCNNode();
    const light = new SCNLight();
    light.color = SKColor.white;
    light.type = SCNLight.LightType.omni;
    light.position = new SCNVector3(0, 10, 10);
    this._defaultLightNode.light = light;
    this._defaultLightNode._presentation = this._defaultLightNode.copy();
    /**
     * @access private
     * @type {CGRect}
     */

    this._viewRect = new CGRect(new CGPoint(0, 0), new CGSize(0, 0));
    /**
     * The background color of the view.
     * @type {SKColor}
     */

    this._backgroundColor = SKColor.white;
    /**
     * @access private
     * @type {WebGLTexture}
     */

    this.__dummyTexture = null;
    /**
     * @access private
     * @type {Object}
     */

    this._lightNodes = {};
    /**
     * @access private
     * @type {Object}
     */

    this._numLights = {};
    /**
     * @access private
     * @type {WebGLBuffer}
     */

    this._cameraBuffer = null;
    /**
     * @access private
     * @type {WebGLBuffer}
     */

    this._lightBuffer = null;
    /**
     * @access private
     * @type {WebGLBuffer}
     */

    this._scnLightsBuffer = null;
    /**
     * @access private
     * @type {WebGLBuffer}
     */

    this._fogBuffer = null; ////////////////////////////
    // Hit Test
    ////////////////////////////

    /**
     * @access private
     * @type {WebGLFramebuffer}
     */

    this._hitFrameBuffer = null;
    /**
     * @access private
     * @type {WebGLRenderbuffer}
     */

    this._hitDepthBuffer = null;
    /**
     * @access private
     * @type {WebGLTexture}
     */

    this._hitObjectIDTexture = null;
    /**
     * @access private
     * @type {WebGLTexture}
     */

    this._hitFaceIDTexture = null;
    /**
     * @access private
     * @type {WebGLTexture}
     */

    this._hitPositionTexture = null;
    /**
     * @access private
     * @type {WebGLTexture}
     */

    this._hitNormalTexture = null;
    /**
     * @access private
     * @type {SCNProgram}
     */

    this._currentProgram = null;
  } // Managing Animation Timing

  /**
   * The timestamp for the next frame to be rendered.
   * @type {number}
   * @desc If the renderer’s scene has any attached actions or animations, use this property to determine how long your app should wait before telling the renderer to draw another frame. If this property’s value matches that of the renderer’s currentTime property, the scene contains a continuous animation—schedule your next render at whatever time best maintains your app’s performance. If the value is infinite, the scene has no running actions or animations.
   * @see https://developer.apple.com/documentation/scenekit/scnrenderer/1518410-nextframetime
   */


  get nextFrameTime() {
    return this._nextFrameTime;
  } // Rendering a Scene Using Metal

  /**
   * Renders the scene’s contents at the specified system time in the specified Metal command buffer.
   * @access public
   * @param {number} time - The timestamp, in seconds, at which to render the scene.
   * @param {CGRect} viewport - The pixel dimensions in which to render.
   * @param {MTLCommandBuffer} commandBuffer - The Metal command buffer in which SceneKit should schedule rendering commands.
   * @param {MTLRenderPassDescriptor} renderPassDescriptor - The Metal render pass descriptor describing the rendering target.
   * @returns {void}
   * @desc This method can be used only with an SCNRenderer object created with the SCNRenderer initializer. Call this method to tell SceneKit to draw the renderer’s scene into the render target described by the renderPassDescriptor parameter, by encoding render commands into the commandBuffer parameter.When you call this method, SceneKit updates its hierarchy of presentation nodes based on the specified timestamp, and then draws the scene using the specified Metal objects. NoteBy default, the playback timing of actions and animations in a scene is based on the system time, not the scene time. Before using this method to control the playback of animations, set the usesSceneTimeBase property of each animation to true, or specify the playUsingSceneTimeBase option when loading a scene file that contains animations.
   * @see https://developer.apple.com/documentation/scenekit/scnrenderer/1518401-render
   */


  renderAtTimePassDescriptor(time, viewport, commandBuffer, renderPassDescriptor) {} // Rendering a Scene Using OpenGL

  /**
   * Renders the scene’s contents in the renderer’s OpenGL context.
   * @deprecated
   * @access public
   * @returns {void}
   * @desc This method can be used only with an SCNRenderer object created with the SCNRenderer initializer. Call this method to tell SceneKit to draw the renderer’s scene into the OpenGL context you created the renderer with.When you call this method, SceneKit updates its hierarchy of presentation nodes based on the current system time, and then draws the scene.
   * @see https://developer.apple.com/documentation/scenekit/scnrenderer/1518403-render
   */


  render() {
    if (this.context === null) {
      console.error('SCNRenderer.render(): context is null');
      return;
    }

    const gl = this.context;

    if (this.scene === null) {
      if (this.overlaySKScene) {
        const sk = this.overlaySKScene;
        gl.clearColor(sk.backgroundColor.red, sk.backgroundColor.green, sk.backgroundColor.blue, sk.backgroundColor.alpha);
        gl.clear(gl.COLOR_BUFFER_BIT);

        this._renderOverlaySKScene();
      }

      return;
    }

    this._lightNodes = this._createLightNodeArray(); // createLightNodeArray must be called before getting program

    const p = this._defaultProgram;

    const glProgram = p._getGLProgramForContext(gl);

    gl.clearColor(this._backgroundColor.red, this._backgroundColor.green, this._backgroundColor.blue, this._backgroundColor.alpha);
    gl.clearDepth(1.0);
    gl.clearStencil(0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT); //gl.useProgram(glProgram)

    this._useProgram(p);

    gl.depthFunc(gl.LEQUAL);
    gl.depthMask(true);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); //////////////////////////
    // Camera
    //////////////////////////

    if (this._cameraBuffer === null) {
      this._initializeCameraBuffer(glProgram);
    }

    const cameraData = [];

    const cameraNode = this._getCameraNode();

    cameraNode._updateWorldTransform();

    const cameraPNode = cameraNode.presentation || cameraNode;
    const camera = cameraPNode.camera;

    camera._updateProjectionTransform(this._viewRect);

    cameraData.push(...cameraPNode.worldTransform.getTranslation().floatArray(), 0);
    cameraData.push(...cameraPNode.viewTransform.floatArray());
    cameraData.push(...cameraPNode.inverseViewTransform.floatArray());
    cameraData.push(...cameraPNode.viewProjectionTransform.floatArray());
    gl.bindBuffer(gl.UNIFORM_BUFFER, this._cameraBuffer);
    gl.bufferData(gl.UNIFORM_BUFFER, new Float32Array(cameraData), gl.DYNAMIC_DRAW);
    gl.bindBuffer(gl.UNIFORM_BUFFER, null); //console.log('cameraNode.worldPosition: ' + cameraPNode.worldTransform.getTranslation().float32Array())
    //console.log('viewTransform: ' + cameraPNode.viewTransform.float32Array())
    //console.log('projectionTransform: ' + cameraNode.camera.projectionTransform.float32Array())
    //console.log('viewProjectionTransform: ' + cameraNode.viewProjectionTransform.float32Array())
    //////////////////////////
    // Fog
    //////////////////////////

    if (this._fogBuffer === null) {
      this._initializeFogBuffer(glProgram);
    }

    const fogData = [];

    if (this.scene.fogColor !== null && this.scene.fogEndDistance !== 0) {
      fogData.push(...this.scene.fogColor.floatArray(), this.scene.fogStartDistance, this.scene.fogEndDistance, this.scene.fogDensityExponent, 0);
    } else {
      fogData.push(0, 0, 0, 0, camera.zFar * 2, camera.zFar * 2 + 1, 1, 0);
    }

    gl.bindBuffer(gl.UNIFORM_BUFFER, this._fogBuffer);
    gl.bufferData(gl.UNIFORM_BUFFER, new Float32Array(fogData), gl.DYNAMIC_DRAW);
    gl.bindBuffer(gl.UNIFORM_BUFFER, null); //////////////////////////
    // Lights
    //////////////////////////

    if (this._lightBuffer === null) {
      this._initializeLightBuffer(glProgram);
    }

    const lights = this._lightNodes;
    const lightData = [];
    lights.ambient.forEach(node => {
      lightData.push(...node.presentation.light.color.float32Array());
    });
    lights.directional.forEach(node => {
      const direction = new SCNVector3(0, 0, -1).rotateWithQuaternion(node.presentation._worldOrientation);
      lightData.push(...node.presentation.light.color.float32Array(), ...direction.float32Array(), 0);
    });
    lights.directionalShadow.forEach(node => {
      const direction = new SCNVector3(0, 0, -1).rotateWithQuaternion(node.presentation._worldOrientation);

      node.presentation.light._updateProjectionTransform();

      lightData.push(...node.presentation.light.color.float32Array(), ...direction.float32Array(), 0, ...node.presentation.light.shadowColor.float32Array(), ...node.presentation.lightViewProjectionTransform.float32Array(), ...node.presentation.shadowProjectionTransform.float32Array());
    });
    lights.omni.forEach(node => {
      lightData.push(...node.presentation.light.color.float32Array(), ...node.presentation._worldTranslation.float32Array(), 0);
    });
    lights.probe.forEach(node => {
      lightData.push(...node.presentation.light.color.float32Array());
    });
    lights.spot.forEach(node => {
      lightData.push(...node.presentation.light.color.float32Array());
    });
    gl.bindBuffer(gl.UNIFORM_BUFFER, this._lightBuffer);
    gl.bufferData(gl.UNIFORM_BUFFER, new Float32Array(lightData), gl.DYNAMIC_DRAW);
    gl.bindBuffer(gl.UNIFORM_BUFFER, null); // FIXME: set params for each light

    const scnLightsData = [];

    if (lights.directionalShadow.length > 0) {
      const l = lights.directionalShadow[0].presentation;
      const direction = new SCNVector3(0, 0, -1).rotateWithQuaternion(l._worldOrientation);
      scnLightsData.push(...direction.float32Array(), 0);
      scnLightsData.push(...l.shadowProjectionTransform.float32Array());
    } else {
      // direction
      scnLightsData.push(0, 0, 0, 0); // identity matrix

      scnLightsData.push(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    }

    gl.bindBuffer(gl.UNIFORM_BUFFER, this._scnLightsBuffer);
    gl.bufferData(gl.UNIFORM_BUFFER, new Float32Array(scnLightsData), gl.DYNAMIC_DRAW);
    gl.bindBuffer(gl.UNIFORM_BUFFER, null); //////////////////////////
    // Background (SkyBox)
    //////////////////////////

    if (this.scene.background._contents !== null) {
      const skyBox = this.scene._skyBox;
      skyBox.position = cameraPNode._worldTranslation;
      const scale = camera.zFar * 1.154;
      skyBox.scale = new SCNVector3(scale, scale, scale);

      skyBox._updateWorldTransform(); // disable fog


      const disabledFogData = fogData.slice(0);
      disabledFogData[4] = camera.zFar * 2.0; // startDistance

      disabledFogData[5] = camera.zFar * 2.1; // endDistance

      disabledFogData[6] = 1.0; // densityExponent

      gl.bindBuffer(gl.UNIFORM_BUFFER, this._fogBuffer);
      gl.bufferData(gl.UNIFORM_BUFFER, new Float32Array(disabledFogData), gl.DYNAMIC_DRAW);
      gl.bindBuffer(gl.UNIFORM_BUFFER, null);

      this._renderNode(skyBox); // enable fog


      gl.bindBuffer(gl.UNIFORM_BUFFER, this._fogBuffer);
      gl.bufferData(gl.UNIFORM_BUFFER, new Float32Array(fogData), gl.DYNAMIC_DRAW);
      gl.bindBuffer(gl.UNIFORM_BUFFER, null);
    } //////////////////////////
    // Shadow
    //////////////////////////
    //gl.useProgram(this._defaultShadowProgram._glProgram)


    this._useProgram(this._defaultShadowProgram);

    gl.enable(gl.DEPTH_TEST);
    gl.depthMask(true);
    gl.depthFunc(gl.LEQUAL);
    gl.clearDepth(1.0);
    gl.clearColor(1.0, 1.0, 1.0, 1.0);
    gl.disable(gl.BLEND);

    const shadowRenderingArray = this._createShadowNodeArray();

    for (const key of Object.keys(lights)) {
      for (const lightNode of lights[key]) {
        this._renderNodesShadowOfLight(shadowRenderingArray, lightNode);
      }
    }

    this._setViewPort(); // reset viewport size


    this._useProgram(p);

    for (let i = 0; i < lights.directionalShadow.length; i++) {
      const node = lights.directionalShadow[i];
      const symbol = `TEXTURE${i + _shadowTextureBaseIndex}`;
      gl.activeTexture(gl[symbol]);
      gl.bindTexture(gl.TEXTURE_2D, node.presentation.light._shadowDepthTexture);
    }

    gl.enable(gl.BLEND); //////////////////////////
    // Nodes
    //////////////////////////

    const renderingArray = this._createRenderingNodeArray();

    renderingArray.forEach(node => {
      this._renderNode(node);
    });
    const particleProgram = this._defaultParticleProgram._glProgram; //gl.useProgram(particleProgram)

    this._useProgram(this._defaultParticleProgram);

    gl.depthMask(false);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
    gl.uniformMatrix4fv(gl.getUniformLocation(particleProgram, 'viewTransform'), false, cameraPNode.viewTransform.float32Array());
    gl.uniformMatrix4fv(gl.getUniformLocation(particleProgram, 'projectionTransform'), false, cameraPNode.projectionTransform.float32Array()); //////////////////////////
    // Particles
    //////////////////////////

    if (this.scene._particleSystems !== null) {
      for (const system of this.scene._particleSystems) {
        this._renderParticleSystem(system);
      }
    }

    const particleArray = this._createParticleNodeArray();

    particleArray.forEach(node => {
      this._renderParticle(node);
    }); //////////////////////////
    // 2D Overlay
    //////////////////////////

    this._renderOverlaySKScene(); // DEBUG: show shadow map
    //this._showShadowMapOfLight(lights.directionalShadow[0])


    gl.flush();
  }

  _renderOverlaySKScene() {
    if (this.overlaySKScene === null) {
      return;
    }

    const gl = this.context;
    gl.disable(gl.CULL_FACE);
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.GEQUAL);
    gl.enable(gl.BLEND);
    gl.depthMask(true);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.clearStencil(0);
    gl.clearDepth(-1);
    gl.clear(gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);

    const skNodes = this._createSKNodeArray();

    for (const node of skNodes) {
      this._renderSKNode(node);
    }
  }
  /**
   * @access private
   * @returns {SCNNode} -
   */


  _getCameraNode() {
    let cameraNode = this._pointOfView;

    if (cameraNode === null) {
      cameraNode = this._searchCameraNode();
      this._pointOfView = cameraNode;

      if (cameraNode === null) {
        cameraNode = this._defaultCameraNode;
      }
    }

    if (cameraNode === this._defaultCameraNode) {
      this._defaultCameraPosNode._updateWorldTransform();
    }

    return cameraNode;
  }
  /**
   *
   * @access private
   * @returns {SCNNode[]} -
   */


  _createShadowNodeArray() {
    const arr = [this.scene._rootNode];
    const targetNodes = [];

    while (arr.length > 0) {
      const node = arr.shift();

      if (node.presentation !== null && node.presentation.geometry !== null && node.presentation.castsShadow && node.presentation._worldOpacity > 0 && !node.presentation.isHidden) {
        targetNodes.push(node);
      }

      arr.push(...node.childNodes);
    }

    return targetNodes;
  }
  /**
   *
   * @access private
   * @returns {SCNNode[]} -
   */


  _createRenderingNodeArray() {
    const arr = [this.scene._rootNode];
    const targetNodes = [];

    while (arr.length > 0) {
      const node = arr.shift();

      if (node.presentation !== null && node.presentation.geometry !== null) {
        targetNodes.push(node);
      }

      arr.push(...node.childNodes);
    }

    targetNodes.sort((a, b) => {
      return a.presentation.renderingOrder - b.presentation.renderingOrder + (b.presentation._worldOpacity - a.presentation._worldOpacity) * 0.5;
    });
    return targetNodes;
  }
  /**
   *
   * @access private
   * @returns {SCNNode[]} -
   */


  _createParticleNodeArray() {
    const arr = [this.scene._rootNode];
    const targetNodes = [];

    while (arr.length > 0) {
      const node = arr.shift();

      if (node.presentation !== null && node.presentation.particleSystems !== null) {
        targetNodes.push(node);
      }

      arr.push(...node.childNodes);
    }

    targetNodes.sort((a, b) => {
      return a.renderingOrder - b.renderingOrder + (b.opacity - a.opacity) * 0.5;
    });
    return targetNodes;
  }
  /**
   *
   * @access private
   * @returns {SCNNode[]} -
   */


  _createLightNodeArray() {
    const targetNodes = {
      ies: [],
      ambient: [],
      directional: [],
      omni: [],
      probe: [],
      spot: [],
      directionalShadow: []
    };
    const arr = [this.scene.rootNode];
    let numLights = 0;

    while (arr.length > 0) {
      const node = arr.shift();

      if (node.presentation !== null && node.presentation.light !== null) {
        if (node.presentation.light.type === 'directional' && node.presentation.light.castsShadow) {
          targetNodes.directionalShadow.push(node);
        } else {
          targetNodes[node.presentation.light.type].push(node);
        }

        if (node.presentation.light.type !== SCNLight.LightType.ambient) {
          numLights += 1;
        }
      }

      arr.push(...node.childNodes);
    }

    if (this.autoenablesDefaultLighting && numLights === 0) {
      targetNodes[this._defaultLightNode.light.type].push(this._defaultLightNode);
    }

    return targetNodes;
  }
  /**
   *
   * @access private
   * @returns {SCNNode[]} -
   */


  _createRenderingPhysicsNodeArray() {
    const arr = [this.scene._rootNode];
    const targetNodes = [];

    while (arr.length > 0) {
      const node = arr.shift();

      if (node.presentation !== null && node.presentation.physicsBody !== null && node.presentation.physicsBody.physicsShape !== null) {
        targetNodes.push(node);
      }

      arr.push(...node.childNodes);
    }

    targetNodes.sort((a, b) => {
      return a.renderingOrder - b.renderingOrder;
    });
    return targetNodes;
  }
  /**
   *
   * @access private
   * @param {SCNNode[]} nodes -
   * @param {SCNNode} lightNode -
   * @returns {void}
   */


  _renderNodesShadowOfLight(nodes, lightNode) {
    const lp = lightNode.presentation;
    const light = lp.light;

    if (!lp.castsShadow) {
      return;
    }

    this._setViewPort(light._shadowMapWidth, light._shadowMapHeight);

    const gl = this.context;

    const glProgram = this._defaultShadowProgram._getGLProgramForContext(gl);

    gl.bindFramebuffer(gl.FRAMEBUFFER, light._getDepthBufferForContext(gl));
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    gl.uniformMatrix4fv(gl.getUniformLocation(glProgram, 'viewProjectionTransform'), false, lp.lightViewProjectionTransform.float32Array());

    for (const node of nodes) {
      const geometry = node.presentation.geometry;
      const geometryCount = geometry.geometryElements.length;

      if (geometryCount === 0) {
        // nothing to draw...
        continue;
      }

      if (geometry._shadowVAO === null) {
        this._initializeShadowVAO(node, glProgram);
      }

      if (node.morpher !== null) ;

      if (node.presentation.skinner !== null) {
        if (node.presentation.skinner._useGPU) {
          gl.uniform1i(gl.getUniformLocation(glProgram, 'numSkinningJoints'), node.presentation.skinner.numSkinningJoints);
          gl.uniform4fv(gl.getUniformLocation(glProgram, 'skinningJoints'), node.presentation.skinner.float32Array());
        } else {
          gl.uniform1i(gl.getUniformLocation(glProgram, 'numSkinningJoints'), 0);
          gl.uniform4fv(gl.getUniformLocation(glProgram, 'skinningJoints'), SCNMatrix4MakeTranslation(0, 0, 0).float32Array3x4f());
        }
      } else {
        gl.uniform1i(gl.getUniformLocation(glProgram, 'numSkinningJoints'), 0);
        gl.uniform4fv(gl.getUniformLocation(glProgram, 'skinningJoints'), node.presentation._worldTransform.float32Array3x4f());
      }

      for (let i = 0; i < geometryCount; i++) {
        const vao = geometry._shadowVAO[i];
        const element = geometry.geometryElements[i];
        gl.bindVertexArray(vao); // FIXME: use bufferData instead of bindBufferBase

        let shape = null;

        switch (element.primitiveType) {
          case SCNGeometryPrimitiveType.triangles:
            shape = gl.TRIANGLES;
            break;

          case SCNGeometryPrimitiveType.triangleStrip:
            shape = gl.TRIANGLE_STRIP;
            break;

          case SCNGeometryPrimitiveType.line:
            shape = gl.LINES;
            break;

          case SCNGeometryPrimitiveType.point:
            shape = gl.POINTS;
            break;

          case SCNGeometryPrimitiveType.polygon:
            shape = gl.TRIANGLE_FAN;
            break;

          default:
            throw new Error(`unsupported primitiveType: ${element.primitiveType}`);
        }

        let size = null;

        switch (element.bytesPerIndex) {
          case 1:
            size = gl.UNSIGNED_BYTE;
            break;

          case 2:
            size = gl.UNSIGNED_SHORT;
            break;

          case 4:
            size = gl.UNSIGNED_INT;
            break;

          default:
            throw new Error(`unsupported index size: ${element.bytesPerIndex}`);
        }

        gl.drawElements(shape, element._glData.length, size, 0);
      }
    }

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  }
  /**
   *
   * @access private
   * @param {SCNNode} node -
   * @returns {void}
   */


  _renderNode(node) {
    if (node.presentation.isHidden || node.presentation._worldOpacity <= 0) {
      return;
    }

    const gl = this.context;
    const geometry = node.presentation.geometry;
    const geometryCount = geometry.geometryElements.length;

    if (geometryCount === 0) {
      // nothing to draw...
      return;
    }

    const scnProgram = this._getProgramForGeometry(geometry);

    const glProgram = scnProgram._getGLProgramForContext(gl);

    this._switchProgram(scnProgram);

    if (geometry._vertexArrayObjects === null) {
      this._initializeVAO(node, glProgram);

      this._initializeUBO(node, glProgram); // FIXME: program should have UBO, not node.

    }

    if (node.morpher !== null || node.skinner && !node.skinner._useGPU) {
      this._updateVAO(node);
    }

    gl.uniformMatrix4fv(gl.getUniformLocation(glProgram, 'modelTransform'), false, node._worldTransform.float32Array());

    if (node.presentation.skinner !== null) {
      if (node.presentation.skinner._useGPU) {
        gl.uniform1i(gl.getUniformLocation(glProgram, 'numSkinningJoints'), node.presentation.skinner.numSkinningJoints);
        gl.uniform4fv(gl.getUniformLocation(glProgram, 'skinningJoints'), node.presentation.skinner.float32Array());
      } else {
        gl.uniform1i(gl.getUniformLocation(glProgram, 'numSkinningJoints'), 0);
        gl.uniform4fv(gl.getUniformLocation(glProgram, 'skinningJoints'), SCNMatrix4MakeTranslation(0, 0, 0).float32Array3x4f());
      }
    } else {
      gl.uniform1i(gl.getUniformLocation(glProgram, 'numSkinningJoints'), 0);
      gl.uniform4fv(gl.getUniformLocation(glProgram, 'skinningJoints'), node.presentation._worldTransform.float32Array3x4f());
    }

    for (let i = 0; i < geometryCount; i++) {
      const materialCount = geometry.materials.length;
      const material = geometry.materials[i % materialCount];
      let p = glProgram;

      if (material && (material.program || material.lightingModel === SCNMaterial.LightingModel.physicallyBased)) {
        const _scnProgram = material.program ? material.program : this._defaultPBRProgram;

        this._switchProgram(_scnProgram); // TODO: refactoring


        p = _scnProgram._getGLProgramForContext(gl);

        if (node.presentation.skinner !== null) {
          if (node.presentation.skinner._useGPU) {
            gl.uniform1i(gl.getUniformLocation(p, 'numSkinningJoints'), node.presentation.skinner.numSkinningJoints);
            gl.uniform4fv(gl.getUniformLocation(p, 'skinningJoints'), node.presentation.skinner.float32Array());
          } else {
            gl.uniform1i(gl.getUniformLocation(p, 'numSkinningJoints'), 0);
            gl.uniform4fv(gl.getUniformLocation(p, 'skinningJoints'), SCNMatrix4MakeTranslation(0, 0, 0).float32Array3x4f());
          }
        } else {
          gl.uniform1i(gl.getUniformLocation(p, 'numSkinningJoints'), 0);
          gl.uniform4fv(gl.getUniformLocation(p, 'skinningJoints'), node.presentation._worldTransform.float32Array3x4f());
        }

        const materialIndex = gl.getUniformBlockIndex(p, 'materialUniform');
        gl.uniformBlockBinding(p, materialIndex, _materialLoc);
        gl.bindBufferBase(gl.UNIFORM_BUFFER, _materialLoc, geometry._materialBuffer);

        material._callBindingHandlerForNodeProgramContextRenderer(node, p, gl, this);
      } else {
        this._switchProgram(scnProgram);

        geometry._callBindingHandlerForNodeProgramContextRenderer(node, glProgram, gl, this);
      }

      const vao = geometry._vertexArrayObjects[i];
      const element = geometry.geometryElements[i];
      gl.bindVertexArray(vao); // FIXME: use bufferData instead of bindBufferBase

      gl.bindBufferBase(gl.UNIFORM_BUFFER, _materialLoc, geometry._materialBuffer);

      geometry._bufferMaterialData(gl, p, i, node.presentation._worldOpacity);

      let shape = null;

      switch (element.primitiveType) {
        case SCNGeometryPrimitiveType.triangles:
          shape = gl.TRIANGLES;
          break;

        case SCNGeometryPrimitiveType.triangleStrip:
          shape = gl.TRIANGLE_STRIP;
          break;

        case SCNGeometryPrimitiveType.line:
          shape = gl.LINES;
          break;

        case SCNGeometryPrimitiveType.point:
          shape = gl.POINTS;
          break;

        case SCNGeometryPrimitiveType.polygon:
          shape = gl.TRIANGLE_FAN;
          break;

        default:
          throw new Error(`unsupported primitiveType: ${element.primitiveType}`);
      }

      let size = null;

      switch (element.bytesPerIndex) {
        case 1:
          size = gl.UNSIGNED_BYTE;
          break;

        case 2:
          size = gl.UNSIGNED_SHORT;
          break;

        case 4:
          size = gl.UNSIGNED_INT;
          break;

        default:
          throw new Error(`unsupported index size: ${element.bytesPerIndex}`);
      }

      gl.drawElements(shape, element._glData.length, size, 0);
    }
  }
  /**
   *
   * @access private
   * @param {SCNNode} node -
   * @returns {void}
   */


  _renderParticle(node) {
    if (node.presentation.isHidden) {
      return;
    } //const systems = node.presentation.particleSystems


    const systems = node.particleSystems;
    systems.forEach(system => {
      this._renderParticleSystem(system, node);
    });
  }
  /**
   *
   * @access private
   * @param {SCNParticleSystem} system - 
   * @param {?SCNNode} [node = null] -
   * @returns {void}
   */


  _renderParticleSystem(system, node = null) {
    //this.currentTime
    const gl = this.context; //let program = this._defaultParticleProgram._glProgram
    //if(system._program !== null){
    //  program = system._program._glProgram
    //}

    let p = this._defaultParticleProgram;

    if (system._program !== null) {
      p = system._program;
    }

    const glProgram = p._getGLProgramForContext(gl);

    this._useProgram(p); //this._switchProgram(p)


    gl.disable(gl.CULL_FACE);

    if (system._vertexBuffer === null) {
      system._initializeVAO(gl, glProgram);
    }

    gl.bindVertexArray(system._vertexArray);

    system._bufferMaterialData(gl, glProgram);

    if (node) {
      gl.uniformMatrix4fv(gl.getUniformLocation(glProgram, 'modelTransform'), false, node._worldTransform.float32Array());
    } else {
      let m = SCNMatrix4MakeTranslation(0, 0, 0);
      gl.uniformMatrix4fv(gl.getUniformLocation(glProgram, 'modelTransform'), false, m.float32Array());
    }

    gl.drawElements(gl.TRIANGLES, system._particles.length * 6, system._glIndexSize, 0);
  }
  /**
   *
   * @access private
   * @param {SCNNode} node -
   * @param {number} objectID -
   * @param {Map} options -
   * @returns {void}
   */


  _renderNodeForHitTest(node, objectID, options) {
    const gl = this.context;
    const geometry = node.presentation.geometry;

    const glProgram = this._defaultHitTestProgram._getGLProgramForContext(gl);

    const geometryCount = geometry.geometryElements.length;

    if (geometryCount === 0) {
      // nothing to draw...
      return;
    }

    if (geometry._vertexArrayObjects === null) {
      // geometry is not ready
      return;
    }

    if (geometry._hitTestVAO === null) {
      this._initializeHitTestVAO(node, glProgram);
    }

    gl.uniform1i(gl.getUniformLocation(glProgram, 'objectID'), objectID);

    if (node.presentation.skinner !== null && node.presentation.skinner._useGPU) {
      if (node.presentation.skinner._useGPU) {
        gl.uniform1i(gl.getUniformLocation(glProgram, 'numSkinningJoints'), node.presentation.skinner.numSkinningJoints);
        gl.uniform4fv(gl.getUniformLocation(glProgram, 'skinningJoints'), node.presentation.skinner.float32Array());
      } else {
        gl.uniform1i(gl.getUniformLocation(glProgram, 'numSkinningJoints'), 0);
        gl.uniform4fv(gl.getUniformLocation(glProgram, 'skinningJoints'), SCNMatrix4MakeTranslation(0, 0, 0).float32Array3x4f());
      }
    } else {
      gl.uniform1i(gl.getUniformLocation(glProgram, 'numSkinningJoints'), 0);
      gl.uniform4fv(gl.getUniformLocation(glProgram, 'skinningJoints'), node.presentation._worldTransform.float32Array3x4f());
    }

    for (let i = 0; i < geometryCount; i++) {
      const vao = geometry._hitTestVAO[i];
      const element = geometry.geometryElements[i];
      gl.bindVertexArray(vao);
      gl.uniform1i(gl.getUniformLocation(glProgram, 'geometryID'), i);
      let shape = null;

      switch (element.primitiveType) {
        case SCNGeometryPrimitiveType.triangles:
          shape = gl.TRIANGLES;
          break;

        case SCNGeometryPrimitiveType.triangleStrip:
          shape = gl.TRIANGLE_STRIP;
          break;

        case SCNGeometryPrimitiveType.line:
          shape = gl.LINES;
          break;

        case SCNGeometryPrimitiveType.point:
          shape = gl.POINTS;
          break;

        case SCNGeometryPrimitiveType.polygon:
          shape = gl.TRIANGLE_FAN;
          break;

        default:
          throw new Error(`unsupported primitiveType: ${element.primitiveType}`);
      }

      let size = null;

      switch (element.bytesPerIndex) {
        case 1:
          size = gl.UNSIGNED_BYTE;
          break;

        case 2:
          size = gl.UNSIGNED_SHORT;
          break;

        case 4:
          size = gl.UNSIGNED_INT;
          break;

        default:
          throw new Error(`unsupported index size: ${element.bytesPerIndex}`);
      } //console.log(`hitTest drawElements: length: ${element._glData.length}`)


      gl.drawElements(shape, element._glData.length, size, 0);
    }
  }
  /**
   *
   * @access private
   * @param {SCNNode} node -
   * @param {number} objectID -
   * @param {Map} options -
   * @returns {void}
   */


  _renderPhysicsNodeForHitTest(node, objectID, options) {
    const gl = this.context;
    const p = node.presentation;
    const body = p.physicsBody;
    const geometry = body.physicsShape._sourceGeometry;
    const geometryCount = geometry.geometryElements.length;

    if (geometryCount === 0) {
      // nothing to draw...
      return;
    }

    const glProgram = this._defaultHitTestProgram._getGLProgramForContext(gl);

    if (geometry._vertexBuffer === null) {
      // should I copy the geometry?
      geometry._createVertexBuffer(gl, node, false, geometry);
    }

    if (geometry._hitTestVAO === null) {
      this._initializeHitTestVAO(node, glProgram, true);
    }

    gl.uniform1i(gl.getUniformLocation(glProgram, 'objectID'), objectID);

    if (node.presentation.skinner !== null && node.presentation.skinner._useGPU) {
      if (node.presentation.skinner._useGPU) {
        gl.uniform1i(gl.getUniformLocation(glProgram, 'numSkinningJoints'), node.presentation.skinner.numSkinningJoints);
        gl.uniform4fv(gl.getUniformLocation(glProgram, 'skinningJoints'), node.presentation.skinner.float32Array());
      } else {
        gl.uniform1i(gl.getUniformLocation(glProgram, 'numSkinningJoints'), 0);
        gl.uniform4fv(gl.getUniformLocation(glProgram, 'skinningJoints'), SCNMatrix4MakeTranslation(0, 0, 0).float32Array3x4f());
      }
    } else {
      gl.uniform1i(gl.getUniformLocation(glProgram, 'numSkinningJoints'), 0);
      gl.uniform4fv(gl.getUniformLocation(glProgram, 'skinningJoints'), node.presentation._worldTransform.float32Array3x4f());
    }

    for (let i = 0; i < geometryCount; i++) {
      const vao = geometry._hitTestVAO[i];
      const element = geometry.geometryElements[i];
      gl.bindVertexArray(vao);
      gl.uniform1i(gl.getUniformLocation(glProgram, 'geometryID'), i);
      let shape = null;

      switch (element.primitiveType) {
        case SCNGeometryPrimitiveType.triangles:
          shape = gl.TRIANGLES;
          break;

        case SCNGeometryPrimitiveType.triangleStrip:
          shape = gl.TRIANGLE_STRIP;
          break;

        case SCNGeometryPrimitiveType.line:
          shape = gl.LINES;
          break;

        case SCNGeometryPrimitiveType.point:
          shape = gl.POINTS;
          break;

        case SCNGeometryPrimitiveType.polygon:
          shape = gl.TRIANGLE_FAN;
          break;

        default:
          throw new Error(`unsupported primitiveType: ${element.primitiveType}`);
      }

      let size = null;

      switch (element.bytesPerIndex) {
        case 1:
          size = gl.UNSIGNED_BYTE;
          break;

        case 2:
          size = gl.UNSIGNED_SHORT;
          break;

        case 4:
          size = gl.UNSIGNED_INT;
          break;

        default:
          throw new Error(`unsupported index size: ${element.bytesPerIndex}`);
      }

      gl.drawElements(shape, element._glData.length, size, 0);
    }
  }
  /**
   *
   * @access private
   * @returns {SKNode[]} -
   */


  _createSKNodeArray() {
    if (this.overlaySKScene === null) {
      return [];
    }

    const arr = [this.overlaySKScene];
    const targetNodes = [];

    while (arr.length > 0) {
      const node = arr.shift();
      targetNodes.push(node);
      arr.push(...node.children);
    } //targetNodes.sort((a, b) => { return a.renderingOrder - b.renderingOrder })


    return targetNodes;
  }
  /**
   *
   * @access private
   * @param {SKNode} node -
   * @returns {void}
   */


  _renderSKNode(node) {
    node._render(this.context, this._viewRect);
  }
  /**
   * Renders the scene’s contents at the specified system time in the renderer’s OpenGL context.
   * @access public
   * @param {number} time - The timestamp, in seconds, at which to render the scene.
   * @returns {void}
   * @desc This method can be used only with an SCNRenderer object created with the SCNRenderer initializer. Call this method to tell SceneKit to draw the renderer’s scene into the OpenGL context you created the renderer with.When you call this method, SceneKit updates its hierarchy of presentation nodes based on the specified timestamp, and then draws the scene.NoteBy default, the playback timing of actions and animations in a scene is based on the system time, not the scene time. Before using this method to control the playback of animations, set the usesSceneTimeBase property of each animation to true, or specify the playUsingSceneTimeBase option when loading a scene file that contains animations.
   * @see https://developer.apple.com/documentation/scenekit/scnrenderer/1518402-render
   */


  renderAtTime(time) {} // Capturing a Snapshot

  /**
   * Creates an image by drawing the renderer’s content at the specified system time.
   * @access public
   * @param {number} time - The timestamp, in seconds, at which to render the scene.
   * @param {CGSize} size - The size, in pixels, of the image to create.
   * @param {SCNAntialiasingMode} antialiasingMode - The antialiasing mode to use for the image output.
   * @returns {Image} - 
   * @desc When you call this method, SceneKit updates its hierarchy of presentation nodes based on the specified timestamp, and then draws the scene into a new image object of the specified size.
   * @see https://developer.apple.com/documentation/scenekit/scnrenderer/1641767-snapshot
   */


  snapshotAtTimeWith(time, size, antialiasingMode) {
    return null;
  } // Instance Methods

  /**
   * 
   * @access public
   * @param {SCNNode[]} lightProbes - 
   * @param {number} time - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnrenderer/2097153-updateprobes
   */


  updateProbesAtTime(lightProbes, time) {} //////////////////////
  // SCNSceneRenderer //
  //////////////////////
  // Presenting a Scene

  /**
   * Required. Displays the specified scene with an animated transition.
   * @access public
   * @param {SCNScene} scene - The new scene to be displayed.
   * @param {SKTransition} transition - An object that specifies the duration and style of the animated transition.
   * @param {?SCNNode} pointOfView - The node to use as the pointOfView property when displaying the new scene.
   * @param {?function(): void} [completionHandler = null] - A block that SceneKit calls after the transition animation has completed.This block takes no parameters and has no return value.
   * @returns {void}
   * @desc Use this method to change the scene displayed in a SceneKit view (or other renderer) with an animated transition. For details on transition styles, see SKTransition.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523028-present
   */


  presentWithIncomingPointOfView(scene, transition, pointOfView, completionHandler = null) {} // Managing Scene Display

  /**
   * Required. The node from which the scene’s contents are viewed for rendering.
   * @type {?SCNNode}
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523982-pointofview
   */


  get pointOfView() {
    return this._getCameraNode();
  }
  /**
   * Required. The node from which the scene’s contents are viewed for rendering.
   * @type {?SCNNode}
   * @param {?SCNNode} newValue -
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523982-pointofview
   */


  set pointOfView(newValue) {
    this._pointOfView = newValue;
  }
  /**
   * Required. The graphics technology SceneKit uses to render the scene.
   * @type {SCNRenderingAPI}
   * @desc You choose a graphics technology when initializing a scene renderer:When initializing a SCNView object, use the init(frame:options:) initializer and the preferredRenderingAPI key. Alternatively, create a view in Interface Builder and use the Rendering API control in the inspector. During initialization, the view will attempt to use the preferred API, but will fall back to a different API if the preferred one is not supported on the current hardware.To create a SCNRenderer object that renders into your own OpenGL contect, use the init(context:options:) initializer. To create a renderer for use in your own Metal workflow, use the init(device:options:) initializer.The rendering technology used by a SCNLayer object is determined by Core Animation.After initializing a renderer, this property reflects the rendering technology in use.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522616-renderingapi
   */


  get renderingAPI() {
    return this._renderingAPI;
  } // Preloading Renderer Resources

  /**
   * Required. Prepares a SceneKit object for rendering.
   * @access public
   * @param {Object} object - An SCNScene, SCNNode, SCNGeometry, or SCNMaterial instance.
   * @param {?function(): boolean} [block = null] - A block that SceneKit calls periodically while preparing the object. The block takes no parameters.Your block should return false to tell SceneKit to continue preparing the object, or true to cancel preparation.Pass nil for this parameter if you do not need an opportunity to cancel preparing the object.
   * @returns {boolean} - 
   * @desc By default, SceneKit lazily loads resources onto the GPU for rendering. This approach uses memory and GPU bandwidth efficiently, but can lead to stutters in an otherwise smooth frame rate when you add large amounts of new content to an animated scene. To avoid such issues, use this method to prepare content for drawing before adding it to the scene. You can call this method on a secondary thread to prepare content asynchronously. SceneKit prepares all content associated with the object parameter you provide. If you provide an SCNMaterial object, SceneKit loads any texture images assigned to its material properties. If you provide an SCNGeometry object, SceneKit loads all materials attached to the geometry, as well as its vertex data. If you provide an SCNNode or SCNScene object, SceneKit loads all geometries and materials associated with the node and all its child nodes, or with the entire node hierarchy of the scene.You can use the block parameter to cancel preparation if content is no longer needed. For example, in a game you might use this method to preload areas of the game world the player is soon to enter, but if the player character dies before entering those areas, you can return true from the block to cancel preloading.You can observe the progress of this operation with the Progress class. For details, see Progress.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522798-prepare
   */


  prepareShouldAbortBlock(object, block = null) {
    return false;
  }
  /**
   * Required. Prepares the specified SceneKit objects for rendering, using a background thread.
   * @access public
   * @param {Object[]} objects - An array of containing one or more SCNScene, SCNNode, SCNGeometry, or SCNMaterial instances.
   * @param {?function(arg1: boolean): void} [completionHandler = null] - A block that SceneKit calls when object preparation fails or completes.The block takes the following parameter:successtrue if all content was successfully prepared for rendering; otherwise, false.
   * @returns {void}
   * @desc By default, SceneKit lazily loads resources onto the GPU for rendering. This approach uses memory and GPU bandwidth efficiently, but can lead to stutters in an otherwise smooth frame rate when you add large amounts of new content to an animated scene. To avoid such issues, use this method to prepare content for drawing before adding it to the scene. SceneKit uses a secondary thread to prepare content asynchronously.SceneKit prepares all content associated with the objects you provide. If you provide an SCNMaterial object, SceneKit loads any texture images assigned to its material properties. If you provide an SCNGeometry object, SceneKit loads all materials attached to the geometry, as well as its vertex data. If you provide an SCNNode or SCNScene object, SceneKit loads all geometries and materials associated with the node and all its child nodes, or with the entire node hierarchy of the scene.You can observe the progress of this operation with the Progress class. For details, see Progress.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523375-prepare
   */


  prepare(objects, completionHandler = null) {} // Working With Projected Scene Contents

  /**
   * Required. Searches the renderer’s scene for objects corresponding to a point in the rendered image.
   * @access public
   * @param {CGPoint} point - 
   * @param {?Map<SCNHitTestOption, Object>} [options = null] - A dictionary of options affecting the search. See Hit Testing Options Keys for acceptable values.
   * @returns {SCNHitTestResult[]} - 
   * @desc A 2D point in the rendered screen coordinate space can refer to any point along a line segment in the 3D scene coordinate space. Hit-testing is the process of finding elements of a scene located along this line segment. For example, you can use this method to find the geometry corresponding to a click event in a SceneKit view.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522929-hittest
   */


  hitTest(point, options = null) {
    if (this.scene === null) {
      return [];
    }

    let _options = new Map();

    if (options instanceof Map) {
      _options = options;
    } else if (Array.isArray(options)) {
      _options = new Map(options);
    }

    const cameraNode = this._getCameraNode();

    cameraNode.camera._updateProjectionTransform(this._viewRect);

    const from = new SCNVector3(point.x, point.y, 0);
    const to = new SCNVector3(point.x, point.y, 1.0);

    {
      return this._hitTestByCPU(cameraNode.viewProjectionTransform, from, to, _options);
    }

    return this._hitTestByGPU(cameraNode.viewProjectionTransform, from, to, _options);
  }

  _initializeHitFrameBuffer() {
    const gl = this.context;
    const width = this._viewRect.size.width;
    const height = this._viewRect.size.height;
    this._hitFrameBuffer = gl.createFramebuffer();
    this._hitDepthBuffer = gl.createRenderbuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._hitFrameBuffer);
    gl.bindRenderbuffer(gl.RENDERBUFFER, this._hitDepthBuffer);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);
    this._hitObjectIDTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, this._hitObjectIDTexture); // texImage2D(target, level, internalformat, width, height, border, format, type, source)

    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    this._hitFaceIDTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, this._hitFaceIDTexture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    this._hitPositionTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, this._hitPositionTexture); //gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, width, height, 0, gl.RGB, gl.UNSIGNED_BYTE, null)

    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    this._hitNormalTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, this._hitNormalTexture); //gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, width, height, 0, gl.RGB, gl.UNSIGNED_BYTE, null)

    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null); //gl.framebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer)

    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this._hitDepthBuffer); //gl.framebufferTexture2D(target, attachment, textarget, texture, level)

    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._hitObjectIDTexture, 0);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT1, gl.TEXTURE_2D, this._hitFaceIDTexture, 0);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT2, gl.TEXTURE_2D, this._hitPositionTexture, 0);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT3, gl.TEXTURE_2D, this._hitNormalTexture, 0);
    gl.drawBuffers([gl.COLOR_ATTACHMENT0, gl.COLOR_ATTACHMENT1, gl.COLOR_ATTACHMENT2, gl.COLOR_ATTACHMENT3]);
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  }
  /**
   * @access private
   * @param {SCNMatrix4} viewProjectionMatrix -
   * @param {SCNVector3} from -
   * @param {SCNVector3} to -
   * @param {Object} options -
   * @returns {SCNHitTestResult[]} -
   */


  _hitTestByCPU(viewProjectionMatrix, from, to, options) {
    const result = [];
    const invVp = viewProjectionMatrix.invert();
    const rayFrom = from.transform(invVp);
    const rayTo = to.transform(invVp); //console.log(`rayFrom: ${rayFrom.float32Array()}`)
    //console.log(`rayTo  : ${rayTo.float32Array()}`)
    //const rayVec = rayTo.sub(rayFrom)

    const renderingArray = this._createRenderingNodeArray(); //console.log(`renderingArray.length: ${renderingArray.length}`)


    let categoryBitMask = options.get(SCNHitTestOption.categoryBitMask);

    if (typeof categoryBitMask === 'undefined') {
      categoryBitMask = -1;
    }

    for (const node of renderingArray) {
      if (node.categoryBitMask & categoryBitMask) {
        //result.push(...this._nodeHitTestByCPU(node, rayFrom, rayVec))
        const hits = SCNPhysicsWorld._hitTestWithSegmentNode(rayFrom, rayTo, node);

        if (hits.length > 0) {
          // convert from the child's coordinate to this node's coordinate
          for (const h of hits) {
            h._node = node;
            h._worldCoordinates = node.convertPositionTo(h._localCoordinates, null);
            h._worldNormal = node.convertPositionTo(h._localNormal, null);
          }

          result.push(...hits);
        }
      }
    }

    return result;
  }
  /**
   * @access private
   * @param {SCNMatrix4} viewProjectionTransform -
   * @param {SCNVector3} from -
   * @param {SCNVector3} to -
   * @param {Map} options -
   * @returns {SCNHitTestResult[]} -
   */


  _hitTestByGPU(viewProjectionTransform, from, to, options) {
    const result = [];
    const gl = this._context;

    if (this._hitFrameBuffer === null) {
      this._initializeHitFrameBuffer();
    }

    const prg = this._defaultHitTestProgram;
    const hitTestProgram = prg._glProgram;

    this._useProgram(prg); //gl.useProgram(hitTestProgram)


    gl.bindFramebuffer(gl.FRAMEBUFFER, this._hitFrameBuffer);
    gl.depthMask(true);
    gl.depthFunc(gl.LEQUAL);
    gl.enable(gl.SCISSOR_TEST);
    gl.disable(gl.BLEND);
    gl.clearColor(0, 0, 0, 0);
    gl.clearDepth(1.0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    const x = (from.x + 1.0) * 0.5 * this._viewRect.size.width;
    const y = (from.y + 1.0) * 0.5 * this._viewRect.size.height;
    let sx = x - 1;
    let sy = y - 1;

    if (sx < 0) {
      sx = 0;
    } else if (sx + 3 > this._viewRect.size.width) {
      sx = this._viewRect.size.width - 3;
    }

    if (sy < 0) {
      sy = 0;
    } else if (sy + 3 > this._viewRect.size.height) {
      sy = this._viewRect.size.width - 3;
    }

    gl.scissor(sx, sy, 3, 3);
    gl.uniformMatrix4fv(gl.getUniformLocation(hitTestProgram, 'viewProjectionTransform'), false, viewProjectionTransform.float32Array());
    let backFaceCulling = options.get(SCNHitTestOption.backFaceCulling);

    if (typeof backFaceCulling === 'undefined') {
      backFaceCulling = true;
    }

    if (backFaceCulling) {
      gl.enable(gl.CULL_FACE);
      gl.cullFace(gl.BACK);
    } else {
      gl.disable(gl.CULL_FACE);
    }

    let categoryBitMask = options.get(SCNHitTestOption.categoryBitMask);

    if (typeof categoryBitMask === 'undefined') {
      categoryBitMask = -1;
    }

    let ignoreHiddenNodes = options.get(SCNHitTestOption.ignoreHiddenNodes);

    if (typeof ignoreHiddenNodes === 'undefined') {
      ignoreHiddenNodes = true;
    }

    const renderingArray = this._createRenderingNodeArray();

    const len = renderingArray.length;

    for (let i = 0; i < len; i++) {
      const node = renderingArray[i];

      if ((node.categoryBitMask & categoryBitMask) === 0) {
        continue;
      }

      if (ignoreHiddenNodes && node.isHidden) {
        continue;
      }

      this._renderNodeForHitTest(node, i + 100, options);
    }

    const objectIDBuf = new Uint8Array(4);
    gl.readBuffer(gl.COLOR_ATTACHMENT0);
    gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, objectIDBuf, 0);
    const objectID = objectIDBuf[0] * 256 + objectIDBuf[1];
    const geometryIndex = objectIDBuf[2] * 256 + objectIDBuf[3];
    const faceIDBuf = new Uint8Array(4);
    gl.readBuffer(gl.COLOR_ATTACHMENT1);
    gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, faceIDBuf, 0);
    const faceIndex = faceIDBuf[0] * 16777216 + faceIDBuf[1] * 65536 + faceIDBuf[2] * 256 + faceIDBuf[3];
    const positionBuf = new Uint8Array(4);
    gl.readBuffer(gl.COLOR_ATTACHMENT2);
    gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, positionBuf, 0); //const screenPos = new SCNVector3(positionBuf[0] / 127.5 - 1.0, positionBuf[1] / 127.5 - 1.0, positionBuf[2] / 127.5 - 1.0)
    //const position = screenPos.transform(viewProjectionTransform.invert())

    const p = ((positionBuf[3] / 255.0 + positionBuf[2]) / 255.0 + positionBuf[1] / 255.0 + positionBuf[0]) / 255.0;
    const position = from.lerp(to, p);
    const normalBuf = new Uint8Array(4);
    gl.readBuffer(gl.COLOR_ATTACHMENT3);
    gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, normalBuf, 0);
    const normal = new SCNVector3(normalBuf[0] / 127.5 - 1.0, normalBuf[1] / 127.5 - 1.0, normalBuf[2] / 127.5 - 1.0); //console.log('***** Hit Result *****')
    //console.log(`objectID: ${objectID}`)
    //console.log(`geometryIndex: ${geometryIndex}`)
    //console.log(`faceIndex: ${faceIndex}`)
    //console.log(`position: ${position.floatArray()}`)
    //console.log(`normal: ${normal.floatArray()}`)
    //console.log('**********************')

    if (objectID >= 100) {
      const r = new SCNHitTestResult();
      const node = renderingArray[objectID - 100];

      const worldInv = node.presentation._worldTransform.invert();

      r._node = node;
      r._geometryIndex = geometryIndex;
      r._faceIndex = faceIndex;
      r._worldCoordinates = position;
      r._worldNormal = normal;
      r._modelTransform = node.presentation._worldTransform;
      r._localCoordinates = position.transform(worldInv);
      r._localNormal = normal.transform(worldInv);
      result.push(r);
    }

    gl.disable(gl.SCISSOR_TEST);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    return result;
  }
  /**
   * @access private
   * @param {SCNVector3} from -
   * @param {SCNVector3} to -
   * @param {Map} options -
   * @param {Object} _options -
   * @returns {SCNHitTestResult[]} -
   */


  _physicsHitTestByGPU(from, to, options, _options) {
    const result = [];
    const gl = this._context;

    const viewProjectionTransform = this._createViewProjectionTransformForRay(from, to);

    const _from = from.transform(viewProjectionTransform);

    const _to = to.transform(viewProjectionTransform);

    if (this._hitFrameBuffer === null) {
      this._initializeHitFrameBuffer();
    }

    const prg = this._defaultHitTestProgram;
    const hitTestProgram = prg._glProgram; //gl.useProgram(hitTestProgram)

    this._useProgram(prg);

    gl.bindFramebuffer(gl.FRAMEBUFFER, this._hitFrameBuffer);
    gl.depthMask(true);
    gl.depthFunc(gl.LEQUAL);
    gl.enable(gl.SCISSOR_TEST);
    gl.disable(gl.BLEND);
    gl.clearColor(0, 0, 0, 0);
    gl.clearDepth(1.0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // screen position

    const x = (_from.x + 1.0) * 0.5 * this._viewRect.size.width;
    const y = (_from.y + 1.0) * 0.5 * this._viewRect.size.height; // left top of the scissor area

    const areaSize = 3;
    let sx = x - 1;
    let sy = y - 1;

    if (sx < 0) {
      sx = 0;
    } else if (sx + areaSize > this._viewRect.size.width) {
      sx = this._viewRect.size.width - areaSize;
    }

    if (sy < 0) {
      sy = 0;
    } else if (sy + areaSize > this._viewRect.size.height) {
      sy = this._viewRect.size.width - areaSize;
    }

    gl.scissor(sx, sy, areaSize, areaSize);
    gl.uniformMatrix4fv(gl.getUniformLocation(hitTestProgram, 'viewProjectionTransform'), false, viewProjectionTransform.float32Array());
    let backFaceCulling = options.get(SCNPhysicsWorld.TestOption.backfaceCulling);

    if (typeof backFaceCulling === 'undefined') {
      backFaceCulling = true;
    }

    if (backFaceCulling) {
      gl.enable(gl.CULL_FACE);
      gl.cullFace(gl.BACK);
    } else {
      gl.disable(gl.CULL_FACE);
    }

    let collisionBitMask = options.get(SCNPhysicsWorld.TestOption.collisionBitMask);

    if (typeof collisionBitMask === 'undefined') {
      collisionBitMask = -1;
    }

    let searchMode = options.get(SCNPhysicsWorld.TestOption.searchMode);

    if (typeof searchMode === 'undefined') {
      searchMode = SCNPhysicsWorld.TestSearchMode.closest;
    }

    let renderingArray = null;

    if (_options && _options.targets) {
      renderingArray = _options.targets;
      collisionBitMask = -1;
    } else {
      renderingArray = this._createRenderingPhysicsNodeArray();
    }

    const len = renderingArray.length;

    for (let i = 0; i < len; i++) {
      const node = renderingArray[i];
      const body = node.physicsBody;

      if ((body.categoryBitMask & collisionBitMask) === 0) {
        continue;
      }

      this._renderPhysicsNodeForHitTest(node, i + 100, options);
    }

    const objectIDBuf = new Uint8Array(4);
    gl.readBuffer(gl.COLOR_ATTACHMENT0);
    gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, objectIDBuf, 0);
    const objectID = objectIDBuf[0] * 256 + objectIDBuf[1];
    const geometryIndex = objectIDBuf[2] * 256 + objectIDBuf[3];
    const faceIDBuf = new Uint8Array(4);
    gl.readBuffer(gl.COLOR_ATTACHMENT1);
    gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, faceIDBuf, 0);
    const faceIndex = faceIDBuf[0] * 16777216 + faceIDBuf[1] * 65536 + faceIDBuf[2] * 256 + faceIDBuf[3];
    const positionBuf = new Uint8Array(4);
    gl.readBuffer(gl.COLOR_ATTACHMENT2);
    gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, positionBuf, 0); //const screenPos = new SCNVector3(positionBuf[0] / 127.5 - 1.0, positionBuf[1] / 127.5 - 1.0, positionBuf[2] / 127.5 - 1.0)
    //const position = screenPos.transform(viewProjectionTransform.invert())

    const p = ((positionBuf[3] / 255.0 + positionBuf[2]) / 255.0 + positionBuf[1] / 255.0 + positionBuf[0]) / 255.0;

    const screenPos = _from.lerp(_to, p);

    const position = screenPos.transform(viewProjectionTransform.invert());
    const normalBuf = new Uint8Array(4);
    gl.readBuffer(gl.COLOR_ATTACHMENT3);
    gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, normalBuf, 0);
    const normal = new SCNVector3(normalBuf[0] / 127.5 - 1.0, normalBuf[1] / 127.5 - 1.0, normalBuf[2] / 127.5 - 1.0); //console.log('***** Hit Result *****')
    //console.log(`objectID: ${objectID}`)
    //console.log(`geometryIndex: ${geometryIndex}`)
    //console.log(`faceIndex: ${faceIndex}`)
    //console.log(`from: ${from.floatArray()}`)
    //console.log(`to: ${to.floatArray()}`)
    //console.log(`positionBuf: ${positionBuf[0]}, ${positionBuf[1]}, ${positionBuf[2]}`)
    //console.log(`sPos: ${screenPos.floatArray()}`)
    //console.log(`position: ${position.floatArray()}`)
    //console.log(`normal: ${normal.floatArray()}`)
    //console.log('**********************')

    if (objectID >= 100) {
      const r = new SCNHitTestResult();
      const node = renderingArray[objectID - 100];

      const worldInv = node.presentation._worldTransform.invert();

      r._node = node;
      r._geometryIndex = geometryIndex;
      r._faceIndex = faceIndex;
      r._worldCoordinates = position;
      r._worldNormal = normal;
      r._modelTransform = node.presentation._worldTransform;
      r._localCoordinates = position.transform(worldInv);
      r._localNormal = normal.transform(worldInv);
      result.push(r);
    }

    gl.disable(gl.SCISSOR_TEST);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    return result;
  }
  /**
   *
   * @access private
   * @param {SCNVector3} from -
   * @param {SCNVector3} to -
   * @returns {SCNMatrix4} -
   */


  _createViewProjectionTransformForRay(from, to) {
    const vec = to.sub(from);
    const len = vec.length();
    const zNear = 1;
    const zFar = zNear + len;
    const proj = new SCNMatrix4();
    proj.m11 = 1;
    proj.m22 = 1;
    proj.m33 = -(zFar + zNear) / len;
    proj.m34 = -1;
    proj.m43 = -2 * zFar * zNear / len; // TODO: use an orthographic projection
    //proj.m33 = -2 / len
    //proj.m43 = -(zFar + zNear) / len
    //proj.m44 = 1

    const view = new SCNMatrix4();
    const up = new SCNVector3(0, 1, 0);

    if (vec.x === 0 && vec.z === 0) {
      up.y = 0;
      up.z = 1;
    }

    const f = vec.normalize();
    const s = f.cross(up).normalize();
    const u = s.cross(f).normalize();
    view.m11 = s.x;
    view.m21 = s.y;
    view.m31 = s.z;
    view.m12 = u.x;
    view.m22 = u.y;
    view.m32 = u.z;
    view.m13 = -f.x;
    view.m23 = -f.y;
    view.m33 = -f.z;
    view.m44 = 1;
    const eye = from.sub(f.mul(zNear));
    const t = eye.transform(view);
    view.m41 = -t.x;
    view.m42 = -t.y;
    view.m43 = -t.z;
    return view.mult(proj);
  }
  /**
   * Required. Returns a Boolean value indicating whether a node might be visible from a specified point of view.
   * @access public
   * @param {SCNNode} node - The node whose visibility is to be tested.
   * @param {SCNNode} pointOfView - A node defining a point of view, as used by the pointOfView property.
   * @returns {boolean} - 
   * @desc Any node containing a camera or spotlight may serve as a point of view (see the pointOfView property for details). Such a node defines a viewing frustum—a portion of the scene’s coordinate space, shaped like a truncated pyramid, that encloses all points visible from that point of view.Use this method to test whether a node lies within the viewing frustum defined by another node (which may or may not be the scene renderer’s current pointOfView node). For example, in a game scene containing multiple camera nodes, you could use this method to determine which camera is currently best for viewing a moving player character.Note that this method does not perform occlusion testing. That is, it returns true if the tested node lies within the specified viewing frustum regardless of whether that node’s contents are obscured by other geometry.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522647-isnode
   */


  isNodeInsideFrustumOf(node, pointOfView) {
    return false;
  }
  /**
   * Required. Returns all nodes that might be visible from a specified point of view.
   * @access public
   * @param {SCNNode} pointOfView - A node defining a point of view, as used by the pointOfView property.
   * @returns {SCNNode[]} - 
   * @desc Any node containing a camera or spotlight may serve as a point of view (see the pointOfView property for details). Such a node defines a viewing frustum—a portion of the scene’s coordinate space, shaped like a truncated pyramid, that encloses all points visible from that point of view.Use this method find all nodes whose content lies within the viewing frustum defined by another node (which may or may not be the scene renderer’s current pointOfView node).Note that this method does not perform occlusion testing. That is, the returned array includes any node that lies within the specified viewing frustum regardless of whether that node’s contents are obscured by other geometry.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522942-nodesinsidefrustum
   */


  nodesInsideFrustumOf(pointOfView) {
    return null;
  }
  /**
   * Required. Projects a point from the 3D world coordinate system of the scene to the 2D pixel coordinate system of the renderer.
   * @access public
   * @param {SCNVector3} point - A point in the world coordinate system of the renderer’s scene.
   * @returns {SCNVector3} - 
   * @desc The z-coordinate of the returned point describes the depth of the projected point relative to the near and far clipping planes of the renderer’s viewing frustum (defined by its pointOfView node). Projecting a point on the near clipping plane returns a point whose z-coordinate is 0.0; projecting a point on the far clipping plane returns a point whose z-coordinate is 1.0.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1524089-projectpoint
   */


  projectPoint(point) {
    return null;
  }
  /**
   * Required. Unprojects a point from the 2D pixel coordinate system of the renderer to the 3D world coordinate system of the scene.
   * @access public
   * @param {SCNVector3} point - A point in the screen-space (view, layer, or GPU viewport) coordinate system of the scene renderer.
   * @returns {SCNVector3} - 
   * @desc The z-coordinate of the point parameter describes the depth at which to unproject the point relative to the near and far clipping planes of the renderer’s viewing frustum (defined by its pointOfView node). Unprojecting a point whose z-coordinate is 0.0 returns a point on the near clipping plane; unprojecting a point whose z-coordinate is 1.0 returns a point on the far clipping plane.A 2D point in the rendered screen coordinate space can refer to any point along a line segment in the 3D scene coordinate space. To test for scene contents along this line—for example, to find the geometry corresponding to the location of a click event in a view—use the hitTest(_:options:) method.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522631-unprojectpoint
   */


  unprojectPoint(point) {
    return null;
  } // Customizing Scene Rendering with Metal

  /**
   * Required. The Metal render command encoder in use for the current SceneKit rendering pass.
   * @type {?MTLRenderCommandEncoder}
   * @desc Use this render command encoder to encode additional rendering commands before or after SceneKit draws its own content.This property is valid only during the SceneKit rendering loop—that is, within one of the methods defined in the SCNSceneRendererDelegate protocol. Accessing this property at any other time returns nil.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522609-currentrendercommandencoder
   */


  get currentRenderCommandEncoder() {
    return this._currentRenderCommandEncoder;
  }
  /**
   * Required. The Metal device this renderer uses for rendering.
   * @type {?MTLDevice}
   * @desc Use this property to create or look up other Metal resources that use the same device as your SceneKit renderer.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523935-device
   */


  get device() {
    return this._device;
  }
  /**
   * Required. The Metal command queue this renderer uses for rendering.
   * @type {?MTLCommandQueue}
   * @desc Use this property to schedule additional command buffers for the Metal device to execute as part of the render cycle. For example, you can use a compute command encoder to modify the vertex data in a Metal buffer for use by a SCNGeometrySource object.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523974-commandqueue
   */


  get commandQueue() {
    return this._commandQueue;
  }
  /**
   * Required. The Metal pixel format for the renderer’s color output.
   * @type {MTLPixelFormat}
   * @desc Use this property, along with the depthPixelFormat and stencilPixelFormat properties, if you perform custom drawing with Metal (see the SCNSceneRendererDelegate and SCNNodeRendererDelegate classes) and need to create a new MTLRenderPipelineState object to change the GPU state as part of your rendering.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523701-colorpixelformat
   */


  get colorPixelFormat() {
    return this._colorPixelFormat;
  }
  /**
   * Required. The Metal pixel format for the renderer’s depth buffer.
   * @type {MTLPixelFormat}
   * @desc Use this property, along with the colorPixelFormat and stencilPixelFormat properties, if you perform custom drawing with Metal (see the SCNSceneRendererDelegate and SCNNodeRendererDelegate classes) and need to create a new MTLRenderPipelineState object to change the GPU state as part of your rendering.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523780-depthpixelformat
   */


  get depthPixelFormat() {
    return this._depthPixelFormat;
  }
  /**
   * Required. The Metal pixel format for the renderer’s stencil buffer.
   * @type {MTLPixelFormat}
   * @desc Use this property, along with the depthPixelFormat and colorPixelFormat properties, if you perform custom drawing with Metal (see the SCNSceneRendererDelegate and SCNNodeRendererDelegate classes) and need to create a new MTLRenderPipelineState object to change the GPU state as part of your rendering.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523315-stencilpixelformat
   */


  get stencilPixelFormat() {
    return this._stencilPixelFormat;
  } // Customizing Scene Rendering with OpenGL

  /**
   * Required. The OpenGL rendering context that SceneKit uses for rendering the scene.
   * @type {?Object}
   * @desc In macOS, the value of this property is a Core OpenGL cglContextObj object.In iOS, the value of this property is an EAGLContext object.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522840-context
   */


  get context() {
    return this._context;
  }

  _setContext(context) {
    this._context = context;

    this._createDummyTexture();
  } // Working With Positional Audio

  /**
   * Required. The 3D audio mixing node SceneKit uses for positional audio effects.
   * @type {AVAudioEnvironmentNode}
   * @desc SceneKit uses this audio node to spatialize sounds from SCNAudioPlayer objects attached to nodes in the scene. You can use this object in conjunction with the audioEngine property to rearrange the audio graph to add other, non-spatialized audio sources or mix in audio processing effects.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523582-audioenvironmentnode
   */


  get audioEnvironmentNode() {
    return this._audioEnvironmentNode;
  }
  /**
   * Required. The audio engine SceneKit uses for playing scene sounds.
   * @type {AVAudioEngine}
   * @desc SceneKit uses this audio engine to play sounds from SCNAudioPlayer objects attached to nodes in the scene. You can use this object directly to add other sound sources not related to scene contents, or to add other sound processing nodes or mixing nodes to the audio engine. To identify the node SceneKit uses for spatializing scene sounds when connecting other nodes, use the audioEnvironmentNode property.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522686-audioengine
   */


  get audioEngine() {
    return this._audioEngine;
  }
  /**
   * @access private
   * @param {SCNGeometry} geometry -
   * @returns {SCNProgram} -
   */


  _getProgramForGeometry(geometry) {
    if (geometry.program !== null && geometry.program._programCompiled) {
      return geometry.program;
    }

    if (geometry.program || geometry.shaderModifiers !== null || geometry._shadableHelper !== null) {
      this._compileProgramForObject(geometry);
    }

    for (const material of geometry.materials) {
      if (material.program || material.shaderModifiers !== null || material._shadableHelper !== null) {
        this._compileProgramForObject(material);
      }
    }

    if (geometry.program) {
      return geometry.program;
    }

    return this._defaultProgram;
  }
  /**
   * @access private
   * @param {SCNShadable} obj -
   * @returns {void}
   */


  _compileProgramForObject(obj) {
    const gl = this.context;
    let p = obj.program;

    if (!p) {
      p = new SCNProgram();
      obj.program = p;
    } else if (p._programCompiled) {
      return p;
    }

    p._parentObject = obj;

    const glProgram = p._getGLProgramForContext(gl);

    const vsText = this._vertexShaderForObject(obj);

    const fsText = this._fragmentShaderForObject(obj); // initialize vertex shader


    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, vsText);
    gl.compileShader(vertexShader);

    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      const info = gl.getShaderInfoLog(vertexShader);
      throw new Error(`vertex shader compile error: ${info}`);
    }

    p._glVertexShader = vertexShader; // initialize fragment shader

    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fsText);
    gl.compileShader(fragmentShader);

    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      const info = gl.getShaderInfoLog(fragmentShader);
      throw new Error(`fragment shader compile error: ${info}`);
    }

    p._glFragmentShader = fragmentShader;
    gl.attachShader(glProgram, vertexShader);
    gl.attachShader(glProgram, fragmentShader); // link program object

    gl.linkProgram(glProgram);

    if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
      const info = gl.getProgramInfoLog(glProgram);
      throw new Error(`program link error: ${info}`);
    }

    p._programCompiled = true;
    return p;
  }
  /**
   * @access private
   * @param {SCNProgram} program -
   * @returns {void}
   */


  _useProgram(program) {
    if (this._currentProgram === program) {
      return;
    }

    const gl = this.context;

    const glProgram = program._getGLProgramForContext(gl);

    gl.useProgram(glProgram);

    program._setDummyTextureForContext(gl);

    this._currentProgram = program;
  }
  /**
   * @access private
   * @param {SCNProgram} program -
   * @returns {void}
   */


  _switchProgram(program) {
    if (this._currentProgram === program) {
      return;
    }

    const gl = this.context;

    const glProgram = program._getGLProgramForContext(gl);

    gl.useProgram(glProgram); // set dummy textures

    program._setDummyTextureForContext(gl); // set shadow textures


    const lights = this._lightNodes;

    for (let i = 0; i < lights.directionalShadow.length; i++) {
      const node = lights.directionalShadow[i];
      const symbol = `TEXTURE${i + 8}`;
      gl.activeTexture(gl[symbol]);
      gl.bindTexture(gl.TEXTURE_2D, node.presentation.light._shadowDepthTexture);
    } // bind buffers


    const cameraIndex = gl.getUniformBlockIndex(glProgram, 'cameraUniform');
    gl.uniformBlockBinding(glProgram, cameraIndex, _cameraLoc);
    gl.bindBufferBase(gl.UNIFORM_BUFFER, _cameraLoc, this._cameraBuffer);
    const fogIndex = gl.getUniformBlockIndex(glProgram, 'fogUniform');
    gl.uniformBlockBinding(glProgram, fogIndex, _fogLoc);
    gl.bindBufferBase(gl.UNIFORM_BUFFER, _fogLoc, this._fogBuffer);
    const lightIndex = gl.getUniformBlockIndex(glProgram, 'lightUniform');
    gl.uniformBlockBinding(glProgram, lightIndex, _lightLoc);
    gl.bindBufferBase(gl.UNIFORM_BUFFER, _lightLoc, this._lightBuffer);
    const scnLightsIndex = gl.getUniformBlockIndex(glProgram, 'SCNLightsUniform');
    gl.uniformBlockBinding(glProgram, scnLightsIndex, _scnLightsLoc);
    gl.bindBufferBase(gl.UNIFORM_BUFFER, _scnLightsLoc, this._scnLightsBuffer); // set uniform variables

    const uniformTime = gl.getUniformLocation(glProgram, 'u_time');

    if (uniformTime) {
      // this._time might be too large.
      const time = this._time % 100000.0;
      gl.uniform1f(uniformTime, time);
    }

    const obj = program._parentObject;

    if (obj) {
      // bind custom uniforms
      let textureNo = 16; // TEXTURE0-15 is reserved for the default renderer (0-11: material, 12-15: shadow)

      for (const key of Object.keys(obj._valuesForUndefinedKeys)) {
        const loc = gl.getUniformLocation(glProgram, key);

        if (loc !== null) {
          const val = obj._valuesForUndefinedKeys[key];

          if (typeof val === 'number') {
            gl.uniform1f(loc, val);
          } else if (_InstanceOf(val, SCNVector3)) {
            gl.uniform3fv(loc, val.float32Array());
          } else if (_InstanceOf(val, SCNVector4) || _InstanceOf(val, SKColor)) {
            gl.uniform4fv(loc, val.float32Array());
          } else if (_InstanceOf(val, SCNMaterialProperty)) {
            // TODO: refactoring: SCNGeometry has the same function
            if (val._contents instanceof Image) {
              //val._contents = this._createTexture(gl, val._contents)
              const image = val._contents;
              const texture = gl.createTexture();
              const canvas = document.createElement('canvas');
              canvas.width = image.naturalWidth;
              canvas.height = image.naturalHeight;
              canvas.getContext('2d').drawImage(image, 0, 0);
              gl.bindTexture(gl.TEXTURE_2D, texture); // texImage2D(target, level, internalformat, width, height, border, format, type, source)
              // Safari complains that 'source' is not ArrayBufferView type, but WebGL2 should accept HTMLCanvasElement.

              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, image.width, image.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
              gl.generateMipmap(gl.TEXTURE_2D);
              val._contents = texture;
            }

            if (val._contents instanceof WebGLTexture) {
              gl.uniform1i(loc, textureNo);
              gl.activeTexture(gl[`TEXTURE${textureNo}`]); // TODO: check texture type

              gl.bindTexture(gl.TEXTURE_2D, val._contents);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, val._magnificationFilterFor(gl));
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, val._minificationFilterFor(gl));
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, val._wrapSFor(gl));
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, val._wrapTFor(gl));
            }

            textureNo += 1;
          } // TODO: implement for other types

        }
      }
    }

    this._currentProgram = program;
  }
  /**
   * @access private
   * @type {SCNProgram}
   */


  get _defaultProgram() {
    const numLightsChanged = this._numLightsChanged();

    if (this.__defaultProgram !== null && !numLightsChanged) {
      return this.__defaultProgram;
    }

    const gl = this.context;

    if (this.__defaultProgram === null) {
      this.__defaultProgram = new SCNProgram();
    }

    const p = this.__defaultProgram;

    const glProgram = p._getGLProgramForContext(gl);

    const vsText = this._defaultVertexShader;
    const fsText = this._defaultFragmentShader; // initialize vertex shader

    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, vsText);
    gl.compileShader(vertexShader);

    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      const info = gl.getShaderInfoLog(vertexShader);
      throw new Error(`vertex shader compile error: ${info}`);
    }

    this.__defaultProgram._glVertexShader = vertexShader; // initialize fragment shader

    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fsText);
    gl.compileShader(fragmentShader);

    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      const info = gl.getShaderInfoLog(fragmentShader);
      throw new Error(`fragment shader compile error: ${info}`);
    }

    this.__defaultProgram._glFragmentShader = fragmentShader;
    gl.attachShader(glProgram, vertexShader);
    gl.attachShader(glProgram, fragmentShader); // link program object

    gl.linkProgram(glProgram);

    if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
      const info = gl.getProgramInfoLog(glProgram);
      throw new Error(`program link error: ${info}`);
    }

    this._switchProgram(p);

    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.enable(gl.CULL_FACE);
    gl.cullFace(gl.BACK); // set default textures to prevent warnings
    //this._setDummyTextureAsDefault(p)

    return this.__defaultProgram;
  }
  /**
   * @access private
   * @type {SCNProgram}
   */


  get _defaultPBRProgram() {
    const numLightsChanged = this._numLightsChanged();

    if (this.__defaultPBRProgram !== null && !numLightsChanged) {
      return this.__defaultPBRProgram;
    }

    const gl = this.context;

    if (this.__defaultPBRProgram === null) {
      this.__defaultPBRProgram = new SCNProgram();
    }

    const p = this.__defaultPBRProgram;

    const glProgram = p._getGLProgramForContext(gl);

    const vsText = this._defaultVertexShader;
    const fsText = this._defaultPBRFragmentShader; // initialize vertex shader

    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, vsText);
    gl.compileShader(vertexShader);

    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      const info = gl.getShaderInfoLog(vertexShader);
      throw new Error(`vertex shader compile error: ${info}`);
    }

    this.__defaultPBRProgram._glVertexShader = vertexShader; // initialize fragment shader

    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fsText);
    gl.compileShader(fragmentShader);

    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      const info = gl.getShaderInfoLog(fragmentShader);
      throw new Error(`fragment shader compile error: ${info}`);
    }

    this.__defaultPBRProgram._glFragmentShader = fragmentShader;
    gl.attachShader(glProgram, vertexShader);
    gl.attachShader(glProgram, fragmentShader); // link program object

    gl.linkProgram(glProgram);

    if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
      const info = gl.getProgramInfoLog(glProgram);
      throw new Error(`program link error: ${info}`);
    }

    this._switchProgram(p);

    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.enable(gl.CULL_FACE);
    gl.cullFace(gl.BACK); // set default textures to prevent warnings
    //this._setDummyTextureAsDefault(p)

    return this.__defaultPBRProgram;
  }
  /**
   * @access private
   * @param {SCNGeometry} geometry -
   * @returns {SCNProgram} -
   */


  _programForGeometry(geometry) {}
  /**
   * @access private
   * @returns {string} -
   */


  get _defaultVertexShader() {
    return this._replaceTexts(_SCNDefaultVertexShader);
  }
  /**
   * @access private
   * @param {SCNShadable} obj -
   * @returns {string} -
   */


  _vertexShaderForObject(obj) {
    let txt = obj.program.vertexShader;

    if (!txt) {
      txt = _SCNDefaultVertexShader;
    }

    return this._replaceTexts(txt, obj);
  }
  /**
   * @access private
   * @returns {string} -
   */


  get _defaultFragmentShader() {
    return this._replaceTexts(_SCNDefaultFragmentShader);
  }
  /**
   * @access private
   * @returns {string} -
   */


  get _defaultPBRFragmentShader() {
    return this._replaceTexts(_SCNDefaultPBRFragmentShader);
  }
  /**
   * @access private
   * @param {SCNShadable} obj -
   * @returns {string} -
   */


  _fragmentShaderForObject(obj) {
    let txt = obj.program.fragmentShader;

    if (!txt) {
      txt = _SCNDefaultFragmentShader;
    }

    return this._replaceTexts(txt, obj);
  }
  /**
   * @access private
   * @param {string} text -
   * @param {?SCNShadable} [shadable = null] -
   * @returns {string} -
   */


  _replaceTexts(text, shadable = null) {
    const vars = new Map();
    const numAmbient = this._numLights[SCNLight.LightType.ambient];
    const numDirectional = this._numLights[SCNLight.LightType.directional];
    const numDirectionalShadow = this._numLights.directionalShadow;
    const numOmni = this._numLights[SCNLight.LightType.omni];
    const numSpot = this._numLights[SCNLight.LightType.spot];
    const numIES = this._numLights[SCNLight.LightType.IES];
    const numProbe = this._numLights[SCNLight.LightType.probe];
    const shadableHelper = shadable ? shadable._shadableHelper : null;
    const customProperties = shadable ? shadable._valuesForUndefinedKeys : {};
    const shaderModifiers = shadable ? shadable.shaderModifiers : null;
    vars.set('__NUM_AMBIENT_LIGHTS__', numAmbient);
    vars.set('__NUM_DIRECTIONAL_LIGHTS__', numDirectional);
    vars.set('__NUM_DIRECTIONAL_SHADOW_LIGHTS__', numDirectionalShadow);
    vars.set('__NUM_OMNI_LIGHTS__', numOmni);
    vars.set('__NUM_SPOT_LIGHTS__', numSpot);
    vars.set('__NUM_IES_LIGHTS__', numIES);
    vars.set('__NUM_PROBE_LIGHTS__', numProbe);
    vars.set('__USE_SHADER_MODIFIER_GEOMETRY__', 0);
    vars.set('__SHADER_MODIFIER_GEOMETRY__', '');
    vars.set('__USE_SHADER_MODIFIER_SURFACE__', 0);
    vars.set('__SHADER_MODIFIER_SURFACE__', '');
    vars.set('__USE_SHADER_MODIFIER_FRAGMENT__', 0);
    vars.set('__SHADER_MODIFIER_FRAGMENT__', '');
    let customUniform = '';
    let customSurface = '';
    let customTexcoord = '';

    if (shaderModifiers) {
      for (const key of Object.keys(shaderModifiers)) {
        const mod = shaderModifiers[key];

        const _texts = mod.split(/^\s*#pragma\s+body\s*$/m);

        if (_texts.length === 1) ; else if (_texts.length === 2) {
          customUniform += _texts[0].replace(/^\s*#pragma\s+.*$/mg, '');
        } else {
          throw new Error('found multiple "#pragma body" in the shaderModifier');
        }
      }
    } else {
      for (const key of Object.keys(customProperties)) {
        const val = customProperties[key];

        if (typeof val === 'number') {
          customUniform += `uniform float ${key};`;
        } else if (_InstanceOf(val, SCNMaterialProperty)) {
          customUniform += `uniform sampler2D ${key};`;
          customTexcoord += `_surface.${key}Texcoord = v_texcoord${val.mappingChannel};`;
          customSurface += `vec2 ${key}Texcoord;`;
        } else {
          // TODO: implement for other types
          throw new Error(`custom property for ${key} is not implemented`);
        }
      }
    }

    vars.set('__USER_CUSTOM_UNIFORM__', customUniform);
    vars.set('__USER_CUSTOM_SURFACE__', customSurface);
    vars.set('__USER_CUSTOM_TEXCOORD__', customTexcoord);
    let modifiers = null;

    if (shaderModifiers) {
      modifiers = shaderModifiers;
    } else if (shadableHelper) {
      modifiers = shadableHelper._shaderModifiers;
    }

    if (modifiers) {
      if (modifiers.SCNShaderModifierEntryPointGeometry) {
        const _text = this._processShaderText(modifiers.SCNShaderModifierEntryPointGeometry);

        vars.set('__USE_SHADER_MODIFIER_GEOMETRY__', 1);
        vars.set('__SHADER_MODIFIER_GEOMETRY__', _text);
      }

      if (modifiers.SCNShaderModifierEntryPointSurface) {
        const _text = this._processShaderText(modifiers.SCNShaderModifierEntryPointSurface);

        vars.set('__USE_SHADER_MODIFIER_SURFACE__', 1);
        vars.set('__SHADER_MODIFIER_SURFACE__', _text);
      }

      if (modifiers.SCNShaderModifierEntryPointFragment) {
        const _text = this._processShaderText(modifiers.SCNShaderModifierEntryPointFragment);

        vars.set('__USE_SHADER_MODIFIER_FRAGMENT__', 1);
        vars.set('__SHADER_MODIFIER_FRAGMENT__', _text);
      }
    }
    let fsLighting = '';

    if (numDirectionalShadow > 0) {
      for (let i = 0; i < numDirectionalShadow; i++) {
        const fsDSText = _fsDirectionalShadow.replace(new RegExp('__I__', 'g'), i);

        fsLighting += fsDSText;
      }
    }

    vars.set('__FS_LIGHTING__', fsLighting);
    let result = text;
    vars.forEach((value, key) => {
      const rex = new RegExp(key, 'g');
      result = result.replace(rex, value);
    });
    return result;
  }

  _processShaderText(text) {
    let _text = text;

    const _texts = text.split(/^\s*#pragma\s+body\s*$/m);

    if (_texts.length == 2) {
      _text = _texts[1].replace(/^\s*#pragma\s+.*$/mg, '');
    }

    _text = _text.replace(/texture2D/g, 'texture');
    _text = _text.replace(/float2/g, 'vec2');
    _text = _text.replace(/float3/g, 'vec3');
    _text = _text.replace(/float4/g, 'vec4');
    _text = _text.replace(/scn_frame\.time/g, 'u_time'); //_text = _text.replace(/#pragma alpha/g, '')

    _text = _text.replace(/half /g, 'float '); // FIXME: check semicolon before half

    _text = _text.replace(/u_modelTransform/g, 'modelTransform'); // TODO: use u_modelTransform

    _text = _text.replace(/u_viewTransform/g, 'camera.viewTransform'); // TODO: use u_viewTransform

    _text = _text.replace(/u_inverseViewTransform/g, 'camera.inverseViewTransform'); // TODO: use u_inverseViewTransform

    _text = _text.replace(/u_viewProjectionTransform/g, 'caemra.viewProjectionTransform'); // TODO: use u_viewTransform

    _text = _text.replace(/\s*uniform[^;]*;/g, ''); // workaround for Badger...

    _text = _text.replace('uvs.x *= 2', 'uvs.x *= 2.0');
    _text = _text.replace('tn * 2 - 1', 'tn * 2.0 - vec3(1)');
    _text = _text.replace('tn2 * 2 - 1', 'tn2 * 2.0 - vec3(1)'); // workaround for Fox2...

    _text = _text.replace('pow(_surface.ambientOcclusion,3)', 'pow(_surface.ambientOcclusion,3.0)');
    _text = _text.replace('pow(AO,5)', 'pow(AO,5.0)');
    _text = _text.replace('pow(1.-fresnelBasis , 6)', 'pow(1.-fresnelBasis , 6.0)');
    _text = _text.replace('pow(1.-fresnelBasis , 4)', 'pow(1.-fresnelBasis , 4.0)');
    _text = _text.replace('vec3(1,0.4,0.0) * 1;', 'vec3(1,0.4,0.0);');
    _text = _text.replace('vec3(0.6,0.3,0.2) * 1;', 'vec3(0.6,0.3,0.2);');
    _text = _text.replace('vec4 WorldPos', 'vec3 WorldPos');
    _text = _text.replace('mult * 5;', 'mult * 5.0;');
    _text = _text.replace('mask * (1 - feather) + feather / 2', 'mask * (1.0 - feather) + feather / 2.0');
    _text = _text.replace('vec4 pos = modelTransform * _geometry.position;', 'vec4 pos = modelTransform * vec4(_geometry.position, 1);');
    _text = _text.replace('cos((u_time * 0.5 + pos.x) * 2)', 'cos((u_time * 0.5 + pos.x) * 2.0)');
    _text = _text.replace('(WorldPos.x * 10)', '(WorldPos.x * 10.0)');
    _text = _text.replace('(WorldPos.z + WorldPos.x) * 3)', '(WorldPos.z + WorldPos.x) * 3.0)');
    _text = _text.replace('pow(flowmap, 1.0/2.2)', 'pow(flowmap, vec2(1.0/2.2))');
    _text = _text.replace(/\(flowmap\/2\)/g, '(flowmap/2.0)');
    return _text;
  }

  _initializeVAO(node, glProgram) {
    const gl = this.context;
    const geometry = node.presentation.geometry;
    const baseGeometry = node.geometry; // prepare vertex array data

    const vertexBuffer = geometry._createVertexBuffer(gl, node); // TODO: retain attribute locations


    const positionLoc = gl.getAttribLocation(glProgram, 'position');
    const normalLoc = gl.getAttribLocation(glProgram, 'normal');
    const tangentLoc = gl.getAttribLocation(glProgram, 'tangent');
    const colorLoc = gl.getAttribLocation(glProgram, 'color');
    const texcoord0Loc = gl.getAttribLocation(glProgram, 'texcoord0');
    const texcoord1Loc = gl.getAttribLocation(glProgram, 'texcoord1');
    const boneIndicesLoc = gl.getAttribLocation(glProgram, 'boneIndices');
    const boneWeightsLoc = gl.getAttribLocation(glProgram, 'boneWeights');
    geometry._vertexArrayObjects = [];
    const elementCount = node.presentation.geometry.geometryElements.length;

    for (let i = 0; i < elementCount; i++) {
      const element = node.presentation.geometry.geometryElements[i];
      const material = node.presentation.geometry.materials[i];
      const vao = gl.createVertexArray();
      gl.bindVertexArray(vao); // initialize vertex buffer

      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
      gl.bindAttribLocation(glProgram, positionLoc, 'position');
      gl.bindAttribLocation(glProgram, normalLoc, 'normal');
      gl.bindAttribLocation(glProgram, tangentLoc, 'tangent');
      gl.bindAttribLocation(glProgram, colorLoc, 'color');
      gl.bindAttribLocation(glProgram, texcoord0Loc, 'texcoord0');
      gl.bindAttribLocation(glProgram, texcoord1Loc, 'texcoord1');
      gl.bindAttribLocation(glProgram, boneIndicesLoc, 'boneIndices');
      gl.bindAttribLocation(glProgram, boneWeightsLoc, 'boneWeights'); // vertexAttribPointer(ulong idx, long size, ulong type, bool norm, long stride, ulong offset)
      // position

      const posSrc = geometry.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.vertex)[0];

      if (posSrc) {
        gl.enableVertexAttribArray(positionLoc);
        gl.vertexAttribPointer(positionLoc, posSrc.componentsPerVector, gl.FLOAT, false, posSrc.dataStride, posSrc.dataOffset);
      } else {
        gl.disableVertexAttribArray(positionLoc);
      } // normal


      const nrmSrc = geometry.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.normal)[0];

      if (nrmSrc) {
        gl.enableVertexAttribArray(normalLoc);
        gl.vertexAttribPointer(normalLoc, nrmSrc.componentsPerVector, gl.FLOAT, false, nrmSrc.dataStride, nrmSrc.dataOffset);
      } else {
        gl.disableVertexAttribArray(normalLoc);
      } // tangent


      const tanSrc = geometry.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.tangent)[0];

      if (tanSrc) {
        gl.enableVertexAttribArray(tangentLoc);
        gl.vertexAttribPointer(tangentLoc, tanSrc.componentsPerVector, gl.FLOAT, false, tanSrc.dataStride, tanSrc.dataOffset);
      } else {
        gl.disableVertexAttribArray(tangentLoc);
      } // color


      const colorSrc = geometry.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.color)[0];

      if (colorSrc) {
        gl.enableVertexAttribArray(colorLoc);
        gl.vertexAttribPointer(colorLoc, colorSrc.componentsPerVector, gl.FLOAT, false, colorSrc.dataStride, colorSrc.dataOffset);
      } else {
        gl.disableVertexAttribArray(colorLoc);
      } // texcoord0


      const tex0Src = geometry.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.texcoord)[0];

      if (tex0Src) {
        //console.log(`texSrc: ${texcoordLoc}, ${texSrc.componentsPerVector}, ${texSrc.dataStride}, ${texSrc.dataOffset}`)
        gl.enableVertexAttribArray(texcoord0Loc);
        gl.vertexAttribPointer(texcoord0Loc, tex0Src.componentsPerVector, gl.FLOAT, false, tex0Src.dataStride, tex0Src.dataOffset);
      } else {
        gl.disableVertexAttribArray(texcoord0Loc);
      } // texcoord1


      const tex1Src = geometry.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.texcoord)[1];

      if (tex1Src) {
        gl.enableVertexAttribArray(texcoord1Loc);
        gl.vertexAttribPointer(texcoord1Loc, tex1Src.componentsPerVector, gl.FLOAT, false, tex1Src.dataStride, tex1Src.dataOffset);
      } else {
        gl.disableVertexAttribArray(texcoord1Loc);
      } // boneIndices


      const indSrc = node.skinner && node.skinner._useGPU ? node.skinner._boneIndices : null;

      if (indSrc) {
        //console.log(`indSrc: ${boneIndicesLoc}, ${indSrc.componentsPerVector}, ${indSrc.dataStride}, ${indSrc.dataOffset}`)
        gl.enableVertexAttribArray(boneIndicesLoc);
        gl.vertexAttribPointer(boneIndicesLoc, indSrc.componentsPerVector, gl.FLOAT, false, indSrc.dataStride, indSrc.dataOffset);
      } else {
        gl.disableVertexAttribArray(boneIndicesLoc);
      } // boneWeights


      const wgtSrc = node.skinner && node.skinner._useGPU ? node.skinner._boneWeights : null;

      if (wgtSrc) {
        //console.log(`wgtSrc: ${boneWeightsLoc}, ${wgtSrc.componentsPerVector}, ${wgtSrc.dataStride}, ${wgtSrc.dataOffset}`)
        gl.enableVertexAttribArray(boneWeightsLoc);
        gl.vertexAttribPointer(boneWeightsLoc, wgtSrc.componentsPerVector, gl.FLOAT, false, wgtSrc.dataStride, wgtSrc.dataOffset);
      } else {
        gl.disableVertexAttribArray(boneWeightsLoc);
      } // FIXME: use setting


      gl.disable(gl.CULL_FACE); // initialize index buffer
      // FIXME: check geometrySource semantic

      const indexBuffer = element._createBuffer(gl);

      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

      geometry._vertexArrayObjects.push(vao);
    }
  }

  _initializeShadowVAO(node, glProgram) {
    const gl = this.context;
    const geometry = node.presentation.geometry;
    const baseGeometry = node.geometry; // prepare vertex array data

    const vertexBuffer = geometry._createVertexBuffer(gl, node); // TODO: retain attribute locations


    const positionLoc = gl.getAttribLocation(glProgram, 'position');
    const boneIndicesLoc = gl.getAttribLocation(glProgram, 'boneIndices');
    const boneWeightsLoc = gl.getAttribLocation(glProgram, 'boneWeights');
    geometry._shadowVAO = [];
    const elementCount = node.presentation.geometry.geometryElements.length;

    for (let i = 0; i < elementCount; i++) {
      const element = node.presentation.geometry.geometryElements[i];
      const material = node.presentation.geometry.materials[i];
      const shadowVAO = gl.createVertexArray();
      gl.bindVertexArray(shadowVAO); // initialize vertex buffer

      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
      gl.bindAttribLocation(glProgram, positionLoc, 'position');
      gl.bindAttribLocation(glProgram, boneIndicesLoc, 'boneIndices');
      gl.bindAttribLocation(glProgram, boneWeightsLoc, 'boneWeights'); // vertexAttribPointer(ulong idx, long size, ulong type, bool norm, long stride, ulong offset)
      // position

      const posSrc = geometry.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.vertex)[0];

      if (posSrc) {
        gl.enableVertexAttribArray(positionLoc);
        gl.vertexAttribPointer(positionLoc, posSrc.componentsPerVector, gl.FLOAT, false, posSrc.dataStride, posSrc.dataOffset);
      } else {
        gl.disableVertexAttribArray(positionLoc);
      } // boneIndices


      const indSrc = node.skinner && node.skinner._useGPU ? node.skinner._boneIndices : null;

      if (indSrc) {
        gl.enableVertexAttribArray(boneIndicesLoc);
        gl.vertexAttribPointer(boneIndicesLoc, indSrc.componentsPerVector, gl.FLOAT, false, indSrc.dataStride, indSrc.dataOffset);
      } else {
        gl.disableVertexAttribArray(boneIndicesLoc);
      } // boneWeights


      const wgtSrc = node.skinner && node.skinner._useGPU ? node.skinner._boneWeights : null;

      if (wgtSrc) {
        gl.enableVertexAttribArray(boneWeightsLoc);
        gl.vertexAttribPointer(boneWeightsLoc, wgtSrc.componentsPerVector, gl.FLOAT, false, wgtSrc.dataStride, wgtSrc.dataOffset);
      } else {
        gl.disableVertexAttribArray(boneWeightsLoc);
      } // FIXME: use setting


      gl.disable(gl.CULL_FACE); // initialize index buffer
      // FIXME: check geometrySource semantic

      const indexBuffer = element._createBuffer(gl);

      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

      geometry._shadowVAO.push(shadowVAO);
    }
  }

  _initializeHitTestVAO(node, glProgram, physics = false) {
    const gl = this.context;
    const geometry = physics ? node.physicsBody.physicsShape._sourceGeometry : node.presentation.geometry;
    const baseGeometry = physics ? geometry : node.geometry; // TODO: retain attribute locations

    const positionLoc = gl.getAttribLocation(glProgram, 'position');
    const normalLoc = gl.getAttribLocation(glProgram, 'normal');
    const boneIndicesLoc = gl.getAttribLocation(glProgram, 'boneIndices');
    const boneWeightsLoc = gl.getAttribLocation(glProgram, 'boneWeights');
    geometry._hitTestVAO = [];
    const elementCount = geometry.geometryElements.length;

    for (let i = 0; i < elementCount; i++) {
      const element = geometry.geometryElements[i];
      const vao = gl.createVertexArray();
      gl.bindVertexArray(vao);
      gl.bindBuffer(gl.ARRAY_BUFFER, geometry._vertexBuffer);
      gl.bindAttribLocation(glProgram, positionLoc, 'position');
      gl.bindAttribLocation(glProgram, normalLoc, 'normal');
      gl.bindAttribLocation(glProgram, boneIndicesLoc, 'boneIndices');
      gl.bindAttribLocation(glProgram, boneWeightsLoc, 'boneWeights'); // vertexAttribPointer(ulong idx, long size, ulong type, bool norm, long stride, ulong offset)
      // position

      const posSrc = geometry.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.vertex)[0];

      if (posSrc) {
        gl.enableVertexAttribArray(positionLoc);
        gl.vertexAttribPointer(positionLoc, posSrc.componentsPerVector, gl.FLOAT, false, posSrc.dataStride, posSrc.dataOffset);
      } else {
        gl.disableVertexAttribArray(positionLoc);
      } // normal


      const nrmSrc = geometry.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.normal)[0];

      if (nrmSrc) {
        gl.enableVertexAttribArray(normalLoc);
        gl.vertexAttribPointer(normalLoc, nrmSrc.componentsPerVector, gl.FLOAT, false, nrmSrc.dataStride, nrmSrc.dataOffset);
      } else {
        gl.disableVertexAttribArray(normalLoc);
      } // boneIndices


      const indSrc = node.skinner ? node.skinner._boneIndices : null;

      if (indSrc) {
        gl.enableVertexAttribArray(boneIndicesLoc);
        gl.vertexAttribPointer(boneIndicesLoc, indSrc.componentsPerVector, gl.FLOAT, false, indSrc.dataStride, indSrc.dataOffset);
      } else {
        gl.disableVertexAttribArray(boneIndicesLoc);
      } // boneWeights


      const wgtSrc = node.skinner ? node.skinner._boneWeights : null;

      if (wgtSrc) {
        gl.enableVertexAttribArray(boneWeightsLoc);
        gl.vertexAttribPointer(boneWeightsLoc, wgtSrc.componentsPerVector, gl.FLOAT, false, wgtSrc.dataStride, wgtSrc.dataOffset);
      } else {
        gl.disableVertexAttribArray(boneWeightsLoc);
      } // initialize index buffer
      // FIXME: check geometrySource semantic


      const indexBuffer = element._createBuffer(gl);

      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, element._buffer);

      geometry._hitTestVAO.push(vao);
    }
  }

  _initializeCameraBuffer(glProgram) {
    const gl = this.context;
    const cameraIndex = gl.getUniformBlockIndex(glProgram, 'cameraUniform');
    this._cameraBuffer = gl.createBuffer();
    gl.uniformBlockBinding(glProgram, cameraIndex, _cameraLoc);
    gl.bindBufferBase(gl.UNIFORM_BUFFER, _cameraLoc, this._cameraBuffer);
  }

  _initializeFogBuffer(glProgram) {
    const gl = this.context;
    const fogIndex = gl.getUniformBlockIndex(glProgram, 'fogUniform');
    this._fogBuffer = gl.createBuffer();
    gl.uniformBlockBinding(glProgram, fogIndex, _fogLoc);
    gl.bindBufferBase(gl.UNIFORM_BUFFER, _fogLoc, this._fogBuffer);
  }

  _initializeLightBuffer(glProgram) {
    const gl = this.context; // TODO: replace lightUniform to SCNLightsUniform

    const lightIndex = gl.getUniformBlockIndex(glProgram, 'lightUniform');
    this._lightBuffer = gl.createBuffer();
    gl.uniformBlockBinding(glProgram, lightIndex, _lightLoc);
    gl.bindBufferBase(gl.UNIFORM_BUFFER, _lightLoc, this._lightBuffer);
    const scnLightsIndex = gl.getUniformBlockIndex(glProgram, 'SCNLightsUniform');
    this._scnLightsBuffer = gl.createBuffer();
    gl.uniformBlockBinding(glProgram, scnLightsIndex, _scnLightsLoc);
    gl.bindBufferBase(gl.UNIFORM_BUFFER, _scnLightsLoc, this._scnLightsBuffer);

    for (let i = 0; i < this._lightNodes.directionalShadow.length; i++) {
      const node = this._lightNodes.directionalShadow[i];
      const symbol = `TEXTURE${i + _shadowTextureBaseIndex}`;
      const name = `u_shadowTexture${i}`;
      gl.uniform1i(gl.getUniformLocation(glProgram, name), i + _shadowTextureBaseIndex);
      gl.activeTexture(gl[symbol]);
      gl.bindTexture(gl.TEXTURE_2D, node.presentation.light._shadowDepthTexture);
    }
  }

  _initializeUBO(node, glProgram) {
    const gl = this.context;
    const geometry = node.presentation.geometry;
    const materialIndex = gl.getUniformBlockIndex(glProgram, 'materialUniform');
    geometry._materialBuffer = gl.createBuffer();
    gl.uniformBlockBinding(glProgram, materialIndex, _materialLoc);
    gl.bindBufferBase(gl.UNIFORM_BUFFER, _materialLoc, geometry._materialBuffer);
  }

  _updateVAO(node) {
    const gl = this.context;
    const geometry = node.presentation.geometry;
    const baseGeometry = node.geometry;

    geometry._updateVertexBuffer(gl, baseGeometry);
  }

  get _dummyTexture() {
    return this.__dummyTexture;
  }

  _createDummyTexture() {
    const gl = this.context;
    const canvas = document.createElement('canvas');
    canvas.width = 1;
    canvas.height = 1;
    const context = canvas.getContext('2d');
    context.fillStyle = 'rgba(255, 255, 255, 1.0)';
    context.fillRect(0, 0, 1, 1);
    this.__dummyTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, this.__dummyTexture); // texImage2D(target, level, internalformat, width, height, border, format, type, source)
    // Safari complains that 'source' is not ArrayBufferView type, but WebGL2 should accept HTMLCanvasElement.

    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
    gl.bindTexture(gl.TEXTURE_2D, null);
  }
  /**
   * @access private
   * @param {SCNProgram} program -
   * @returns {void}
   */
  //_setDummyTextureAsDefault(program) {
  //  const gl = this.context
  //  const p = program
  //  const texNames = [
  //    gl.TEXTURE0,
  //    gl.TEXTURE1,
  //    gl.TEXTURE2,
  //    gl.TEXTURE3,
  //    gl.TEXTURE4,
  //    gl.TEXTURE5,
  //    gl.TEXTURE6,
  //    gl.TEXTURE7
  //  ]
  //  const texSymbols = [
  //    'u_emissionTexture',
  //    'u_ambientTexture',
  //    'u_diffuseTexture',
  //    'u_specularTexture',
  //    'u_reflectiveTexture',
  //    'u_transparentTexture',
  //    'u_multiplyTexture',
  //    'u_normalTexture'
  //  ]
  //  for(let i=0; i<texNames.length; i++){
  //    const texName = texNames[i]
  //    const symbol = texSymbols[i]
  //    gl.uniform1i(gl.getUniformLocation(p._glProgram, symbol), i)
  //    gl.activeTexture(texName)
  //    gl.bindTexture(gl.TEXTURE_2D, this.__dummyTexture)
  //  }
  //}


  _switchToDefaultCamera() {
    if (this._pointOfView === null) {
      this._defaultCameraPosNode.position = new SCNVector3(0, 0, 0);
      this._defaultCameraRotNode.rotation = new SCNVector4(0, 0, 0, 0);
      this._defaultCameraNode.position = new SCNVector3(0, 0, _defaultCameraDistance);
    } else if (this._pointOfView !== this._defaultCameraNode) {
      const rot = this.pointOfView.presentation._worldRotation;
      const rotMat = SCNMatrix4.matrixWithRotation(rot);
      const pos = this.pointOfView.presentation._worldTranslation;
      this._defaultCameraPosNode.position = new SCNVector3(0, 0, -_defaultCameraDistance).rotate(rotMat).add(pos);
      this._defaultCameraRotNode.rotation = rot;
      this._defaultCameraNode.position = new SCNVector3(0, 0, _defaultCameraDistance); //console.log(`pov defined: pov.pos: ${this._pointOfView._worldTranslation.float32Array()}`)
      //console.log(`pov defined: node.pos: ${this._defaultCameraNode._worldTranslation.float32Array()}`)
    }

    this._pointOfView = this._defaultCameraNode;
  }

  _setDefaultCameraOrientation(orientation) {
    this._defaultCameraRotNode.orientation = orientation;
  }

  _searchCameraNode() {
    const nodes = [this.scene._rootNode];
    let node = nodes.shift();

    while (node) {
      if (node.camera !== null) {
        return node;
      }

      nodes.push(...node._childNodes);
      node = nodes.shift();
    }

    return null;
  }
  /**
   * @access private
   * @returns {SCNVector3} -
   */


  _getCameraPosition() {
    if (this._pointOfView === this._defaultCameraNode) {
      return this._defaultCameraPosNode.position;
    } else if (this._pointOfView === null) {
      return new SCNVector3(0, 0, 0);
    }

    const rot = this._getCameraOrientation();

    const rotMat = SCNMatrix4.matrixWithRotation(rot);
    const pos = this._pointOfView.presentation._worldTranslation;
    return pos.add(new SCNVector3(0, 0, -_defaultCameraDistance).rotate(rotMat));
  }
  /**
   * @access private
   * @returns {SCNVector4} -
   */


  _getCameraOrientation() {
    if (this._pointOfView === this._defaultCameraNode) {
      return this._defaultCameraRotNode.presentation.orientation;
    } else if (this._pointOfView === null) {
      return new SCNVector4(0, 0, 0, 0);
    }

    return this._pointOfView.presentation._worldOrientation;
  }
  /**
   * @access private
   * @returns {number} -
   */


  _getCameraDistance() {
    if (this._pointOfView === this._defaultCameraNode) {
      return this._defaultCameraNode.presentation.position.z;
    }

    return _defaultCameraDistance;
  }
  /**
   * @access private
   * @returns {boolean} - true if the number of lights is changed.
   */


  _numLightsChanged() {
    let changed = false;
    const types = [...Object.values(SCNLight.LightType), 'directionalShadow'];

    for (const type of types) {
      const num = this._lightNodes[type].length;

      if (num !== this._numLights[type]) {
        changed = true;
        this._numLights[type] = num;
      }
    }

    return changed;
  }
  /**
   * @access private
   * @param {SCNNode} node -
   * @param {SCNVector3} rayPoint - 
   * @param {SCNVector3} rayVec -
   * @returns {SCNHitTestResult[]} -
   */


  _nodeHitTestByCPU(node, rayPoint, rayVec) {
    const result = [];
    const geometry = node.presentation.geometry;
    const geometryCount = geometry.geometryElements.length;

    if (geometryCount === 0) {
      // nothing to draw...
      return result;
    }

    const invRay = rayVec.mul(-1); //console.log(`rayPoint: ${rayPoint.float32Array()}`)
    //console.log(`rayVec: ${rayVec.float32Array()}`)
    //if(node.morpher !== null){
    //  this._updateVAO(node)
    //}
    // TODO: test the bounding box/sphere first for performance

    const source = geometry.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.vertex)[0];
    const sourceLen = source.vectorCount;
    const sourceData = [];
    const modelTransform = node.presentation._worldTransform;
    const skinningJoints = [];

    if (node.presentation.skinner) {
      const skinner = node.presentation.skinner;
      const numBones = skinner._bones.length;

      for (let i = 0; i < numBones; i++) {
        const bone = skinner._bones[i];

        const mat = skinner._boneInverseBindTransforms[i].mult(bone._presentation._worldTransform);

        skinningJoints.push(mat);
      }

      for (let i = 0; i < sourceLen; i++) {
        const weights = skinner._boneWeights._vectorAt(i);

        const indices = skinner._boneIndices._vectorAt(i);

        const mat = new SCNMatrix4();

        for (let j = 0; j < skinner.numSkinningJoints; j++) {
          mat.add(skinningJoints[indices[j]].mul(weights[j]));
        }

        sourceData.push(source._scnVectorAt(i).transform(mat));
      }
    } else {
      for (let i = 0; i < sourceLen; i++) {
        sourceData.push(source._scnVectorAt(i).transform(modelTransform));
      }
    }

    for (let i = 0; i < geometryCount; i++) {
      //console.log(`geometry element ${i}`)
      const element = geometry.geometryElements[i];

      switch (element.primitiveType) {
        case SCNGeometryPrimitiveType.line:
          console.warn('hitTest for line is not implemented');
          continue;

        case SCNGeometryPrimitiveType.point:
          console.warn('hitTest for point is not implemented');
          continue;
      }

      const elementData = element._glData;
      const len = element.primitiveCount; //console.log(`primitiveCount: ${len}`)
      // TODO: check cull settings

      for (let pi = 0; pi < len; pi++) {
        const indices = element._indexAt(pi);

        const v0 = sourceData[indices[0]];
        const v1 = sourceData[indices[1]];
        const v2 = sourceData[indices[2]];
        const e1 = v1.sub(v0);
        const e2 = v2.sub(v0);

        let denom = this._det(e1, e2, invRay);

        if (denom <= 0) {
          continue;
        }

        denom = 1.0 / denom;
        const d = rayPoint.sub(v0);
        const u = this._det(d, e2, invRay) * denom;

        if (u < 0 || u > 1) {
          continue;
        }

        const v = this._det(e1, d, invRay) * denom;

        if (v < 0 || v > 1) {
          continue;
        }

        const t = this._det(e1, e2, d) * denom;

        if (t < 0) {
          continue;
        } // Hit!
        //console.log(`Hit! ${i}: ${pi}`)


        const hitPoint = rayPoint.add(rayVec.mul(t));
        const invModel = modelTransform.invert();
        const res = new SCNHitTestResult();
        res._node = node;
        res._geometryIndex = i;
        res._faceIndex = pi;
        res._worldCoordinates = hitPoint;
        res._localCoordinates = hitPoint.transform(invModel);
        const nom = e1.cross(e2);
        res._worldNormal = nom.normalize();
        res._localNormal = nom.transform(invModel);
        res._modelTransform = modelTransform;
        res._boneNode = null; // it should be array... what should I put here?

        result.push(res);
      }
    }

    return result;
  }
  /**
   * @access private
   * @type {SCNProgram}
   */


  get _defaultParticleProgram() {
    if (this.__defaultParticleProgram !== null) {
      return this.__defaultParticleProgram;
    }

    const gl = this.context;

    if (this.__defaultParticleProgram === null) {
      this.__defaultParticleProgram = new SCNProgram();
    }

    const p = this.__defaultParticleProgram;

    const glProgram = p._getGLProgramForContext(gl);

    const vsText = _SCNDefaultParticleVertexShader;
    const fsText = _SCNDefaultParticleFragmentShader; // initialize vertex shader

    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, vsText);
    gl.compileShader(vertexShader);

    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      const info = gl.getShaderInfoLog(vertexShader);
      throw new Error(`particle vertex shader compile error: ${info}`);
    } // initialize fragment shader


    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fsText);
    gl.compileShader(fragmentShader);

    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      const info = gl.getShaderInfoLog(fragmentShader);
      throw new Error(`particle fragment shader compile error: ${info}`);
    }

    gl.attachShader(glProgram, vertexShader);
    gl.attachShader(glProgram, fragmentShader); // link program object

    gl.linkProgram(glProgram);

    if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
      const info = gl.getProgramInfoLog(glProgram);
      throw new Error(`program link error: ${info}`);
    } //gl.useProgram(glProgram)


    this._useProgram(p); //gl.clearColor(1, 1, 1, 1)
    //gl.clearDepth(1.0)
    //gl.clearStencil(0)


    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.enable(gl.CULL_FACE);
    gl.cullFace(gl.BACK); // set default textures to prevent warnings

    this._setDummyParticleTextureAsDefault();

    return this.__defaultParticleProgram;
  }
  /**
   * @access private
   * @type {SCNProgram}
   */


  get _defaultShadowProgram() {
    if (this.__defaultShadowProgram !== null) {
      return this.__defaultShadowProgram;
    }

    const gl = this.context;

    if (this.__defaultShadowProgram === null) {
      this.__defaultShadowProgram = new SCNProgram();
    }

    const p = this.__defaultShadowProgram;

    const glProgram = p._getGLProgramForContext(gl);

    const vsText = _SCNDefaultShadowVertexShader;
    const fsText = _SCNDefaultShadowFragmentShader; // initialize vertex shader

    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, vsText);
    gl.compileShader(vertexShader);

    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      const info = gl.getShaderInfoLog(vertexShader);
      throw new Error(`particle vertex shader compile error: ${info}`);
    } // initialize fragment shader


    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fsText);
    gl.compileShader(fragmentShader);

    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      const info = gl.getShaderInfoLog(fragmentShader);
      throw new Error(`particle fragment shader compile error: ${info}`);
    }

    gl.attachShader(glProgram, vertexShader);
    gl.attachShader(glProgram, fragmentShader); // link program object

    gl.linkProgram(glProgram);

    if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
      const info = gl.getProgramInfoLog(glProgram);
      throw new Error(`program link error: ${info}`);
    } //gl.useProgram(glProgram)


    this._useProgram(p); //gl.clearColor(1, 1, 1, 1)
    //gl.clearDepth(1.0)
    //gl.clearStencil(0)


    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL); //gl.enable(gl.BLEND)

    gl.disable(gl.BLEND); //gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)

    gl.enable(gl.CULL_FACE);
    gl.cullFace(gl.BACK);
    return this.__defaultShadowProgram;
  }

  _setDummyParticleTextureAsDefault() {
    const gl = this.context;
    const p = this._defaultParticleProgram;

    const glProgram = p._getGLProgramForContext(gl);

    const texNames = [gl.TEXTURE0 //gl.TEXTURE1
    ];
    const texSymbols = ['particleTexture' //'colorTexture'
    ];

    for (let i = 0; i < texNames.length; i++) {
      const texName = texNames[i];
      const symbol = texSymbols[i];
      gl.uniform1i(gl.getUniformLocation(glProgram, symbol), i);
      gl.activeTexture(texName);
      gl.bindTexture(gl.TEXTURE_2D, this.__dummyTexture);
    }
  }
  /**
   * @access private
   * @type {SCNProgram}
   */


  get _defaultHitTestProgram() {
    if (this.__defaultHitTestProgram !== null) {
      return this.__defaultHitTestProgram;
    }

    const gl = this.context;

    if (this.__defaultHitTestProgram === null) {
      this.__defaultHitTestProgram = new SCNProgram();
    }

    const p = this.__defaultHitTestProgram;

    const glProgram = p._getGLProgramForContext(gl);

    const vsText = _SCNDefaultHitTestVertexShader;
    const fsText = _SCNDefaultHitTestFragmentShader; // initialize vertex shader

    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, vsText);
    gl.compileShader(vertexShader);

    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      const info = gl.getShaderInfoLog(vertexShader);
      throw new Error(`hitTest vertex shader compile error: ${info}`);
    } // initialize fragment shader


    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fsText);
    gl.compileShader(fragmentShader);

    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      const info = gl.getShaderInfoLog(fragmentShader);
      throw new Error(`hitTest fragment shader compile error: ${info}`);
    }

    gl.attachShader(glProgram, vertexShader);
    gl.attachShader(glProgram, fragmentShader); // link program object

    gl.linkProgram(glProgram);

    if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
      const info = gl.getProgramInfoLog(glProgram);
      throw new Error(`program link error: ${info}`);
    } //gl.useProgram(glProgram)


    this._useProgram(p); //gl.clearColor(1, 1, 1, 1)
    //gl.clearDepth(1.0)
    //gl.clearStencil(0)


    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.enable(gl.CULL_FACE);
    gl.cullFace(gl.BACK); //this._setDummyHitTestTextureAsDefault()

    return this.__defaultHitTestProgram;
  } // for debug


  _showShadowMapOfLight(lightNode) {
    const gl = this.context;
    const p = lightNode.presentation;
    const light = p.light;

    if (!this.__debugShadowMapSprite) {
      const node = new SKSpriteNode();
      node.size = new CGSize(100, 100);
      node.anchorPoint = new CGPoint(0.0, 0.0);
      const texture = new SKTexture();
      texture._glTexture = light._shadowDepthTexture;
      texture._image = {
        naturalWidth: 100,
        naturalHeight: 100
      };
      node._texture = texture;
      node.__presentation = node.copy();
      node.__presentation._isPresentationInstance = true;
      node.position = new CGPoint(100, 100);

      node._updateWorldTransform();

      this.__debugShadowMapSprite = node;
    }

    gl.clearDepth(-1);
    gl.clearStencil(0);
    gl.depthMask(true);
    gl.enable(gl.DEPTH_TEST);
    gl.disable(gl.CULL_FACE);
    gl.depthFunc(gl.GEQUAL);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.clear(gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);

    this._renderSKNode(this.__debugShadowMapSprite);
  }

  _setViewPort(width = null, height = null) {
    let w = width;
    let h = height;

    if (w === null || h === null) {
      w = this._viewRect.size.width;
      h = this._viewRect.size.height;
    }

    this.context.viewport(0, 0, w, h);
  }
  /**
   * calculate a determinant of 3x3 matrix from 3 vectors.
   * @access private
   * @param {SCNVector3} v1 -
   * @param {SCNVector3} v2 -
   * @param {SCNVector3} v3 -
   * @returns {number} -
   */


  _det(v1, v2, v3) {
    return v1.x * v2.y * v3.z + v1.y * v2.z * v3.x + v1.z * v2.x * v3.y - v1.x * v2.z * v3.y - v1.y * v2.x * v3.z - v1.z * v2.y * v3.x;
  }

}

/**
 * Options for choosing the graphics technology for an SCNView object (or other SceneKit renderer) to use for drawing its contents. Used by the renderingAPI property and the preferredRenderingAPI option when initializing an SCNView object.
 * @typedef {Object} SCNRenderingAPI
 * @property {number} metal - Use the Metal framework for SceneKit rendering.
 * @property {number} openGLES2 - Use the OpenGL ES 2.0 API for SceneKit rendering in iOS.
 * @property {number} openGLLegacy - Use the Legacy OpenGL API for SceneKit rendering in macOS.
 * @property {number} openGLCore32 - Use the OpenGL 3.2 Core Profile API for SceneKit rendering in macOS.
 * @property {number} openGLCore41 - Use the OpenGL 4.1 Core Profile API for SceneKit rendering in macOS.
 * @property {number} webGL - Use the OpenGL 4.1 Core Profile API for SceneKit rendering in macOS.
 * @see https://developer.apple.com/documentation/scenekit/scnrenderingapi
 */

const SCNRenderingAPI = {
  metal: 0,
  openGLLegacy: 1,
  openGLCore32: 2,
  openGLCore41: 3,
  openGLES2: 999,
  webGL: 998
};

/**
 * Methods you can implement to participate in the process of exporting a scene to a file.
 * @interface
 * @see https://developer.apple.com/documentation/scenekit/scnsceneexportdelegate
 */

class SCNSceneExportDelegate {
  /**
   * constructor
   * @access public
   * @constructor
   */
  //constructor() {
  //}
  // Writing Image Attachments

  /**
   * Tells the delegate to export an image attached to a scene.
   * @access public
   * @param {Image} image - An image attached to the scene being exported.
   * @param {string} documentURL - The URL the scene is being exported to.
   * @param {?string} originalImageURL - The URL the image was originally loaded from, or nil if the image was not previously loaded from a URL.
   * @returns {?string} - 
   * @desc If you implement this method, Scene Kit calls it for each image (for example, a texture) attached to the scene. Your app can then save the image data in a location and format of your choice, returning a URL for the exported image file.If you do not provide a delegate when exporting a scene, or if your delegate returns nil from this method, Scene Kit exports the image in a default format to a default location.
   * @see https://developer.apple.com/documentation/scenekit/scnsceneexportdelegate/1524221-write
   */
  writeWithSceneDocumentURL(image, documentURL, originalImageURL) {
    return null;
  }

}

/**
 * The signature for the block that SceneKit calls during scene export.
 * @type {function(totalProgress: number, error: ?Error, stop: UnsafeMutablePointer<ObjCBool>): void}
 * @param {number} totalProgress - A number between 0.0 and 1.0 that indicates the progress of the export operation, with 0.0 indicating that the operation has just begun and 1.0 indicating the operation has completed.
 * @param {?Error} error - An error encountered during the export process, or nil if no errors have occurred.
 * @param {UnsafeMutablePointer<ObjCBool>} stop - Set *stop to true inside the block to cancel export.
 * @returns {void}
 * @desc stopSet *stop to true inside the block to cancel export.
 * @see https://developer.apple.com/documentation/scenekit/scnsceneexportprogresshandler
 */

const SCNSceneExportProgressHandler = (totalProgress, error, stop) => {};

//import SCNNode from './SCNNode'
//import SCNDebugOptions from './SCNDebugOptions'
//import SCNRenderingAPI from './SCNRenderingAPI'
//import SCNHitTestResult from './SCNHitTestResult'
//import CGPoint from '../CoreGraphics/CGPoint'
//import SCNHitTestOption from './SCNHitTestOption'
//import SCNVector3 from './SCNVector3'
//import SCNSceneRendererDelegate from './SCNSceneRendererDelegate'

/**
 * Methods and properties common to the SCNView, SCNLayer and SCNRenderer classes.
 * @interface
 * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer
 */

class SCNSceneRenderer {
  /**
   * constructor
   * @access public
   * @constructor
   */
  constructor() {
    // Presenting a Scene

    /**
     * Required. The scene to be displayed.
     * @type {?SCNScene}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523956-scene
     */
    this.scene = null; // Managing Scene Display

    /**
     * Required. The node from which the scene’s contents are viewed for rendering.
     * @type {?SCNNode}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523982-pointofview
     */

    this.pointOfView = null;
    /**
     * Required. A Boolean value that determines whether SceneKit automatically adds lights to a scene.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523812-autoenablesdefaultlighting
     */

    this.autoenablesDefaultLighting = false;
    /**
     * Required. A Boolean value that determines whether SceneKit applies jittering to reduce aliasing artifacts.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1524026-isjitteringenabled
     */

    this.isJitteringEnabled = false;
    /**
     * Required. A Boolean value that determines whether SceneKit displays rendering performance statistics in an accessory view.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522763-showsstatistics
     */

    this.showsStatistics = false;
    /**
     * Required. Options for drawing overlay content in a scene that can aid debugging.
     * @type {SCNDebugOptions}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523281-debugoptions
     */

    this.debugOptions = null;
    this._renderingAPI = null; // Managing Scene Animation Timing

    /**
     * Required. The current scene time.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522680-scenetime
     */

    this.sceneTime = 0;
    /**
     * Required. A Boolean value that determines whether the scene is playing.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523401-isplaying
     */

    this.isPlaying = false;
    /**
     * Required. A Boolean value that determines whether SceneKit restarts the scene time after all animations in the scene have played.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522878-loops
     */

    this.loops = false; // Participating in the Scene Rendering Process

    /**
     * Required. A delegate object that receives messages about SceneKit’s rendering process.
     * @type {?SCNSceneRendererDelegate}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522671-delegate
     */

    this.delegate = null; // Customizing Scene Rendering with Metal

    this._currentRenderCommandEncoder = null;
    this._device = null;
    this._commandQueue = null;
    this._colorPixelFormat = null;
    this._depthPixelFormat = null;
    this._stencilPixelFormat = null; // Customizing Scene Rendering with OpenGL

    this._context = null; // Rendering Sprite Kit Content over a Scene

    /**
     * Required. A Sprite Kit scene to be rendered on top of the SceneKit content.
     * @type {?SKScene}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1524051-overlayskscene
     */

    this.overlaySKScene = null; // Working With Positional Audio

    /**
     * Required. The node representing the listener’s position in the scene for use with positional audio effects.
     * @type {?SCNNode}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523747-audiolistener
     */

    this.audioListener = null;
    this._audioEnvironmentNode = null;
    this._audioEngine = null; // Instance Properties

    /**
     * Required. 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522854-currenttime
     */

    this.currentTime = 0;
  } // Presenting a Scene

  /**
   * Required. Displays the specified scene with an animated transition.
   * @access public
   * @param {SCNScene} scene - The new scene to be displayed.
   * @param {SKTransition} transition - An object that specifies the duration and style of the animated transition.
   * @param {?SCNNode} pointOfView - The node to use as the pointOfView property when displaying the new scene.
   * @param {?function(): void} [completionHandler = null] - A block that SceneKit calls after the transition animation has completed.This block takes no parameters and has no return value.
   * @returns {void}
   * @desc Use this method to change the scene displayed in a SceneKit view (or other renderer) with an animated transition. For details on transition styles, see SKTransition.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523028-present
   */


  presentWithIncomingPointOfView(scene, transition, pointOfView, completionHandler = null) {} // Managing Scene Display

  /**
   * Required. The graphics technology SceneKit uses to render the scene.
   * @type {SCNRenderingAPI}
   * @desc You choose a graphics technology when initializing a scene renderer:When initializing a SCNView object, use the init(frame:options:) initializer and the preferredRenderingAPI key. Alternatively, create a view in Interface Builder and use the Rendering API control in the inspector. During initialization, the view will attempt to use the preferred API, but will fall back to a different API if the preferred one is not supported on the current hardware.To create a SCNRenderer object that renders into your own OpenGL contect, use the init(context:options:) initializer. To create a renderer for use in your own Metal workflow, use the init(device:options:) initializer.The rendering technology used by a SCNLayer object is determined by Core Animation.After initializing a renderer, this property reflects the rendering technology in use.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522616-renderingapi
   */


  get renderingAPI() {
    return this._renderingAPI;
  } // Preloading Renderer Resources

  /**
   * Required. Prepares a SceneKit object for rendering.
   * @access public
   * @param {Object} object - An SCNScene, SCNNode, SCNGeometry, or SCNMaterial instance.
   * @param {?function(): boolean} [block = null] - A block that SceneKit calls periodically while preparing the object. The block takes no parameters.Your block should return false to tell SceneKit to continue preparing the object, or true to cancel preparation.Pass nil for this parameter if you do not need an opportunity to cancel preparing the object.
   * @returns {boolean} - 
   * @desc By default, SceneKit lazily loads resources onto the GPU for rendering. This approach uses memory and GPU bandwidth efficiently, but can lead to stutters in an otherwise smooth frame rate when you add large amounts of new content to an animated scene. To avoid such issues, use this method to prepare content for drawing before adding it to the scene. You can call this method on a secondary thread to prepare content asynchronously. SceneKit prepares all content associated with the object parameter you provide. If you provide an SCNMaterial object, SceneKit loads any texture images assigned to its material properties. If you provide an SCNGeometry object, SceneKit loads all materials attached to the geometry, as well as its vertex data. If you provide an SCNNode or SCNScene object, SceneKit loads all geometries and materials associated with the node and all its child nodes, or with the entire node hierarchy of the scene.You can use the block parameter to cancel preparation if content is no longer needed. For example, in a game you might use this method to preload areas of the game world the player is soon to enter, but if the player character dies before entering those areas, you can return true from the block to cancel preloading.You can observe the progress of this operation with the Progress class. For details, see Progress.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522798-prepare
   */


  prepareShouldAbortBlock(object, block = null) {
    return false;
  }
  /**
   * Required. Prepares the specified SceneKit objects for rendering, using a background thread.
   * @access public
   * @param {Object[]} objects - An array of containing one or more SCNScene, SCNNode, SCNGeometry, or SCNMaterial instances.
   * @param {?function(arg1: boolean): void} [completionHandler = null] - A block that SceneKit calls when object preparation fails or completes.The block takes the following parameter:successtrue if all content was successfully prepared for rendering; otherwise, false.
   * @returns {void}
   * @desc By default, SceneKit lazily loads resources onto the GPU for rendering. This approach uses memory and GPU bandwidth efficiently, but can lead to stutters in an otherwise smooth frame rate when you add large amounts of new content to an animated scene. To avoid such issues, use this method to prepare content for drawing before adding it to the scene. SceneKit uses a secondary thread to prepare content asynchronously.SceneKit prepares all content associated with the objects you provide. If you provide an SCNMaterial object, SceneKit loads any texture images assigned to its material properties. If you provide an SCNGeometry object, SceneKit loads all materials attached to the geometry, as well as its vertex data. If you provide an SCNNode or SCNScene object, SceneKit loads all geometries and materials associated with the node and all its child nodes, or with the entire node hierarchy of the scene.You can observe the progress of this operation with the Progress class. For details, see Progress.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523375-prepare
   */


  prepare(objects, completionHandler = null) {} // Working With Projected Scene Contents

  /**
   * Required. Searches the renderer’s scene for objects corresponding to a point in the rendered image.
   * @access public
   * @param {CGPoint} point - 
   * @param {?Map<SCNHitTestOption, Object>} [options = null] - A dictionary of options affecting the search. See Hit Testing Options Keys for acceptable values.
   * @returns {SCNHitTestResult[]} - 
   * @desc A 2D point in the rendered screen coordinate space can refer to any point along a line segment in the 3D scene coordinate space. Hit-testing is the process of finding elements of a scene located along this line segment. For example, you can use this method to find the geometry corresponding to a click event in a SceneKit view.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522929-hittest
   */


  hitTest(point, options = null) {
    return null;
  }
  /**
   * Required. Returns a Boolean value indicating whether a node might be visible from a specified point of view.
   * @access public
   * @param {SCNNode} node - The node whose visibility is to be tested.
   * @param {SCNNode} pointOfView - A node defining a point of view, as used by the pointOfView property.
   * @returns {boolean} - 
   * @desc Any node containing a camera or spotlight may serve as a point of view (see the pointOfView property for details). Such a node defines a viewing frustum—a portion of the scene’s coordinate space, shaped like a truncated pyramid, that encloses all points visible from that point of view.Use this method to test whether a node lies within the viewing frustum defined by another node (which may or may not be the scene renderer’s current pointOfView node). For example, in a game scene containing multiple camera nodes, you could use this method to determine which camera is currently best for viewing a moving player character.Note that this method does not perform occlusion testing. That is, it returns true if the tested node lies within the specified viewing frustum regardless of whether that node’s contents are obscured by other geometry.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522647-isnode
   */


  isNodeInsideFrustumOf(node, pointOfView) {
    return false;
  }
  /**
   * Required. Returns all nodes that might be visible from a specified point of view.
   * @access public
   * @param {SCNNode} pointOfView - A node defining a point of view, as used by the pointOfView property.
   * @returns {SCNNode[]} - 
   * @desc Any node containing a camera or spotlight may serve as a point of view (see the pointOfView property for details). Such a node defines a viewing frustum—a portion of the scene’s coordinate space, shaped like a truncated pyramid, that encloses all points visible from that point of view.Use this method find all nodes whose content lies within the viewing frustum defined by another node (which may or may not be the scene renderer’s current pointOfView node).Note that this method does not perform occlusion testing. That is, the returned array includes any node that lies within the specified viewing frustum regardless of whether that node’s contents are obscured by other geometry.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522942-nodesinsidefrustum
   */


  nodesInsideFrustumOf(pointOfView) {
    return null;
  }
  /**
   * Required. Projects a point from the 3D world coordinate system of the scene to the 2D pixel coordinate system of the renderer.
   * @access public
   * @param {SCNVector3} point - A point in the world coordinate system of the renderer’s scene.
   * @returns {SCNVector3} - 
   * @desc The z-coordinate of the returned point describes the depth of the projected point relative to the near and far clipping planes of the renderer’s viewing frustum (defined by its pointOfView node). Projecting a point on the near clipping plane returns a point whose z-coordinate is 0.0; projecting a point on the far clipping plane returns a point whose z-coordinate is 1.0.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1524089-projectpoint
   */


  projectPoint(point) {
    return null;
  }
  /**
   * Required. Unprojects a point from the 2D pixel coordinate system of the renderer to the 3D world coordinate system of the scene.
   * @access public
   * @param {SCNVector3} point - A point in the screen-space (view, layer, or GPU viewport) coordinate system of the scene renderer.
   * @returns {SCNVector3} - 
   * @desc The z-coordinate of the point parameter describes the depth at which to unproject the point relative to the near and far clipping planes of the renderer’s viewing frustum (defined by its pointOfView node). Unprojecting a point whose z-coordinate is 0.0 returns a point on the near clipping plane; unprojecting a point whose z-coordinate is 1.0 returns a point on the far clipping plane.A 2D point in the rendered screen coordinate space can refer to any point along a line segment in the 3D scene coordinate space. To test for scene contents along this line—for example, to find the geometry corresponding to the location of a click event in a view—use the hitTest(_:options:) method.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522631-unprojectpoint
   */


  unprojectPoint(point) {
    return null;
  } // Customizing Scene Rendering with Metal

  /**
   * Required. The Metal render command encoder in use for the current SceneKit rendering pass.
   * @type {?MTLRenderCommandEncoder}
   * @desc Use this render command encoder to encode additional rendering commands before or after SceneKit draws its own content.This property is valid only during the SceneKit rendering loop—that is, within one of the methods defined in the SCNSceneRendererDelegate protocol. Accessing this property at any other time returns nil.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522609-currentrendercommandencoder
   */


  get currentRenderCommandEncoder() {
    return this._currentRenderCommandEncoder;
  }
  /**
   * Required. The Metal device this renderer uses for rendering.
   * @type {?MTLDevice}
   * @desc Use this property to create or look up other Metal resources that use the same device as your SceneKit renderer.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523935-device
   */


  get device() {
    return this._device;
  }
  /**
   * Required. The Metal command queue this renderer uses for rendering.
   * @type {?MTLCommandQueue}
   * @desc Use this property to schedule additional command buffers for the Metal device to execute as part of the render cycle. For example, you can use a compute command encoder to modify the vertex data in a Metal buffer for use by a SCNGeometrySource object.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523974-commandqueue
   */


  get commandQueue() {
    return this._commandQueue;
  }
  /**
   * Required. The Metal pixel format for the renderer’s color output.
   * @type {MTLPixelFormat}
   * @desc Use this property, along with the depthPixelFormat and stencilPixelFormat properties, if you perform custom drawing with Metal (see the SCNSceneRendererDelegate and SCNNodeRendererDelegate classes) and need to create a new MTLRenderPipelineState object to change the GPU state as part of your rendering.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523701-colorpixelformat
   */


  get colorPixelFormat() {
    return this._colorPixelFormat;
  }
  /**
   * Required. The Metal pixel format for the renderer’s depth buffer.
   * @type {MTLPixelFormat}
   * @desc Use this property, along with the colorPixelFormat and stencilPixelFormat properties, if you perform custom drawing with Metal (see the SCNSceneRendererDelegate and SCNNodeRendererDelegate classes) and need to create a new MTLRenderPipelineState object to change the GPU state as part of your rendering.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523780-depthpixelformat
   */


  get depthPixelFormat() {
    return this._depthPixelFormat;
  }
  /**
   * Required. The Metal pixel format for the renderer’s stencil buffer.
   * @type {MTLPixelFormat}
   * @desc Use this property, along with the depthPixelFormat and colorPixelFormat properties, if you perform custom drawing with Metal (see the SCNSceneRendererDelegate and SCNNodeRendererDelegate classes) and need to create a new MTLRenderPipelineState object to change the GPU state as part of your rendering.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523315-stencilpixelformat
   */


  get stencilPixelFormat() {
    return this._stencilPixelFormat;
  } // Customizing Scene Rendering with OpenGL

  /**
   * Required. The OpenGL rendering context that SceneKit uses for rendering the scene.
   * @type {?Object}
   * @desc In macOS, the value of this property is a Core OpenGL cglContextObj object.In iOS, the value of this property is an EAGLContext object.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522840-context
   */


  get context() {
    return this._context;
  } // Working With Positional Audio

  /**
   * Required. The 3D audio mixing node SceneKit uses for positional audio effects.
   * @type {AVAudioEnvironmentNode}
   * @desc SceneKit uses this audio node to spatialize sounds from SCNAudioPlayer objects attached to nodes in the scene. You can use this object in conjunction with the audioEngine property to rearrange the audio graph to add other, non-spatialized audio sources or mix in audio processing effects.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523582-audioenvironmentnode
   */


  get audioEnvironmentNode() {
    return this._audioEnvironmentNode;
  }
  /**
   * Required. The audio engine SceneKit uses for playing scene sounds.
   * @type {AVAudioEngine}
   * @desc SceneKit uses this audio engine to play sounds from SCNAudioPlayer objects attached to nodes in the scene. You can use this object directly to add other sound sources not related to scene contents, or to add other sound processing nodes or mixing nodes to the audio engine. To identify the node SceneKit uses for spatializing scene sounds when connecting other nodes, use the audioEnvironmentNode property.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522686-audioengine
   */


  get audioEngine() {
    return this._audioEngine;
  }

}

//import SCNScene from './SCNScene'

/**
 * Methods your app can implement to participate in SceneKit’s animation loop or perform additional rendering. 
 * @interface
 * @see https://developer.apple.com/documentation/scenekit/scnscenerendererdelegate
 */

class SCNSceneRendererDelegate {
  /**
   * constructor
   * @access public
   * @constructor
   */
  //constructor() {
  //}
  // Adding Custom Logic to the Rendering Loop

  /**
   * Tells the delegate to perform any updates that need to occur before actions, animations, and physics are evaluated.
   * @access public
   * @param {SCNSceneRenderer} renderer - 
   * @param {number} time - The current system time, in seconds. Use this parameter for any time-based elements of your game logic.
   * @returns {void}
   * @desc SceneKit calls this method exactly once per frame, so long as the SCNView object (or other SCNSceneRenderer object) displaying the scene is not paused. Implement this method to add game logic to the rendering loop. Any changes you make to the scene graph during this method are immediately reflected in the displayed scene. That is, SceneKit immediately updates the hierarchy of presentation nodes it uses to render the scene (instead of using the SCNTransaction class to “batch” your changes).
    * @see https://developer.apple.com/documentation/scenekit/scnscenerendererdelegate/1522937-renderer
   */
  rendererUpdateAtTime(renderer, time) {}
  /**
   * Tells the delegate to perform any updates that need to occur after actions and animations are evaluated.
   * @access public
   * @param {SCNSceneRenderer} renderer - 
   * @param {number} time - The current system time, in seconds. Use this parameter for any time-based elements of your game logic.
   * @returns {void}
   * @desc SceneKit calls this method exactly once per frame, so long as the SCNView object (or other SCNSceneRenderer object) displaying the scene is not paused. Implement this method to add game logic to the rendering loop. Any changes you make to the scene graph during this method are immediately reflected in the displayed scene. That is, SceneKit immediately updates the hierarchy of presentation nodes it uses to render the scene (instead of using the SCNTransaction class to “batch” your changes).
    * @see https://developer.apple.com/documentation/scenekit/scnscenerendererdelegate/1523038-renderer
   */


  rendererDidApplyAnimationsAtTime(renderer, time) {}
  /**
   * Tells the delegate to perform any updates that need to occur after physics simulations are performed.
   * @access public
   * @param {SCNSceneRenderer} renderer - 
   * @param {number} time - The current system time, in seconds. Use this parameter for any time-based elements of your game logic.
   * @returns {void}
   * @desc SceneKit calls this method exactly once per frame, so long as the SCNView object (or other SCNSceneRenderer object) displaying the scene is not paused. Implement this method to add game logic to the rendering loop. Any changes you make to the scene graph during this method are immediately reflected in the displayed scene. That is, SceneKit immediately updates the hierarchy of presentation nodes it uses to render the scene (instead of using the SCNTransaction class to “batch” your changes).
  This method is the last opportunity SceneKit provides for you to change the scene graph before rendering.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerendererdelegate/1522738-renderer
   */


  rendererDidSimulatePhysicsAtTime(renderer, time) {} // Rendering Custom Scene Content

  /**
   * Tells the delegate that the renderer has cleared the viewport and is about to render the scene.
   * @access public
   * @param {SCNSceneRenderer} renderer - 
   * @param {SCNScene} scene - The SCNScene object to be rendered.
   * @param {number} time - The current system time, in seconds. If your custom rendering involves animation, use this parameter to compute your own animation state.
   * @returns {void}
   * @desc Implement this method to perform custom drawing before SceneKit renders a scene—for example, to draw backdrop content underneath SceneKit content. You should only execute Metal or OpenGL drawing commands (and any setup required to perform them) in this method—the results of modifying SceneKit objects during this method are undefined.To render using Metal, use the renderer parameter to retrieve the scene renderer’s currentRenderCommandEncoder object and encode your own drawing commands. If you need to reference other Metal state, see the properties listed in SCNSceneRenderer.To render using OpenGL, simply call the relevant OpenGL drawing commands—SceneKit automatically makes its OpenGL context the current context before calling this method. If you need to reference the OpenGL context being rendered into, examine the context property of the renderer parameter.You must draw using the appropriate graphics technology for the view currently being rendered. Use the renderingAPI property of the renderer object to determine whether Metal or OpenGL is in use. 
   * @see https://developer.apple.com/documentation/scenekit/scnscenerendererdelegate/1523483-renderer
   */


  rendererWillRenderSceneAtTime(renderer, scene, time) {}
  /**
   * Tells the delegate that the renderer has rendered the scene.
   * @access public
   * @param {SCNSceneRenderer} renderer - 
   * @param {SCNScene} scene - The scene object that was rendered.
   * @param {number} time - The current system time, in seconds. If your custom rendering involves animation, use this parameter to compute your own animation state.
   * @returns {void}
   * @desc Implement this method to perform custom drawing after SceneKit has rendered a scene—for example, to draw overlay content on top of SceneKit content. You should only execute Metal or OpenGL drawing commands (and any setup required to perform them) in this method—the results of modifying SceneKit objects in this method are undefined.To render using Metal, use the renderer parameter to retrieve the scene renderer’s currentRenderCommandEncoder object and encode your own drawing commands. If you need to reference other Metal state, see the properties listed in SCNSceneRenderer.To render using OpenGL, simply call the relevant OpenGL drawing commands—SceneKit automatically makes its OpenGL context the current context before calling this method. If you need to reference the OpenGL context being rendered into, examine the context property of the renderer parameter.You must draw using the appropriate graphics technology for the view currently being rendered. Use the renderingAPI property of the renderer object to determine whether Metal or OpenGL is in use. 
   * @see https://developer.apple.com/documentation/scenekit/scnscenerendererdelegate/1524233-renderer
   */


  rendererDidRenderSceneAtTime(renderer, scene, time) {}

}

/**
 * Constants identifying phases of SceneKit’s scene loading process, used in a SCNSceneSourceStatusHandler block.
 * @typedef {Object} SCNSceneSourceStatus
 * @property {number} error - An error occurred when SceneKit attempted to load the scene.
 * @property {number} parsing - SceneKit has begun deserializing the source file.
 * @property {number} validating - SceneKit has begun validating the scene file’s format.
 * @property {number} processing - SceneKit has begun generating scene graph objects from the scene file’s contents.
 * @property {number} complete - SceneKit has successfully finished loading the scene file’s contents.
 * @see https://developer.apple.com/documentation/scenekit/scnscenesourcestatus
 */

const SCNSceneSourceStatus = {
  error: -1,
  parsing: 4,
  validating: 8,
  processing: 12,
  complete: 16
};

/**
 * The signature for the block that SceneKit calls periodically to report progress while loading a scene.
 * @type {function(totalProgress: number, status: SCNSceneSourceStatus, error: ?Error, stopLoading: UnsafeMutablePointer<ObjCBool>): void}
 * @param {number} totalProgress - A floating-point number between 0.0 and 1.0 indicating the overall progress of loading the scene. A value of 0.0 indicates that the loading process has just begun, and a value of 1.0 indicates that the process has completed.
 * @param {SCNSceneSourceStatus} status - A constant identifying one of the distinct phases of SceneKit’s loading procedure. See SCNSceneSourceStatus for possible values.
 * @param {?Error} error - An error object describing any error that has occurred during scene loading, or nil if no errors has been encountered.
 * @param {UnsafeMutablePointer<ObjCBool>} stopLoading - A reference to a Boolean value. Set *stop to true within the block to abort further processing of the scene source’s contents.
 * @returns {void}
 * @see https://developer.apple.com/documentation/scenekit/scnscenesourcestatushandler
 */

const SCNSceneSourceStatusHandler = (totalProgress, status, error, stopLoading) => {};

//import SCNShaderModifierEntryPoint from './SCNShaderModifierEntryPoint'
//import SCNBindingBlock from './SCNBindingBlock'

/**
 * Methods for customizing SceneKit's rendering of geometry and materials using Metal or OpenGL shader programs.
 * @interface
 * @see https://developer.apple.com/documentation/scenekit/scnshadable
 */

class SCNShadable {
  /**
   * constructor
   * @access public
   * @returns {void}
   */
  init() {
    // Assigning a Custom Shader Program

    /**
     * A program used when rendering the object.
     * @type {?SCNProgram}
     * @see https://developer.apple.com/documentation/scenekit/scnshadable/1523689-program
     */
    this.program = null; // Customizing SceneKit’s Shader Programs

    /**
     * A dictionary of GLSL source code snippets for customizing the shader programs provided by SceneKit.
     * @type {?Map<SCNShaderModifierEntryPoint, string>}
     * @see https://developer.apple.com/documentation/scenekit/scnshadable/1523348-shadermodifiers
     */

    this.shaderModifiers = null;
  } // Handling Parameters in Custom OpenGL Shader Programs

  /**
   * Specifies a block to be called before rendering with programs with the specified GLSL uniform variable or attribute name.
   * @access public
   * @param {string} symbol - A GLSL uniform variable or attribute name.
   * @param {?SCNBindingBlock} [block = null] - A block to be called by SceneKit.
   * @returns {void}
   * @desc Use this method to associate a block with a SceneKit object (geometry or material) to handle setup of an attribute or uniform variable in a custom SCNProgram shader associated with that object. SceneKit calls your block before rendering the object. In the block, you can execute any OpenGL commands or other code necessary for preparing your custom shader. For example, the following block updates the time uniform variable in a custom fragment shader for producing animated effects:CFTimeInterval startTime = CFAbsoluteTimeGetCurrent();
  [myNode.geometry.firstMaterial handleBindingOfSymbol:@"time" usingBlock:
    ^(unsigned int programID, unsigned int location, SCNNode *renderedNode, SCNRenderer *renderer) {
        glUniform1f(location, CFAbsoluteTimeGetCurrent() - startTime);
    }];
  This method is for OpenGL shader programs only. To bind custom variable data for Metal shader programs, use the handleBinding(ofBufferNamed:frequency:handler:) method.CFTimeInterval startTime = CFAbsoluteTimeGetCurrent();
  [myNode.geometry.firstMaterial handleBindingOfSymbol:@"time" usingBlock:
    ^(unsigned int programID, unsigned int location, SCNNode *renderedNode, SCNRenderer *renderer) {
        glUniform1f(location, CFAbsoluteTimeGetCurrent() - startTime);
    }];
    * @see https://developer.apple.com/documentation/scenekit/scnshadable/1523063-handlebinding
   */


  handleBindingOfSymbolHandler(symbol, block = null) {}
  /**
   * Specifies a block to be called after rendering with programs with the specified GLSL uniform variable or attribute name.
   * @access public
   * @param {string} symbol - A GLSL uniform variable or attribute name.
   * @param {?SCNBindingBlock} [block = null] - A block to be called by SceneKit.
   * @returns {void}
   * @desc Use this method to associate a block with a SceneKit object (geometry or material) to handle cleanup related to an attribute or uniform variable in a custom SCNProgram shader associated with that object. SceneKit will call your block after rendering the object. In the block, you can execute any OpenGL commands or other code necessary for post-rendering tasks.This method is for OpenGL shader programs only. To bind custom variable data for Metal shader programs, use the handleBinding(ofBufferNamed:frequency:handler:) method.
   * @see https://developer.apple.com/documentation/scenekit/scnshadable/1522783-handleunbinding
   */


  handleUnbindingOfSymbolHandler(symbol, block = null) {}

}

class SCNShadableHelper extends NSObject {
  static get _propTypes() {
    return {
      owner: ['SCNGeometry', '_owner'],
      shaderModifiers: ['NSDictionary', '_shaderModifiers']
    };
  }

  constructor() {
    super();
    this._owner = null;
    this._shaderModifiers = null;
  }

}

/**
 * 
 * @typedef {Object} SCNShaderModifierEntryPoint
 * @property {string} fragment - Use this entry point to change the color of a fragment after all other shading has been performed.
 * @property {string} geometry - Use this entry point to deform a geometry’s surface or alter its vertex attributes.
 * @property {string} lightingModel - Use this entry point to provide a custom lighting equation.
 * @property {string} surface - Use this entry point to modify the surface properties of a material before lighting is computed.
 * @see https://developer.apple.com/documentation/scenekit/scnshadermodifierentrypoint
 */

const SCNShaderModifierEntryPoint = {
  fragment: 'SCNShaderModifierEntryPointFragment',
  geometry: 'SCNShaderModifierEntryPointGeometry',
  lightingModel: 'SCNShaderModifierEntryPointLightingModel',
  surface: 'SCNShaderModifierEntryPointSurface'
};

/**
 * Options for SceneKit’s rendering of shadows cast by a light, used by the shadowMode property.
 * @typedef {Object} SCNShadowMode
 * @property {number} forward - SceneKit renders shadows during lighting computations.
 * @property {number} deferred - SceneKit renders shadows in a postprocessing pass.
 * @property {number} modulated - SceneKit renders shadows by projecting the light’s gobo image. The light does not illuminate the scene.
 * @see https://developer.apple.com/documentation/scenekit/scnshadowmode
 */

const SCNShadowMode = {
  forward: 0,
  deferred: 1,
  modulated: 2
};

/**
 * A geometry based on a two-dimensional path, optionally extruded to create a three-dimensional object.
 * @access public
 * @extends {SCNGeometry}
 * @see https://developer.apple.com/documentation/scenekit/scnshape
 */

class SCNShape extends SCNGeometry {
  // Creating a Shape

  /**
   * Creates a shape geometry with the specified path and extrusion depth.
   * @access public
   * @constructor
   * @param {?UIBezierPath} path - The two-dimensional path forming the basis of the shape.
   * @param {number} extrusionDepth - The thickness of the extruded shape along the z-axis.
   * @desc SceneKit determines the filled area of the path using the even-odd winding rule (see Winding Rules in Cocoa Drawing Guide) and extrudes this area to create a three-dimensional geometry. The result of extruding a self-intersecting path is undefined.The extruded shape is centered at the zero point of its z-axis. For example, an extrusion depth of 1.0 creates a shape that extends from -0.5 to 0.5 along the z-axis. An extrusion depth of zero creates a flat, one-sided shape.The path’s flatness (see flatness in NSBezierPath) determines the level of detail SceneKit uses in building a three-dimensional shape from the path. A larger flatness value results in fewer polygons to render, increasing performance, and a smaller flatness value increases the smoothness of curves at a cost to performance.
   * @see https://developer.apple.com/documentation/scenekit/scnshape/1523432-init
   */
  constructor(path, extrusionDepth) {
    super(); // Modifying a Shape

    /**
     * The thickness of the extruded shape along the z-axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnshape/1523365-extrusiondepth
     */

    this.extrusionDepth = 0;
    /**
     * The two-dimensional path forming the basis of the shape.
     * @type {?UIBezierPath}
     * @see https://developer.apple.com/documentation/scenekit/scnshape/1523434-path
     */

    this.path = null; // Chamfering a Shape

    /**
     * A constant specifying which ends of the extruded shape’s profile are chamfered.
     * @type {SCNChamferMode}
     * @see https://developer.apple.com/documentation/scenekit/scnshape/1523989-chamfermode
     */

    this.chamferMode = null;
    /**
     * A path that determines the cross-sectional contour of each chamfered edge.
     * @type {?UIBezierPath}
     * @see https://developer.apple.com/documentation/scenekit/scnshape/1522865-chamferprofile
     */

    this.chamferProfile = null;
    /**
     * The width or depth of each chamfered edge. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnshape/1524145-chamferradius
     */

    this.chamferRadius = 0;
  }

}

/**
 * An object that manages the relationship between skeletal animations and the nodes and geometries they animate.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/scenekit/scnskinner
 */

class SCNSkinner extends NSObject {
  static get _propTypes() {
    return {
      $constructor: (propNames, propValues) => {
        const invTransforms = [];
        const len = propValues.bones.length;

        for (let i = 0; i < len; i++) {
          const inv = propValues[`baseGeometryBindTransform-${i}`]; //console.log(`inv ${i} ${inv.float32Array()}`)

          if (typeof inv === 'undefined') {
            throw new Error(`boneInverseBindTransforms ${i} does not exist`);
          }

          invTransforms.push(inv);
        }

        const instance = new SCNSkinner(propValues.baseGeometry, propValues.bones, invTransforms, propValues.boneWeights, propValues.boneIndices);
        instance.skeleton = propValues.skeleton;
        instance.baseGeometryBindTransform = propValues.baseGeometryBindTransform;
        return instance;
      },
      $unknownKey: key => {
        //console.warn(`SCNSkinner unknownKey ${key}`)
        const pattern = new RegExp(/^baseGeometryBindTransform-(\d+)$/);
        const result = key.match(pattern);

        if (result !== null) {
          return ['SCNMatrix4', null];
        }

        return null;
      },
      baseGeometry: ['SCNGeometry', null],
      baseGeometryBindTransform: ['SCNMatrix4', null],
      skeleton: ['SCNNode', null],
      bones: ['NSArray', null],
      boneWeights: ['SCNGeometrySource', null],
      boneIndices: ['SCNGeometrySource', null]
    };
  } // Creating a Skinner Object

  /**
   * Creates a skinner object with the specified visible geometry and skeleton information.
   * @access public
   * @constructor
   * @param {?SCNGeometry} baseGeometry - The geometry whose surface the skinner’s animation skeleton deforms.
   * @param {SCNNode[]} bones - An array of SCNNode objects, each representing a bone or control point for the animation skeleton.
   * @param {?NSValue[]} boneInverseBindTransforms - An array of NSValue objects containing SCNMatrix4 transforms, each of which corresponds to a node in the bones array. Each value is the inverse matrix (see SCNMatrix4Invert(_:)) of that node’s transform property for the skeleton’s default pose.
   * @param {SCNGeometrySource} boneWeights - The geometry source defining the influence of each bone on the positions of vertices in the geometry. For details, see the boneWeights property.
   * @param {SCNGeometrySource} boneIndices - The geometry source defining the mapping from bone indices in skeleton data to the skinner’s bones array. For details, see the boneIndices property.
   * @desc To use the skinner object in a scene, assign it to the skinner property of a node. That node’s geometry property should reference the same SCNGeometry object as the skinner’s baseGeometry property.
   * @see https://developer.apple.com/documentation/scenekit/scnskinner/1523964-init
   */


  constructor(baseGeometry, bones, boneInverseBindTransforms, boneWeights, boneIndices) {
    super(); // data length consistency check

    const boneLen = bones.length; //const vectorLen = baseGeometry.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.vertex).vectorCount

    if (boneInverseBindTransforms.length !== boneLen) {
      throw new Error(`SCNSkinner: bones.length (${boneLen}) !== boneInverseBindTransforms.length (${boneInverseBindTransforms.length})`);
    } //if(boneWeights.vectorCount !== vectorLen){
    //  throw new Error(`SCNSkinner: vertices.length (${vectorLen}) !== boneWeights.vectorCount (${boneWeights.vectorCount})`)
    //}
    //if(boneIndices.vectorCount !== vectorLen){
    //  throw new Error(`SCNSkinner: vertices.length (${vectorLen}) !== boneIndices.vectorCount (${boneIndices.vectorCount})`)
    //}


    if (boneWeights.componentsPerVector !== boneIndices.componentsPerVector) {
      throw new Error(`SCNSkinner: boneWeights.componentsPerVector (${boneWeights.componentsPerVector}) !== boneIndices.componentsPerVector (${boneWeights.componentsPerVector})`);
    } // Working with a Skinned Geometry

    /**
     * The geometry whose surface the skinner’s animation skeleton deforms.
     * @type {?SCNGeometry}
     * @see https://developer.apple.com/documentation/scenekit/scnskinner/1522823-basegeometry
     */


    this.baseGeometry = baseGeometry;
    /**
     * The coordinate transformation for the skinner’s geometry in its default state.
     * @type {SCNMatrix4}
     * @see https://developer.apple.com/documentation/scenekit/scnskinner/1523160-basegeometrybindtransform
     */

    this.baseGeometryBindTransform = SCNMatrix4MakeTranslation(0, 0, 0); // Working with an Animation Skeleton

    /**
     * The root node of the skinner object’s animation skeleton.
     * @type {?SCNNode}
     * @see https://developer.apple.com/documentation/scenekit/scnskinner/1523048-skeleton
     */

    this.skeleton = null;
    /**
     * @access private
     * @type {SCNNode[]}
     */

    this._bones = bones;
    /**
     * @access private
     * @type {SCNMatrix4[]}
     */

    this._boneInverseBindTransforms = boneInverseBindTransforms;
    /**
     * @access private
     * @type {SCNGeometrySource}
     */

    this._boneWeights = boneWeights;
    /**
     * @access private
     * @type {SCNGeometrySource}
     */

    this._boneIndices = boneIndices;
    this._useGPU = true;

    this._checkUseGPU();
  }

  _checkUseGPU() {
    this._useGPU = true;

    if (this._boneWeights && this._boneWeights.componentsPerVector > 4) {
      this._useGPU = false;
    }

    if (this._boneIndices && this._boneIndices.componentsPerVector > 4) {
      this._useGPU = false;
    }
  } // Working with an Animation Skeleton

  /**
   * The control nodes of the animation skeleton.
   * @type {SCNNode[]}
   * @desc An array of SCNNode objects, each of which represents a control point of the animation skeleton. Moving a node deforms the surface of the skinner’s geometry, based on the skeleton data from which the skinner object was created.
   * @see https://developer.apple.com/documentation/scenekit/scnskinner/1522732-bones
   */


  get bones() {
    return this._bones.slice(0);
  }
  /**
   * The default transforms for the animation skeleton’s bone nodes.
   * @type {?SCNMatrix4[]}
   * @desc An array of NSValue objects containing SCNMatrix4 transforms, each of which corresponds to a node in the bones array. Each value is the inverse matrix (see SCNMatrix4Invert(_:)) of that node’s transform property for the skeleton’s default pose.
   * @see https://developer.apple.com/documentation/scenekit/scnskinner/1523802-boneinversebindtransforms
   */


  get boneInverseBindTransforms() {
    return this._boneInverseBindTransforms.slice(0);
  }
  /**
   * The geometry source that defines the influence of each bone on the positions the geometry’s vertices.
   * @type {SCNGeometrySource}
   * @desc This geometry source’s semantic property must be boneWeights. Its data is an array of floating-point vectors, whose componentsPerVector count is the number of bones influencing each vertex. Each vector corresponds to a vertex in the geometry’s vertex geometry source, and each component in a vector specifies the influence of a bone on that vertex’s position. The boneIndices source determines which nodes in the bones array correspond to each component in the vector. A component value of 0.0 means that the bone has no influence on that vertex; positive or negative values scale the transformation of a bone node before SceneKit applies that transformation to the vertex.NoteSceneKit performs skeletal animation on the GPU only if the componentsPerVector count in this geometry source is 4 or less. Larger vectors result in CPU-based animation and drastically reduced rendering performance.
   * @see https://developer.apple.com/documentation/scenekit/scnskinner/1522986-boneweights
   */


  get boneWeights() {
    return this._boneWeights;
  } //set boneWeights(newValue) {
  //  this._boneWeights = newValue
  //  this._checkUseGPU()
  //}

  /**
   * The geometry source defining the mapping from bone indices in skeleton data to the skinner’s bones array.
   * @type {SCNGeometrySource}
   * @desc This geometry source’s semantic property must be boneIndices. Its data is an array of integer vectors, each of which corresponds to a weight vector in the boneWeights geometry source. Each component in a vector specifies the index of the node in the bones array for the corresponding bone weight component.
   * @see https://developer.apple.com/documentation/scenekit/scnskinner/1524117-boneindices
   */


  get boneIndices() {
    return this._boneIndices;
  } //set boneIndices(newValue) {
  //  this._boneIndices = newValue
  //  this._checkUseGPU()
  //}

  /**
   * @access public
   * @returns {number} -
   */


  get numSkinningJoints() {
    return this._boneWeights.componentsPerVector;
  }
  /**
   * returns Float32Array of 3x4 matrices
   * @access public
   * @returns {Float32Array} -
   */


  float32Array() {
    const arr = [];
    const len = this._bones.length;

    for (let i = 0; i < len; i++) {
      const bone = this._bones[i]; // TODO: implement appropriate matrix multiplication.
      //       it doesn't consider the rotation of initial pose so far.
      //const mat = this._boneInverseBindTransforms[i].mult(bone._presentation._worldTransform)
      //const mat = this.baseGeometryBindTransform.mult(this._boneInverseBindTransforms[i]).mult(bone._presentation._worldTransform)

      const mat = this.baseGeometryBindTransform.mult(this._boneInverseBindTransforms[i]).mult(bone.presentation._worldTransform); //const mat = bone._presentation._worldTransform.mult(this._boneInverseBindTransforms[i])
      //mat = bone.presentation.transform.mult(mat)
      //if(bone._parent !== null){
      //  mat = mat.mult(bone._parent.presentation._worldTransform)
      //  //mat = bone._parent.presentation._worldTransform.mult(mat)
      //}
      //mat = bone.presentation.transform.mult(mat)
      //mat = mat.mult(bone.presentation.transform)

      arr.push(...mat.floatArray3x4f());
      /*
      if(!mat.isIdentity()){
        console.warn(`inverse: ${this._boneInverseBindTransforms[i].floatArray3x4f()}`)
        console.warn(`presentation.worldTransform: ${bone.presentation._worldTransform.floatArray3x4f()}`)
        console.warn(`parent.presentation.world: ${bone._parent.presentation._worldTransform.floatArray3x4f()}`)
        console.warn(`presentation.transform: ${bone.presentation.transform.floatArray3x4f()}`)
        console.warn(`worldTransform: ${bone._worldTransform.floatArray3x4f()}`)
        console.warn(`transfrom: ${bone.transform.floatArray3x4f()}`)
        console.warn(`presentation.position.y: ${bone.presentation.position.y}`)
        console.warn(`position.y: ${bone.position.y}`)
        console.warn(`mat: ${mat.floatArray3x4f()}`)
        throw new Error(`mat ${i} ${bone.name} is not identity`)
      }
      */
    } // DEBUG

    /*
    console.log('boneInverseBindTransforms')
    for(let i=0; i<4; i++){
      const mat = this._boneInverseBindTransforms[i]
      console.log(mat.floatArray3x4f())
    }
    console.log('bone._presentation._worldTransform')
    for(let i=0; i<4; i++){
      const mat = this._bones[i]._presentation._worldTransform
      console.log(mat.floatArray3x4f())
    }
    */


    return new Float32Array(arr);
  }
  /**
   * @access private
   * @param {SCNNode} node -
   * @returns {void}
   */


  _update(node) {
    if (this._useGPU) {
      return;
    }

    const p = node.presentation;

    if (node.geometry === null || p === null || p.geometry === null) {
      // data is not ready
      return;
    } // baseGeometryBindTransform


    this.baseGeometryBindTransform;
    this._boneInverseBindTransforms;
    const boneLen = this._bones.length;
    const transforms = [];

    for (let i = 0; i < boneLen; i++) {
      const bone = this._bones[i]; //transforms.push(this.baseGeometryBindTransform.mult(this._boneInverseBindTransforms[i]).mult(bone._presentation._worldTransform))

      transforms.push(this.baseGeometryBindTransform.mult(this._boneInverseBindTransforms[i]).mult(bone.presentation._worldTransform));
    }

    const baseGeometry = this.baseGeometry;
    const baseVertex = baseGeometry.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.vertex)[0];
    const baseNormal = baseGeometry.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.normal)[0]; // TODO: tangent
    //const pg = baseGeometry.presentation

    const pg = p.geometry;
    const vertex = pg.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.vertex)[0];
    const normal = pg.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.normal)[0];
    const weights = this._boneWeights;
    const indices = this._boneIndices;
    const len = weights.vectorCount;
    const vlen = weights.componentsPerVector;

    if (baseNormal) {
      for (let i = 0; i < len; i++) {
        const bv = baseVertex._scnVectorAt(i);

        const bn = baseNormal._scnVectorAt(i);

        const w = weights._vectorAt(i);

        const ind = indices._vectorAt(i);

        let pos = new SCNVector3(0, 0, 0);
        let nom = new SCNVector3(0, 0, 0);

        for (let j = 0; j < vlen; j++) {
          if (ind[j] < 0) {
            continue;
          }

          if (w[j] === 0) {
            continue;
          }

          const jointMatrix = transforms[ind[j]];
          pos = pos.add(bv.transform(jointMatrix).mul(w[j]));
          nom = nom.add(bn.rotate(jointMatrix).mul(w[j]));
        }

        vertex._setVectorAt(pos, i);

        normal._setVectorAt(nom, i);
      }
    }
  }

}

//import SCNBindingBlock from './SCNBindingBlock'

/**
 * A specification for augmenting or postprocessing SceneKit's rendering of a scene using additional drawing passes with custom Metal or OpenGL shaders.
 * @access public
 * @extends {NSObject}
 * @implements {SCNAnimatable}
 * @see https://developer.apple.com/documentation/scenekit/scntechnique
 */

class SCNTechnique extends NSObject {
  // Creating a Technique

  /**
   * Creates a technique from a technique definition dictionary.,
   * @access public
   * @constructor
   * @param {Map<string, Object>} dictionary - A dictionary defining the series of rendering passes that comprise the technique.
   * @desc See the class overview for details of a technique definition dictionary.
   * @see https://developer.apple.com/documentation/scenekit/scntechnique/1520494-init
   */
  constructor(dictionary) {
    super(); // Retrieving a Technique’s Definition

    this._dictionaryRepresentation = dictionary;
  } // Combining Techniques

  /**
   * Creates a new rendering technique that combines a series of techniques.
   * @access public
   * @param {SCNTechnique[]} techniques - An array of SCNTechnique objects.
   * @returns {void}
   * @desc The new technique applies the effects of the techniques in the order specified in the techniques array. Each output of a technique in the array becomes an input to the next technique in the array.
   * @see https://developer.apple.com/documentation/scenekit/scntechnique/1520497-init
   */


  initBySequencingTechniques(techniques) {
    // Retrieving a Technique’s Definition
    this._dictionaryRepresentation = null;
  } // Retrieving a Technique’s Definition

  /**
   * The dictionary defining the rendering technique.
   * @type {Map<string, Object>}
   * @desc Read this property when you want to save a property list file containing the definition of a technique.See the class overview for details of a technique definition dictionary.
   * @see https://developer.apple.com/documentation/scenekit/scntechnique/1520492-dictionaryrepresentation
   */


  get dictionaryRepresentation() {
    return this._dictionaryRepresentation;
  } // Handling Parameters for a Technique’s Shader Programs

  /**
   * Specifies a block to be called before rendering using programs with the specified GLSL uniform variable or attribute name.
   * @access public
   * @param {string} symbol - A GLSL uniform variable or attribute name used in one of the technique’s shader programs.
   * @param {?SCNBindingBlock} [block = null] - A block that SceneKit calls.
   * @returns {void}
   * @desc This method associates a block for handling setup of an attribute or uniform variable in the shader programs associated with the technique. SceneKit calls your block before any performing any rendering passes that use that symbol. In the block, you can execute any OpenGL commands or other code necessary for preparing your custom shader.NoteYou must associate a handler block with a technique before assigning that technique to a SceneKit object. The result of calling this method on a technique currently in use is undefined.Use this method when you need to update a value in a shader program every time SceneKit renders a frame. To set a value infrequently, or only once, use the setObject(_:forKeyedSubscript:) or setValue(_:forKey:) method instead.If you associate a block with a symbol using this method, SceneKit ignores values set using the setObject(_:forKeyedSubscript:) method.
   * @see https://developer.apple.com/documentation/scenekit/scntechnique/1520490-handlebinding
   */


  handleBindingOfSymbolUsing(symbol, block = null) {}
  /**
   * Sets a value for the specified shader  variable or attribute name, using subscript syntax.
   * @access public
   * @param {?Object} obj - An object containing a new value for the shader symbol.
   * @param {NSCopying} key - A shader variable or attribute name used in one of the technique’s shader programs.
   * @returns {void}
   * @desc The value parameter should be an object appropriate to the type of the shader symbol being set. For example, use an NSNumber object to set the value of a float uniform variable, or use an NSValue object containing an SCNVector3 structure to set the value of a GLSL vec3 uniform variable or a Metal float3 variable.Use this method when you need to set a value infrequently or only once. To update a shader value every time SceneKit renders a frame, use the handleBinding(ofSymbol:using:) method instead.If you use the handleBinding(ofSymbol:using:) method to associate a handler block for a symbol, SceneKit ignores values set for the symbol using the setObject(_:forKeyedSubscript:) method.
   * @see https://developer.apple.com/documentation/scenekit/scntechnique/1520495-setobject
   */


  setObjectForKeyedSubscript(obj, key) {}

}

/**
 * The common interface for SceneKit objects that support multipass rendering using SCNTechnique objects.
 * @interface
 * @see https://developer.apple.com/documentation/scenekit/scntechniquesupport
 */

class SCNTechniqueSupport {
  /**
   * constructor
   * @access public
   * @constructor
   */
  constructor() {
    // Specifying a Technique

    /**
     * Required. The technique SceneKit uses when rendering the object.
     * @type {?SCNTechnique}
     * @see https://developer.apple.com/documentation/scenekit/scntechniquesupport/1520496-technique
     */
    this.technique = null;
  }

}

//import CGSize from '../CoreGraphics/CGSize'

/**
 * A geometry based on a string of text, optionally extruded to create a three-dimensional object. 
 * @access public
 * @extends {SCNGeometry}
 * @see https://developer.apple.com/documentation/scenekit/scntext
 */

class SCNText extends SCNGeometry {
  // Creating a Text Geometry

  /**
   * Creates a text geometry from a specified string, extruded with a specified depth.
   * @access public
   * @constructor
   * @param {?Object} string - An NSString or NSAttributedString object containing text from which to create the geometry.
   * @param {number} extrusionDepth - The extent of the text geometry in the Z dimension of its local coordinate space. Specify a depth of 0.0 to create 2D text confined to a plane.
   * @desc In the local coordinate system of the text geometry, the origin corresponds to the lower left corner of the text’s layout rectangle, with the text extending in the x- and y-axis dimensions. (SceneKit computes a layout rectangle automatically, or you can specify one using the containerFrame property.) The geometry is centered along its z-axis. For example, if its extrusionDepth property is 1.0, the geometry extends from -0.5 to 0.5 along the z-axis. An extrusion depth of zero creates a flat, one-sided shape—the geometry is confined to the plane whose z-coordinate is 0.0, and viewable only from its front unless its material’s isDoubleSided property is true.
   * @see https://developer.apple.com/documentation/scenekit/scntext/1522734-init
   */
  constructor(string, extrusionDepth) {
    super(); // Managing the Geometry’s Text Content

    /**
     * The string object whose text the geometry represents.
     * @type {?Object}
     * @see https://developer.apple.com/documentation/scenekit/scntext/1523439-string
     */

    this.string = null;
    /**
     * The font that SceneKit uses to create geometry from the text.
     * @type {!UIFont}
     * @see https://developer.apple.com/documentation/scenekit/scntext/1523273-font
     */

    this.font = null; // Managing Text Layout

    /**
     * A rectangle specifying the area in which SceneKit should lay out the text.
     * @type {CGRect}
     * @see https://developer.apple.com/documentation/scenekit/scntext/1523654-containerframe
     */

    this.containerFrame = null;
    /**
     * A Boolean value that specifies whether SceneKit wraps long lines of text.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scntext/1523585-iswrapped
     */

    this.isWrapped = false;
    /**
     * A constant that specifies how SceneKit horizontally aligns each line of text within its container.
     * @type {string}
     * @see https://developer.apple.com/documentation/scenekit/scntext/1523158-alignmentmode
     */

    this.alignmentMode = '';
    /**
     * A constant that specifies how SceneKit truncates text that is too long to fit its container.
     * @type {string}
     * @see https://developer.apple.com/documentation/scenekit/scntext/1523414-truncationmode
     */

    this.truncationMode = '';
    this._textSize = null; // Managing the Text’s 3D Representation

    /**
     * A number that determines the accuracy or smoothness of the text geometry.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scntext/1524111-flatness
     */

    this.flatness = 0;
    /**
     * The extent of the extruded text in the z-axis direction. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scntext/1522604-extrusiondepth
     */

    this.extrusionDepth = 0;
    /**
     * The width or depth of each chamfered edge. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scntext/1522846-chamferradius
     */

    this.chamferRadius = 0;
    /**
     * A path that determines the cross-sectional contour of each chamfered edge.
     * @type {?UIBezierPath}
     * @see https://developer.apple.com/documentation/scenekit/scntext/1523334-chamferprofile
     */

    this.chamferProfile = null;
  } // Managing Text Layout

  /**
   * The two-dimensional extent of the text after layout.
   * @type {CGSize}
   * @desc This property reports the size of the smallest bounding rectangle containing the text. This size does not necessarily match that of the layout rectangle specified by the containerFrame property. A long body of text may overflow the layout rectangle, depending on the values of the isWrapped and truncationMode properties, and a short string of text may fit in an area smaller than the layout rectangle.
   * @see https://developer.apple.com/documentation/scenekit/scntext/1523680-textsize
   */


  get textSize() {
    return this._textSize;
  }

}

//import SCNActionTimingMode from './SCNActionTimingMode'

/**
 * 
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/scenekit/scntimingfunction
 */

class SCNTimingFunction extends NSObject {
  // Initializers

  /**
   * 
   * @access public
   * @param {CAMediaTimingFunction} caTimingFunction - 
   * @returns {SCNTimingFunction} -
   * @see https://developer.apple.com/documentation/scenekit/scntimingfunction/2866052-init
   */
  initCaMediaTimingFunction(caTimingFunction) {}
  /**
   * 
   * @access public
   * @constructor
   * @param {SCNActionTimingMode} timingMode - 
   * @see https://developer.apple.com/documentation/scenekit/scntimingfunction/2866061-init
   */


  constructor(timingMode) {
    super();
  }

}

/**
 * A torus, or ring-shaped geometry.
 * @access public
 * @extends {SCNGeometry}
 * @see https://developer.apple.com/documentation/scenekit/scntorus
 */

class SCNTorus extends SCNGeometry {
  // Creating a Torus

  /**
   * Creates a torus geometry with the specified ring radius and pipe radius.
   * @access public
   * @constructor
   * @param {number} ringRadius - The major radius of the torus, defining its circular ring in the x- and z-axis dimensions of its local coordinate space.
   * @param {number} pipeRadius - The minor radius of the torus, defining the pipe that encircles the ring.
   * @desc The torus is centered in its local coordinate system. For example, if you create a torus whose ring radius is 5.0 and pipe radius is 1.0, it extends from -6.0 to 6.0 (with a hole through the center from -4.0 to 4.0) in the x- and z-axes and from -1.0 to 1.0 in the y-axis.
   * @see https://developer.apple.com/documentation/scenekit/scntorus/1523833-init
   */
  constructor(ringRadius = 0.5, pipeRadius = 0.25) {
    super([], []); // Adjusting a Torus’ Dimensions

    /**
     * The major radius of the torus, defining a circle in the x- and z-axis dimensions. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scntorus/1522906-ringradius
     */

    this.ringRadius = ringRadius;
    /**
     * The minor radius of the torus, defining the pipe that encircles the torus ring. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scntorus/1522623-piperadius
     */

    this.pipeRadius = pipeRadius; // Configuring Torus Properties

    /**
     * The number of subdivisions around the torus ring. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scntorus/1523598-ringsegmentcount
     */

    this.ringSegmentCount = 48;
    /**
     * The number of subdivisions around the torus pipe. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scntorus/1522807-pipesegmentcount
     */

    this.pipeSegmentCount = 24;

    this._createGeometry();

    this.materials.push(new SCNMaterial());
  }

  _createGeometry() {
    const sourceData = [];
    const indexData = [];
    const vectorCount = (this.ringSegmentCount + 1) * (this.pipeSegmentCount + 1);

    for (let ri = 0; ri <= this.ringSegmentCount; ri++) {
      const r = 2.0 * ri * Math.PI / this.ringSegmentCount;
      const sinr = Math.sin(r);
      const cosr = Math.cos(r);
      const cx = -sinr * this.ringRadius;
      const cz = -cosr * this.ringRadius;
      const tx = ri / this.ringSegmentCount;

      for (let pi = 0; pi <= this.pipeSegmentCount; pi++) {
        const pr = 2.0 * pi * Math.PI / this.pipeSegmentCount;
        const sinp = Math.sin(pr);
        const cosp = Math.cos(pr);
        const x = cx + this.pipeRadius * sinr * cosp;
        const y = -this.pipeRadius * sinp;
        const z = cz + this.pipeRadius * cosr * cosp; // vertex

        sourceData.push(x, y, z); // normal

        sourceData.push(sinr * cosp, -sinp, cosr * cosp); // texcoord

        const tz = 1.0 - pi / this.pipeSegmentCount;
        sourceData.push(tx, tz);
      }
    }

    const vertexSource = new SCNGeometrySource(sourceData, // data
    SCNGeometrySource.Semantic.vertex, // semantic
    vectorCount, // vectorCount
    true, // floatComponents
    3, // componentsPerVector
    4, // bytesPerComponent
    0, // offset
    32 // sride
    );
    const normalSource = new SCNGeometrySource(sourceData, // data
    SCNGeometrySource.Semantic.normal, // semantic
    vectorCount, // vectorCount
    true, // floatComponents
    3, // componentsPerVector
    4, // bytesPerComponent
    12, // offset
    32 // stride
    );
    const texcoordSource = new SCNGeometrySource(sourceData, // data
    SCNGeometrySource.Semantic.texcoord, // semantic
    vectorCount, // vectorCount
    true, // floatComponents
    2, // componentsPerVector
    4, // bytesPerComponent
    24, // offset
    32 // stride
    );
    const indexLen = this.ringSegmentCount * this.pipeSegmentCount;
    let base = 0;

    for (let i = 0; i < indexLen; i++) {
      const i2 = base + this.pipeSegmentCount + 1;
      indexData.push(base, i2 + 1, base + 1);
      indexData.push(base, i2, i2 + 1);
      base += 1;

      if ((i + 1) % this.pipeSegmentCount === 0) {
        base += 1;
      }
    }

    const element = new SCNGeometryElement(indexData, SCNGeometryPrimitiveType.triangles);
    this._geometryElements = [element];
    this._geometrySources = [vertexSource, normalSource, texcoordSource];
    this.boundingBox = {
      min: new SCNVector3(-this.radius, -this.radius, -this.radius),
      max: new SCNVector3(this.radius, this.radius, this.radius)
    };
  }

}

/**
 * A constraint that runs a specified closure to compute a new transform (position, rotation, and scale) for each node that the constraint affects.
 * @access public
 * @extends {SCNConstraint}
 * @see https://developer.apple.com/documentation/scenekit/scntransformconstraint
 */

class SCNTransformConstraint extends SCNConstraint {
  /**
   * constructor
   * @access public
   * @constructor
   */
  //constructor() {
  //  super()
  //}
  // Creating a Transform Constraint

  /**
   * Creates a new transform constraint.
   * @access public
   * @param {boolean} world - true to evaluate the constraint in the scene’s world coordinate space, or false to evaluate it relative to the local coordinate space of each constrained node.
   * @param {function(arg1: SCNNode, arg2: SCNMatrix4): SCNMatrix4} block - A block to be called when Scene Kit evaluates the constraint.The block takes the following parameters:nodeThe constrained node.transformThe constrained node’s current presentation transformation—the value of the transform property of the constrained node’s presentation object. If the node is affected by an in-progress animation, this value reflects the currently visible state of the node during the animation (rather than its target state that will be visible when the animation completes).The block returns a transformation matrix, which Scene Kit then applies to the node. If you return the transform value passed to the block, your constraint has no effect on the node. 
   * @returns {SCNTransformConstraint}
   * @desc The world parameter determines the coordinate space of the transformations passed to and returned by the block parameter.
   * @see https://developer.apple.com/documentation/scenekit/scntransformconstraint/1468679-init
   */
  static constraintInWorldSpaceWith(world, block) {
    const constraint = new SCNTransformConstraint(); // TODO: implement

    return constraint;
  } // Type Methods

  /**
   * 
   * @access public
   * @param {boolean} world - 
   * @param {function(arg1: SCNNode, arg2: SCNQuaternion): SCNQuaternion} block - 
   * @returns {SCNTransformConstraint} - 
   * @see https://developer.apple.com/documentation/scenekit/scntransformconstraint/2867503-orientationconstraint
   */


  static orientationConstraintInWorldSpaceWith(world, block) {
    const constraint = new SCNTransformConstraint(); // TODO: implement

    return constraint;
  }
  /**
   * 
   * @access public
   * @param {boolean} world - 
   * @param {function(arg1: SCNNode, arg2: SCNVector3): SCNVector3} block - 
   * @returns {SCNTransformConstraint} - 
   * @see https://developer.apple.com/documentation/scenekit/scntransformconstraint/2867461-positionconstraint
   */


  static positionConstraintInWorldSpaceWith(world, block) {
    const constraint = new SCNTransformConstraint(); // TODO: implement

    return constraint;
  }

}

/**
 * A tube or pipe geometry—a right circular cylinder with a circular hole along its central axis.
 * @access public
 * @extends {SCNGeometry}
 * @see https://developer.apple.com/documentation/scenekit/scntube
 */

class SCNTube extends SCNGeometry {
  // Creating a Tube

  /**
   * Creates a tube geometry with the specified inner radius, outer radius, and height.
   * @access public
   * @constructor
   * @param {number} innerRadius - The radius of the tube’s circular central hole in the x- and z-axes of its local coordinate space.
   * @param {number} outerRadius - The radius of the tube’s circular cross section in the x- and z-axes of its local coordinate space.
   * @param {number} height - The height of the tube along the y-axis of its local coordinate space.
   * @desc The tube is centered in its local coordinate system. For example, if you create a tube whose outer radius is 5.0, inner radius is 1.0, and height is 10.0, its circular cross section extends from -5.0 to 5.0 along the x- and z-axes, the y-coordinates of its base and top are -5.0 and 5.0, and the hole through its center extends from -0.5 to 0.5 along the x- and z-axes.
   * @see https://developer.apple.com/documentation/scenekit/scntube/1522843-init
   */
  constructor(innerRadius = 0.25, outerRadius = 0.5, height = 1.0) {
    super(); // Adjusting a Tube’s Dimensions

    /**
     * The radius of the tube’s outer circular cross section. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scntube/1523270-outerradius
     */

    this.outerRadius = outerRadius;
    /**
     * The radius of the circular hole through the tube. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scntube/1524070-innerradius
     */

    this.innerRadius = innerRadius;
    /**
     * The extent of the tube along its y-axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scntube/1522640-height
     */

    this.height = height; // Adjusting Geometric Detail

    /**
     * The number of subdivisions around the circumference of the tube. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scntube/1523619-radialsegmentcount
     */

    this.radialSegmentCount = 48;
    /**
     * The number of subdivisions in the inner and outer surfaces of the tube along its y-axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scntube/1523080-heightsegmentcount
     */

    this.heightSegmentCount = 1;

    this._createGeometry();

    this.materials.push(new SCNMaterial());
  }

  _createGeometry() {
    const sourceData = [];
    const top = this.height * 0.5;
    const bottom = -this.height * 0.5;
    const outerData = [];
    const innerData = [];
    const topData = [];
    const bottomData = [];
    const rStep = 2.0 * Math.PI / this.radialSegmentCount;
    const tStep = 1.0 / this.radialSegmentCount;

    for (let i = 0; i <= this.radialSegmentCount; i++) {
      const x = -Math.sin(rStep * i);
      const z = -Math.cos(rStep * i);
      const ovx = x * this.outerRadius;
      const ovz = z * this.outerRadius;
      const ivx = x * this.innerRadius;
      const ivz = z * this.innerRadius; // vertex

      outerData.push(ovx, bottom, ovz);
      innerData.push(ivx, top, ivz);
      topData.push(ovx, top, ovz);
      bottomData.push(-ovx, bottom, ovz); // normal

      outerData.push(x, 0, z);
      innerData.push(-x, 0, -z);
      topData.push(0, 1, 0);
      bottomData.push(0, -1, 0); // texcoord

      const tx = tStep * i;
      outerData.push(tx, 1.0);
      innerData.push(1.0 - tx, 0.0);
      const ttx = 0.5 + Math.cos(rStep * i) * 0.5;
      const tty = 0.5 + Math.sin(rStep * i) * 0.5;
      topData.push(ttx, tty);
      bottomData.push(ttx, tty); // vertex

      outerData.push(ovx, top, ovz);
      innerData.push(ivx, bottom, ivz);
      topData.push(ivx, top, ivz);
      bottomData.push(-ivx, bottom, ivz); // normal

      outerData.push(x, 0, z);
      innerData.push(-x, 0, -z);
      topData.push(0, 1, 0);
      bottomData.push(0, -1, 0); // texcoord

      outerData.push(tx, 0.0);
      innerData.push(1.0 - tx, 1.0);
      const ttx2 = 0.5 + Math.cos(rStep * i) * 0.25;
      const tty2 = 0.5 + Math.sin(rStep * i) * 0.25;
      topData.push(ttx2, tty2);
      bottomData.push(ttx2, tty2);
    }

    sourceData.push(...outerData, ...innerData, ...topData, ...bottomData);
    const vectorCount = (this.radialSegmentCount + 1) * 8;
    const vertexSource = new SCNGeometrySource(sourceData, // data
    SCNGeometrySource.Semantic.vertex, // semantic
    vectorCount, // vectorCount
    true, // floatComponents
    3, // componentsPerVector
    4, // bytesPerComponent
    0, // offset
    32 // sride
    );
    const normalSource = new SCNGeometrySource(sourceData, // data
    SCNGeometrySource.Semantic.normal, // semantic
    vectorCount, // vectorCount
    true, // floatComponents
    3, // componentsPerVector
    4, // bytesPerComponent
    12, // offset
    32 // stride
    );
    const texcoordSource = new SCNGeometrySource(sourceData, // data
    SCNGeometrySource.Semantic.texcoord, // semantic
    vectorCount, // vectorCount
    true, // floatComponents
    2, // componentsPerVector
    4, // bytesPerComponent
    24, // offset
    32 // stride
    );
    const elements = [];

    for (let i = 0; i < 4; i++) {
      const indexData = [];
      const offset = (this.radialSegmentCount + 1) * i * 2;

      for (let j = 0; j < this.radialSegmentCount; j++) {
        const base = offset + j * 2;
        indexData.push(base, base + 3, base + 1);
        indexData.push(base, base + 2, base + 3);
      }

      elements.push(new SCNGeometryElement(indexData, SCNGeometryPrimitiveType.triangles));
    }

    this._geometryElements = elements;
    this._geometrySources = [vertexSource, normalSource, texcoordSource];
    this.boundingBox = {
      min: new SCNVector3(-this.outerRadius, bottom, -this.outerRadius),
      max: new SCNVector3(this.outerRadius, top, this.outerRadius)
    };
  }

  _updateBoundingBoxForSkinner(skinner = null) {
    if (skinner === null) {
      return this.boundingBox;
    }

    return super._updateBoundingBoxForSkinner(skinner);
  }

}

const _epsilon$1 = 0.00001;
/**
 * Returns a Boolean value that indicates whether the corresponding components of two vectors are equal.
 * @access public
 * @param {SCNVector3} a - The first vector.
 * @param {SCNVector3} b - The second vector.
 * @returns {boolean} - 
 * @desc This function performs a numeric (not bitwise) comparison of each pair of component values.
 * @see https://developer.apple.com/documentation/scenekit/1409643-scnvector3equaltovector3
 */

const SCNVector3EqualToVector3 = function (a, b) {
  return Math.abs(a.x - b.x) < _epsilon$1 && Math.abs(a.y - b.y) < _epsilon$1 && Math.abs(a.z - b.z) < _epsilon$1;
};

/**
 * 
 * @access public
 * @param {number[]} v - 
 * @returns {SCNVector3} - 
 * @see https://developer.apple.com/documentation/scenekit/1524143-scnvector3fromfloat3
 */

const SCNVector3FromFloat3 = function (v) {
  return new SCNVector3(v);
};

//import GLKVector3 from '../undefined/GLKVector3'

/**
 * Returns a three-element SceneKit vector structure corresponding to a GLKit vector structure.
 * @access public
 * @param {GLKVector3} vector - A three-element GLKit vector structure.
 * @returns {SCNVector3} - 
 * @see https://developer.apple.com/documentation/scenekit/1409692-scnvector3fromglkvector3
 */

const SCNVector3FromGLKVector3 = function (vector) {
  return null;
};

/**
 * Returns a new three-component vector created from individual component values.
 * @access public
 * @param {number} x - The first component of the vector.
 * @param {number} y - The second component of the vector.
 * @param {number} z - The third component of the vector.
 * @returns {SCNVector3} - 
 * @see https://developer.apple.com/documentation/scenekit/1409705-scnvector3make
 */

const SCNVector3Make = function (x, y, z) {
  return new SCNVector3(x, y, z);
};

/**
 * 
 * @access public
 * @param {SCNVector3} v - 
 * @returns {number[]} - 
 * @see https://developer.apple.com/documentation/scenekit/1523448-scnvector3tofloat3
 */

const SCNVector3ToFloat3 = function (v) {
  return [v.x, v.y, v.z];
};

/**
 * Returns a three-element GLKit vector structure corresponding to a SceneKit vector structure.
 * @access public
 * @param {SCNVector3} vector - A three-element SceneKit vector structure.
 * @returns {GLKVector3} - 
 * @see https://developer.apple.com/documentation/scenekit/1409651-scnvector3toglkvector3
 */

const SCNVector3ToGLKVector3 = function (vector) {
  return null;
};

const SCNVector3Zero = new SCNVector3(0, 0, 0);

const _epsilon$2 = 0.00001;
/**
 * Returns a Boolean value that indicates whether the corresponding components of two vectors are equal.
 * @access public
 * @param {SCNVector4} a - The first vector.
 * @param {SCNVector4} b - The second vector.
 * @returns {boolean} - 
 * @desc This function performs a numeric (not bitwise) comparison of each pair of component values.
 * @see https://developer.apple.com/documentation/scenekit/1409707-scnvector4equaltovector4
 */

const SCNVector4EqualToVector4 = function (a, b) {
  return Math.abs(a.x - b.x) < _epsilon$2 && Math.abs(a.y - b.y) < _epsilon$2 && Math.abs(a.z - b.z) < _epsilon$2 && Math.abs(a.w - b.w) < _epsilon$2;
};

/**
 * 
 * @access public
 * @param {number[]} v - 
 * @returns {SCNVector4} - 
 * @see https://developer.apple.com/documentation/scenekit/1523606-scnvector4fromfloat4
 */

const SCNVector4FromFloat4 = function (v) {
  return new SCNVector4(v);
};

//import GLKVector4 from '../undefined/GLKVector4'

/**
 * Returns a four-element SceneKit vector structure corresponding to a GLKit vector structure.
 * @access public
 * @param {GLKVector4} vector - A four-element GLKit vector structure.
 * @returns {SCNVector4} - 
 * @see https://developer.apple.com/documentation/scenekit/1409729-scnvector4fromglkvector4
 */

const SCNVector4FromGLKVector4 = function (vector) {
  return null;
};

/**
 * Returns a new four-component vector created from individual component values.
 * @access public
 * @param {number} x - The first component of the vector.
 * @param {number} y - The second component of the vector.
 * @param {number} z - The third component of the vector.
 * @param {number} w - The fourth component of the vector.
 * @returns {SCNVector4} - 
 * @see https://developer.apple.com/documentation/scenekit/1409677-scnvector4make
 */

const SCNVector4Make = function (x, y, z, w) {
  return new SCNVector4Make(x, y, z, w);
};

/**
 * 
 * @access public
 * @param {SCNVector4} v - 
 * @returns {number[]} - 
 * @see https://developer.apple.com/documentation/scenekit/1523001-scnvector4tofloat4
 */

const SCNVector4ToFloat4 = function (v) {
  return [v.x, v.y, v.z, v.w];
};

//import SCNVector4 from './SCNVector4'

/**
 * Returns a four-element GLKit vector structure corresponding to a SceneKit vector structure.
 * @access public
 * @param {SCNVector4} vector - A four-element SceneKit vector structure.
 * @returns {GLKVector4} - 
 * @see https://developer.apple.com/documentation/scenekit/1409663-scnvector4toglkvector4
 */

const SCNVector4ToGLKVector4 = function (vector) {
  return null;
};

/*global window*/

const _Option$1 = {
  preferLowPowerDevice: 'SCNPreferLowPowerDeviceKey',
  preferredDevice: 'SCNPreferredDeviceKey',
  preferredRenderingAPI: 'SCNPreferredRenderingAPIKey'
};

const _KeyCode = new Map([['KeyA', 0x00], ['KeyS', 0x01], ['KeyD', 0x02], ['KeyF', 0x03], ['KeyH', 0x04], ['KeyG', 0x05], ['KeyZ', 0x06], ['KeyX', 0x07], ['KeyC', 0x08], ['KeyV', 0x09], ['IntlBackslash', 0x0A], ['KeyB', 0x0B], ['KeyQ', 0x0C], ['KeyW', 0x0D], ['KeyE', 0x0E], ['KeyR', 0x0F], ['KeyY', 0x10], ['KeyT', 0x11], ['Digit1', 0x12], ['Digit2', 0x13], ['Digit3', 0x14], ['Digit4', 0x15], ['Digit6', 0x16], ['Digit5', 0x17], ['Equal', 0x18], // '^' in JIS keyboard
['Digit9', 0x19], ['Digit7', 0x1A], ['Minus', 0x1B], ['Digit8', 0x1C], ['Digit0', 0x1D], ['BracketRight', 0x1E], // '[' in JIS keyboard
['KeyO', 0x1F], ['KeyU', 0x20], ['BracietLeft', 0x21], // '@' in JIS keyboard
['KeyI', 0x22], ['KeyP', 0x23], ['Enter', 0x24], ['KeyL', 0x25], ['KeyJ', 0x26], ['Quote', 0x27], // ':' in JIS keyboard
['KeyK', 0x28], ['Semicolon', 0x29], ['Backslash', 0x2A], // ']' in JIS keyboard
['Comma', 0x2B], ['Slash', 0x2C], ['KeyN', 0x2D], ['KeyM', 0x2E], ['Period', 0x2F], ['Tab', 0x30], ['Space', 0x31], ['Backquote', 0x32], ['Delete', 0x33], ['NumpadEnter', 0x34], ['Escape', 0x35], ['OSRight', 0x36], ['MetaRight', 0x36], ['OSLeft', 0x37], ['MetaLeft', 0x37], ['ShiftLeft', 0x38], ['CapsLock', 0x39], ['AltLeft', 0x3A], ['ControlLeft', 0x3B], ['ShiftRight', 0x3C], ['AltRight', 0x3D], ['ControlRight', 0x3E], ['Fn', 0x3F], // impossible to catch the key event for function key
['F17', 0x40], ['NumpadDecimal', 0x41], // 0x42: unknown
['NumpadMultiply', 0x43], // 0x44: unknown
['NumpadAdd', 0x45], // 0x46: unknown
['NumLock', 0x47], ['AudioVolumeUp', 0x48], ['AudioVolumeDown', 0x49], ['AudioVolumeMute', 0x4A], ['NumpadDivide', 0x4B], ['NumpadEnter', 0x4C], // 0x4D: unknown
['NumpadSubtract', 0x4E], ['F18', 0x4F], ['F19', 0x50], ['NumpadEqual', 0x51], ['Numpad0', 0x52], ['Numpad1', 0x53], ['Numpad2', 0x54], ['Numpad3', 0x55], ['Numpad4', 0x56], ['Numpad5', 0x57], ['Numpad6', 0x58], ['Numpad7', 0x59], ['F20', 0x5A], ['Numpad8', 0x5B], ['Numpad9', 0x5C], ['IntlYen', 0x5D], // JIS_Yen
['IntlRo', 0x5E], // JIS_Underscore
['NumpadComma', 0x5F], ['F5', 0x60], ['F6', 0x61], ['F7', 0x62], ['F3', 0x63], ['F8', 0x64], ['F9', 0x65], ['Lang2', 0x66], // JIS_Eisu. It could be ''
['F11', 0x67], ['Lang1', 0x68], // JIS_Kana. It could be 'KanaMode'
['F13', 0x69], ['F16', 0x6A], ['F14', 0x6B], // 0x6C: unknown
['F10', 0x6D], // 0x6E: unknown
['F12', 0x6F], // 0x70: unknown
['F15', 0x71], ['Help', 0x72], ['Insert', 0x72], ['Home', 0x73], ['PageUp', 0x74], ['Delete', 0x75], ['F4', 0x76], ['End', 0x77], ['F2', 0x78], ['PageDown', 0x79], ['F1', 0x7A], ['ArrowLeft', 0x7B], ['ArrowRight', 0x7C], ['ArrowDown', 0x7D], ['ArrowUp', 0x7E]]);
/**
 * A view for displaying 3D SceneKit content.
 * @access public
 * @implements {SCNSceneRenderer}
 * @implements {SCNTechniqueSupport}
 * @see https://developer.apple.com/documentation/scenekit/scnview
 */


class SCNView {
  // Initializing a SceneKit View

  /**
   * Initializes and returns a newly allocated SceneKit view object with the specified frame rectangle and options.
   * @access public
   * @constructor
   * @param {CGRect} frame - The frame rectangle for the view, measured in points and specified in the coordinate system of its superview.
   * @param {?Map<string, Object>} [options = null] - Rendering options for the view. See SCNView.
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnview/1524215-init
   */
  constructor(frame, options = null) {
    //super()
    // Specifying a Scene

    /**
     * The scene to be displayed in the view.
     * @access private
     * @type {?SCNScene}
     * @see https://developer.apple.com/documentation/scenekit/scnview/1523904-scene
     */
    this._scene = null; // Configuring a View

    /**
     * The background color of the view.
     * @type {SKColor}
     * @see https://developer.apple.com/documentation/scenekit/scnview/1523088-backgroundcolor
     */

    this._backgroundColor = SKColor.white;
    /**
     * A Boolean value that determines whether the user can manipulate the current point of view that is used to render the scene. 
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnview/1523171-allowscameracontrol
     */

    this.allowsCameraControl = false;
    /**
     * The antialiasing mode used for rendering the view’s scene.
     * @type {SCNAntialiasingMode}
     * @see https://developer.apple.com/documentation/scenekit/scnview/1524085-antialiasingmode
     */

    this.antialiasingMode = SCNAntialiasingMode.multisampling4X;
    /**
     * The animation frame rate that the view uses to render its scene.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnview/1621205-preferredframespersecond
     */

    this.preferredFramesPerSecond = 0; // Working with a View’s OpenGL ES Context

    /**
     * The OpenGL ES context that the view uses to render its contents.
     * @type {?EAGLContext}
     * @see https://developer.apple.com/documentation/scenekit/scnview/1621072-eaglcontext
     */
    //this.eaglContext = null
    // Working with a View’s OpenGL Context

    /**
     * The OpenGL context that the view uses to render its contents.
     * @type {?NSOpenGLContext}
     * @see https://developer.apple.com/documentation/scenekit/scnview/1522850-openglcontext
     */
    //this.openGLContext = null

    /**
     * @access private
     * @type {WebGL2RenderingContext}
     */

    this._context = null;
    /**
     * The view’s OpenGL pixel format.
     * @type {?NSOpenGLPixelFormat}
     * @see https://developer.apple.com/documentation/scenekit/scnview/1523612-pixelformat
     */

    this.pixelFormat = null; ////////////////////////////////////////////////
    // SCNSceneRenderer
    ////////////////////////////////////////////////

    /**
     * Required. The graphics technology SceneKit uses to render the scene.
     * @access private
     * @type {SCNRenderingAPI}
     */

    this._renderingAPI = SCNRenderingAPI.webGL; // Participating in the Scene Rendering Process

    /**
     * Required. A delegate object that receives messages about SceneKit’s rendering process.
     * @access private
     * @type {?SCNSceneRendererDelegate}
     */

    this._delegate = null; // Customizing Scene Rendering with Metal
    //this._currentRenderCommandEncoder = null

    this._device = null; // MTLIGAccelDevice
    //this._commandQueue = null // MTLIGAccessCommandQueue
    //this._colorPixelFormat = null // MTLPixelFormat
    //this._depthPixelFormat = null // MTLPixelFormat
    //this._stencilPixelFormat = null // MTLPixelFormat
    // Rendering Sprite Kit Content over a Scene

    /**
     * Required. A Sprite Kit scene to be rendered on top of the SceneKit content.
     * @type {?SKScene}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1524051-overlayskscene
     */
    //this.overlaySKScene = null
    // Working With Positional Audio

    /**
     * Required. The node representing the listener’s position in the scene for use with positional audio effects.
     * @type {?SCNNode}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523747-audiolistener
     */
    //this.audioListener = null
    //this._audioEnvironmentNode = null
    //this._audioEngine = null
    // Instance Properties

    /**
     * Required. 
     * @type {number}
     * @deprecated
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522854-currenttime
     */
    //this.currentTime = 0
    ////////////////////////////////////////////////
    // SCNTechniqueSupport
    ////////////////////////////////////////////////
    // Specifying a Technique

    /**
     * Required. The technique SceneKit uses when rendering the object.
     * @type {?SCNTechnique}
     * @see https://developer.apple.com/documentation/scenekit/scntechniquesupport/1520496-technique
     */

    this.technique = null; // for JavaScript

    /**
     * @access private
     * @type {CGRect}
     */

    this._frame = frame;
    /**
     * @access private
     * @type {HTMLCanvasElement}
     */

    this._canvas = document.createElement('canvas');
    this._canvas.tabIndex = 1; // to get keydown/up events, it needs to set tabIndex

    if (typeof frame === 'undefined') {
      frame = CGRect.rectWithXYWidthHeight(0, 0, 300, 300);
    }

    this._canvas.style.width = frame.width;
    this._canvas.style.height = frame.height;
    /**
     * @access private
     * @type {number}
     */

    this._canvasWidth = 0;
    /**
     * @access private
     * @type {number}
     */

    this._canvasHeight = 0;
    /**
     * @access private
     * @type {number}
     */

    this._currentSystemTime = 0;
    /**
     * @access private
     * @type {number}
     */

    this._elapsedTime = 0;
    /**
     * @access private
     * @type {number}
     */

    this._previousSystemTimeMs = 0;
    /**
     * @access private
     * @type {number}
     */

    this._sumElapsedTimeMs = 0;
    /**
     * @access private
     * @type {number}
     */

    this._sumFrames = 0;
    /**
     * @access private
     * @type {number}
     */

    this._lastFpsCalculationTimeMs = 0;
    /**
     * @access private
     * @type {number}
     */

    this._fpsCalculationSpanMs = 2000;
    /**
     * @access private
     * @type {number}
     */

    this._fps = 0;
    /**
     * @access private
     * @type {SCNSceneRenderer}
     */

    this._renderer = new SCNRenderer(); //this._renderer.scene = this._scene
    //if(this._scene !== null){
    //  this._scene._physicsWorld._renderer = this._renderer
    //}

    /**
     * @access private
     * @type {function(function(timestamp: number))}
     */

    this._requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || (callback => {
      window.setTimeout(callback, 1000 / 60);
    });

    const preferLowPowerDevice = options ? options[SCNView.Option.preferLowPowerDevice] : null;
    const preferredDevice = options ? options[SCNView.Option.preferredDevice] : null;
    const preferredRenderingAPI = options ? options[SCNView.Option.preferredRenderingAPI] : null;
    const opt = {
      alpha: true,
      depth: true,
      stencil: true,
      antialias: true,
      premultipliedAlpha: true,
      preserveDrawingBuffer: false,
      preferLowPowerToHighPerformance: Boolean(preferLowPowerDevice),
      failIfMajorPerformanceCaveat: false //const contextNames = ['webgl2', 'webgl', 'webkit-3d', 'moz-webgl', 'experimental-webgl']

    };
    const contextNames = ['webgl2'];

    for (const name of contextNames) {
      try {
        this._context = this._canvas.getContext(name, opt);
      } catch (e) {
        /* just ignore and try the next name */
      }

      if (this._context) {
        break;
      }
    }

    if (!this._context) {
      throw new Error('can\'t create WebGL context');
    }

    this._context.viewport(frame.minX, frame.minY, frame.width, frame.height);

    this._renderer._setContext(this._context);

    this._renderer._backgroundColor = this._backgroundColor;
    this._renderer._viewRect = frame;
    this._mouseIsDown = false;
    this._mouseDownX = 0;
    this._mouseDownY = 0; // add event listeners

    this._canvas.addEventListener('mousedown', e => {
      const ev = this._createEvent(e);

      this._mouseIsDown = true;
      this._mouseDownX = e.clientX;
      this._mouseDownY = e.clientY;

      if (this.allowsCameraControl) {
        this._baseCameraPosition = this._renderer._getCameraPosition();
        this._baseCameraOrientation = this._renderer._getCameraOrientation();
        this._baseCameraDistance = this._renderer._getCameraDistance();
      }

      this.mouseDownWith(ev);
    });

    this._canvas.addEventListener('mousemove', e => {
      const ev = this._createEvent(e);

      this.mouseMovedWith(ev);

      if (this._mouseIsDown) {
        if (this.allowsCameraControl) {
          const mx = e.clientX;
          const my = e.clientY;
          const dx = mx - this._mouseDownX;
          const dy = my - this._mouseDownY;
          const d = Math.sqrt(dx * dx + dy * dy);
          const rotScale = 0.01;

          if (d > 0) {
            const r = -d * 0.5 * rotScale;
            const sinr = Math.sin(r) / d;
            const q = new SCNVector4(dy * sinr, dx * sinr, 0, Math.cos(r));

            const orientation = this._baseCameraOrientation.cross(q);

            this._renderer._setDefaultCameraOrientation(orientation);
          }

          this._renderer._switchToDefaultCamera();
        }

        this.mouseDraggedWith(ev);
      }
    });

    document.addEventListener('mouseup', e => {
      if (this._mouseIsDown) {
        this._mouseIsDown = false;

        const ev = this._createEvent(e);

        this.mouseUpWith(ev);

        this._preventDefault(ev);
      }
    });

    this._canvas.addEventListener('mouseover', e => {
      const ev = this._createEvent(e);

      this._preventDefault(ev);
    });

    this._canvas.addEventListener('mouseout', e => {
      const ev = this._createEvent(e);

      this.mouseExitedWith(ev);

      this._preventDefault(ev);
    });

    this._canvas.addEventListener('mousewheel', e => {
      const ev = this._createEvent(e);

      this.scrollWheelWith(ev);

      this._preventDefault(ev);
    }); // For Firefox


    this._canvas.addEventListener('DOMMouseScroll', e => {
      const ev = this._createEvent(e);

      this.scrollWheelWith(ev);

      this._preventDefault(ev);
    });

    this._canvas.addEventListener('keydown', e => {
      const ev = this._createEvent(e);

      this.keyDownWith(ev);

      this._preventDefault(ev);
    });

    this._canvas.addEventListener('keyup', e => {
      const ev = this._createEvent(e);

      this.keyUpWith(ev);

      this._preventDefault(ev);
    });
  }

  connectedCallback() {}

  disconnectedCallback() {}

  attributeChangedCallback() {}
  /**
   * @access private
   * @returns {void}
   */


  _resizeCanvas() {
    const w = this._canvas.clientWidth;
    const h = this._canvas.clientHeight;

    if (this._frame && this._frame.width === w && this._frame.height === h) {
      return;
    }

    this._frame = CGRect.rectWithXYWidthHeight(0, 0, w, h);
    this._canvas.width = w;
    this._canvas.height = h;

    this._context.viewport(0, 0, w, h);

    this._renderer._viewRect = this._frame;
    this.setFrameSize(this._frame.size);
  }
  /**
   *
   * @access public
   * @param {HTMLElement} element - parent element to append this view
   * @returns {void}
   */


  appendTo(element) {
    element.appendChild(this._canvas); // update canvas size

    if (typeof this._frame === 'undefined') {
      this._canvas.style.width = '100%';
      this._canvas.style.height = '100%';

      if (this._canvas.clientHeight <= 0) {
        this._canvas.style.height = 300;
      }
    }

    this._resizeCanvas();

    if (typeof window !== 'undefined') {
      window.addEventListener('resize', () => {
        this._resizeCanvas();
      });
    }
  }

  get backgroundColor() {
    return this._backgroundColor;
  }

  set backgroundColor(newValue) {
    this._backgroundColor = newValue; //this._context.clearColor(newValue.r, newValue.g, newValue.b, newValue.a)

    this._renderer._backgroundColor = newValue;
  }
  /**
   * Required. A Boolean value that determines whether the scene is playing.
   * @type {boolean}
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523401-isplaying
   */


  get isPlaying() {
    return this._renderer.isPlaying;
  }
  /**
   * Required. A Boolean value that determines whether the scene is playing.
   * @type {boolean}
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523401-isplaying
   */


  set isPlaying(newValue) {
    if (newValue) {
      this.play();
    } else {
      this.pause();
    }
  } // Specifying a Scene

  /**
   * The scene to be displayed in the view.
   * @access private
   * @type {?SCNScene}
   * @see https://developer.apple.com/documentation/scenekit/scnview/1523904-scene
   */


  get scene() {
    return this._scene;
  }
  /**
   * The scene to be displayed in the view.
   * @access private
   * @type {?SCNScene}
   * @see https://developer.apple.com/documentation/scenekit/scnview/1523904-scene
   */


  set scene(newValue) {
    // FIXME: it should not be changed while drawing
    this._scene = newValue;
    this._renderer.scene = this._scene;

    if (this._scene === null) {
      return;
    }

    this._scene._physicsWorld._renderer = this._renderer;

    this._updateTransform();

    this._scene.rootNode._resetPhysicsTransformRecursively();
  } // Playing Action and Animation in a View’s Scene

  /**
   * Pauses playback of the view’s scene.
   * @access public
   * @param {?Object} sender - The object requesting the action (used when connecting a control in Interface Builder). SceneKit ignores this parameter.
   * @returns {void}
   * @desc This method has no effect if the scene is already paused.
   * @see https://developer.apple.com/documentation/scenekit/scnview/1522825-pause
   */


  pause(sender) {
    if (!this._isPlaying) {
      return;
    }

    this._isPlaying = false;
  }
  /**
   * Resumes playback of the view’s scene.
   * @access public
   * @param {?Object} sender - The object requesting the action (used when connecting a control in Interface Builder). SceneKit ignores this parameter.
   * @returns {void}
   * @desc This method has no effect if the scene is not paused.
   * @see https://developer.apple.com/documentation/scenekit/scnview/1523699-play
   */


  play(sender) {
    if (this._isPlaying) {
      return;
    }

    this._isPlaying = true;

    this.__requestAnimationFrame();
  }
  /**
   * Stops playback of the view’s scene and resets the scene time to its start time.
   * @access public
   * @param {?Object} sender - The object requesting the action (used when connecting a control in Interface Builder). SceneKit ignores this parameter.
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnview/1524132-stop
   */


  stop(sender) {
    this._isPlaying = false;
  } // Capturing a View Snapshot

  /**
   * Renders the view’s scene into a new image object.
   * @access public
   * @returns {Image} - 
   * @desc This method is thread-safe and may be called at any time.
   * @see https://developer.apple.com/documentation/scenekit/scnview/1524031-snapshot
   */


  snapshot() {
    return null;
  } // Structures

  /**
   * @type {Object} Option
   * @property {string} preferLowPowerDevice An option for whether to select low-power-usage devices for Metal rendering.
   * @property {string} preferredDevice The device to use for Metal rendering.
   * @property {string} preferredRenderingAPI The rendering API to use for rendering the view (for example, Metal or OpenGL).
   * @see https://developer.apple.com/documentation/scenekit/scnview.option
   */


  static get Option() {
    return _Option$1;
  } ////////////////////////////////////////////////
  // SCNSceneRenderer
  ////////////////////////////////////////////////
  // Presenting a Scene

  /**
   * Required. Displays the specified scene with an animated transition.
   * @access public
   * @param {SCNScene} scene - The new scene to be displayed.
   * @param {SKTransition} transition - An object that specifies the duration and style of the animated transition.
   * @param {?SCNNode} pointOfView - The node to use as the pointOfView property when displaying the new scene.
   * @param {?function(): void} [completionHandler = null] - A block that SceneKit calls after the transition animation has completed.This block takes no parameters and has no return value.
   * @returns {void}
   * @desc Use this method to change the scene displayed in a SceneKit view (or other renderer) with an animated transition. For details on transition styles, see SKTransition.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523028-present
   */


  presentWithIncomingPointOfView(scene, transition, pointOfView, completionHandler = null) {} // Managing Scene Display

  /**
   * Required. The node from which the scene’s contents are viewed for rendering.
   * @type {?SCNNode}
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523982-pointofview
   */


  get pointOfView() {
    return this._renderer.pointOfView;
  }

  set pointOfView(newValue) {
    this._renderer.pointOfView = newValue;
  }
  /**
   * Required. A Boolean value that determines whether SceneKit automatically adds lights to a scene.
   * @type {boolean}
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523812-autoenablesdefaultlighting
   */


  get autoenablesDefaultLighting() {
    return this._renderer.autoenablesDefaultLighting;
  }

  set autoenablesDefaultLighting(newValue) {
    this._renderer.autoenablesDefaultLighting = newValue;
  }
  /**
   * Required. A Boolean value that determines whether SceneKit applies jittering to reduce aliasing artifacts.
   * @type {boolean}
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1524026-isjitteringenabled
   */


  get isJitteringEnabled() {
    return this._renderer.isJitteringEnabled;
  }

  set isJitteringEnabled(newValue) {
    this._renderer.isJitteringEnabled = newValue;
  }
  /**
   * Required. A Boolean value that determines whether SceneKit displays rendering performance statistics in an accessory view.
   * @type {boolean}
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522763-showsstatistics
   */


  get showsStatistics() {
    return this._renderer.showsStatistics;
  }

  set showsStatistics(newValue) {
    this._renderer.showsStatistics = newValue;
  }
  /**
   * Required. Options for drawing overlay content in a scene that can aid debugging.
   * @type {SCNDebugOptions}
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523281-debugoptions
   */


  get debugOptions() {
    return this._renderer.debugOptions;
  }

  set debugOptions(newValue) {
    this._renderer.debugOptions = newValue;
  }
  /**
   * Required. The current scene time.
   * @type {number}
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522680-scenetime
   */


  get sceneTime() {
    return this._renderer.sceneTime;
  }

  set sceneTime(newValue) {
    this._renderer.sceneTime = newValue;
  }
  /**
   * Required. A Boolean value that determines whether SceneKit restarts the scene time after all animations in the scene have played.
   * @type {boolean}
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522878-loops
   */


  get loops() {
    return this._renderer.loops;
  }

  set loops(newValue) {
    this._renderer.loops = newValue;
  }
  /**
   * Required. The graphics technology SceneKit uses to render the scene.
   * @type {SCNRenderingAPI}
   * @desc You choose a graphics technology when initializing a scene renderer:When initializing a SCNView object, use the init(frame:options:) initializer and the preferredRenderingAPI key. Alternatively, create a view in Interface Builder and use the Rendering API control in the inspector. During initialization, the view will attempt to use the preferred API, but will fall back to a different API if the preferred one is not supported on the current hardware.To create a SCNRenderer object that renders into your own OpenGL contect, use the init(context:options:) initializer. To create a renderer for use in your own Metal workflow, use the init(device:options:) initializer.The rendering technology used by a SCNLayer object is determined by Core Animation.After initializing a renderer, this property reflects the rendering technology in use.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522616-renderingapi
   */


  get renderingAPI() {
    return this._renderingAPI;
  } // Participating in the Scene Rendering Process

  /**
   * Required. A delegate object that receives messages about SceneKit’s rendering process.
   * @type {?SCNSceneRendererDelegate}
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522671-delegate
   */


  get delegate() {
    return this._delegate;
  }
  /**
   * Required. A delegate object that receives messages about SceneKit’s rendering process.
   * @type {?SCNSceneRendererDelegate}
   * @param {?SCNSceneRendererDelegate} newValue -
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522671-delegate
   */


  set delegate(newValue) {
    // FIXME: delegate should not be changed while drawing
    this._delegate = newValue;
  } // Preloading Renderer Resources

  /**
   * Required. Prepares a SceneKit object for rendering.
   * @access public
   * @param {Object} object - An SCNScene, SCNNode, SCNGeometry, or SCNMaterial instance.
   * @param {?function(): boolean} [block = null] - A block that SceneKit calls periodically while preparing the object. The block takes no parameters.Your block should return false to tell SceneKit to continue preparing the object, or true to cancel preparation.Pass nil for this parameter if you do not need an opportunity to cancel preparing the object.
   * @returns {boolean} - 
   * @desc By default, SceneKit lazily loads resources onto the GPU for rendering. This approach uses memory and GPU bandwidth efficiently, but can lead to stutters in an otherwise smooth frame rate when you add large amounts of new content to an animated scene. To avoid such issues, use this method to prepare content for drawing before adding it to the scene. You can call this method on a secondary thread to prepare content asynchronously. SceneKit prepares all content associated with the object parameter you provide. If you provide an SCNMaterial object, SceneKit loads any texture images assigned to its material properties. If you provide an SCNGeometry object, SceneKit loads all materials attached to the geometry, as well as its vertex data. If you provide an SCNNode or SCNScene object, SceneKit loads all geometries and materials associated with the node and all its child nodes, or with the entire node hierarchy of the scene.You can use the block parameter to cancel preparation if content is no longer needed. For example, in a game you might use this method to preload areas of the game world the player is soon to enter, but if the player character dies before entering those areas, you can return true from the block to cancel preloading.You can observe the progress of this operation with the Progress class. For details, see Progress.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522798-prepare
   */


  prepareShouldAbortBlock(object, block = null) {
    return false;
  }
  /**
   * Required. Prepares the specified SceneKit objects for rendering, using a background thread.
   * @access public
   * @param {Object[]} objects - An array of containing one or more SCNScene, SCNNode, SCNGeometry, or SCNMaterial instances.
   * @param {?function(arg1: boolean): void} [completionHandler = null] - A block that SceneKit calls when object preparation fails or completes.The block takes the following parameter:successtrue if all content was successfully prepared for rendering; otherwise, false.
   * @returns {void}
   * @desc By default, SceneKit lazily loads resources onto the GPU for rendering. This approach uses memory and GPU bandwidth efficiently, but can lead to stutters in an otherwise smooth frame rate when you add large amounts of new content to an animated scene. To avoid such issues, use this method to prepare content for drawing before adding it to the scene. SceneKit uses a secondary thread to prepare content asynchronously.SceneKit prepares all content associated with the objects you provide. If you provide an SCNMaterial object, SceneKit loads any texture images assigned to its material properties. If you provide an SCNGeometry object, SceneKit loads all materials attached to the geometry, as well as its vertex data. If you provide an SCNNode or SCNScene object, SceneKit loads all geometries and materials associated with the node and all its child nodes, or with the entire node hierarchy of the scene.You can observe the progress of this operation with the Progress class. For details, see Progress.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523375-prepare
   */


  prepare(objects, completionHandler = null) {} // Working With Projected Scene Contents

  /**
   * Required. Searches the renderer’s scene for objects corresponding to a point in the rendered image.
   * @access public
   * @param {CGPoint} point - 
   * @param {?Map<SCNHitTestOption, Object>} [options = null] - A dictionary of options affecting the search. See Hit Testing Options Keys for acceptable values.
   * @returns {SCNHitTestResult[]} - 
   * @desc A 2D point in the rendered screen coordinate space can refer to any point along a line segment in the 3D scene coordinate space. Hit-testing is the process of finding elements of a scene located along this line segment. For example, you can use this method to find the geometry corresponding to a click event in a SceneKit view.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522929-hittest
   */


  hitTest(point, options = null) {
    const x = (point.x - this._frame.minX) / this._frame.width * 2.0 - 1.0;
    const y = (point.y - this._frame.minY) / this._frame.height * 2.0 - 1.0;
    return this._renderer.hitTest(new CGPoint(x, -y), options);
  }
  /**
   * Required. Returns a Boolean value indicating whether a node might be visible from a specified point of view.
   * @access public
   * @param {SCNNode} node - The node whose visibility is to be tested.
   * @param {SCNNode} pointOfView - A node defining a point of view, as used by the pointOfView property.
   * @returns {boolean} - 
   * @desc Any node containing a camera or spotlight may serve as a point of view (see the pointOfView property for details). Such a node defines a viewing frustum—a portion of the scene’s coordinate space, shaped like a truncated pyramid, that encloses all points visible from that point of view.Use this method to test whether a node lies within the viewing frustum defined by another node (which may or may not be the scene renderer’s current pointOfView node). For example, in a game scene containing multiple camera nodes, you could use this method to determine which camera is currently best for viewing a moving player character.Note that this method does not perform occlusion testing. That is, it returns true if the tested node lies within the specified viewing frustum regardless of whether that node’s contents are obscured by other geometry.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522647-isnode
   */


  isNodeInsideFrustumOf(node, pointOfView) {
    return false;
  }
  /**
   * Required. Returns all nodes that might be visible from a specified point of view.
   * @access public
   * @param {SCNNode} pointOfView - A node defining a point of view, as used by the pointOfView property.
   * @returns {SCNNode[]} - 
   * @desc Any node containing a camera or spotlight may serve as a point of view (see the pointOfView property for details). Such a node defines a viewing frustum—a portion of the scene’s coordinate space, shaped like a truncated pyramid, that encloses all points visible from that point of view.Use this method find all nodes whose content lies within the viewing frustum defined by another node (which may or may not be the scene renderer’s current pointOfView node).Note that this method does not perform occlusion testing. That is, the returned array includes any node that lies within the specified viewing frustum regardless of whether that node’s contents are obscured by other geometry.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522942-nodesinsidefrustum
   */


  nodesInsideFrustumOf(pointOfView) {
    return null;
  }
  /**
   * Required. Projects a point from the 3D world coordinate system of the scene to the 2D pixel coordinate system of the renderer.
   * @access public
   * @param {SCNVector3} point - A point in the world coordinate system of the renderer’s scene.
   * @returns {SCNVector3} - 
   * @desc The z-coordinate of the returned point describes the depth of the projected point relative to the near and far clipping planes of the renderer’s viewing frustum (defined by its pointOfView node). Projecting a point on the near clipping plane returns a point whose z-coordinate is 0.0; projecting a point on the far clipping plane returns a point whose z-coordinate is 1.0.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1524089-projectpoint
   */


  projectPoint(point) {
    return null;
  }
  /**
   * Required. Unprojects a point from the 2D pixel coordinate system of the renderer to the 3D world coordinate system of the scene.
   * @access public
   * @param {SCNVector3} point - A point in the screen-space (view, layer, or GPU viewport) coordinate system of the scene renderer.
   * @returns {SCNVector3} - 
   * @desc The z-coordinate of the point parameter describes the depth at which to unproject the point relative to the near and far clipping planes of the renderer’s viewing frustum (defined by its pointOfView node). Unprojecting a point whose z-coordinate is 0.0 returns a point on the near clipping plane; unprojecting a point whose z-coordinate is 1.0 returns a point on the far clipping plane.A 2D point in the rendered screen coordinate space can refer to any point along a line segment in the 3D scene coordinate space. To test for scene contents along this line—for example, to find the geometry corresponding to the location of a click event in a view—use the hitTest(_:options:) method.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522631-unprojectpoint
   */


  unprojectPoint(point) {
    return null;
  } // Customizing Scene Rendering with Metal

  /**
   * Required. The Metal render command encoder in use for the current SceneKit rendering pass.
   * @type {?MTLRenderCommandEncoder}
   * @desc Use this render command encoder to encode additional rendering commands before or after SceneKit draws its own content.This property is valid only during the SceneKit rendering loop—that is, within one of the methods defined in the SCNSceneRendererDelegate protocol. Accessing this property at any other time returns nil.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522609-currentrendercommandencoder
   */


  get currentRenderCommandEncoder() {
    return this._renderer.currentRenderCommandEncoder;
  }
  /**
   * Required. The Metal device this renderer uses for rendering.
   * @type {?MTLDevice}
   * @desc Use this property to create or look up other Metal resources that use the same device as your SceneKit renderer.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523935-device
   */


  get device() {
    return this._device;
  }
  /**
   * Required. The Metal command queue this renderer uses for rendering.
   * @type {?MTLCommandQueue}
   * @desc Use this property to schedule additional command buffers for the Metal device to execute as part of the render cycle. For example, you can use a compute command encoder to modify the vertex data in a Metal buffer for use by a SCNGeometrySource object.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523974-commandqueue
   */


  get commandQueue() {
    return this._renderer.commandQueue;
  }
  /**
   * Required. The Metal pixel format for the renderer’s color output.
   * @type {MTLPixelFormat}
   * @desc Use this property, along with the depthPixelFormat and stencilPixelFormat properties, if you perform custom drawing with Metal (see the SCNSceneRendererDelegate and SCNNodeRendererDelegate classes) and need to create a new MTLRenderPipelineState object to change the GPU state as part of your rendering.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523701-colorpixelformat
   */


  get colorPixelFormat() {
    return this._renderer.colorPixelFormat;
  }
  /**
   * Required. The Metal pixel format for the renderer’s depth buffer.
   * @type {MTLPixelFormat}
   * @desc Use this property, along with the colorPixelFormat and stencilPixelFormat properties, if you perform custom drawing with Metal (see the SCNSceneRendererDelegate and SCNNodeRendererDelegate classes) and need to create a new MTLRenderPipelineState object to change the GPU state as part of your rendering.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523780-depthpixelformat
   */


  get depthPixelFormat() {
    return this._renderer.depthPixelFormat;
  }
  /**
   * Required. The Metal pixel format for the renderer’s stencil buffer.
   * @type {MTLPixelFormat}
   * @desc Use this property, along with the depthPixelFormat and colorPixelFormat properties, if you perform custom drawing with Metal (see the SCNSceneRendererDelegate and SCNNodeRendererDelegate classes) and need to create a new MTLRenderPipelineState object to change the GPU state as part of your rendering.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523315-stencilpixelformat
   */


  get stencilPixelFormat() {
    return this._renderer._stencilPixelFormat;
  } // Customizing Scene Rendering with OpenGL

  /**
   * Required. The OpenGL rendering context that SceneKit uses for rendering the scene.
   * @type {?WebGLRenderingContext}
   * @desc In macOS, the value of this property is a Core OpenGL cglContextObj object.In iOS, the value of this property is an EAGLContext object.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522840-context
   */


  get context() {
    return this._renderer.context;
  } // Rendering Sprite Kit Content over a Scene

  /**
   * Required. A Sprite Kit scene to be rendered on top of the SceneKit content.
   * @type {?SKScene}
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1524051-overlayskscene
   */


  get overlaySKScene() {
    return this._renderer.overlaySKScene;
  }

  set overlaySKScene(newValue) {
    this._renderer.overlaySKScene = newValue;
  } // Working With Positional Audio

  /**
   * Required. The node representing the listener’s position in the scene for use with positional audio effects.
   * @type {?SCNNode}
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523747-audiolistener
   */


  get audioListener() {
    return this._renderer.audioListener;
  }

  set audioListener(newValue) {
    this._renderer.audioListener = newValue;
  }
  /**
   * Required. The 3D audio mixing node SceneKit uses for positional audio effects.
   * @type {AVAudioEnvironmentNode}
   * @desc SceneKit uses this audio node to spatialize sounds from SCNAudioPlayer objects attached to nodes in the scene. You can use this object in conjunction with the audioEngine property to rearrange the audio graph to add other, non-spatialized audio sources or mix in audio processing effects.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523582-audioenvironmentnode
   */


  get audioEnvironmentNode() {
    return this._renderer.audioEnvironmentNode;
  }
  /**
   * Required. The audio engine SceneKit uses for playing scene sounds.
   * @type {AVAudioEngine}
   * @desc SceneKit uses this audio engine to play sounds from SCNAudioPlayer objects attached to nodes in the scene. You can use this object directly to add other sound sources not related to scene contents, or to add other sound processing nodes or mixing nodes to the audio engine. To identify the node SceneKit uses for spatializing scene sounds when connecting other nodes, use the audioEnvironmentNode property.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522686-audioengine
   */


  get audioEngine() {
    return this._renderer.audioEngine;
  } // Instance Properties

  /**
   * Required. 
   * @type {number}
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522854-currenttime
   */


  get currentTime() {
    return this._renderer.currentTime;
  }

  set currentTime(newValue) {
    this._renderer.currentTime = newValue;
  } ////////////////////////////////////////////////
  // NSView/UIView
  ////////////////////////////////////////////////
  // TODO: implement NSView/UIView and extend it


  viewDidMoveToWindow() {}

  setFrameSize(newSize) {}
  /**
   * draw one frame
   * @access private
   * @param {number} time - current time
   * @param {WebGLRenderingContext} context - context to draw frame
   * @returns {void}
   */


  _drawAtTimeWithContext(time, context) {
    this._renderer._time = time;

    this._createPresentationNodes();

    this._createSKPresentationNodes();

    this._updateTransform();

    if (this._delegate && this._delegate.rendererUpdateAtTime) {
      this._delegate.rendererUpdateAtTime(this._renderer, time);
    } ///////////////////////////////
    // runs actions & animations //
    ///////////////////////////////


    this._copyTransformToPresentationNodes();

    this._copyTransformToPresentationSKNodes();

    this._updateTransform();

    this._runActions();

    this._runAnimations();

    this._runSKActions();

    this._updateTransform();

    if (this._delegate && this._delegate.rendererDidApplyAnimationsAtTime) {
      this._delegate.rendererDidApplyAnimationsAtTime(this._renderer, time);
    }

    this._updateTransform(); ///////////////////////
    // simulates physics //
    ///////////////////////


    if (this._scene && this._scene._physicsWorld !== null) {
      this._scene._physicsWorld._simulate(time);
    }

    if (this._delegate && this._delegate.rendererDidSimulatePhysicsAtTime) {
      this._delegate.rendererDidSimulatePhysicsAtTime(this._renderer, time);
    } ///////////////////////////
    // evaluates constraints //
    ///////////////////////////


    if (this._delegate && this._delegate.rendererWillRenderSceneAtTime) {
      this._delegate.rendererWillRenderSceneAtTime(this._renderer, this._scene, time);
    } ///////////////////////
    // renders the scene //
    ///////////////////////


    this._updateSkinner();

    this._updateMorph();

    this._updateParticles();

    this._updateSKTransform();

    this._renderer.render();

    if (this._delegate && this._delegate.rendererDidRenderSceneAtTime) {
      this._delegate.rendererDidRenderSceneAtTime(this._renderer, time);
    }
  }

  _createPresentationNodes() {
    if (this._scene === null) {
      return;
    }

    const arr = [this._scene.rootNode];

    while (arr.length > 0) {
      const node = arr.shift();

      if (!node._presentation) {
        node._createPresentation();
      }

      arr.push(...node.childNodes);
    }
  }

  _copyTransformToPresentationNodes() {
    if (this._scene === null) {
      return;
    }

    const arr = [this._scene.rootNode, this._scene._skyBox, this._renderer._defaultCameraPosNode, this._renderer._defaultLightNode];

    while (arr.length > 0) {
      const node = arr.shift();

      node._copyTransformToPresentation();

      node._copyMaterialPropertiesToPresentation();

      node._copyMorpherToPresentation();

      arr.push(...node.childNodes);
    }
  }

  _createSKPresentationNodes() {
    if (this.overlaySKScene === null) {
      return;
    }

    const arr = [this.overlaySKScene];

    while (arr.length > 0) {
      const node = arr.shift();
      let p = node.__presentation;

      if (p === null) {
        p = node.copy();
        p._isPresentationInstance = true;
        node.__presentation = p;
      } //node._copyTransformToPresentation()


      arr.push(...node.children);
    }
  }

  _copyTransformToPresentationSKNodes() {
    if (this.overlaySKScene === null) {
      return;
    }

    const arr = [this.overlaySKScene];

    while (arr.length > 0) {
      const node = arr.shift();

      node._copyTransformToPresentation();

      arr.push(...node.children);
    }
  }
  /**
   * request animation frame repeatedly as long as isPlaying is true
   * @access private
   * @returns {void}
   */


  __requestAnimationFrame() {
    // Reflect.apply(this._requestAnimationFrame, window, () => {
    this._requestAnimationFrame.call(window, () => {
      const time = Date.now();
      let elapsedTimeMs = 0;

      if (this._previousSystemTimeMs) {
        elapsedTimeMs = time - this._previousSystemTimeMs;
      }

      if (elapsedTimeMs) {
        if (!this._lastFpsCalculationTimeMs) {
          this._lastFpsCalculationTime = time;
        }

        this._sumElapsedTimeMs += elapsedTimeMs;
        this._sumFrames += 1;

        if (time - this._lastFpsCalculationTimeMs > this._fpsCalculationSpanMs) {
          this._fps = this._sumFrames / (this._sumElapsedTimeMs * 0.001);
          this._sumFrames = 0;
          this._sumElapsedTimeMs = 0;
          this._lastFpsCalculationTimeMs = time;
          console.error('fps: ' + this._fps);
        }
      }

      this._currentSystemTime = time * 0.001;
      this._elapsedTime = elapsedTimeMs * 0.001;
      this.currentTime = this._currentSystemTime;

      GCController._update();

      this._drawAtTimeWithContext(this.currentTime, this._context);

      if (this._isPlaying) {
        this.__requestAnimationFrame();
      }

      this._previousSystemTimeMs = time;
    });
  }

  _updateTransform(node, parentTransform) {
    if (this._scene === null) {
      return;
    }

    this._scene.rootNode._updateWorldTransform();

    this._scene.rootNode._updateBoundingBox();
  }

  _updateSkinner(node) {
    if (typeof node === 'undefined') {
      if (this._scene) {
        this._updateSkinner(this._scene.rootNode);
      }

      return;
    }

    if (node.skinner !== null && !node.skinner._useGPU) {
      node.skinner._update(node);
    }

    node.childNodes.forEach(child => {
      this._updateSkinner(child);
    });
  }

  _updateMorph(node) {
    if (typeof node === 'undefined') {
      if (this._scene) {
        this._updateMorph(this._scene.rootNode);
      }

      return;
    }

    if (node.morpher !== null) {
      node.morpher._morph(node);
    }

    node.childNodes.forEach(child => {
      this._updateMorph(child);
    });
  }

  _updateSKTransform() {
    if (this.overlaySKScene === null) {
      return;
    }

    this.overlaySKScene._updateWorldTransform();
  }

  _runActions() {
    if (this._scene === null) {
      return;
    }

    this._runActionForNode(this._scene.rootNode);
  }

  _runActionForNode(node) {
    this._runActionForObject(node);

    node.childNodes.forEach(child => this._runActionForNode(child));
  }

  _runActionForObject(obj) {
    const deleteKeys = [];

    obj._actions.forEach((action, key) => {
      action._applyAction(obj, this.currentTime);

      if (action._finished) {
        if (action._completionHandler) {
          action._completionHandler();
        }

        deleteKeys.push(key);
      }
    });

    deleteKeys.forEach(key => {
      obj._actions.delete(key);
    });
  }

  _runSKActions() {
    if (this.overlaySKScene === null) {
      return;
    }

    this._runSKActionForNode(this.overlaySKScene);
  }

  _runSKActionForNode(node) {
    this._runSKActionForObject(node);

    node.children.forEach(child => this._runSKActionForNode(child));
  }

  _runSKActionForObject(obj) {
    const deleteKeys = [];

    obj._actions.forEach((action, key) => {
      action._applyAction(obj, this.currentTime);

      if (action._finished) {
        if (action._completionHandler) {
          action._completionHandler();
        }

        deleteKeys.push(key);
      }
    });

    deleteKeys.forEach(key => {
      obj._actions.delete(key);
    });
  }

  _runAnimations() {
    if (this._scene === null) {
      return;
    }

    this._runAnimationForNode(this._scene.rootNode);
  }

  _runAnimationForNode(node) {
    node.childNodes.forEach(child => this._runAnimationForNode(child));

    this._runAnimationForObject(node); // TODO: implement animations for all animatable objects:
    //         SCNCamera, SCNConstraint, SCNGeometry, SCNLight, SCNMaterial, 
    //         SCNMaterialProperty, SCNMorpher, SCNParticleSystem, SCNTechnique


    if (node.geometry) {
      this._runAnimationForObject(node.geometry);

      node.geometry.materials.forEach(material => {
        this._runAnimationForObject(material);

        const properties = [material._diffuse, material._ambient, material._specular, material._normal, material._reflective, material._emission, material._transparent, material._multiply, material._ambientOcclusion, material._selfIllumination, material._metalness, material._roughness];
        properties.forEach(prop => {
          this._runAnimationForObject(prop);
        });
      });
    }

    if (node._particleSystems) {
      for (const system of node._particleSystems) {
        this._runAnimationForObject(system);
      }
    }
  }

  _runAnimationForObject(obj) {
    const deleteKeys = [];

    obj._animations.forEach((animation, key) => {
      animation._applyAnimation(obj, this.currentTime);

      if (animation._isFinished && animation.isRemovedOnCompletion) {
        deleteKeys.push(key);
      }
    });

    deleteKeys.forEach(key => {
      obj._animations.delete(key);
    });
  }

  _updateParticles() {
    if (this._scene === null) {
      return;
    }

    this._updateParticlesForScene();

    this._updateParticlesForNode(this._scene.rootNode);
  }

  _updateParticlesForScene() {
    if (this._scene._particleSystems === null) {
      return;
    }

    const gravity = this._scene.physicsWorld ? this._scene.physicsWorld.gravity : null;
    const len = this._scene._particleSystems.length;

    for (let i = 0; i < len; i++) {
      const system = this._scene._particleSystems[i];
      const transform = this._scene._particleSystemsTransform[i];

      system._updateParticles(transform, gravity, this.currentTime);
    }

    for (const system of this._scene._particleSystems) {
      if (system._finished) {
        this._scene.removeParticleSystem(system);
      }
    }
  }

  _updateParticlesForNode(node) {
    this._updateParticlesForObject(node);

    node.childNodes.forEach(child => this._updateParticlesForNode(child));
  }

  _updateParticlesForObject(obj) {
    if (obj.particleSystems === null) {
      return;
    }

    const gravity = this._scene.physicsWorld ? this._scene.physicsWorld.gravity : null;

    for (const system of obj.particleSystems) {
      system._updateParticles(obj.presentation.worldTransform, gravity, this.currentTime);
    }

    for (const system of obj.particleSystems) {
      if (system._finished) {
        obj.removeParticleSystem(system);
      }
    }
  } // NSView

  /**
   * @access private
   * @param {Event} e -
   * @returns {NSEvent} -
   */


  _createEvent(e) {
    // TODO: implement NSEvent
    const ev = {};
    ev.locationInWindow = new CGPoint(e.clientX, e.clientY);
    ev.modifierFlags = 0; // TODO: implement

    ev.timestamp = e.timeStamp; // ev.type

    if (typeof window !== 'undefined') {
      ev.window = window;
    }

    ev.windowNumber = 0;
    ev.eventRef = e;
    ev.cgEvent = null;
    ev.characters = null; // TODO: implement

    ev.charactersIgnoringModifiers = null; // TODO: implement

    ev.isARepeat = false;

    if (typeof e.repeat !== 'undefined') {
      ev.isARepeat = e.repeat;
    }

    if (e.code && _KeyCode.has(e.code)) {
      ev.keyCode = _KeyCode.get(e.code);
    } else {
      ev.keyCode = 0;
    }

    ev.buttonNumber = 0;
    ev.clickCount = 0;
    ev.associatedEventsMask = null;
    ev.eventNumber = 0;
    ev.trackingNumber = 0;
    ev.trackingArea = 0;
    ev.userData = null;
    ev.data1 = 0;
    ev.data2 = 0;
    ev.sutype = null;

    if (typeof e.deltaX !== 'undefined') {
      ev.deltaX = e.deltaX;
      ev.deltaY = e.deltaY;
      ev.deltaZ = e.deltaZ;
    } else {
      // for Firefox
      ev.deltaX = 0;
      ev.deltaY = 0;
      ev.deltaZ = 0;

      if (typeof e.detail !== 'undefined') {
        ev.deltaY = -e.detail * 10.0;
      }
    }

    ev._doDefaultAction = false;
    return ev;
  }

  _preventDefault(e) {
    if (!e._doDefaultAction) {
      e.eventRef.preventDefault();
    }
  }
  /**
   * @access public
   * @param {NSEvent} theEvent -
   * @returns {void}
   */


  mouseDownWith(theEvent) {
    theEvent._doDefaultAction = true;
  }
  /**
   * @access public
   * @param {NSEvent} theEvent -
   * @returns {void}
   */


  mouseDraggedWith(theEvent) {
    theEvent._doDefaultAction = true;
  }
  /**
   * @access public
   * @param {NSEvent} theEvent -
   * @returns {void}
   */


  mouseUpWith(theEvent) {
    theEvent._doDefaultAction = true;
  }
  /**
   * @access public
   * @param {NSEvent} theEvent -
   * @returns {void}
   */


  mouseMovedWith(theEvent) {
    theEvent._doDefaultAction = true;
  }
  /**
   * @access public
   * @param {NSEvent} theEvent -
   * @returns {void}
   */


  mouseEnteredWith(theEvent) {
    theEvent._doDefaultAction = true;
  }
  /**
   * @access public
   * @param {NSEvent} theEvent -
   * @returns {void}
   */


  mouseExitedWith(theEvent) {
    theEvent._doDefaultAction = true;
  }
  /**
   * @access public
   * @param {NSEvent} theEvent -
   * @returns {void}
   */


  rightMouseDraggedWith(theEvent) {
    theEvent._doDefaultAction = true;
  }
  /**
   * @access public
   * @param {NSEvent} theEvent -
   * @returns {void}
   */


  rightMouseUpWith(theEvent) {
    theEvent._doDefaultAction = true;
  }
  /**
   * @access public
   * @param {NSEvent} theEvent -
   * @returns {void}
   */


  otherMouseDownWith(theEvent) {
    theEvent._doDefaultAction = true;
  }
  /**
   * @access public
   * @param {NSEvent} theEvent -
   * @returns {void}
   */


  otherMouseDraggedWith(theEvent) {
    theEvent._doDefaultAction = true;
  }
  /**
   * @access public
   * @param {NSEvent} theEvent -
   * @returns {void}
   */


  otherMouseUpWith(theEvent) {
    theEvent._doDefaultAction = true;
  }
  /**
   * @access public
   * @param {NSEvent} theEvent -
   * @returns {void}
   */


  scrollWheelWith(theEvent) {
    theEvent._doDefaultAction = true;
  }
  /**
   * @access public
   * @param {NSEvent} theEvent -
   * @returns {void}
   */


  keyDownWith(theEvent) {
    theEvent._doDefaultAction = true;
  }
  /**
   * @access public
   * @param {NSEvent} theEvent -
   * @returns {void}
   */


  keyUpWith(theEvent) {
    theEvent._doDefaultAction = true;
  }
  /**
   * @access public
   * @param {NSEvent} theEvent -
   * @returns {void}
   */


  flagsChangedWith(theEvent) {}
  /**
   * @access public
   * @param {NSEvent} theEvent -
   * @returns {void}
   */


  tablePointWith(theEvent) {}
  /**
   * @access public
   * @param {NSEvent} theEvent -
   * @returns {void}
   */


  tableProximityWith(theEvent) {}

  convertFrom(point, view) {
    let sx = 0;
    let sy = 0;

    if (view) {
      // FIXME: add accessor functions to get the element position
      sx = view._frame.origin.x;
      sy = view._frame.origin.y;
    } // FIXME: add accessor functions to get the element position


    const rect = this._canvas.getBoundingClientRect();

    const dx = rect.left;
    const dy = rect.top;
    return new CGPoint(point.x + sx - dx, point.y + sy - dy);
  }
  /**
   * @type {CGRect}
   */


  get bounds() {
    const rect = this._canvas.getBoundingClientRect();

    return new CGRect(new CGPoint(rect.left, rect.top), new CGSize(rect.width, rect.height));
  }

} // TODO: use extension of HTMLElement when it's supported.
//if(customElements){
//  customElements.define('scn-view', SCNView)
//}

/**
 * The modes that an action can use to adjust the apparent timing of the action.
 * @typedef {Object} SKActionTimingMode
 * @property {number} linear - Specifies linear pacing. Linear pacing causes an animation to occur evenly over its duration.
 * @property {number} easeIn - Specifies ease-in pacing. Ease-in pacing causes the animation to begin slowly and then speed up as it progresses.
 * @property {number} easeOut - Specifies ease-out pacing. Ease-out pacing causes the animation to begin quickly and then slow as it completes.
 * @property {number} easeInEaseOut - Specifies ease-in ease-out pacing. An ease-in ease-out animation begins slowly, accelerates through the middle of its duration, and then slows again before completing.
 * @see https://developer.apple.com/documentation/spritekit/skactiontimingmode
 */

const SKActionTimingMode = {
  linear: 0,
  easeIn: 1,
  easeOut: 2,
  easeInEaseOut: 3
};

/**
 * An object that is executed by an SKNode to change its structure or content.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/spritekit/skaction
 */

class SKAction extends NSObject {
  // Creating Custom Actions

  /**
   * Creates an action of the given name from an action file with a new duration.
   * @access public
   * @constructor
   * @param {string} name - The name of the action.
   * @param {string} url - The URL of the file containing the action.
   * @param {number} sec - The duration of the action, in seconds.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417754-init
   */
  constructor(name, url, sec) {
    super(); // Inspecting an Action’s Animation Properties

    /**
     * A speed factor that modifies how fast an action runs.
     * @type {number}
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417718-speed
     */

    this._speed = 1.0;
    /**
     * The timing mode used to execute an action.
     * @type {SKActionTimingMode}
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417807-timingmode
     */

    this._timingMode = SKActionTimingMode.linear;
    /**
     * A block used to customize the timing function.
     * @type {SKActionTimingFunction}
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417666-timingfunction
     */

    this._timingFunction = null;
    /**
     * The duration required to complete an action.
     * @type {number}
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417790-duration
     */

    this._duration = 0;
    /**
     * @access private
     * @type {boolean}
     */

    this._finished = false;
    this._beginTime = 0;
    this._isRunning = false;
    this._pausedTime = 0;
    this._completionHandler = null;
    this.__actionStartTime = null;
  }
  /**
   * A speed factor that modifies how fast an action runs.
   * @type {number}
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417718-speed
   */


  get speed() {
    return this._speed;
  }

  set speed(newValue) {
    this._speed = newValue;
  }
  /**
   * The timing mode used to execute an action.
   * @type {SKActionTimingMode}
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417807-timingmode
   */


  get timingMode() {
    return this._timingMode;
  }

  set timingMode(newValue) {
    this._timingMode = newValue;
  }
  /**
   * A block used to customize the timing function.
   * @type {SKActionTimingFunction}
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417666-timingfunction
   */


  get timingFunction() {
    return this._timingFunction;
  }

  set timingFunction(newValue) {
    this._timingFunction = newValue;
  }
  /**
   * The duration required to complete an action.
   * @type {number}
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417790-duration
   */


  get duration() {
    return this._duration;
  }

  set duration(newValue) {
    this._duration = newValue;
  }

  get _actionStartTime() {
    return this.__actionStartTime;
  }

  set _actionStartTime(newValue) {
    this.__actionStartTime = newValue;
  }
  /**
   * @access public
   * @returns {SKAction} -
   */


  copy() {
    const action = super.copy();
    action._beginTime = this._beginTime;
    action._duration = this._duration;
    action._speed = this.speed;
    action._timingMode = this.timingMode;
    action._timingFunction = this.timingFunction;
    action._finished = this._finished; //action._isRunning = this._isRunning
    //action._pausedTime = this._pausedTime
    //action._completionHandler = this._completionHandler

    return action;
  }
  /**
   * apply action to the given node.
   * @access private
   * @param {Object} obj - target object to apply this action.
   * @param {number} time - active time
   * @param {boolean} [needTimeConversion = true] -
   * @returns {void}
   */


  _applyAction(obj, time, needTimeConversion = true) {
    const t = this._getTime(time, needTimeConversion); //this._handleEvents(obj, t)

  }

  _getTime(time, needTimeConversion) {
    if (!needTimeConversion) {
      if (time >= 1.0 && !this._finished) {
        this._finished = true;
      }

      return time;
    }

    const baseTime = this._basetimeFromTime(time);

    if (this.timingFunction === null) {
      return baseTime;
    }

    return this.timingFunction._getValueAtTime(baseTime);
  }
  /**
   * convert parent time to base time
   * @access private
   * @param {number} time - parent time
   * @returns {number} - animation base time for the current frame (0-1 or null).
   */


  _basetimeFromTime(time) {
    const activeTime = time - this._actionStartTime;
    return this._basetimeFromActivetime(activeTime);
  }
  /**
   * convert parent time to active time
   * @access private
   * @param {number} time - parent time
   * @returns {number} - animation active time for the current frame.
   */


  _activetimeFromTime(time) {
    return time - this._actionStartTime;
  }
  /**
   * convert active time to base time
   * @access private
   * @param {number} time - active time
   * @returns {number} - animation base time for the current frame (0-1 or null).
   */


  _basetimeFromActivetime(time) {
    let dt = time - this._beginTime; //let dt = time

    if (this.speed === 0) {
      return 0;
    }

    if (this._duration === 0) {
      return dt / Math.abs(this.speed);
    }

    let duration = this._duration / Math.abs(this.speed);

    if (duration === 0) {
      duration = 0.25;
    }

    if (dt >= duration) {
      // the action is over.
      if (!this._finished) {
        this._finished = true;
      }
    }

    return dt / duration;
  }
  /**
   * @access private
   * @param {Object} from -
   * @param {Object} to -
   * @param {number} t -
   * @returns {Object} -
   */


  _lerp(from, to, t) {
    if (t === null) {
      // the action is over.
      return to;
    } //if(from instanceof SCNVector4){
    //  // TODO: slerp for Quaternion
    //  return from.lerp(to, t)
    //}else if(from instanceof SCNVector3){
    //  return from.lerp(to, t)
    //}else if(from instanceof CGSize){


    if (_InstanceOf(from, CGSize)) {
      return from._lerp(to, t);
    } else if (_InstanceOf(from, CGPoint)) {
      return from._lerp(to, t);
    } else if (_InstanceOf(from, CGRect)) {
      return from._lerp(to, t);
    } else if (_InstanceOf(from, SKColor)) {
      return from._lerp(to, t);
    }

    return from + (to - from) * t;
  }
  /**
   * @access private
   * @param {Object} from -
   * @param {Object} to -
   * @param {number} t -
   * @returns {Object} -
   */
  //_slerp(from, to, t) {
  //  if(!(from instanceof SCNVector4)){
  //    throw new Error('SCNAction._slerp: object is not SCNVector4')
  //  }
  //  return from.slerp(to, t)
  //}


  _resetFinished() {
    this._finished = false;
  }
  /**
   * Creates an action of the given name from an action file.
   * @access public
   * @param {string} name - The name of the action.
   * @returns {SKAction} -
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417814-init
   */


  static actionWithName(name) {
    return new SKAction(name, null, 0.25);
  }
  /**
   * Creates an action of the given name from an action file with a new duration.
   * @access public
   * @param {string} name - The name of the action.
   * @param {number} sec - The duration of the action.
   * @returns {void}
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417697-init
   */


  static actionWithNamedDuration(name, sec) {
    return new SKAction(name, null, sec);
  }
  /**
   * Creates an action of the given name from an action file.
   * @access public
   * @param {string} name - The name of the action.
   * @param {string} url - The URL of the file containing the action.
   * @returns {void}
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417680-init
   */


  static actionWithNamedFrom(name, url) {
    return new SKAction(name, url);
  } // Creating Actions That Move Nodes

  /**
   * Creates an action that moves a node relative to its current position.
   * @access public
   * @param {number} deltaX - The x-value, in points, to add to the node’s position.
   * @param {number} deltaY - The y-value, in points, to add to the node’s position.
   * @param {number} sec - The duration of the animation.
   * @returns {SKAction} - 
   * @desc When the action executes, the node’s position property animates from its current position to its new position.This action is reversible; the reverse is created as if the following code is executed:let negDelta = CGVector(dx: -deltaX, dy: -deltaY)
  let action = SKAction.moveBy(x: -deltaX, y: -deltaX, duration: sec)
  let negDelta = CGVector(dx: -deltaX, dy: -deltaY)
  let action = SKAction.moveBy(x: -deltaX, y: -deltaX, duration: sec)
    * @see https://developer.apple.com/documentation/spritekit/skaction/1417722-moveby
   */


  static moveByXYDuration(deltaX, deltaY, sec) {
    return null;
  }
  /**
   * Creates an action that moves a node relative to its current position.
   * @access public
   * @param {CGVector} delta - A vector that describes the change to apply to the node’s position.
   * @param {number} sec - The duration of the animation.
   * @returns {SKAction} - 
   * @desc When the action executes, the node’s position property animates from its current position to its new position.This action is reversible; the reverse is created as if the following code is executed:let negDelta = CGVector(dx: -deltaX, dy: -deltaY)
  let action = SKAction.move(by: negDelta, duration: sec)
  let negDelta = CGVector(dx: -deltaX, dy: -deltaY)
  let action = SKAction.move(by: negDelta, duration: sec)
    * @see https://developer.apple.com/documentation/spritekit/skaction/1417739-move
   */


  static moveByDuration(delta, sec) {
    return null;
  }
  /**
   * Creates an action that moves a node to a new position.
   * @access public
   * @param {CGPoint} location - The coordinates for the node’s new position.
   * @param {number} sec - The duration of the animation.
   * @returns {SKAction} - 
   * @desc When the action executes, the node’s position property animates from its current position to its new position.This action is not reversible; the reverse of this action has the same duration but does not move the node.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417768-move
   */


  static moveToDuration(location, sec) {
    return null;
  }
  /**
   * Creates an action that moves the node along a relative path, orienting the node to the path.
   * @access public
   * @param {CGPath} path - A Core Graphics path whose coordinates are relative to the node’s current position.
   * @param {number} sec - The duration of the animation.
   * @returns {SKAction} - 
   * @desc Calling this method is equivalent to calling the follow(_:asOffset:orientToPath:duration:) method, passing in true to both the offset and orient parameters.This action is reversible; the resulting action creates and then follows a reversed path with the same duration.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417822-follow
   */


  static followDuration(path, sec) {
    return null;
  }
  /**
   * Creates an action that moves the node along a relative path at a specified speed, orienting the node to the path.
   * @access public
   * @param {CGPath} path - A Core Graphics path whose coordinates are relative to the node’s current position.
   * @param {number} speed - The speed at which the node should move, in points per second.
   * @returns {SKAction} - 
   * @desc Calling this method is equivalent to calling the follow(_:asOffset:orientToPath:speed:) method, passing in true to both the offset and orient parameters.This action is reversible; the resulting action creates and then follows a reversed path with the same speed.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417786-follow
   */


  static follow(path, speed) {
    return null;
  }
  /**
   * Creates an action that moves the node along a path.
   * @access public
   * @param {CGPath} path - A path to follow.
   * @param {boolean} offset - If true, the points in the path are relative offsets to the node’s starting position. If false, the points in the node are absolute coordinate values.
   * @param {boolean} orient - If true, the node’s zRotation property animates so that the node turns to follow the path. If false, the zRotation property of the node is unchanged.
   * @param {number} sec - The duration of the animation.
   * @returns {SKAction} - 
   * @desc When the action executes, the node’s position and zRotation properties are animated along the provided path.This action is reversible; the resulting action creates a reversed path and then follows it, with the same duration.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417662-follow
   */


  static followAsOffsetOrientToPathDuration(path, offset, orient, sec) {
    return null;
  }
  /**
   * Creates an action that moves the node at a specified speed along a path.
   * @access public
   * @param {CGPath} path - A path to follow.
   * @param {boolean} offset - If true, the points in the path are relative offsets to the node’s starting position. If false, the points in the node are absolute coordinate values.
   * @param {boolean} orient - If true, the node’s zRotation property animates so that the node turns to follow the path. If false, the zRotation property of the node is unchanged.
   * @param {number} speed - The speed at which the node should move, in points per second.
   * @returns {SKAction} - 
   * @desc When the action executes, the node’s position and zRotation properties are animated along the provided path. The duration of the action is determined by the length of the path and the speed of the node.This action is reversible; the resulting action creates a reversed path and then follows it, with the same speed.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417798-follow
   */


  static followAsOffsetOrientToPath(path, offset, orient, speed) {
    return null;
  } // Creating Actions That Rotate Nodes

  /**
   * Creates an action that rotates the node by a relative value.
   * @access public
   * @param {number} radians - The amount to rotate the node, in radians.
   * @param {number} sec - The duration of the animation.
   * @returns {SKAction} - 
   * @desc When the action executes, the node’s zRotation property animates to the new angle.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.rotate(byAngle: -radians, duration: sec)
  let action = SKAction.rotate(byAngle: -radians, duration: sec)
    * @see https://developer.apple.com/documentation/spritekit/skaction/1417805-rotate
   */


  static rotateByAngleDuration(radians, sec) {
    return null;
  }
  /**
   * Creates an action that rotates the node counterclockwise to an absolute angle.
   * @access public
   * @param {number} radians - The angle to rotate the node to, in radians.
   * @param {number} sec - The duration of the animation.
   * @returns {SKAction} - 
   * @desc When the action executes, the node’s zRotation property is interpolated to the new angle.This action is not reversible; the reverse of this action has the same duration but does not change anything.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417668-rotate
   */


  static rotateToAngleDuration(radians, sec) {
    return null;
  } // Creating Actions That Change a Node’s Animation Speed

  /**
   * Creates an action that changes how fast the node executes actions by a relative value.
   * @access public
   * @param {number} speed - The amount to add to the node’s speed.
   * @param {number} sec - The duration of the animation.
   * @returns {SKAction} - 
   * @desc When the action executes, the node’s speed property animates to the new value.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.speed(by: -speed, duration: sec)
  let action = SKAction.speed(by: -speed, duration: sec)
    * @see https://developer.apple.com/documentation/spritekit/skaction/1417690-speed
   */


  static speedByDuration(speed, sec) {
    return null;
  }
  /**
   * Creates an action that changes how fast the node executes actions.
   * @access public
   * @param {number} speed - The new value for the node’s speed.
   * @param {number} sec - The duration of the animation.
   * @returns {SKAction} - 
   * @desc When the action executes, the node’s speed property animates to the new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417684-speed
   */


  static speedToDuration(speed, sec) {
    return null;
  } // Creating Actions That Change a Node’s Scale

  /**
   * Creates an action that changes the x and y scale values of a node by a relative value.
   * @access public
   * @param {number} scale - The amount to add to the node’s x and y scale values.
   * @param {number} sec - The duration of the animation.
   * @returns {SKAction} - 
   * @desc When the action executes, the node’s xScale and yScale properties are animated to the new value.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.scale(by: -scale, duration: sec)
  let action = SKAction.scale(by: -scale, duration: sec)
    * @see https://developer.apple.com/documentation/spritekit/skaction/1417741-scale
   */


  static scaleByDuration(scale, sec) {
    return null;
  }
  /**
   * Creates an action that changes the x and y scale values of a node to achieve 
   * @access public
   * @param {CGSize} size - The new size of the node.
   * @param {number} sec - The duration of the animation.
   * @returns {SKAction} - 
   * @desc When the action executes, the node’s xScale and yScale properties are animated to achieve the specified size in its parent's coordinate space. This action is not reversible; the reverse of this action has the same duration but does not change anything.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1643619-scale
   */


  static scaleToDuration(size, sec) {
    return null;
  }
  /**
   * Creates an action that adds relative values to the x and y scale values of a node.
   * @access public
   * @param {number} xScale - The amount to add to the node’s x scale value.
   * @param {number} yScale - The amount to add to the node’s y scale value.
   * @param {number} sec - The duration of the animation.
   * @returns {SKAction} - 
   * @desc When the action executes, the node’s xScale and yScale properties are animated to the new value.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.scaleX(by: -scaleX, y: -scaleY, duration: sec)
  let action = SKAction.scaleX(by: -scaleX, y: -scaleY, duration: sec)
    * @see https://developer.apple.com/documentation/spritekit/skaction/1417796-scalex
   */


  static scaleXByYDuration(xScale, yScale, sec) {
    return null;
  }
  /**
   * Creates an action that changes the x and y scale values of a node.
   * @access public
   * @param {number} xScale - The new value for the node’s x scale value.
   * @param {number} yScale - The new value for the node’s y scale value.
   * @param {number} sec - The duration of the animation.
   * @returns {SKAction} - 
   * @desc When the action executes, the node’s xScale and yScale properties are animated to the new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417728-scalex
   */


  static scaleXToYDuration(xScale, yScale, sec) {
    return null;
  }
  /**
   * Creates an action that changes the x scale value of a node to a new value.
   * @access public
   * @param {number} scale - The new value for the node’s x scale value.
   * @param {number} sec - The duration of the animation.
   * @returns {SKAction} - 
   * @desc When the action executes, the node’s xScale property animates to the new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417699-scalex
   */


  static scaleXToDuration(scale, sec) {
    return null;
  }
  /**
   * Creates an action that changes the y scale value of a node to a new value.
   * @access public
   * @param {number} scale - The new value for the node’s y scale value.
   * @param {number} sec - The duration of the animation.
   * @returns {SKAction} - 
   * @desc When the action executes, the node’s yScale property animates to the new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417708-scaley
   */


  static scaleYToDuration(scale, sec) {
    return null;
  } // Creating Actions to Show or Hide a Node

  /**
   * Creates an action that makes a node visible.
   * @access public
   * @returns {SKAction} - 
   * @desc This action has an instantaneous duration. When the action executes, the node’s isHidden property is set to false.This action is reversible; the reversed action hides the node.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417660-unhide
   */


  static unhide() {
    return null;
  }
  /**
   * Creates an action that hides a node.
   * @access public
   * @returns {SKAction} - 
   * @desc This action has an instantaneous duration. When the action executes, the node’s isHidden property is set to true.This action is reversible; the reversed action shows the node.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417704-hide
   */


  static hide() {
    return null;
  } // Creating Actions That Change a Node’s Transparency

  /**
   * Creates an action that changes the alpha value of the node to 1.0.
   * @access public
   * @param {number} sec - The duration of the animation.
   * @returns {SKAction} - 
   * @desc When the action executes, the node’s alpha property animates from its current value to 1.0.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.fadeOut(withDuration: sec)
  let action = SKAction.fadeOut(withDuration: sec)
    * @see https://developer.apple.com/documentation/spritekit/skaction/1417818-fadein
   */


  static fadeInWithDuration(sec) {
    return null;
  }
  /**
   * Creates an action that changes the alpha value of the node to 0.0.
   * @access public
   * @param {number} sec - The duration of the animation.
   * @returns {SKAction} - 
   * @desc When the action executes, the node’s alpha property animates from its current value to 0.0. This causes the node to disappear.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.fadeIn(withDuration: sec)
  let action = SKAction.fadeIn(withDuration: sec)
    * @see https://developer.apple.com/documentation/spritekit/skaction/1417738-fadeout
   */


  static fadeOutWithDuration(sec) {
    return null;
  }
  /**
   * Creates an action that adjusts the alpha value of a node by a relative value.
   * @access public
   * @param {number} factor - The amount to add to the node’s alpha value.
   * @param {number} sec - The duration of the animation.
   * @returns {SKAction} - 
   * @desc When the action executes, the node’s alpha property animates to its new value.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.fadeAlpha(by: -factor, duration: sec)
  let action = SKAction.fadeAlpha(by: -factor, duration: sec)
    * @see https://developer.apple.com/documentation/spritekit/skaction/1417716-fadealpha
   */


  static fadeAlphaByDuration(factor, sec) {
    return null;
  }
  /**
   * Creates an action that adjusts the alpha value of a node to a new value.
   * @access public
   * @param {number} alpha - The new value of the node’s alpha.
   * @param {number} sec - The duration of the animation.
   * @returns {SKAction} - 
   * @desc When the action executes, the node’s alpha property animates to its new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417673-fadealpha
   */


  static fadeAlphaToDuration(alpha, sec) {
    return null;
  } // Creating Actions That Change a Sprite Node’s Content

  /**
   * Creates an action that adjusts the size of a sprite.
   * @access public
   * @param {number} width - The amount to add to the sprite’s width.
   * @param {number} height - The amount to add to the sprite’s height.
   * @param {number} duration - The duration of the animation.
   * @returns {SKAction} - 
   * @desc This action can only be executed by a SKSpriteNode object. When the action executes, the sprite’s size property animates to its new value.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.resize(byWidth: -width, height: -height, duration: sec)
  let action = SKAction.resize(byWidth: -width, height: -height, duration: sec)
    * @see https://developer.apple.com/documentation/spritekit/skaction/1417812-resize
   */


  static resizeByWidth(width, height, duration) {
    return null;
  }
  /**
   * Creates an action that changes the height of a sprite to a new absolute value.
   * @access public
   * @param {number} height - The new height of the sprite.
   * @param {number} duration - The duration of the animation.
   * @returns {SKAction} - 
   * @desc This action can only be executed by an SKSpriteNode object. When the action executes, the sprite’s size property animates to its new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417825-resize
   */


  static resizeToHeight(height, duration) {
    return null;
  }
  /**
   * Creates an action that changes the width of a sprite to a new absolute value.
   * @access public
   * @param {number} width - The new width of the sprite.
   * @param {number} duration - The duration of the animation.
   * @returns {SKAction} - 
   * @desc This action can only be executed by an SKSpriteNode object. When the action executes, the sprite’s size property animates to its new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417686-resize
   */


  static resizeToWidth(width, duration) {
    return null;
  }
  /**
   * Creates an action that changes a sprite’s texture.
   * @access public
   * @param {SKTexture} texture - The new texture to use on the sprite.
   * @returns {SKAction} - 
   * @desc This action can only be executed by an SKSpriteNode object. When the action executes, the sprite’s texture property changes immediately to the new texture.This action is not reversible; the reverse of this action does nothing.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417784-settexture
   */


  static setTexture(texture) {
    return null;
  }
  /**
   * Creates an action that animates changes to a sprite’s texture.
   * @access public
   * @param {SKTexture[]} textures - An array of textures to use when animating a sprite.
   * @param {number} sec - The duration, in seconds, that each texture is displayed. 
   * @returns {SKAction} - 
   * @desc This action can only be executed by an SKSpriteNode object. When the action executes, the sprite’s texture property animates through the array of textures. The sprite’s texture property is changed to the next texture in the array. The action then pauses for the specified time before continuing. The action continues until it has finished animating through all of the textures in the array. The total duration of the action is the number of textures multiplied by the frame interval.This action is reversible; the resulting action animates through the same textures from last to first.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417828-animate
   */


  static animateWithTimePerFrame(textures, sec) {
    return null;
  }
  /**
   * Creates an action that changes a sprite’s normal texture.
   * @access public
   * @param {SKTexture} texture - The new texture to use on the sprite.
   * @returns {SKAction} - 
   * @desc This action can only be executed by an SKSpriteNode object. When the action executes, the sprite’s normalTexture property changes immediately to the new texture.This action is not reversible; the reverse of this action does nothing.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417706-setnormaltexture
   */


  static setNormalTexture(texture) {
    return null;
  }
  /**
   * Creates an action that animates changes to a sprite’s normal texture.
   * @access public
   * @param {SKTexture[]} textures - An array of textures to use.
   * @param {number} sec - The amount of time that each texture is displayed.
   * @returns {SKAction} - 
   * @desc This action can only be executed by an SKSpriteNode object. When the action executes, the sprite’s normalTexture property animates through the array of textures. The sprite’s normalTexture property is changed to the next texture in the array. The action then pauses for the specified time before continuing. The action continues until it has finished animating through all of the textures in the array. The total duration of the action is the number of textures multiplied by the frame interval.This action is reversible; the resulting action animates through the same textures from last to first.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417746-animate
   */


  static animateWithNormalTexturesTimePerFrame(textures, sec) {
    return null;
  }
  /**
   * Creates an animation that animates a sprite’s color and blend factor.
   * @access public
   * @param {CGColor} color - The new color for the sprite.
   * @param {number} colorBlendFactor - The new blend factor for the sprite.
   * @param {number} sec - The duration of the animation.
   * @returns {SKAction} - 
   * @desc This action can only be executed by an SKSpriteNode object. When the action executes, the sprite’s color and colorBlendFactor properties are animated to their new values.This action is not reversible; the reverse of this action does nothing.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417678-colorize
   */


  static colorizeWithDuration(color, colorBlendFactor, sec) {
    return null;
  } // Creating Physics Actions

  /**
   * Creates an action that applies a force to the center of gravity of a node’s physics body.
   * @access public
   * @param {CGVector} force - A vector that describes how much force is applied in each dimension. The force is measured in Newtons.
   * @param {number} sec - The duration over which the force is applied to the physics body.
   * @returns {SKAction} - 
   * @desc When the action executes, the force is applied continuously to the physics body for the duration of the action. This action accelerates the body without imparting any angular acceleration to it.This action is reversible; it applies an equal force in the opposite direction.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417782-applyforce
   */


  static applyForceDuration(force, sec) {
    return null;
  }
  /**
   * Creates an action that applies a torque to an node’s physics body.
   * @access public
   * @param {number} torque - The amount of torque, in Newton-meters.
   * @param {number} sec - The duration over which the torque is applied to the physics body.
   * @returns {SKAction} - 
   * @desc When the action executes, the torque is applied continuously to the physics body for the duration of the action. This action generates an angular acceleration on the body without causing any linear acceleration.This action is reversible; it applies an equal torque in the opposite direction.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417756-applytorque
   */


  static applyTorqueDuration(torque, sec) {
    return null;
  }
  /**
   * Creates an action that applies an force to a specific point on a node’s physics body.
   * @access public
   * @param {CGVector} force - A vector that describes how much force is applied in each dimension. The force is measured in Newtons.
   * @param {CGPoint} point - A point in scene coordinates that defines where the force is applied to the physics body.
   * @param {number} sec - The duration over which the force is applied to the physics body.
   * @returns {SKAction} - 
   * @desc When the action executes, the force is applied continuously to the physics body for the duration of the action. Because the force is applied to a specific point on the body, it may impart both linear acceleration and angular acceleration. This action is reversible; it applies an equal force in the opposite direction.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417823-applyforce
   */


  static applyForceAtDuration(force, point, sec) {
    return null;
  }
  /**
   * Creates an action that applies an impulse to the center of gravity of a physics body.
   * @access public
   * @param {CGVector} impulse - A vector that describes how much momentum to impart to the body in each dimension over the duration of the action. The impulse is measured in Newton-seconds.
   * @param {number} sec - The duration over which the total impulse should be applied to the physics body.
   * @returns {SKAction} - 
   * @desc When the action executes, applies a constant force to the physics body for the duration of the action. The force is calculated by dividing the impulse strength by the duration of the action. For example, if an impulse of 1 Newton-second is applied to the physics body, and the the duration is 10 seconds, then a force of 0.1 Newtons is applied to the physics body.This action is reversible; it applies an equal impulse in the opposite direction.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417770-applyimpulse
   */


  static applyImpulseDuration(impulse, sec) {
    return null;
  }
  /**
   * Creates an action that applies an angular impulse to a node’s physics body.
   * @access public
   * @param {number} impulse - The total impulse to apply to the physics body. The impulse is measured in Newton-seconds.
   * @param {number} sec - The number of seconds over which to apply the impulse. For example, if you specify a duration of four seconds, one quarter of the impulse will be applied each second.
   * @returns {SKAction} - 
   * @desc When the action executes, applies a constant torque to the physics body for the duration of the action. The torque is calculated by dividing the impulse strength by the duration of the action. This action affects the body’s angular velocity without changing the body’s linear velocity.This action is reversible; it applies an equal angular impulse in the opposite direction.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417775-applyangularimpulse
   */


  static applyAngularImpulseDuration(impulse, sec) {
    return null;
  }
  /**
   * Creates an action that applies an impulse to a specific point of a node’s physics body.
   * @access public
   * @param {CGVector} impulse - The total impulse to apply to the physics body. The impulse is measured in Newton-seconds.
   * @param {CGPoint} point - A point in scene coordinates that defines where the impulse was applied to the physics body.
   * @param {number} sec - A new action object.
   * @returns {SKAction} - 
   * @desc When the action executes, applies a constant force to the physics body for the duration of the action. The force is calculated by dividing the impulse strength by the duration of the action. For example, if an impulse of 1 Newton-second is applied to the physics body, and the the duration is 10 seconds, then a force of 0.1 Newtons is applied to the physics body. Because the force is applied to a specific point on the body, it may impart both linear acceleration and angular acceleration.This action is reversible; it applies an equal impulse in the opposite direction.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417732-applyimpulse
   */


  static applyImpulseAtDuration(impulse, point, sec) {
    return null;
  }
  /**
   * Creates an action that changes the charge of a node’s physics body to a new value.
   * @access public
   * @param {number} v - The new charge of the physics body.
   * @param {number} duration - The duration of the animation.
   * @returns {SKAction} - 
   * @desc When the action executes, the physics body’s charge property animates from its current value to its new value.This action is not reversible.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417752-changecharge
   */


  static changeChargeTo(v, duration) {
    return null;
  }
  /**
   * Creates an action that changes the charge of a node’s physics body by a relative value.
   * @access public
   * @param {number} v - The amount to add to the physics body’s charge.
   * @param {number} duration - The duration of the animation.
   * @returns {SKAction} - 
   * @desc When the action executes, the physics body’s charge property animates from its current value to its new value.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.changeCharge(by: -v, duration: sec)
  let action = SKAction.changeCharge(by: -v, duration: sec)
    * @see https://developer.apple.com/documentation/spritekit/skaction/1417714-changecharge
   */


  static changeChargeBy(v, duration) {
    return null;
  }
  /**
   * Creates an action that changes the mass of a node’s physics body to a new value.
   * @access public
   * @param {number} v - The new mass of the physics body.
   * @param {number} duration - The duration of the animation.
   * @returns {SKAction} - 
   * @desc When the action executes, the physics body’s mass property animates from its current value to its new value.This action is not reversible.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417780-changemass
   */


  static changeMassTo(v, duration) {
    return null;
  }
  /**
   * Creates an action that changes the mass of a node’s physics body by a relative value.
   * @access public
   * @param {number} v - The amount to add to the physics body’s mass.
   * @param {number} duration - The duration of the animation.
   * @returns {SKAction} - 
   * @desc When the action executes, the physics body’s mass property animates from its current value to its new value.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.changeMass(by: -v, duration: sec)
  let action = SKAction.changeMass(by: -v, duration: sec)
    * @see https://developer.apple.com/documentation/spritekit/skaction/1417710-changemass
   */


  static changeMassBy(v, duration) {
    return null;
  }
  /**
   * Creates an action that animates a change of a physics field’s strength.
   * @access public
   * @param {number} strength - The new strength for the field.
   * @param {number} sec - The duration of the animation.
   * @returns {SKAction} - 
   * @desc When the action executes, the field node’s strength property animates from its current value to its new value.This action is not reversible; the reverse of this action has the same duration but does not do anything.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417815-strength
   */


  static strengthToDuration(strength, sec) {
    return null;
  }
  /**
   * Creates an action that animates a change of a physics field’s strength to a value relative to the existing value.
   * @access public
   * @param {number} strength - The value to add to the field.
   * @param {number} sec - The duration of the animation.
   * @returns {SKAction} - 
   * @desc When the action executes, the field node’s strength property animates from its current value to its new value.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.strength(by: -strength, duration: sec)
  let action = SKAction.strength(by: -strength, duration: sec)
    * @see https://developer.apple.com/documentation/spritekit/skaction/1417762-strength
   */


  static strengthByDuration(strength, sec) {
    return null;
  }
  /**
   * Creates an action that animates a change of a physics field’s falloff.
   * @access public
   * @param {number} falloff - The new falloff for the field.
   * @param {number} sec - The duration of the animation, in seconds.
   * @returns {SKAction} - 
   * @desc When the action runs, the field node’s falloff property animates from its current value to its new value. This action is not reversible.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417758-falloff
   */


  static falloffToDuration(falloff, sec) {
    return null;
  }
  /**
   * Creates an action that animates a change of a physics field’s falloff to a value relative to the existing value.
   * @access public
   * @param {number} falloff - The value to add to the falloff.
   * @param {number} sec - The duration of the animation, in seconds.
   * @returns {SKAction} - 
   * @desc When the action executes, the field node’s falloff property animates from its current value to its new value.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.falloff(by: -falloff, duration: sec)
  let action = SKAction.falloff(by: -falloff, duration: sec)
    * @see https://developer.apple.com/documentation/spritekit/skaction/1417766-falloff
   */


  static falloffByDuration(falloff, sec) {
    return null;
  } // Creating Actions to Warp a Node

  /**
   * Creates an action to distort a node through a sequence of SKWarpGeometry objects.  
   * @access public
   * @param {SKWarpGeometry[]} warps - The sequence of warps to apply to the node.
   * @param {number[]} times - The times at which each warp distortion in the sequence should complete.
   * @returns {?SKAction} - 
   * @desc The numberOfColumns and numberOfRows in each geometry in the sequence should match.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1690937-animate
   */


  static animateWithWarps(warps, times) {
    return null;
  }
  /**
   * Creates an action to distort a node based using an SKWarpGeometry object.  
   * @access public
   * @param {SKWarpGeometry} warp - The warp geometry to distort the node to.
   * @param {number} duration - The duration of the animation.
   * @returns {?SKAction} - 
   * @desc The numberOfColumns and numberOfRows in the node's current geometry should match those of the specified geometry.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1690951-warp
   */


  static warpTo(warp, duration) {
    return null;
  } // Creating Audio Actions

  /**
   * Creates an action that plays a sound.
   * @access public
   * @param {string} soundFile - The name of a sound file in the app’s bundle.
   * @param {boolean} wait - If true, the duration of this action is the same as the length of the audio playback. If false, the action is considered to have completed immediately.
   * @returns {SKAction} - 
   * @desc Use SKAction playSoundFileNamed:waitForCompletion: only for short incidentals. Use AVAudioPlayer for long running background music. This action is not reversible; the reversed action is identical to the original action.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417664-playsoundfilenamed
   */


  static playSoundFileNamedWaitForCompletion(soundFile, wait) {
    return null;
  }
  /**
   * Creates an action that tells an audio node to start playback.
   * @access public
   * @returns {SKAction} - 
   * @desc This action may only be executed on an SKAudioNode object.This action is not reversible.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417730-play
   */


  static play() {
    return null;
  }
  /**
   * Creates an action that tells an audio node to pause playback.
   * @access public
   * @returns {SKAction} - 
   * @desc This action may only be executed on an SKAudioNode object. The audio is paused, and if restarted, resumes at where it was paused.This action is not reversible.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417820-pause
   */


  static pause() {
    return null;
  }
  /**
   * Creates an action that tells an audio node to stop playback.
   * @access public
   * @returns {SKAction} - 
   * @desc This action may only be executed on an SKAudioNode object. The audio is stopped, and if restarted, begins at the beginning.This action is not reversible.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417794-stop
   */


  static stop() {
    return null;
  }
  /**
   * Creates an action that changes an audio node’s playback rate to a new value.
   * @access public
   * @param {number} v - The new value for the playback rate. A playback rate of 1.0 represents normal speed.
   * @param {number} duration - The duration of the animation, in seconds.
   * @returns {SKAction} - 
   * @desc When the action executes, the audio node’s playback rate animates from its current value to its new value. For more information, see AVAudio3DMixing.This action is not reversible.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417808-changeplaybackrate
   */


  static changePlaybackRateTo(v, duration) {
    return null;
  }
  /**
   * Creates an action that changes an audio node’s playback rate by a relative amount.
   * @access public
   * @param {number} v - The amount to change the playback rate by. A playback rate of 1.0 represents normal speed.
   * @param {number} duration - The duration of the animation, in seconds.
   * @returns {SKAction} - 
   * @desc When the action executes, the audio node’s playback rate animates from its current value to its new value. For more information, see AVAudio3DMixing.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.changePlaybackRate(by: -v, duration: sec)
  let action = SKAction.changePlaybackRate(by: -v, duration: sec)
    * @see https://developer.apple.com/documentation/spritekit/skaction/1417670-changeplaybackrate
   */


  static changePlaybackRateBy(v, duration) {
    return null;
  }
  /**
   * Creates an action that changes an audio node’s volume to a new value.
   * @access public
   * @param {number} v - The new value for the volume. The value should be between 0.0 (silence) and 1.0 (maximum value for source audio), inclusive. 
   * @param {number} duration - The duration of the animation, in seconds.
   * @returns {SKAction} - 
   * @desc When the action executes, the audio node’s volume animates from its current value to its new value. For more information, see AVAudio3DMixing.This action is not reversible.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417682-changevolume
   */


  static changeVolumeTo(v, duration) {
    return null;
  }
  /**
   * Creates an action that changes an audio node’s volume by a relative value.
   * @access public
   * @param {number} v - The amount to change the volume by. 
   * @param {number} duration - The duration of the animation, in seconds.
   * @returns {SKAction} - 
   * @desc When the action executes, the audio node’s volume animates from its current value to its new value. For more information, see AVAudio3DMixing.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.changeVolume(by: -v, duration: sec)
  let action = SKAction.changeVolume(by: -v, duration: sec)
    * @see https://developer.apple.com/documentation/spritekit/skaction/1417726-changevolume
   */


  static changeVolumeBy(v, duration) {
    return null;
  }
  /**
   * Creates an action that changes an audio node’s obstruction to a new value.
   * @access public
   * @param {number} v - The new value for the obstruction, in decibels.
   * @param {number} duration - The duration of the animation, in seconds.
   * @returns {SKAction} - 
   * @desc When the action executes, the audio node’s obstruction animates from its current value to its new value. Passing this action a value of -100 yields the greatest reduction in volume. For more information, see AVAudio3DMixing.This action is not reversible.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1519718-changeobstruction
   */


  static changeObstructionTo(v, duration) {
    return null;
  }
  /**
   * Creates an action that changes an audio node’s obstruction by a relative value.
   * @access public
   * @param {number} v - The amount to change the obstruction by, in decibels.
   * @param {number} duration - The duration of the animation, in seconds.
   * @returns {SKAction} - 
   * @desc When the action executes, the audio node’s obstruction animates from its current value to its new value. For more information, see AVAudio3DMixing.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.changeObstruction(by: -v, duration: sec)
  let action = SKAction.changeObstruction(by: -v, duration: sec)
    * @see https://developer.apple.com/documentation/spritekit/skaction/1520346-changeobstruction
   */


  static changeObstructionBy(v, duration) {
    return null;
  }
  /**
   * Creates an action that changes an audio node’s occlusion to a new value.
   * @access public
   * @param {number} v - The new value for the occlusion, in decibels.
   * @param {number} duration - The duration of the animation, in seconds.
   * @returns {SKAction} - 
   * @desc When the action executes, the audio node’s occlusion animates from its current value to its new value. Passing this action a value of -100 yields the greatest reduction in volume. For more information, see AVAudio3DMixing.This action is not reversible.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1520433-changeocclusion
   */


  static changeOcclusionTo(v, duration) {
    return null;
  }
  /**
   * Creates an action that changes an audio node’s occlusion by a relative value.
   * @access public
   * @param {number} v - The amount to change the occlusion by, in decibels.
   * @param {number} duration - The duration of the animation, in seconds.
   * @returns {SKAction} - 
   * @desc When the action executes, the audio node’s occlusion animates from its current value to its new value. For more information, see AVAudio3DMixing.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.changeOcclusion(by: -v, duration: sec)
  let action = SKAction.changeOcclusion(by: -v, duration: sec)
    * @see https://developer.apple.com/documentation/spritekit/skaction/1520117-changeocclusion
   */


  static changeOcclusionBy(v, duration) {
    return null;
  }
  /**
   * Creates an action that changes an audio node’s reverb to a new value.
   * @access public
   * @param {number} v - The new value for the reverb. The value should be between 0.0 and 1.0, inclusive.
   * @param {number} duration - The duration of the animation, in seconds.
   * @returns {SKAction} - 
   * @desc When the action executes, the audio node’s reverb animates from its current value to its new value. For more information, see AVAudio3DMixing.This action is not reversible.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1520320-changereverb
   */


  static changeReverbTo(v, duration) {
    return null;
  }
  /**
   * Creates an action that changes an audio node’s reverb by a relative value.
   * @access public
   * @param {number} v - The amount to change the reverb by.
   * @param {number} duration - The duration of the animation, in seconds.
   * @returns {SKAction} - 
   * @desc When the action executes, the audio node’s reverb animates from its current value to its new value. For more information, see AVAudio3DMixing.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.changeReverb(by: -v, duration: sec)
  let action = SKAction.changeReverb(by: -v, duration: sec)
    * @see https://developer.apple.com/documentation/spritekit/skaction/1519568-changereverb
   */


  static changeReverbBy(v, duration) {
    return null;
  }
  /**
   * Creates an action that changes an audio node’s stereo panning to a new value.
   * @access public
   * @param {number} v - The new value for stereo panning. The value must between -1.0 (left channel only) and 1.0 (right channel only), inclusive.
   * @param {number} duration - The duration of the animation, in seconds.
   * @returns {SKAction} - 
   * @desc When the action executes, the audio node’s stereo panning animates from its current value to its new value. For more information, see AVAudio3DMixing.This action is not reversible.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1519976-stereopan
   */


  static stereoPanTo(v, duration) {
    return null;
  }
  /**
   * Creates an action that changes an audio node’s stereo panning by a relative value.
   * @access public
   * @param {number} v - The amount to change the stereo panning by. 
   * @param {number} duration - The duration of the animation, in seconds.
   * @returns {SKAction} - 
   * @desc When the action executes, the audio node’s stereo panning animates from its current value to its new value. For more information, see AVAudio3DMixing.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.stereoPan(by: -v, duration: sec)
  let action = SKAction.stereoPan(by: -v, duration: sec)
    * @see https://developer.apple.com/documentation/spritekit/skaction/1519713-stereopan
   */


  static stereoPanBy(v, duration) {
    return null;
  } // Removing Nodes from the Scene

  /**
   * Creates an action that removes the node from its parent.
   * @access public
   * @returns {SKAction} - 
   * @desc When the action executes, the node is immediately removed from its parent.This action is not reversible; the reverse of this action is the same action.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417748-removefromparent
   */


  static removeFromParent() {
    return null;
  } // Creating Actions That Perform Actions on a Node’s Child

  /**
   * Creates an action that runs an action on a named child object.
   * @access public
   * @param {SKAction} action - The action to execute.
   * @param {string} name - The name of a child object. See the name property on the SKNode object.
   * @returns {SKAction} - 
   * @desc This action has an instantaneous duration, although the action executed on the child may have a duration of its own. When the action executes, it looks up an appropriate child node and calls its run(_:) method, passing in the action to execute. This action is reversible; it tells the child to execute the reverse of the action specified by the action parameter.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417671-run
   */


  static runOnChildWithName(action, name) {
    return null;
  } // Creating Actions That Combine or Repeat Other Actions

  /**
   * Creates an action that runs a collection of actions in parallel.
   * @access public
   * @param {SKAction[]} actions - An array of SKAction objects.
   * @returns {SKAction} - 
   * @desc When the action executes, the actions that comprise the group all start immediately and run in parallel. The duration of the group action is the longest duration among the collection of actions. If an action in the group has a duration less than the group’s duration, the action completes, then idles until the group completes the remaining actions. This matters most when creating a repeating action that repeats a group.This action is reversible; it creates a new group action that contains the reverse of each action specified in the group. 
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417688-group
   */


  static group(actions) {
    return null;
  }
  /**
   * Creates an action that runs a collection of actions sequentially.
   * @access public
   * @param {SKAction[]} actions - An array of SKAction objects.
   * @returns {SKAction} - 
   * @desc When the action executes, the first action in the sequence starts and runs to completion. Subsequent actions in the sequence run in a similar fashion until all of the actions in the sequence have executed. The duration of the sequence action is the sum of the durations of the actions in the sequence.This action is reversible; it creates a new sequence action that reverses the order of the actions. Each action in the reversed sequence is itself reversed. For example, if an action sequence is {1,2,3}, the reversed sequence would be {3R,2R,1R}.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417817-sequence
   */


  static sequence(actions) {
    return null;
  }
  /**
   * Creates an action that repeats another action a specified number of times.
   * @access public
   * @param {SKAction} action - The action to execute.
   * @param {number} count - The number of times to execute the action.
   * @returns {SKAction} - 
   * @desc When the action executes, the associated action runs to completion and then repeats, until the count is reached.This action is reversible; it creates a new action that is the reverse of the specified action and then repeats it the same number of times.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417750-repeat
   */


  static repeat(action, count) {
    return null;
  }
  /**
   * Creates an action that repeats another action forever.
   * @access public
   * @param {SKAction} action - The action to execute.
   * @returns {SKAction} - 
   * @desc When the action executes, the associated action runs to completion and then repeats.This action is reversible; it creates a new action that is the reverse of the specified action and then repeats it forever.NoteThe action to be repeated must have a non-instantaneous duration.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417676-repeatforever
   */


  static repeatForever(action) {
    return null;
  } // Creating an Action to Introduce a Delay into a Sequence

  /**
   * Creates an action that idles for a specified period of time.
   * @access public
   * @param {number} sec - The amount of time to wait.
   * @returns {SKAction} - 
   * @desc When the action executes, the action waits for the specified amount of time, then ends. This is typically used as part of a sequence of actions to insert a delay between two other actions. You might also use it in conjunction with the run(_:completion:) method to trigger code that needs to run at a later time.This action is not reversible; the reverse of this action is the same action.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417788-wait
   */


  static waitForDuration(sec) {
    return null;
  }
  /**
   * Creates an action that idles for a randomized period of time.
   * @access public
   * @param {number} sec - The average amount of time to wait.
   * @param {number} durationRange - The range of possible values for the duration.
   * @returns {SKAction} - 
   * @desc When the action executes, the action waits for the specified amount of time, then ends. This is typically used as part of a sequence of actions to insert a delay between two other actions. However, you might also use it in conjunction with the run(_:completion:) method to trigger code that needs to run at a later time.Each time the action is executed, the action computes a new random value for the duration. The duration may vary in either direction by up to half of the value of the durationRange parameter.This action is not reversible; the reverse of this action is the same action.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417760-wait
   */


  static waitForDurationWithRange(sec, durationRange) {
    return null;
  } // Creating Actions to Perform Inverse Kinematic Calculations

  /**
   * Creates an action that performs an inverse kinematic reach.
   * @access public
   * @param {SKNode} node - The node whose position the current node should move closer to. 
   * @param {SKNode} root - The highest level ancestor of the target node that should be rotated.
   * @param {number} sec - The length of the animation.
   * @returns {SKAction} - 
   * @desc This action is typically used to implement character animation across a series of moving parts. When the action executes, it performs an inverse kinematic calculation to determine new rotation values for the target node and any of its ancestors up to and including the root node. Each node is rotated around its anchor point in an attempt to get the targeted node’s position closer to the intended destination. Each node’s rotation value is constrained by that node’s reachConstraints property. If the action cannot successfully reach the target position, it gets the node as close as it can to the target position.This action is not reversible; the reverse of this action is the same action.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417827-reach
   */


  static reachToRootNodeDuration(node, root, sec) {
    return null;
  }
  /**
   * Creates an action that performs an inverse kinematic reach.
   * @access public
   * @param {CGPoint} position - The intended destination for the node, specified in the scene’s coordinate system. 
   * @param {SKNode} root - The highest level ancestor of the target node that should be rotated.
   * @param {number} velocity - The maximum speed at which the node should move.
   * @returns {SKAction} - 
   * @desc This action is typically used to implement character animation across a series of moving parts. When the action executes, it performs an inverse kinematic calculation to determine new rotation values for the target node and any of its ancestors up to and including the root node. Each node is rotated around its anchor point in an attempt to get the targeted node’s position closer to the intended destination. Each node’s rotation value is constrained by that node’s reachConstraints property. If the action cannot successfully reach the target position, it gets the node as close as it can to the target position.The duration of the action is calculated implicitly based on the speed of movement and the distance that the node needs to travel.This action is not reversible; the reverse of this action is the same action.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417720-reach
   */


  static reachToRootNode(position, root, velocity) {
    return null;
  }
  /**
   * Creates an action that executes a block over a duration.
   * @access public
   * @param {number} seconds - The duration of the action, in seconds.
   * @param {function(arg1: SKNode, arg2: number): void} block - The block to run. The block takes the following parameters:nodeThe node on which the action is running.elapsedTimeThe amount of time that has passed in the animation.
   * @returns {SKAction} - 
   * @desc When the action executes, the block is called repeatedly until the action’s duration expires. The elapsed time is computed and passed to the block whenever the block is called.This action is not reversible; the reverse action executes the same block.The following code shows how you can create a custom action to update an attribute of an SKShader attached to a sprite node. let customAction = SKAction.customAction(withDuration: 2.0) {
    node, elapsedTime in
    
    if let node = node as? SKSpriteNode {
        node.setValue(SKAttributeValue(float: Float(elapsedTime)),
                                       forAttribute: "a_time")
    }
  }
  let customAction = SKAction.customAction(withDuration: 2.0) {
    node, elapsedTime in
    
    if let node = node as? SKSpriteNode {
        node.setValue(SKAttributeValue(float: Float(elapsedTime)),
                                       forAttribute: "a_time")
    }
  }
    * @see https://developer.apple.com/documentation/spritekit/skaction/1417745-customaction
   */


  static customActionWithDurationActionBlock(seconds, block) {
    return null;
  }
  /**
   * Creates an action that calls a method on an object.
   * @access public
   * @param {function} selector - The selector of the method to call.
   * @param {Object} target - The target object.
   * @returns {SKAction} - 
   * @desc The action object maintains a strong reference to the target object.When the action executes, the target object’s method is called. This action occurs instantaneously.This action is not reversible; the reverse of this action calls the selector again.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417764-perform
   */


  static performOnTarget(selector, target) {
    return null;
  }
  /**
   * Creates an action that executes a block.
   * @access public
   * @param {function(): void} block - The block to run.
   * @returns {SKAction} - 
   * @desc When the action executes, the block is called. This action takes place instantaneously.This action is not reversible; the reverse action executes the same block.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417692-run
   */


  static run(block) {
    return null;
  } // Reversing an Action

  /**
   * Creates an action that reverses the behavior of another action.
   * @access public
   * @returns {SKAction} - 
   * @desc This method always returns an action object; however, not all actions are reversible. When reversed, some actions return an object that either does nothing or that performs the same action as the original action. For details on how an action is reversed, see the description of the class method used to create that action.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417803-reversed
   */


  reversed() {
    return null;
  }

}

//import SKAttributeValue from './SKAttributeValue'

/**
 * A node that can apply Core Image filters or SKWarpGeometry distortions to its children.
 * @access public
 * @extends {SKNode}
 * @implements {SKWarpable}
 * @see https://developer.apple.com/documentation/spritekit/skeffectnode
 */

class SKEffectNode extends SKNode {
  /**
   * constructor
   * @access public
   * @constructor
   */
  constructor() {
    super(); // Enabling Filter Effects

    /**
     * A Boolean value that determines whether the effect node applies the filter to its children as they are drawn.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/spritekit/skeffectnode/1459385-shouldenableeffects
     */

    this.shouldEnableEffects = true; // Configuring the Filter

    /**
     * The Core Image filter to apply.
     * @type {?CIFilter}
     * @see https://developer.apple.com/documentation/spritekit/skeffectnode/1459392-filter
     */

    this.filter = null;
    /**
     * A Boolean value that determines whether the effect node automatically sets the filter’s image center.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/spritekit/skeffectnode/1459390-shouldcenterfilter
     */

    this.shouldCenterFilter = true; // Blending the Results to the Framebuffer

    /**
     * The blend mode used to draw the filtered image into the parent’s framebuffer.
     * @type {SKBlendMode}
     * @see https://developer.apple.com/documentation/spritekit/skeffectnode/1459386-blendmode
     */

    this.blendMode = SKBlendMode.alpha; // Working with Custom Shaders

    /**
     * A custom shader that is called when the effect node is blended into the parent’s framebuffer.
     * @type {?SKShader}
     * @see https://developer.apple.com/documentation/spritekit/skeffectnode/1459388-shader
     */

    this.shader = null;
    /**
     * The values of each attribute associated with the node's attached shader.
     * @type {Map<string, SKAttributeValue>}
     * @see https://developer.apple.com/documentation/spritekit/skeffectnode/2715848-attributevalues
     */

    this.attributeValues = new Map(); // Caching the Filter Results

    /**
     * A Boolean value that indicates whether the results of rendering the child nodes should be cached.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/spritekit/skeffectnode/1459381-shouldrasterize
     */

    this.shouldRasterize = false;
  } // Working with Custom Shaders

  /**
   * Sets an attribute value for an attached shader.
   * @access public
   * @param {SKAttributeValue} value - An attribute value object containing the scalar or vector value to set in the attached shader.
   * @param {string} key - The attribute name.
   * @returns {void}
   * @see https://developer.apple.com/documentation/spritekit/skeffectnode/2715853-setvalue
   */
  //setValueForAttribute(value, key) {
  //}

  /**
   * The value of a shader attribute.
   * @access public
   * @param {string} key - The attribute name.
   * @returns {?SKAttributeValue} - 
   * @see https://developer.apple.com/documentation/spritekit/skeffectnode/2715844-value
   */
  //valueForAttributeNamed(key) {
  //  return null
  //}


}

class SKFade extends SKAction {
  /**
   * constructor
   * @access public
   * @constructor
   */
  constructor() {
    super();
    this._actions = [];
    this._finished = false;
    this._duration = 0;
    this._timingMode = SKActionTimingMode.linear;
    this._beginTime = 0;
    this._isRunning = false;
    this._pausedTime = 0;
    this._toValue = null;
    this._byValue = null;
  }
  /**
   * Creates an action that changes the alpha value of the node to 1.0.
   * @access public
   * @param {number} sec - The duration of the animation.
   * @returns {SKAction} - 
   * @desc When the action executes, the node’s alpha property animates from its current value to 1.0.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.fadeOut(withDuration: sec)
  let action = SKAction.fadeOut(withDuration: sec)
    * @see https://developer.apple.com/documentation/spritekit/skaction/1417818-fadein
   */


  static fadeInWithDuration(sec) {
    const action = new SKFade();
    action._toValue = 1;
    action._duration = sec;
    return action;
  }
  /**
   * Creates an action that changes the alpha value of the node to 0.0.
   * @access public
   * @param {number} sec - The duration of the animation.
   * @returns {SKAction} - 
   * @desc When the action executes, the node’s alpha property animates from its current value to 0.0. This causes the node to disappear.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.fadeIn(withDuration: sec)
  let action = SKAction.fadeIn(withDuration: sec)
    * @see https://developer.apple.com/documentation/spritekit/skaction/1417738-fadeout
   */


  static fadeOutWithDuration(sec) {
    const action = new SKFade();
    action._toValue = 0;
    action._duration = sec;
    return action;
  }
  /**
   * Creates an action that adjusts the alpha value of a node by a relative value.
   * @access public
   * @param {number} factor - The amount to add to the node’s alpha value.
   * @param {number} sec - The duration of the animation.
   * @returns {SKAction} - 
   * @desc When the action executes, the node’s alpha property animates to its new value.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.fadeAlpha(by: -factor, duration: sec)
  let action = SKAction.fadeAlpha(by: -factor, duration: sec)
    * @see https://developer.apple.com/documentation/spritekit/skaction/1417716-fadealpha
   */


  static fadeAlphaByDuration(factor, sec) {
    const action = new SKFade();
    action._byValue = factor;
    action._duration = sec;
    return action;
  }
  /**
   * Creates an action that adjusts the alpha value of a node to a new value.
   * @access public
   * @param {number} alpha - The new value of the node’s alpha.
   * @param {number} sec - The duration of the animation.
   * @returns {SKAction} - 
   * @desc When the action executes, the node’s alpha property animates to its new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417673-fadealpha
   */


  static fadeAlphaToDuration(alpha, sec) {
    const action = new SKFade();
    action._toValue = alpha;
    action._duration = sec;
    return action;
  }
  /**
   * @access public
   * @returns {SCNActionFade} -
   */


  copy() {
    const action = super.copy();
    action._toValue = this._toValue;
    action._byValue = this._byValue;
    action._duration = this._duration;
    return action;
  }
  /**
   * apply action to the given node.
   * @access private
   * @param {Object} obj - target object to apply this action.
   * @param {number} time - active time
   * @param {boolean} [needTimeConversion = true] -
   * @returns {void}
   */


  _applyAction(obj, time, needTimeConversion = true) {
    const t = this._getTime(time, needTimeConversion);

    if (!(obj instanceof SKNode)) {
      throw new Error(`unsupported class for SKFade: ${obj.constructor.name}`);
    }

    const baseValue = obj.alpha;
    let toValue = 0;

    if (this._toValue !== null) {
      toValue = this._toValue;
    } else if (this._byValue !== null) {
      toValue = baseValue + this._byValue;
    } else {
      throw new Error('both toValue and byValue are null');
    }

    const value = this._lerp(baseValue, toValue, t);

    obj._presentation.alpha = value;

    if (this._finished) {
      obj.alpha = toValue;
    }
  }

}
SKAction.fadeInWithDuration = SKFade.fadeInWithDuration;
SKAction.fadeOutWithDuration = SKFade.fadeOutWithDuration;
SKAction.fadeAlphaByDuration = SKFade.fadeAlphaByDuration;
SKAction.fadeAlphaToDuration = SKFade.fadeAlphaToDuration;

//import SKNode from './SKNode'

class SKGroup extends SKAction {
  /**
   * constructor
   * @access public
   * @constructor
   */
  constructor() {
    super();
    this._actions = [];
  }
  /**
   * Creates an action that runs a collection of actions in parallel.
   * @access public
   * @param {SKAction[]} actions - An array of SKAction objects.
   * @returns {SKAction} - 
   * @desc When the action executes, the actions that comprise the group all start immediately and run in parallel. The duration of the group action is the longest duration among the collection of actions. If an action in the group has a duration less than the group’s duration, the action completes, then idles until the group completes the remaining actions. This matters most when creating a repeating action that repeats a group.This action is reversible; it creates a new group action that contains the reverse of each action specified in the group. 
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417688-group
   */


  static group(actions) {
    const action = new SKGroup();
    action._actions = actions;
    return action;
  }
  /**
   * @access public
   * @returns {SCNActionFade} -
   */


  copy() {
    const action = super.copy();
    action._actions = [];

    this._actions.forEach(act => {
      action._actions.push(act.copy());
    });

    return action;
  }

  get duration() {
    let d = 0;

    this._actions.forEach(act => {
      if (d < act.duration) {
        d = act.duration;
      }
    });

    return d;
  }
  /**
   * apply action to the given node.
   * @access private
   * @param {Object} obj - target object to apply this action.
   * @param {number} time - active time
   * @param {boolean} [needTimeConversion = true] -
   * @returns {void}
   */


  _applyAction(obj, time, needTimeConversion = true) {
    const duration = this._activetimeFromTime(time);

    let finished = true;

    this._actions.forEach(action => {
      if (!action._finished) {
        action._applyAction(obj, duration, needTimeConversion);

        if (!action._finished) {
          finished = false;
        }
      }
    });

    this._finished = finished;
  }

  _resetFinished() {
    this._actions.forEach(action => {
      action._resetFinished();
    });

    this._finished = false;
  }

}
SKAction.group = SKGroup.group;

/**
 * Options for aligning text horizontally.
 * @typedef {Object} SKLabelHorizontalAlignmentMode
 * @property {number} center - Centers the text horizontally on the node’s origin.
 * @property {number} left - Positions the text so that the left side of the text is on the node’s origin.
 * @property {number} right - Positions the text so that the right side of the text is on the node’s origin.
 * @see https://developer.apple.com/documentation/spritekit/sklabelhorizontalalignmentmode
 */

const SKLabelHorizontalAlignmentMode = {
  center: 0,
  left: 1,
  right: 2
};

/**
 * Options for aligning text vertically. 
 * @typedef {Object} SKLabelVerticalAlignmentMode
 * @property {number} baseline - Positions the text so that the font’s baseline lies on the node’s origin.
 * @property {number} center - Centers the text vertically on the node’s origin.
 * @property {number} top - Positions the text so that the top of the text is on the node’s origin.
 * @property {number} bottom - Positions the text so that the bottom of the text is on the node’s origin.
 * @see https://developer.apple.com/documentation/spritekit/sklabelverticalalignmentmode
 */

const SKLabelVerticalAlignmentMode = {
  baseline: 0,
  center: 1,
  top: 2,
  bottom: 3
};

/**
 * @access private
 * @type {string}
 */

const _defaultVertexShader$1 = `#version 300 es
  precision mediump float;

  in vec3 position;
  in vec2 texcoord;

  uniform float screenWidth;
  uniform float screenHeight;

  out vec2 v_texcoord;

  void main() {
    vec3 pos = position;
    pos.x = (pos.x * 2.0 / screenWidth) - 1.0;
    pos.y = (pos.y * 2.0 / screenHeight) - 1.0;
    v_texcoord = texcoord;
    gl_Position = vec4(pos, 1.0);
  }
`;
/**
 * @access private
 * @type {string}
 */

const _defaultFragmentShader$1 = `#version 300 es
  precision mediump float;

  uniform sampler2D spriteTexture;
  uniform float alpha;
  in vec2 v_texcoord;

  out vec4 outColor;

  void main() {
    outColor = texture(spriteTexture, v_texcoord);
    outColor.a *= alpha;
  }
`;
/**
 * A node that displays a text label.
 * @access public
 * @extends {SKNode}
 * @see https://developer.apple.com/documentation/spritekit/sklabelnode
 */

class SKLabelNode extends SKNode {
  // Creating a New Label Node

  /**
   * Initializes a new label object with a text string.
   * @access public
   * @constructor
   * @param {?string} text - The text to use to initialize the label node.
   * @desc The label node’s font is set to Helvetica Neue Ultra Light, 32 point.
   * @see https://developer.apple.com/documentation/spritekit/sklabelnode/1519612-init
   */
  constructor(text) {
    super(); // Configuring the Label Message

    /**
     * The string that the label node displays.
     * @access private
     * @type {?string}
     * @see https://developer.apple.com/documentation/spritekit/sklabelnode/1519788-text
     */

    this._text = null; // Configuring the Label Font

    /**
     * The color of the label.
     * @access private
     * @type {?CGColor}
     * @see https://developer.apple.com/documentation/spritekit/sklabelnode/1520057-fontcolor
     */

    this._fontColor = new SKColor(1.0, 1.0, 1.0, 1.0);
    /**
     * The font used for the text in the label.
     * @access private
     * @type {?string}
     * @see https://developer.apple.com/documentation/spritekit/sklabelnode/1520129-fontname
     */

    this._fontName = 'HelveticaNeue-UltraLight';
    /**
     * The size of the font used in the label.
     * @access private
     * @type {number}
     * @see https://developer.apple.com/documentation/spritekit/sklabelnode/1520208-fontsize
     */

    this._fontSize = 32.0; // Configuring the Label’s Position

    /**
     * The vertical position of the text within the node.
     * @access private
     * @type {SKLabelVerticalAlignmentMode}
     * @see https://developer.apple.com/documentation/spritekit/sklabelnode/1519933-verticalalignmentmode
     */

    this._verticalAlignmentMode = SKLabelVerticalAlignmentMode.baseline;
    /**
     * The horizontal position of the text within the node.
     * @access private
     * @type {SKLabelHorizontalAlignmentMode}
     * @see https://developer.apple.com/documentation/spritekit/sklabelnode/1519711-horizontalalignmentmode
     */

    this._horizontalAlignmentMode = SKLabelHorizontalAlignmentMode.center; // Performing Color Blending

    /**
     * The label’s blend color.
     * @type {?CGColor}
     * @see https://developer.apple.com/documentation/spritekit/sklabelnode/1519938-color
     */

    this.color = new SKColor(1.0, 1.0, 1.0, 1.0);
    /**
     * A floating-point value that describes how the color is blended with the font color.
     * @type {number}
     * @see https://developer.apple.com/documentation/spritekit/sklabelnode/1519724-colorblendfactor
     */

    this.colorBlendFactor = 0.0; // Blending the Label into the Framebuffer

    /**
     * The blend mode used to draw the label into the parent’s framebuffer.
     * @type {SKBlendMode}
     * @see https://developer.apple.com/documentation/spritekit/sklabelnode/1519598-blendmode
     */

    this.blendMode = SKBlendMode.alpha;
    this._canvas = document.createElement('canvas');
    this._context = this._canvas.getContext('2d');
    this._glContext = null;
    this._texture = null;
    this._textureUpToDate = false;
    /**
     * @access private
     * @type {WebGLProgram}
     */

    this._program = null;
    this._vertexArrayObject = null;
    this._vertexBuffer = null;
    this._indexBuffer = null;
    this.text = text;
  }
  /**
   * Initializes a new label object with a specified font.
   * @access public
   * @param {?string} fontName - The name of the font used by the label.
   * @returns {SKLabelNode} -
   * @see https://developer.apple.com/documentation/spritekit/sklabelnode/1519917-init
   */


  static labelWithFontNamed(fontName) {
    const label = new SKLabelNode();
    label.fontName = fontName;
    return label;
  }
  /**
   * Initializes a new label object with a text string.
   * @access public
   * @param {?string} text - The text to use to initialize the label node.
   * @returns {SKLabelNode} -
   * @desc The label node’s font is set to Helvetica Neue Ultra Light, 32 point.
   * @see https://developer.apple.com/documentation/spritekit/sklabelnode/1519612-init
   */


  static labelWithText(text) {
    return new SKLabelNode(text);
  }

  get text() {
    return this._text;
  }

  set text(newValue) {
    this._text = newValue;

    this._updateCanvas();
  }

  get fontColor() {
    return this._fontColor;
  }

  set fontColor(newValue) {
    this._fontColor = newValue;

    this._updateCanvas();
  }

  get fontName() {
    return this._fontName;
  }

  set fontName(newValue) {
    this._fontName = newValue;

    this._updateCanvas();
  }

  get fontSize() {
    return this._fontSize;
  }

  set fontSize(newValue) {
    this._fontSize = newValue;

    this._updateCanvas();
  }

  get verticalAlignmentMode() {
    return this._verticalAlignmentMode;
  }

  set verticalAlignmentMode(newValue) {
    this._verticalAlignmentMode = newValue;

    this._updateCanvas();
  }

  get horizontalAlignmentMode() {
    return this._horizontalAlignmentMode;
  }

  set horizontalAlignmentMode(newValue) {
    this._horizontalAlignmentMode = newValue;

    this._updateCanvas();
  }

  _updateCanvas() {
    this._context.font = `${this._fontSize}px ${this._fontName}`;

    const metrics = this._context.measureText(this._text);

    this._canvas.width = metrics.width;
    this._canvas.height = this._fontSize * 3;
    this._context.font = `${this._fontSize}px ${this._fontName}`;
    this._context.fillStyle = this._fontColor.hexColor;

    switch (this._verticalAlignmentMode) {
      case SKLabelVerticalAlignmentMode.baseline:
        this._context.textBaseline = 'alphabetic';
        break;

      case SKLabelVerticalAlignmentMode.center:
        this._context.textBaseline = 'middle';
        break;

      case SKLabelVerticalAlignmentMode.top:
        this._context.textBaseline = 'top';
        break;

      case SKLabelVerticalAlignmentMode.bottom:
        this._context.textBaseline = 'bottom';
        break;

      default:
        throw new Error(`unknown vertical alignment mode: ${this._verticalAlignmentMode}`);
    } //switch(this._horizontalAlignmentMode){
    //  case SKLabelHorizontalAlignmentMode.center:
    //    this._context.textAlign = 'center'
    //    break
    //  case SKLabelHorizontalAlignmentMode.left:
    //    this._context.textAlign = 'left'
    //    break
    //  case SKLabelHorizontalAlignmentMode.right:
    //    this._context.textAlign = 'right'
    //    break
    //  default:
    //    throw new Error(`unknown horizontal alignment mode: ${this._horizontalAlignmentMode}`)
    //}


    this._context.textAlign = 'left';

    this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);

    this._context.fillText(this._text, 0, this._canvas.height * 0.5);

    this._textureUpToDate = false;
  }
  /**
   * @access private
   * @param {WebGLRenderingContext} gl -
   * @param {CGRect} viewRect -
   * @returns {void}
   */


  _render(gl, viewRect) {
    const p = this.__presentation;

    if (this._texture === null || this._glContext !== gl) {
      this._glContext = gl;
      this._texture = gl.createTexture();
      this._textureUpToDate = false;
    }

    if (!this._textureUpToDate) {
      gl.bindTexture(gl.TEXTURE_2D, this._texture); // texImage2D(target, level, internalformat, width, height, border, format, type, source)

      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this._canvas.width, this._canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, this._canvas);
      gl.generateMipmap(gl.TEXTURE_2D);
      gl.bindTexture(gl.TEXTURE_2D, null);
      this._textureUpToDate = true;
    }

    if (this._program === null) {
      this._program = this._createProgram(gl);
    }

    const program = this._program;
    gl.useProgram(program);

    if (this._vertexArrayObject === null) {
      this._createVertexArrayObject(gl, program);
    }

    gl.bindVertexArray(this._vertexArrayObject);
    gl.uniform1f(gl.getUniformLocation(program, 'screenWidth'), viewRect.size.width);
    gl.uniform1f(gl.getUniformLocation(program, 'screenHeight'), viewRect.size.height);
    gl.uniform1f(gl.getUniformLocation(program, 'alpha'), p.alpha);

    const data = this._createVertexData();

    gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);
    gl.uniform1i(gl.getUniformLocation(program, 'spriteTexture'), 0);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, this._texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_BYTE, 0);
  }

  _createProgram(gl) {
    const program = gl.createProgram();
    const vsText = _defaultVertexShader$1;
    const fsText = _defaultFragmentShader$1; // initialize vertex shader

    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, vsText);
    gl.compileShader(vertexShader);

    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      const info = gl.getShaderInfoLog(vertexShader);
      throw new Error(`SKSpriteNode vertex shader compile error: ${info}`);
    } // initialize fragment shader


    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fsText);
    gl.compileShader(fragmentShader);

    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      const info = gl.getShaderInfoLog(fragmentShader);
      throw new Error(`particle fragment shader compile error: ${info}`);
    }

    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader); // link program object

    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      const info = gl.getProgramInfoLog(program);
      throw new Error(`program link error: ${info}`);
    } //gl.useProgram(program)


    return program;
  }
  /**
   * @access private
   * @param {WebGLRenderingContext} gl -
   * @param {WebGLProgram} program -
   * @returns {void}
   */


  _createVertexArrayObject(gl, program) {
    this._vertexArrayObject = gl.createVertexArray();
    gl.bindVertexArray(this._vertexArrayObject);
    this._vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
    const positionLoc = gl.getAttribLocation(program, 'position');
    gl.bindAttribLocation(program, positionLoc, 'position');
    gl.enableVertexAttribArray(positionLoc); // idx, size, type, norm, stride, offset

    gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 20, 0);
    const texcoordLoc = gl.getAttribLocation(program, 'texcoord');
    gl.bindAttribLocation(program, texcoordLoc, 'texcoord');
    gl.enableVertexAttribArray(texcoordLoc); // idx, size, type, norm, stride, offset

    gl.vertexAttribPointer(texcoordLoc, 2, gl.FLOAT, false, 20, 12);
    this._indexBuffer = gl.createBuffer();
    const indexData = new Uint8Array([0, 3, 2, 0, 1, 3]);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexData, gl.STATIC_DRAW);
  }

  _createVertexData() {
    const p = this.__presentation._worldPosition;
    const w = this._canvas.width * this.__presentation.xScale;
    const h = this._canvas.height * this.__presentation.yScale;
    let left = p.x;
    let right = p.x;
    let top = p.y + h * 0.5;
    let bottom = p.y - h * 0.5;

    switch (this.__presentation._horizontalAlignmentMode) {
      case SKLabelHorizontalAlignmentMode.center:
        left -= w * 0.5;
        right += w * 0.5;
        break;

      case SKLabelHorizontalAlignmentMode.left:
        right += w;
        break;

      case SKLabelHorizontalAlignmentMode.right:
        left -= w;
        break;

      default:
        // unknown mode
        break;
    }

    const arr = [left, top, this.__presentation._worldZPosition, 0, 0, right, top, this.__presentation._worldZPosition, 1, 0, left, bottom, this.__presentation._worldZPosition, 0, 1, right, bottom, this.__presentation._worldZPosition, 1, 1];
    return new Float32Array(arr);
  }

  copy() {
    const node = new SKLabelNode();

    node._copyValue(this);

    return node;
  }

  _copyValue(src) {
    super._copyValue(src);

    this._text = src._text;
    this._fontColor = src._fontColor._copy();
    this._fontName = src._fontName;
    this._fontSize = src._fontSize;
    this._verticalAlignmentMode = src._verticalAlignmentMode;
    this._horizontalAlignmentMode = src._horizontalAlignmentMode;
    this.color = src.color._copy();
    this.colorBlendFactor = src.colorBlendFactor;
    this.blendMode = src.blendMode;
    this._canvas = src._canvas;
    this._context = src._context; //this._glContext = src._glContext
    //this._texture = src._texture
    //this._program = src._program
    //this._vertexArrayObject = src._vertexArrayObject
    //this._vertexBuffer = src._vertexBuffer
    //this._indexBuffer = src._indexBuffer
  }

}

//import SKNode from './SKNode'

class SKRepeat extends SKAction {
  /**
   * constructor
   * @access public
   * @constructor
   */
  constructor() {
    super();
    this._timesToRepeat = 0;
    this._repeatedAtion = null;
    this._forever = false;
    this._timesRepeated = 0;
  }
  /**
   * Creates an action that repeats another action a specified number of times.
   * @access public
   * @param {SKAction} action - The action to execute.
   * @param {number} count - The number of times to execute the action.
   * @returns {SKAction} - 
   * @desc When the action executes, the associated action runs to completion and then repeats, until the count is reached.This action is reversible; it creates a new action that is the reverse of the specified action and then repeats it the same number of times.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417750-repeat
   */


  static repeat(action, count) {
    const _action = new SKRepeat();

    _action._repeatedAction = action;
    _action._duration = action.duration;
    _action._timesToRepeat = count;
    _action._forever = count === Infinity;
    return _action;
  }
  /**
   * Creates an action that repeats another action forever.
   * @access public
   * @param {SKAction} action - The action to execute.
   * @returns {SKAction} - 
   * @desc When the action executes, the associated action runs to completion and then repeats.This action is reversible; it creates a new action that is the reverse of the specified action and then repeats it forever.NoteThe action to be repeated must have a non-instantaneous duration.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417676-repeatforever
   */


  static repeatForever(action) {
    return this.repeat(action, Infinity);
  }
  /**
   * @access public
   * @returns {SCNActionFade} -
   */


  copy() {
    const action = super.copy();
    action._timesToRepeat = this._timesToRepeat;
    action._repeatedAction = this._repeatedAction;
    action._forever = this._forever;
    action._timesRepeated = this._timesRepeated;
    return action;
  }

  _getTime(time, needTimeConversion) {
    if (!needTimeConversion) {
      return time;
    }

    const baseTime = this._basetimeFromTime(time);

    if (this.timingFunction === null) {
      return baseTime;
    }

    const n = Math.floor(baseTime);

    const t = this.timingFunction._getValueAtTime(baseTime - n);

    return n + t;
  }
  /**
   * apply action to the given node.
   * @access private
   * @param {Object} obj - target object to apply this action.
   * @param {number} time - active time
   * @param {boolean} [needTimeConversion = true] -
   * @returns {void}
   */


  _applyAction(obj, time, needTimeConversion = true) {
    const dt = this._getTime(time, needTimeConversion);

    const timesRepeated = Math.floor(dt);

    while (timesRepeated > this._timesRepeated) {
      this._timesRepeated += 1;

      this._repeatedAction._applyAction(obj, 1.0, false);

      if (!this._forever && this._timesRepeated >= this._timesToRepeat) {
        this._finished = true;
        return;
      }

      this._repeatedAction._resetFinished();
    }

    const t = dt - this._timesRepeated;

    this._repeatedAction._applyAction(obj, t, false);

    this._finished = false;
  }

  get duration() {
    if (this._forever) {
      return Infinity;
    }

    return this._repeatedAction.duration * this._timesToRepeat;
  }

  _resetFinished() {
    this._repeatedAction._resetFinished();

    this._timesRepeated = 0;
    this._finished = false;
  }

}
SKAction.repeat = SKRepeat.repeat;
SKAction.repeatForever = SKRepeat.repeatForever;

class SKScale extends SKAction {
  /**
   * constructor
   * @access public
   * @constructor
   */
  constructor() {
    super();
    this._actions = [];
    this._finished = false;
    this._duration = 0;
    this._timingMode = SKActionTimingMode.linear;
    this._beginTime = 0;
    this._isRunning = false;
    this._pausedTime = 0;
    this._scaleXTo = null;
    this._scaleXBy = null;
    this._scaleWidthTo = null;
    this._scaleYTo = null;
    this._scaleYBy = null;
    this._scaleHeightTo = null;
  }
  /**
   * Creates an action that changes the x and y scale values of a node by a relative value.
   * @access public
   * @param {number} scale - The amount to add to the node’s x and y scale values.
   * @param {number} sec - The duration of the animation.
   * @returns {SKAction} - 
   * @desc When the action executes, the node’s xScale and yScale properties are animated to the new value.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.scale(by: -scale, duration: sec)
  let action = SKAction.scale(by: -scale, duration: sec)
    * @see https://developer.apple.com/documentation/spritekit/skaction/1417741-scale
   */


  static scaleByDuration(scale, sec) {
    const action = new SKScale();
    action._scaleXBy = scale;
    action._scaleYBy = scale;
    action._duration = sec;
    return action;
  }
  /**
   * Creates an action that changes the x and y scale values of a node to achieve 
   * @access public
   * @param {number|CGSize} size - The new size of the node.
   * @param {number} sec - The duration of the animation.
   * @returns {SKAction} - 
   * @desc When the action executes, the node’s xScale and yScale properties are animated to achieve the specified size in its parent's coordinate space. This action is not reversible; the reverse of this action has the same duration but does not change anything.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1643619-scale
   */


  static scaleToDuration(size, sec) {
    const action = new SKScale();

    if (size instanceof CGSize) {
      action._scaleWidthTo = size.width;
      action._scaleHeightTo = size.height;
    } else if (typeof size === 'number') {
      action._scaleXTo = size;
      action._scaleYTo = size;
    } else {
      throw new Error('unsupported format');
    }

    action._duration = sec;
    return action;
  }
  /**
   * Creates an action that adds relative values to the x and y scale values of a node.
   * @access public
   * @param {number} xScale - The amount to add to the node’s x scale value.
   * @param {number} yScale - The amount to add to the node’s y scale value.
   * @param {number} sec - The duration of the animation.
   * @returns {SKAction} - 
   * @desc When the action executes, the node’s xScale and yScale properties are animated to the new value.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.scaleX(by: -scaleX, y: -scaleY, duration: sec)
  let action = SKAction.scaleX(by: -scaleX, y: -scaleY, duration: sec)
    * @see https://developer.apple.com/documentation/spritekit/skaction/1417796-scalex
   */


  static scaleXByYDuration(xScale, yScale, sec) {
    const action = new SKScale();
    action._scaleXBy = xScale;
    action._scaleYBy = yScale;
    action._duration = sec;
    return action;
  }
  /**
   * Creates an action that changes the x and y scale values of a node.
   * @access public
   * @param {number} xScale - The new value for the node’s x scale value.
   * @param {number} yScale - The new value for the node’s y scale value.
   * @param {number} sec - The duration of the animation.
   * @returns {SKAction} - 
   * @desc When the action executes, the node’s xScale and yScale properties are animated to the new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417728-scalex
   */


  static scaleXToYDuration(xScale, yScale, sec) {
    const action = new SKScale();
    action._scaleXTo = xScale;
    action._scaleYTo = yScale;
    action._duration = sec;
    return action;
  }
  /**
   * Creates an action that changes the x scale value of a node to a new value.
   * @access public
   * @param {number} scale - The new value for the node’s x scale value.
   * @param {number} sec - The duration of the animation.
   * @returns {SKAction} - 
   * @desc When the action executes, the node’s xScale property animates to the new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417699-scalex
   */


  static scaleXToDuration(scale, sec) {
    const action = new SKScale();
    action._scaleXTo = scale;
    action._duration = sec;
    return action;
  }
  /**
   * Creates an action that changes the y scale value of a node to a new value.
   * @access public
   * @param {number} scale - The new value for the node’s y scale value.
   * @param {number} sec - The duration of the animation.
   * @returns {SKAction} - 
   * @desc When the action executes, the node’s yScale property animates to the new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417708-scaley
   */


  static scaleYToDuration(scale, sec) {
    const action = new SKScale();
    action._scaleYTo = scale;
    action._duration = sec;
    return action;
  }
  /**
   * @access public
   * @returns {SCNActionFade} -
   */


  copy() {
    const action = super.copy();
    action._scaleXTo = this._scaleXTo;
    action._scaleXBy = this._scaleXBy;
    action._scaleWidthTo = this._scaleWidthTo;
    action._scaleYTo = this._scaleYTo;
    action._scaleYBy = this._scaleYBy;
    action._scaleHeightTo = this._scaleHeightTo;
    return action;
  }
  /**
   * apply action to the given node.
   * @access private
   * @param {Object} obj - target object to apply this action.
   * @param {number} time - active time
   * @param {boolean} [needTimeConversion = true] -
   * @returns {void}
   */


  _applyAction(obj, time, needTimeConversion = true) {
    const t = this._getTime(time, needTimeConversion);

    if (!(obj instanceof SKNode)) {
      throw new Error(`unsupported class for SKSequence: ${obj.constructor.name}`);
    }

    const baseXValue = obj.xScale;
    let toXValue = null;

    if (this._scaleXTo !== null) {
      toXValue = this._scaleXTo;
    } else if (this._scaleXBy !== null) {
      toXValue = baseXValue + this._scaleXBy;
    } else if (this._scaleWidthTo !== null) {
      toXValue = this._scaleWidthTo / this._frame.size.width;
    }

    const baseYValue = obj.yScale;
    let toYValue = null;

    if (this._scaleYTo !== null) {
      toYValue = this._scaleYTo;
    } else if (this._scaleYBy !== null) {
      toYValue = baseYValue + this._scaleYBy;
    } else if (this._scaleHeightTo !== null) {
      toYValue = this._scaleHeightTo / this._frame.size.height;
    }

    if (toXValue === null && toYValue === null) {
      throw new Error('both toXValue and toYValue are null');
    }

    if (toXValue !== null) {
      const xValue = this._lerp(baseXValue, toXValue, t);

      obj._presentation.xScale = xValue;
    }

    if (toYValue !== null) {
      const yValue = this._lerp(baseYValue, toYValue, t);

      obj._presentation.yScale = yValue;
    }

    if (this._finished) {
      if (toXValue !== null) {
        obj.xScale = toXValue;
      }

      if (toYValue !== null) {
        obj.yScale = toYValue;
      }
    }
  }

}
SKAction.scaleByDuration = SKScale.scaleByDuration;
SKAction.scaleToDuration = SKScale.scaleToDuration;
SKAction.scaleXByYDuration = SKScale.scaleXByYDuration;
SKAction.scaleXToYDuration = SKScale.scaleXToYDuration;
SKAction.scaleXToDuration = SKScale.scaleXToDuration;
SKAction.scaleYToDuration = SKScale.scaleYToDuration;

/**
 * The modes that determine how the scene’s area is mapped to the view that presents it.
 * @typedef {Object} SKSceneScaleMode
 * @property {number} fill - Each axis of the scene is scaled independently so that each axis in the scene exactly maps to the length of that axis in the view.
 * @property {number} aspectFill - The scaling factor of each dimension is calculated and the larger of the two is chosen. Each axis of the scene is scaled by the same scaling factor. This guarantees that the entire area of the view is filled but may cause parts of the scene to be cropped.
 * @property {number} aspectFit - The scaling factor of each dimension is calculated and the smaller of the two is chosen. Each axis of the scene is scaled by the same scaling factor. This guarantees that the entire scene is visible but may require letterboxing in the view.
 * @property {number} resizeFill - The scene is not scaled to match the view. Instead, the scene is automatically resized so that its dimensions always match those of the view.
 * @see https://developer.apple.com/documentation/spritekit/skscenescalemode
 */

const SKSceneScaleMode = {
  fill: 0,
  aspectFill: 1,
  aspectFit: 2,
  resizeFill: 3
};

//import SKView from './SKView'
//import SKSceneDelegate from './SKSceneDelegate'
//import SKPhysicsWorld from './SKPhysicsWorld'
//import SKNode from './SKNode'

/**
 * The root node for all Sprite Kit objects displayed in a view. 
 * @access public
 * @extends {SKEffectNode}
 * @see https://developer.apple.com/documentation/spritekit/skscene
 */

class SKScene extends SKEffectNode {
  // Initializing a Scene

  /**
   * Initializes a new scene object.
   * @access public
   * @constructor
   * @param {CGSize} size - The size of the scene in points.
   * @desc This is the class’s designated initializer method.
   * @see https://developer.apple.com/documentation/spritekit/skscene/1520435-init
   */
  constructor(size) {
    super(); // Determining What Portion of the Scene Is Visible in the View

    /**
     * The camera node in the scene that determines what part of the scene’s coordinate space is visible in the view.
     * @type {?SKCameraNode}
     * @see https://developer.apple.com/documentation/spritekit/skscene/1519696-camera
     */

    this.camera = null;
    /**
     * The point in the view’s frame that corresponds to the scene’s origin.
     * @type {CGPoint}
     * @see https://developer.apple.com/documentation/spritekit/skscene/1519864-anchorpoint
     */

    this.anchorPoint = new CGPoint(0, 0);
    /**
     * The dimensions of the scene in points.
     * @type {CGSize}
     * @see https://developer.apple.com/documentation/spritekit/skscene/1519831-size
     */

    this.size = size ? size : new CGSize(1, 1);
    /**
     * Defines how the scene is mapped to the view that presents it.
     * @type {SKSceneScaleMode}
     * @see https://developer.apple.com/documentation/spritekit/skscene/1519562-scalemode
     */

    this.scaleMode = SKSceneScaleMode.fill; // Setting the Background Color of a Scene

    /**
     * The background color of the scene.
     * @type {SKColor}
     * @see https://developer.apple.com/documentation/spritekit/skscene/1520278-backgroundcolor
     */

    this.backgroundColor = new SKColor(0.15, 0.15, 0.15, 1.0); // Presenting a Scene

    this._view = null; // Executing the Animation Loop

    /**
     * A delegate to be called during the animation loop. 
     * @type {?SKSceneDelegate}
     * @see https://developer.apple.com/documentation/spritekit/skscene/1520213-delegate
     */

    this.delegate = null; // Working with Physics in the Scene
    //this._physicsWorld = new SKPhysicsWorld()

    this._physicsWorld = null; // Working with Audio in the Scene

    /**
     * A node used to determine the position of the listener for positional audio in the scene.
     * @type {?SKNode}
     * @see https://developer.apple.com/documentation/spritekit/skscene/1520363-listener
     */

    this.listener = null; //this._audioEngine = null
  }

  _copyValue(src) {
    this.camera = src.camera;
    this.anchorPoint = src.anchorPoint.copy();
    this.size = src.size.copy();
    this.scaleMode = src.scaleMode;
    this.backgroundColor = src.backgroundColor._copy();
    this._view = src._view;
    this.delegate = src.delegate;
    this._physicsWorld = src._physicsWorld;
    this.listener = src.listener;
  } // Determining What Portion of the Scene Is Visible in the View

  /**
   * Called whenever the scene’s size changes.
   * @access public
   * @param {CGSize} oldSize - The old size of the scene, in points.
   * @returns {void}
   * @desc This method is intended to be overridden in a subclass. Typically, you use this method to adjust the positions of nodes in the scene.
   * @see https://developer.apple.com/documentation/spritekit/skscene/1519545-didchangesize
   */


  didChangeSize(oldSize) {} // Converting Between View and Scene Coordinates

  /**
   * Converts a point from view coordinates to scene coordinates.
   * @access public
   * @param {CGPoint} point - A point in view coordinates.
   * @returns {CGPoint} - 
   * @desc The scene must be presented in a view before calling this method.
   * @see https://developer.apple.com/documentation/spritekit/skscene/1520395-convertpoint
   */


  convertPointFromView(point) {
    return null;
  }
  /**
   * Converts a point from scene coordinates to view coordinates.
   * @access public
   * @param {CGPoint} point - A point in scene coordinates.
   * @returns {CGPoint} - 
   * @desc The scene must be presented in a view before calling this method.
   * @see https://developer.apple.com/documentation/spritekit/skscene/1520082-convertpoint
   */


  convertPointToView(point) {
    return null;
  } // Presenting a Scene

  /**
   * Called immediately after the scene has been initialized or decoded.
   * @access public
   * @returns {void}
   * @desc This method is intended to be overridden in a subclass. You can use this method to implement any custom behavior after it has been initialized or decoded.
   * @see https://developer.apple.com/documentation/spritekit/skscene/1645216-scenedidload
   */


  sceneDidLoad() {}
  /**
   * Called immediately before a scene is removed from a view.
   * @access public
   * @param {SKView} view - The view that is presenting the scene.
   * @returns {void}
   * @desc This method is intended to be overridden in a subclass. You can use this method to implement any custom behavior for your scene when it is about to be removed from the view.
   * @see https://developer.apple.com/documentation/spritekit/skscene/1519703-willmove
   */


  willMoveFrom(view) {}
  /**
   * Called immediately after a scene is presented by a view.
   * @access public
   * @param {SKView} view - The view that is presenting the scene.
   * @returns {void}
   * @desc This method is intended to be overridden in a subclass. You can use this method to implement any custom behavior for your scene when it is about to be presented by a view. For example, you might use this method to create the scene’s contents.
   * @see https://developer.apple.com/documentation/spritekit/skscene/1519607-didmove
   */


  didMoveTo(view) {}
  /**
   * The view that is currently presenting the scene.
   * @type {?SKView}
   * @desc To present a scene, you call the presentScene(_:) method or presentScene(_:transition:) method on the SKView class. If the scene is not currently presented, this property holds nil.
   * @see https://developer.apple.com/documentation/spritekit/skscene/1519726-view
   */


  get view() {
    return this._view;
  } // Executing the Animation Loop

  /**
   * Performs any scene-specific updates that need to occur before scene actions are evaluated.
   * @access public
   * @param {number} currentTime - The current system time.
   * @returns {void}
   * @desc Do not call this method directly; it is called exactly once per frame, so long as the scene is presented in a view and is not paused. By default, this method does nothing. Your scene subclass should override this method and perform any necessary updates to the scene.
   * @see https://developer.apple.com/documentation/spritekit/skscene/1519802-update
   */


  update(currentTime) {}
  /**
   * Performs any scene-specific updates that need to occur after scene actions are evaluated.
   * @access public
   * @returns {void}
   * @desc Do not call this method directly; it is called exactly once per frame, so long as the scene is presented in a view and is not paused. By default, this method does nothing. Your scene subclass should override this method and perform any necessary updates to the scene.
   * @see https://developer.apple.com/documentation/spritekit/skscene/1519903-didevaluateactions
   */


  didEvaluateActions() {}
  /**
   * Performs any scene-specific updates that need to occur after physics simulations are performed.
   * @access public
   * @returns {void}
   * @desc Do not call this method directly; it is called exactly once per frame, so long as the scene is presented in a view and is not paused. By default, this method does nothing. Your scene subclass should override this method and perform any necessary updates to the scene.
   * @see https://developer.apple.com/documentation/spritekit/skscene/1519965-didsimulatephysics
   */


  didSimulatePhysics() {}
  /**
   * Performs any scene-specific updates that need to occur after constraints are applied.
   * @access public
   * @returns {void}
   * @desc Do not call this method directly; it is called exactly once per frame, so long as the scene is presented in a view and is not paused. By default, this method does nothing. Your scene subclass should override this method and perform any necessary updates to the scene.
   * @see https://developer.apple.com/documentation/spritekit/skscene/1520006-didapplyconstraints
   */


  didApplyConstraints() {}
  /**
   * Called after the scene has finished all of the steps required to process animations.
   * @access public
   * @returns {void}
   * @desc Do not call this method directly; it is called exactly once per frame, so long as the scene is presented in a view and is not paused. By default, this method does nothing. Your scene subclass should override this method and perform any necessary updates to the scene. This method is the last method to be called before the scene is rendered.
   * @see https://developer.apple.com/documentation/spritekit/skscene/1520269-didfinishupdate
   */


  didFinishUpdate() {} // Working with Physics in the Scene

  /**
   * The physics simulation associated with the scene.
   * @type {SKPhysicsWorld}
   * @desc Every scene automatically creates a physics world object to simulate physics on nodes in the scene. You use this property to access the scene’s global physics properties, such as gravity. To add physics to a particular node, see physicsBody.
   * @see https://developer.apple.com/documentation/spritekit/skscene/1519584-physicsworld
   */


  get physicsWorld() {
    return this._physicsWorld;
  } // Working with Audio in the Scene

  /**
   * The AV Foundation audio engine used to play audio from audio nodes contained in the scene.
   * @type {AVAudioEngine}
   * @desc An audio engine instance is automatically created for you when the scene is created. You can use methods and properties on a scene’s audio engine for overall control of all of its child audio nodes. The following code shows how a scene’s overall volume can be reduced from its default of 1.0 down to 0.2 and then paused:let scene = SKScene()
  scene.audioEngine.mainMixerNode.outputVolume = 0.2
  scene.audioEngine.pause()
  let scene = SKScene()
  scene.audioEngine.mainMixerNode.outputVolume = 0.2
  scene.audioEngine.pause()
    * @see https://developer.apple.com/documentation/spritekit/skscene/1519644-audioengine
   */
  //get audioEngine() {
  //  return this._audioEngine
  //}


}

class SKSequence extends SKAction {
  /**
   * constructor
   * @access public
   * @constructor
   */
  constructor() {
    super();
    this._actions = [];
    this._animIndex = 0;
    this._finished = false;
    this._duration = 0;
    this._timingMode = SKActionTimingMode.linear;
    this._beginTime = 0;
    this._isRunning = false;
    this._pausedTime = 0;
  }
  /**
   * Creates an action that runs a collection of actions sequentially.
   * @access public
   * @param {SKAction[]} actions - An array of SKAction objects.
   * @returns {SKAction} - 
   * @desc When the action executes, the first action in the sequence starts and runs to completion. Subsequent actions in the sequence run in a similar fashion until all of the actions in the sequence have executed. The duration of the sequence action is the sum of the durations of the actions in the sequence.This action is reversible; it creates a new sequence action that reverses the order of the actions. Each action in the reversed sequence is itself reversed. For example, if an action sequence is {1,2,3}, the reversed sequence would be {3R,2R,1R}.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417817-sequence
   */


  static sequence(actions) {
    const action = new SKSequence();
    action._actions = actions;
    action._duration = 0;
    return action;
  }

  get duration() {
    let d = 0;

    this._actions.forEach(act => {
      if (act.speed > 0) {
        d += act.duration / act.speed;
      }
    });

    return d;
  }
  /**
   * @access public
   * @returns {SCNActionFade} -
   */


  copy() {
    const action = super.copy();
    action._actions = this._actions.slice(0);
    action._animIndex = this._animIndex;
    return action;
  }
  /**
   * apply action to the given node.
   * @access private
   * @param {Object} obj - target object to apply this action.
   * @param {number} time - active time
   * @param {boolean} [needTimeConversion = true] -
   * @returns {void}
   */


  _applyAction(obj, time, needTimeConversion = true) {
    const total = this.duration;
    let duration = 0;

    if (total <= 0 || total === Infinity) {
      duration = this._activetimeFromTime(time);
    } else {
      duration = this._getTime(time, needTimeConversion) * total;
    }

    for (let i = 0; i < this._animIndex; i++) {
      duration -= this._actions[i].duration / this._actions[i].speed;
    }

    for (; this._animIndex < this._actions.length; this._animIndex++) {
      const action = this._actions[this._animIndex];

      action._applyAction(obj, duration, true);

      duration -= action.duration / action.speed;

      if (duration <= 0 || !action._finished) {
        break;
      }
    }

    if (this._animIndex >= this._actions.length) {
      this._finished = true;
    }
  }

  _resetFinished() {
    this._actions.forEach(action => {
      action._resetFinished();
    });

    this._finished = false;
    this._animIndex = 0;
  }

}
SKAction.sequence = SKSequence.sequence;

//import CGRect from '../CoreGraphics/CGRect'
//import CGSize from '../CoreGraphics/CGSize'
//import SKTexture from './SKTexture'
//import SKShader from './SKShader'
//import SKAttributeValue from './SKAttributeValue'

/**
 * A node that renders a shape defined by a Core Graphics path.
 * @access public
 * @extends {SKNode}
 * @see https://developer.apple.com/documentation/spritekit/skshapenode
 */

class SKShapeNode extends SKNode {
  /**
   * constructor
   * @access public
   * @constructor
   */
  constructor() {
    super(); // Inspecting the Shape Node’s Path

    /**
     * The path that defines the shape.
     * @type {?CGPath}
     * @see https://developer.apple.com/documentation/spritekit/skshapenode/1519741-path
     */

    this.path = null; // Setting the Fill Properties

    /**
     * The color used to fill the shape.
     * @type {SKColor}
     * @see https://developer.apple.com/documentation/spritekit/skshapenode/1520154-fillcolor
     */

    this.fillColor = new SKColor(0, 0, 0, 0);
    /**
     * The texture used to fill the shape.
     * @type {?SKTexture}
     * @see https://developer.apple.com/documentation/spritekit/skshapenode/1519956-filltexture
     */

    this.fillTexture = null;
    /**
     * A custom shader used to determine the color of the filled portion of the shape node.
     * @type {?SKShader}
     * @see https://developer.apple.com/documentation/spritekit/skshapenode/1519629-fillshader
     */

    this.fillShader = null; // Setting the Stroke Properties

    /**
     * The width used to stroke the path.
     * @type {number}
     * @see https://developer.apple.com/documentation/spritekit/skshapenode/1519885-linewidth
     */

    this.lineWidth = 1.0;
    /**
     * The glow that extends outward from the stroked line.
     * @type {number}
     * @see https://developer.apple.com/documentation/spritekit/skshapenode/1520116-glowwidth
     */

    this.glowWidth = 0;
    /**
     * A Boolean value that determines whether the stroked path is smoothed when drawn.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/spritekit/skshapenode/1519719-isantialiased
     */

    this.isAntialiased = true;
    /**
     * The color used to stroke the shape.
     * @type {SKColor}
     * @see https://developer.apple.com/documentation/spritekit/skshapenode/1519748-strokecolor
     */

    this.strokeColor = new SKColor(1.0, 1.0, 1.0, 1.0);
    /**
     * The texture used to stroke the shape.
     * @type {?SKTexture}
     * @see https://developer.apple.com/documentation/spritekit/skshapenode/1519824-stroketexture
     */

    this.strokeTexture = null;
    /**
     * A custom shader used to determine the color of the stroked portion of the shape node.
     * @type {?SKShader}
     * @see https://developer.apple.com/documentation/spritekit/skshapenode/1519784-strokeshader
     */

    this.strokeShader = null;
    /**
     * The style used to render the endpoints of the stroked portion of the shape node.
     * @type {CGLineCap}
     * @see https://developer.apple.com/documentation/spritekit/skshapenode/1520360-linecap
     */

    this.lineCap = CGLineCap.butt;
    /**
     * The junction type used when the stroked portion of the shape node is rendered.
     * @type {CGLineJoin}
     * @see https://developer.apple.com/documentation/spritekit/skshapenode/1520358-linejoin
     */

    this.lineJoin = CGLineJoin.bevel;
    /**
     * The miter limit to use when the line is stroked using a miter join style.
     * @type {number}
     * @see https://developer.apple.com/documentation/spritekit/skshapenode/1520240-miterlimit
     */

    this.miterLimit = 0.5; // Blending the Shape with the Framebuffer

    /**
     * The blend mode used to blend the shape into the parent’s framebuffer.
     * @type {SKBlendMode}
     * @see https://developer.apple.com/documentation/spritekit/skshapenode/1520045-blendmode
     */

    this.blendMode = SKBlendMode.alpha; // Reading the Shape Node’s Properties
    //this._lineLength = 0
    // Working with Custom Shaders

    /**
     * The values of each attribute associated with the node's attached shader.
     * @type {Map<string, SKAttributeValue>}
     * @see https://developer.apple.com/documentation/spritekit/skshapenode/2715841-attributevalues
     */

    this.attributeValues = new Map(); // Instance Properties

    this._customPlaygroundQuickLook = null;
  } // Creating a Shape Path

  /**
   * Creates a shape node from a Core Graphics path.
   * @access public
   * @param {CGPath} path - The Core Graphics path to use. The path is relative to the node’s origin.
   * @returns {void}
   * @see https://developer.apple.com/documentation/spritekit/skshapenode/1520022-init
   */


  static node(path) {}
  /**
   * Creates a shape node with a rectangular path centered on the node’s origin.
   * @access public
   * @param {CGSize} size - The size of the rectangle.
   * @returns {void}
   * @see https://developer.apple.com/documentation/spritekit/skshapenode/1520147-init
   */


  static nodeWithRectOf(size) {}
  /**
   * Creates a shape node with a circular path centered on the node’s origin.
   * @access public
   * @param {number} radius - The radius of the circle.
   * @returns {void}
   * @see https://developer.apple.com/documentation/spritekit/skshapenode/1519570-init
   */


  static nodeWithCircleOfRadius(radius) {
    const node = new SKShapeNode(); // TODO: implement

    return node;
  }
  /**
   * Creates a shape node with an elliptical path centered on the node’s origin.
   * @access public
   * @param {CGSize} size - The height and width of the ellipse.
   * @returns {void}
   * @see https://developer.apple.com/documentation/spritekit/skshapenode/1519980-init
   */


  static nodeWithEllipseOf(size) {}
  /**
   * Creates a shape node with an elliptical path that fills the specified rectangle.
   * @access public
   * @param {CGRect} rect - A rectangle, relative to the node’s origin.
   * @returns {void}
   * @see https://developer.apple.com/documentation/spritekit/skshapenode/1520412-init
   */


  static nodeWithEllipseIn(rect) {}
  /**
   * Creates a shape node from a series of points.
   * @access public
   * @param {UnsafeMutablePointer<CGPoint>} points - An array of Core Graphics points. The points are relative to the node’s origin.
   * @param {number} numPoints - The number of points in the array.
   * @returns {void}
   * @see https://developer.apple.com/documentation/spritekit/skshapenode/1520120-init
   */


  static nodeWithPointsCount(points, numPoints) {}
  /**
   * Creates a shape node from a series of spline points.
   * @access public
   * @param {UnsafeMutablePointer<CGPoint>} points - An array of Core Graphics points.
   * @param {number} numPoints - The number of points in the array.
   * @returns {void}
   * @see https://developer.apple.com/documentation/spritekit/skshapenode/1520140-init
   */


  static nodeWithSplinePointsCount(points, numPoints) {} // Reading the Shape Node’s Properties

  /**
   * The length of the line defined by the shape node.
   * @type {number}
   * @desc 
   * @see https://developer.apple.com/documentation/spritekit/skshapenode/1520398-linelength
   */


  get lineLength() {
    //return this._lineLength
    // TODO: implement
    return 0;
  } // Working with Custom Shaders

  /**
   * Sets an attribute value for an attached shader.
   * @access public
   * @param {SKAttributeValue} value - An attribute value object containing the scalar or vector value to set in the attached shader.
   * @param {string} key - The attribute name.
   * @returns {void}
   * @see https://developer.apple.com/documentation/spritekit/skshapenode/2715855-setvalue
   */


  setValueForAttribute(value, key) {}
  /**
   * The value of a shader attribute.
   * @access public
   * @param {string} key - The attribute name.
   * @returns {?SKAttributeValue} - 
   * @see https://developer.apple.com/documentation/spritekit/skshapenode/2715843-value
   */


  valueForAttributeNamed(key) {
    return null;
  } // Instance Properties

  /**
   * A custom playground quick look for this instance.
   * @type {PlaygroundQuickLook}
   * @desc 
   * @see https://developer.apple.com/documentation/spritekit/skshapenode/1645784-customplaygroundquicklook
   */


  get customPlaygroundQuickLook() {
    return this._customPlaygroundQuickLook;
  }
  /**
   * @access private
   * @param {WebGLRenderingContext} gl -
   * @returns {void}
   */


  _render(gl) {}

}

class SKWait extends SKAction {
  /**
   * constructor
   * @access public
   * @constructor
   */
  constructor() {
    super();
    this._actions = [];
    this._finished = false;
    this._duration = 0;
    this._timingMode = SKActionTimingMode.linear;
    this._beginTime = 0;
    this._isRunning = false;
    this._pausedTime = 0;
  }
  /**
   * Creates an action that idles for a specified period of time.
   * @access public
   * @param {number} sec - The amount of time to wait.
   * @returns {SKAction} - 
   * @desc When the action executes, the action waits for the specified amount of time, then ends. This is typically used as part of a sequence of actions to insert a delay between two other actions. You might also use it in conjunction with the run(_:completion:) method to trigger code that needs to run at a later time.This action is not reversible; the reverse of this action is the same action.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417788-wait
   */


  static waitForDuration(sec) {
    const action = new SKWait();
    action._duration = sec;
    return action;
  }
  /**
   * Creates an action that idles for a randomized period of time.
   * @access public
   * @param {number} sec - The average amount of time to wait.
   * @param {number} durationRange - The range of possible values for the duration.
   * @returns {SKAction} - 
   * @desc When the action executes, the action waits for the specified amount of time, then ends. This is typically used as part of a sequence of actions to insert a delay between two other actions. However, you might also use it in conjunction with the run(_:completion:) method to trigger code that needs to run at a later time.Each time the action is executed, the action computes a new random value for the duration. The duration may vary in either direction by up to half of the value of the durationRange parameter.This action is not reversible; the reverse of this action is the same action.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417760-wait
   */


  static waitForDurationWithRange(sec, durationRange) {
    const duration = Math.max(0, sec + (Math.random() - 0.5) * durationRange);
    const action = new SKWait();
    action._duration = duration;
    return action;
  }

}
SKAction.waitForDuration = SKWait.waitForDuration;
SKAction.waitForDurationWithRange = SKWait.waitForDurationWithRange;

//+ Jonas Raoni Soares Silva
//@ http://jsfromhell.com/classes/binary-parser [rev. #1]
const BinaryParser = function (bigEndian, allowExceptions) {
  this.bigEndian = bigEndian, this.allowExceptions = allowExceptions;
};
let p = BinaryParser.prototype;

p.encodeFloat = function (number, precisionBits, exponentBits) {
  var bias = Math.pow(2, exponentBits - 1) - 1,
      minExp = -bias + 1,
      maxExp = bias,
      minUnnormExp = minExp - precisionBits,
      status = isNaN(n = parseFloat(number)) || n == -Infinity || n == +Infinity ? n : 0,
      exp = 0,
      len = 2 * bias + 1 + precisionBits + 3,
      bin = new Array(len),
      signal = (n = status !== 0 ? 0 : n) < 0,
      n = Math.abs(n),
      intPart = Math.floor(n),
      floatPart = n - intPart,
      i,
      lastBit,
      rounded,
      j,
      result;

  for (i = len; i; bin[--i] = 0);

  for (i = bias + 2; intPart && i; bin[--i] = intPart % 2, intPart = Math.floor(intPart / 2));

  for (i = bias + 1; floatPart > 0 && i; (bin[++i] = ((floatPart *= 2) >= 1) - 0) && --floatPart);

  for (i = -1; ++i < len && !bin[i];);

  if (bin[(lastBit = precisionBits - 1 + (i = (exp = bias + 1 - i) >= minExp && exp <= maxExp ? i + 1 : bias + 1 - (exp = minExp - 1))) + 1]) {
    if (!(rounded = bin[lastBit])) for (j = lastBit + 2; !rounded && j < len; rounded = bin[j++]);

    for (j = lastBit + 1; rounded && --j >= 0; (bin[j] = !bin[j] - 0) && (rounded = 0));
  }

  for (i = i - 2 < 0 ? -1 : i - 3; ++i < len && !bin[i];);

  (exp = bias + 1 - i) >= minExp && exp <= maxExp ? ++i : exp < minExp && (exp != bias + 1 - len && exp < minUnnormExp && this.warn("encodeFloat::float underflow"), i = bias + 1 - (exp = minExp - 1));
  (intPart || status !== 0) && (this.warn(intPart ? "encodeFloat::float overflow" : "encodeFloat::" + status), exp = maxExp + 1, i = bias + 2, status == -Infinity ? signal = 1 : isNaN(status) && (bin[i] = 1));

  for (n = Math.abs(exp + bias), j = exponentBits + 1, result = ""; --j; result = n % 2 + result, n = n >>= 1);

  for (n = 0, j = 0, i = (result = (signal ? "1" : "0") + result + bin.slice(i, i + precisionBits).join("")).length, r = []; i; n += (1 << j) * result.charAt(--i), j == 7 && (r[r.length] = String.fromCharCode(n), n = 0), j = (j + 1) % 8);

  r[r.length] = n ? String.fromCharCode(n) : "";
  return (this.bigEndian ? r.reverse() : r).join("");
};

p.encodeInt = function (number, bits, signed) {
  var max = Math.pow(2, bits),
      r = [];
  (number >= max || number < -(max >> 1)) && this.warn("encodeInt::overflow") && (number = 0);
  number < 0 && (number += max);

  for (; number; r[r.length] = String.fromCharCode(number % 256), number = Math.floor(number / 256));

  for (bits = -(-bits >> 3) - r.length; bits--; r[r.length] = "\0");

  return (this.bigEndian ? r.reverse() : r).join("");
};

p.decodeFloat = function (data, precisionBits, exponentBits) {
  var b = ((b = new this.Buffer(this.bigEndian, data)).checkBuffer(precisionBits + exponentBits + 1), b),
      bias = Math.pow(2, exponentBits - 1) - 1,
      signal = b.readBits(precisionBits + exponentBits, 1),
      exponent = b.readBits(precisionBits, exponentBits),
      significand = 0,
      divisor = 2,
      curByte = b.buffer.length + (-precisionBits >> 3) - 1,
      byteValue,
      startBit,
      mask;

  do for (byteValue = b.buffer[++curByte], startBit = precisionBits % 8 || 8, mask = 1 << startBit; mask >>= 1; byteValue & mask && (significand += 1 / divisor), divisor *= 2); while (precisionBits -= startBit);

  return exponent == (bias << 1) + 1 ? significand ? NaN : signal ? -Infinity : +Infinity : (1 + signal * -2) * (exponent || significand ? !exponent ? Math.pow(2, -bias + 1) * significand : Math.pow(2, exponent - bias) * (1 + significand) : 0);
};

p.decodeInt = function (data, bits, signed) {
  var b = new this.Buffer(this.bigEndian, data),
      x = b.readBits(0, bits),
      max = Math.pow(2, bits);
  return signed && x >= max / 2 ? x - max : x;
};

const p2 = (p.Buffer = function (bigEndian, buffer) {
  this.bigEndian = bigEndian || 0, this.buffer = [], this.setBuffer(buffer);
}).prototype;

p2.readBits = function (start, length) {
  //shl fix: Henri Torgemane ~1996 (compressed by Jonas Raoni)
  function shl(a, b) {
    for (++b; --b; a = ((a %= 0x7fffffff + 1) & 0x40000000) == 0x40000000 ? a * 2 : (a - 0x40000000) * 2 + 0x7fffffff + 1);

    return a;
  }

  if (start < 0 || length <= 0) return 0;
  this.checkBuffer(start + length);

  for (var offsetLeft, offsetRight = start % 8, curByte = this.buffer.length - (start >> 3) - 1, lastByte = this.buffer.length + (-(start + length) >> 3), diff = curByte - lastByte, sum = (this.buffer[curByte] >> offsetRight & (1 << (diff ? 8 - offsetRight : length)) - 1) + (diff && (offsetLeft = (start + length) % 8) ? (this.buffer[lastByte++] & (1 << offsetLeft) - 1) << (diff-- << 3) - offsetRight : 0); diff; sum += shl(this.buffer[lastByte++], (diff-- << 3) - offsetRight));

  return sum;
};

p2.setBuffer = function (data) {
  if (data) {
    for (var l, i = l = data.length, b = this.buffer = new Array(l); i; b[l - i] = data.charCodeAt(--i));

    this.bigEndian && b.reverse();
  }
};

p2.hasNeededBits = function (neededBits) {
  return this.buffer.length >= -(-neededBits >> 3);
};

p2.checkBuffer = function (neededBits) {
  if (!this.hasNeededBits(neededBits)) throw new Error("checkBuffer::missing bytes");
};

p.warn = function (msg) {
  if (this.allowExceptions) throw new Error(msg);
  return 1;
};

p.toSmall = function (data) {
  return this.decodeInt(data, 8, true);
};

p.fromSmall = function (number) {
  return this.encodeInt(number, 8, true);
};

p.toByte = function (data) {
  return this.decodeInt(data, 8, false);
};

p.fromByte = function (number) {
  return this.encodeInt(number, 8, false);
};

p.toShort = function (data) {
  return this.decodeInt(data, 16, true);
};

p.fromShort = function (number) {
  return this.encodeInt(number, 16, true);
};

p.toWord = function (data) {
  return this.decodeInt(data, 16, false);
};

p.fromWord = function (number) {
  return this.encodeInt(number, 16, false);
};

p.toInt = function (data) {
  return this.decodeInt(data, 32, true);
};

p.fromInt = function (number) {
  return this.encodeInt(number, 32, true);
};

p.toDWord = function (data) {
  return this.decodeInt(data, 32, false);
};

p.fromDWord = function (number) {
  return this.encodeInt(number, 32, false);
};

p.toFloat = function (data) {
  return this.decodeFloat(data, 23, 8);
};

p.fromFloat = function (number) {
  return this.encodeFloat(number, 23, 8);
};

p.toDouble = function (data) {
  return this.decodeFloat(data, 52, 11);
};

p.fromDouble = function (number) {
  return this.encodeFloat(number, 52, 11);
};

const _supportedEncoding = ['ascii', 'utf8', 'utf16le', 'utf16be', 'ucs2', 'base64', 'latin1', 'binary', 'hex'];
/*global Buffer*/

let _Buffer = null;

if (typeof Buffer !== 'undefined') {
  _Buffer = Buffer;
} else {
  const allowException = true;

  const _beParser = new BinaryParser(true, allowException);

  const _leParser = new BinaryParser(false, allowException);

  class Buffer {
    constructor() {
      this._data = null;
    }

    static from(array, byteOffset = 0, length = null) {
      const buf = new Buffer();

      if (Array.isArray(array)) {
        const ab = new ArrayBuffer(array);
        buf._data = new DataView(ab.buffer, byteOffset, length);
      } else if (array instanceof ArrayBuffer) {
        buf._data = new DataView(array, byteOffset, length);
      } else if (array.buffer instanceof ArrayBuffer) {
        buf._data = new DataView(array.buffer, byteOffset, length);
      }

      if (buf._data === null) {
        throw new Error(`Buffer.from: unsupported data type: ${array}`);
      }

      return buf;
    }

    readIntBE(offset, byteLength, noAssert = false) {
      switch (byteLength) {
        case 1:
          return this.readInt8(offset, noAssert);

        case 2:
          return this.readInt16BE(offset, noAssert);

        case 4:
          return this.readInt32BE(offset, noAssert);
      }

      const data = this.slice(offset, offset + byteLength)._data;

      return _beParser.decodeInt(data, byteLength * 8, true);
    }

    readIntLE(offset, byteLength, noAssert = false) {
      switch (byteLength) {
        case 1:
          return this.readInt8(offset, noAssert);

        case 2:
          return this.readInt16LE(offset, noAssert);

        case 4:
          return this.readInt32LE(offset, noAssert);
      }

      const data = this.slice(offset, offset + byteLength)._data;

      return _leParser.decodeInt(data, byteLength * 8, true);
    }

    readInt8(offset, noAssert = false) {
      return this._data.getInt8(offset);
    }

    readInt16BE(offset, noAssert = false) {
      return this._data.getInt16(offset, false);
    }

    readInt16LE(offset, noAssert = false) {
      return this._data.getInt16(offset, true);
    }

    readInt32BE(offset, noAssert = false) {
      return this._data.getInt32(offset, false);
    }

    readInt32LE(offset, noAssert = false) {
      return this._data.getInt32(offset, true);
    }

    readUIntBE(offset, byteLength, noAssert = false) {
      switch (byteLength) {
        case 1:
          return this.readUInt8(offset, noAssert);

        case 2:
          return this.readUInt16BE(offset, noAssert);

        case 4:
          return this.readUInt32BE(offset, noAssert);
      }

      const data = this.slice(offset, offset + byteLength)._data;

      return _beParser.decodeInt(data, byteLength * 8, false);
    }

    readUIntLE(offset, byteLength, noAssert = false) {
      switch (byteLength) {
        case 1:
          return this.readUInt8(offset, noAssert);

        case 2:
          return this.readUInt16LE(offset, noAssert);

        case 4:
          return this.readUInt32LE(offset, noAssert);
      }

      const data = this.slice(offset, offset + byteLength)._data;

      return _leParser.decodeInt(data, byteLength * 8, false);
    }

    readUInt8(offset, noAssert = false) {
      return this._data.getUint8(offset);
    }

    readUInt16BE(offset, noAssert = false) {
      return this._data.getUint16(offset, false);
    }

    readUInt16LE(offset, noAssert = false) {
      return this._data.getUint16(offset, true);
    }

    readUInt32BE(offset, noAssert = false) {
      return this._data.getUint32(offset, false);
    }

    readUInt32LE(offset, noAssert = false) {
      return this._data.getUint32(offset, true);
    }

    readFloatBE(offset, noAssert = false) {
      return this._data.getFloat32(offset, false);
    }

    readFloatLE(offset, noAssert = false) {
      return this._data.getFloat32(offset, true);
    }

    readDoubleBE(offset, noAssert = false) {
      return this._data.getFloat64(offset, false);
    }

    readDoubleLE(offset, noAssert = false) {
      return this._data.getFloat64(offset, true);
    }

    slice(start, end) {
      return new Buffer(this._data.buffer.slice(start, end));
    }

    toString(encoding, start, end) {
      if (!Buffer.isEncoding(encoding)) {
        throw new Error(`unsupported encoding: ${encoding}`);
      }

      const data = new Uint8Array(this._data.buffer);

      if (encoding === 'binary') {
        return String.fromCharCode.apply('', data);
      } else if (encoding === 'ascii' || encoding === 'latin1') {
        const len = data.indexOf(0);

        const _data = data.slice(0, len);

        return String.fromCharCode.apply('', _data);
      } else if (encoding === 'hex') {
        return this._hex(data, false);
      } else if (encoding === 'base64') {
        const str = String.fromCharCode.apply('', data);

        if (typeof atob === 'function') {
          return atob(str);
        }

        throw new Error('needs atob() function to convert to base64');
      }

      let str = '';

      if (encoding === 'utf16be') {
        str = this._hexBE(data, true);
      } else {
        str = this._hex(data, true);
      }

      if (encoding === 'utf8') {
        return UnescapeUTF8(str);
      } else if (encoding === 'utf16le' || encoding === 'utf16be' || encoding === 'ucs2') {
        return UnescapeUTF16LE(str);
      }

      throw new Error(`unsupported encoding: ${encoding}`);
    }

    _hexBE(data, usePercent) {
      const length = data.length;
      let hexArray = [];

      for (let i = 0; i < length; i += 2) {
        const num1 = data[i + 1].toString(16);

        if (data[i + 1] < 16) {
          hexArray[i] = '0' + num1;
        } else {
          hexArray[i] = num1;
        }

        const num2 = data[i].toString(16);

        if (data[i] < 16) {
          hexArray[i + 1] = '0' + num2;
        } else {
          hexArray[i + 1] = num2;
        }
      }

      let pad = '';

      if (usePercent) {
        pad = '%';
      }

      return hexArray.join(pad);
    }

    _hex(data, usePercent) {
      const hexArray = data.map(num => {
        if (num < 16) {
          return '0' + num.toString(16);
        }

        return num.toString(16);
      });
      let pad = '';

      if (usePercent) {
        pad = '%';
      }

      return hexArray.join(pad);
    }

    get length() {
      return this._data.byteLength;
    }

    static isEncoding(encoding) {
      return _supportedEncoding.indexOf(encoding) >= 0;
    }

  }

  _Buffer = Buffer;
}

var _Buffer$1 = _Buffer;

/*global HTMLCanvasElement*/

let _HTMLCanvasElement = null;

if (typeof HTMLCanvasElement !== 'undefined') {
  _HTMLCanvasElement = HTMLCanvasElement;
} else {
  class HTMLCanvasElement {
    getContext(name, opt) {
      throw new Error('getContext is not implemented');
    }

  }

  _HTMLCanvasElement = HTMLCanvasElement;
}

var _HTMLCanvasElement$1 = _HTMLCanvasElement;

/**
 * @access private
 * @type {string}
 */

const vsText = `#version 300 es
  precision mediump float;

  out vec3 position;

  void main() {
    position = vec3(0, 0, 0);
    gl_Position = vec4(0, 0, 0, 0);
  }
`;
/**
 * @access private
 * @type {string}
 */

const fsText = `#version 300 es
  precision mediump float;
  precision highp sampler2DShadow;

  in vec3 position;
  out vec4 outColor;

  void main() {
    outColor = vec4(1, 1, 1, 1);
  }
`;
/**
 * Check if the browser can use WebGL2.
 * @access public
 * @type {function(): boolean}
 * @returns {boolean} - true if the browser supports WebGL2.
 */

const CanUseWebGL2 = () => {
  const canvas = document.createElement('canvas');
  const opt = {
    alpha: true,
    depth: true,
    stencil: true,
    antialias: true,
    premultipliedAlpha: true,
    preserveDrawingBuffer: false
  };
  const gl = canvas.getContext('webgl2', opt);

  if (!gl) {
    console.log('canvas.getContext returns null');
    return false;
  }

  const vertexShader = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vertexShader, vsText);
  gl.compileShader(vertexShader);

  if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
    const info = gl.getShaderInfoLog(vertexShader);
    console.log(`vertexShader compile test error: ${info}`);
    return false;
  }

  const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fragmentShader, fsText);
  gl.compileShader(fragmentShader);

  if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
    const info = gl.getShaderInfoLog(fragmentShader);
    console.log(`fragmentShader compile test error: ${info}`);
    return false;
  }

  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);

  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    const info = gl.getProgramInfoLog(program);
    console.log(`program link test error: ${info}`);
    return false;
  }

  return true;
};

_ClassList.registerClass(NSColor, 'NSColor');

_ClassList.registerClass(NSColorSpaceModel, 'NSColorSpaceModel');

_ClassList.registerClass(AVAudioMixerNode, 'AVAudioMixerNode');

_ClassList.registerClass(AVAudioNode, 'AVAudioNode');

_ClassList.registerClass(CFAbsoluteTimeGetCurrent, 'CFAbsoluteTimeGetCurrent');

_ClassList.registerClass(CGBlendMode, 'CGBlendMode');

_ClassList.registerClass(CGLineCap, 'CGLineCap');

_ClassList.registerClass(CGLineJoin, 'CGLineJoin');

_ClassList.registerClass(CGMutablePath, 'CGMutablePath');

_ClassList.registerClass(CGPath, 'CGPath');

_ClassList.registerClass(CGPathApplierFunction, 'CGPathApplierFunction');

_ClassList.registerClass(CGPathFillRule, 'CGPathFillRule');

_ClassList.registerClass(CGPoint, 'CGPoint');

_ClassList.registerClass(CGRect, 'CGRect');

_ClassList.registerClass(CGSize, 'CGSize');

_ClassList.registerClass(CGVector, 'CGVector');

_ClassList.registerClass(DispatchObject, 'DispatchObject');

_ClassList.registerClass(DispatchQueue, 'DispatchQueue');

_ClassList.registerClass(DispatchTime, 'DispatchTime');

_ClassList.registerClass(DispatchTimeInterval, 'DispatchTimeInterval');

_ClassList.registerClass(NotificationCenter, 'NotificationCenter');

_ClassList.registerClass(NSArray, 'NSArray');

_ClassList.registerClass(NSCoder, 'NSCoder');

_ClassList.registerClass(NSColorSpace, 'NSColorSpace');

_ClassList.registerClass(NSData, 'NSData');

_ClassList.registerClass(NSDictionary, 'NSDictionary');

_ClassList.registerClass(NSKeyedArchiver, 'NSKeyedArchiver');

_ClassList.registerClass(NSKeyedUnarchiver, 'NSKeyedUnarchiver');

_ClassList.registerClass(NSMutableArray, 'NSMutableArray');

_ClassList.registerClass(NSMutableData, 'NSMutableData');

_ClassList.registerClass(NSMutableDictionary, 'NSMutableDictionary');

_ClassList.registerClass(NSNotification, 'NSNotification');

_ClassList.registerClass(NSURL, 'NSURL');

_ClassList.registerClass(NSValue, 'NSValue');

_ClassList.registerClass(GCController, 'GCController');

_ClassList.registerClass(GCControllerAxisInput, 'GCControllerAxisInput');

_ClassList.registerClass(GCControllerButtonInput, 'GCControllerButtonInput');

_ClassList.registerClass(GCControllerDirectionPad, 'GCControllerDirectionPad');

_ClassList.registerClass(GCControllerElement, 'GCControllerElement');

_ClassList.registerClass(GCExtendedGamepad, 'GCExtendedGamepad');

_ClassList.registerClass(GCGamepad, 'GCGamepad');

_ClassList.registerClass(GCMicroGamepad, 'GCMicroGamepad');

_ClassList.registerClass(GKAgent, 'GKAgent');

_ClassList.registerClass(GKAgent2D, 'GKAgent2D');

_ClassList.registerClass(GKAgentDelegate, 'GKAgentDelegate');

_ClassList.registerClass(GKBehavior, 'GKBehavior');

_ClassList.registerClass(GKComponent, 'GKComponent');

_ClassList.registerClass(GKEntity, 'GKEntity');

_ClassList.registerClass(GKGoal, 'GKGoal');

_ClassList.registerClass(GKPath, 'GKPath');

_ClassList.registerClass(GKScene, 'GKScene');

_ClassList.registerClass(GKSCNNodeComponent, 'GKSCNNodeComponent');

_ClassList.registerClass(MTLTessellationPartitionMode, 'MTLTessellationPartitionMode');

_ClassList.registerClass(NSObject, 'NSObject');

_ClassList.registerClass(CAAction, 'CAAction');

_ClassList.registerClass(CAAnimation, 'CAAnimation');

_ClassList.registerClass(CAAnimationDelegate, 'CAAnimationDelegate');

_ClassList.registerClass(CAAnimationGroup, 'CAAnimationGroup');

_ClassList.registerClass(CABasicAnimation, 'CABasicAnimation');

_ClassList.registerClass(CACodingProxy, 'CACodingProxy');

_ClassList.registerClass(CACurrentMediaTime, 'CACurrentMediaTime');

_ClassList.registerClass(CAKeyframeAnimation, 'CAKeyframeAnimation');

_ClassList.registerClass(CAMediaTiming, 'CAMediaTiming');

_ClassList.registerClass(CAMediaTimingFunction, 'CAMediaTimingFunction');

_ClassList.registerClass(CAPropertyAnimation, 'CAPropertyAnimation');

_ClassList.registerClass(CATransform3D, 'CATransform3D');

_ClassList.registerClass(LKNSArrayCodingProxy, 'LKNSArrayCodingProxy');

_ClassList.registerClass(LKNSValueCodingProxy, 'LKNSValueCodingProxy');

_ClassList.registerClass(_SCNDefaultFragmentShader, '_SCNDefaultFragmentShader');

_ClassList.registerClass(_SCNDefaultHitTestFragmentShader, '_SCNDefaultHitTestFragmentShader');

_ClassList.registerClass(_SCNDefaultHitTestVertexShader, '_SCNDefaultHitTestVertexShader');

_ClassList.registerClass(_SCNDefaultParticleFragmentShader, '_SCNDefaultParticleFragmentShader');

_ClassList.registerClass(_SCNDefaultParticleVertexShader, '_SCNDefaultParticleVertexShader');

_ClassList.registerClass(_SCNDefaultPBRFragmentShader, '_SCNDefaultPBRFragmentShader');

_ClassList.registerClass(_SCNDefaultShadowFragmentShader, '_SCNDefaultShadowFragmentShader');

_ClassList.registerClass(_SCNDefaultShadowVertexShader, '_SCNDefaultShadowVertexShader');

_ClassList.registerClass(_SCNDefaultVertexShader, '_SCNDefaultVertexShader');

_ClassList.registerClass(_SCNMtlLoader, '_SCNMtlLoader');

_ClassList.registerClass(_SCNObjLoader, '_SCNObjLoader');

_ClassList.registerClass(SCNAccelerationConstraint, 'SCNAccelerationConstraint');

_ClassList.registerClass(SCNAction, 'SCNAction');

_ClassList.registerClass(SCNActionable, 'SCNActionable');

_ClassList.registerClass(SCNActionCustom, 'SCNActionCustom');

_ClassList.registerClass(SCNActionFade, 'SCNActionFade');

_ClassList.registerClass(SCNActionGroup, 'SCNActionGroup');

_ClassList.registerClass(SCNActionHide, 'SCNActionHide');

_ClassList.registerClass(SCNActionJavaScript, 'SCNActionJavaScript');

_ClassList.registerClass(SCNActionMove, 'SCNActionMove');

_ClassList.registerClass(SCNActionPerformSelector, 'SCNActionPerformSelector');

_ClassList.registerClass(SCNActionPlaySound, 'SCNActionPlaySound');

_ClassList.registerClass(SCNActionReference, 'SCNActionReference');

_ClassList.registerClass(SCNActionRemove, 'SCNActionRemove');

_ClassList.registerClass(SCNActionRepeat, 'SCNActionRepeat');

_ClassList.registerClass(SCNActionRotate, 'SCNActionRotate');

_ClassList.registerClass(SCNActionRunAction, 'SCNActionRunAction');

_ClassList.registerClass(SCNActionRunBlock, 'SCNActionRunBlock');

_ClassList.registerClass(SCNActionScale, 'SCNActionScale');

_ClassList.registerClass(SCNActionSequence, 'SCNActionSequence');

_ClassList.registerClass(SCNActionTimingFunction, 'SCNActionTimingFunction');

_ClassList.registerClass(SCNActionTimingMode, 'SCNActionTimingMode');

_ClassList.registerClass(SCNActionWait, 'SCNActionWait');

_ClassList.registerClass(SCNAnimatable, 'SCNAnimatable');

_ClassList.registerClass(SCNAnimation, 'SCNAnimation');

_ClassList.registerClass(SCNAnimationEvent, 'SCNAnimationEvent');

_ClassList.registerClass(SCNAnimationEventBlock, 'SCNAnimationEventBlock');

_ClassList.registerClass(SCNAnimationPlayer, 'SCNAnimationPlayer');

_ClassList.registerClass(SCNAntialiasingMode, 'SCNAntialiasingMode');

_ClassList.registerClass(SCNAudioPlayer, 'SCNAudioPlayer');

_ClassList.registerClass(SCNAudioSource, 'SCNAudioSource');

_ClassList.registerClass(SCNBillboardAxis, 'SCNBillboardAxis');

_ClassList.registerClass(SCNBillboardConstraint, 'SCNBillboardConstraint');

_ClassList.registerClass(SCNBindingBlock, 'SCNBindingBlock');

_ClassList.registerClass(SCNBlendMode, 'SCNBlendMode');

_ClassList.registerClass(SCNBoundingVolume, 'SCNBoundingVolume');

_ClassList.registerClass(SCNBox, 'SCNBox');

_ClassList.registerClass(SCNBufferBindingBlock, 'SCNBufferBindingBlock');

_ClassList.registerClass(SCNBufferFrequency, 'SCNBufferFrequency');

_ClassList.registerClass(SCNBufferStream, 'SCNBufferStream');

_ClassList.registerClass(SCNCamera, 'SCNCamera');

_ClassList.registerClass(SCNCameraProjectionDirection, 'SCNCameraProjectionDirection');

_ClassList.registerClass(SCNCapsule, 'SCNCapsule');

_ClassList.registerClass(SCNChamferMode, 'SCNChamferMode');

_ClassList.registerClass(SCNColorMask, 'SCNColorMask');

_ClassList.registerClass(SCNCone, 'SCNCone');

_ClassList.registerClass(SCNConstraint, 'SCNConstraint');

_ClassList.registerClass(SCNCullMode, 'SCNCullMode');

_ClassList.registerClass(SCNCylinder, 'SCNCylinder');

_ClassList.registerClass(SCNDebugOptions, 'SCNDebugOptions');

_ClassList.registerClass(SCNDistanceConstraint, 'SCNDistanceConstraint');

_ClassList.registerClass(SCNFieldForceEvaluator, 'SCNFieldForceEvaluator');

_ClassList.registerClass(SCNFillMode, 'SCNFillMode');

_ClassList.registerClass(SCNFilterMode, 'SCNFilterMode');

_ClassList.registerClass(SCNFloor, 'SCNFloor');

_ClassList.registerClass(SCNGeometry, 'SCNGeometry');

_ClassList.registerClass(SCNGeometryElement, 'SCNGeometryElement');

_ClassList.registerClass(SCNGeometryPrimitiveType, 'SCNGeometryPrimitiveType');

_ClassList.registerClass(SCNGeometrySource, 'SCNGeometrySource');

_ClassList.registerClass(SCNGeometryTessellator, 'SCNGeometryTessellator');

_ClassList.registerClass(SCNHitTestOption, 'SCNHitTestOption');

_ClassList.registerClass(SCNHitTestResult, 'SCNHitTestResult');

_ClassList.registerClass(SCNIKConstraint, 'SCNIKConstraint');

_ClassList.registerClass(SCNLayer, 'SCNLayer');

_ClassList.registerClass(SCNLevelOfDetail, 'SCNLevelOfDetail');

_ClassList.registerClass(SCNLight, 'SCNLight');

_ClassList.registerClass(SCNLookAtConstraint, 'SCNLookAtConstraint');

_ClassList.registerClass(SCNMaterial, 'SCNMaterial');

_ClassList.registerClass(SCNMaterialProperty, 'SCNMaterialProperty');

_ClassList.registerClass(SCNMatrix4, 'SCNMatrix4');

_ClassList.registerClass(SCNMatrix4EqualToMatrix4, 'SCNMatrix4EqualToMatrix4');

_ClassList.registerClass(SCNMatrix4FromGLKMatrix4, 'SCNMatrix4FromGLKMatrix4');

_ClassList.registerClass(SCNMatrix4FromMat4, 'SCNMatrix4FromMat4');

_ClassList.registerClass(SCNMatrix4Invert, 'SCNMatrix4Invert');

_ClassList.registerClass(SCNMatrix4IsIdentity, 'SCNMatrix4IsIdentity');

_ClassList.registerClass(SCNMatrix4MakeRotation, 'SCNMatrix4MakeRotation');

_ClassList.registerClass(SCNMatrix4MakeScale, 'SCNMatrix4MakeScale');

_ClassList.registerClass(SCNMatrix4MakeTranslation, 'SCNMatrix4MakeTranslation');

_ClassList.registerClass(SCNMatrix4Mult, 'SCNMatrix4Mult');

_ClassList.registerClass(SCNMatrix4Rotate, 'SCNMatrix4Rotate');

_ClassList.registerClass(SCNMatrix4Scale, 'SCNMatrix4Scale');

_ClassList.registerClass(SCNMatrix4ToGLKMatrix4, 'SCNMatrix4ToGLKMatrix4');

_ClassList.registerClass(SCNMatrix4ToMat4, 'SCNMatrix4ToMat4');

_ClassList.registerClass(SCNMatrix4Translate, 'SCNMatrix4Translate');

_ClassList.registerClass(SCNMorpher, 'SCNMorpher');

_ClassList.registerClass(SCNMorpherCalculationMode, 'SCNMorpherCalculationMode');

_ClassList.registerClass(SCNMovabilityHint, 'SCNMovabilityHint');

_ClassList.registerClass(SCNNode, 'SCNNode');

_ClassList.registerClass(SCNNodeRendererDelegate, 'SCNNodeRendererDelegate');

_ClassList.registerClass(SCNOrderedDictionary, 'SCNOrderedDictionary');

_ClassList.registerClass(SCNParticleBirthDirection, 'SCNParticleBirthDirection');

_ClassList.registerClass(SCNParticleBirthLocation, 'SCNParticleBirthLocation');

_ClassList.registerClass(SCNParticleBlendMode, 'SCNParticleBlendMode');

_ClassList.registerClass(SCNParticleEvent, 'SCNParticleEvent');

_ClassList.registerClass(SCNParticleEventBlock, 'SCNParticleEventBlock');

_ClassList.registerClass(SCNParticleImageSequenceAnimationMode, 'SCNParticleImageSequenceAnimationMode');

_ClassList.registerClass(SCNParticleInputMode, 'SCNParticleInputMode');

_ClassList.registerClass(SCNParticleModifierBlock, 'SCNParticleModifierBlock');

_ClassList.registerClass(SCNParticleModifierStage, 'SCNParticleModifierStage');

_ClassList.registerClass(SCNParticleOrientationMode, 'SCNParticleOrientationMode');

_ClassList.registerClass(SCNParticlePropertyController, 'SCNParticlePropertyController');

_ClassList.registerClass(SCNParticleSortingMode, 'SCNParticleSortingMode');

_ClassList.registerClass(SCNParticleSystem, 'SCNParticleSystem');

_ClassList.registerClass(SCNPhysicsBallSocketJoint, 'SCNPhysicsBallSocketJoint');

_ClassList.registerClass(SCNPhysicsBehavior, 'SCNPhysicsBehavior');

_ClassList.registerClass(SCNPhysicsBody, 'SCNPhysicsBody');

_ClassList.registerClass(SCNPhysicsBodyType, 'SCNPhysicsBodyType');

_ClassList.registerClass(SCNPhysicsCollisionCategory, 'SCNPhysicsCollisionCategory');

_ClassList.registerClass(SCNPhysicsContact, 'SCNPhysicsContact');

_ClassList.registerClass(SCNPhysicsContactDelegate, 'SCNPhysicsContactDelegate');

_ClassList.registerClass(SCNPhysicsField, 'SCNPhysicsField');

_ClassList.registerClass(SCNPhysicsFieldScope, 'SCNPhysicsFieldScope');

_ClassList.registerClass(SCNPhysicsHingeJoint, 'SCNPhysicsHingeJoint');

_ClassList.registerClass(SCNPhysicsNoiseField, 'SCNPhysicsNoiseField');

_ClassList.registerClass(SCNPhysicsShape, 'SCNPhysicsShape');

_ClassList.registerClass(SCNPhysicsSliderJoint, 'SCNPhysicsSliderJoint');

_ClassList.registerClass(SCNPhysicsTurbulenceField, 'SCNPhysicsTurbulenceField');

_ClassList.registerClass(SCNPhysicsVehicle, 'SCNPhysicsVehicle');

_ClassList.registerClass(SCNPhysicsVehicleWheel, 'SCNPhysicsVehicleWheel');

_ClassList.registerClass(SCNPhysicsWorld, 'SCNPhysicsWorld');

_ClassList.registerClass(SCNPlane, 'SCNPlane');

_ClassList.registerClass(SCNProgram, 'SCNProgram');

_ClassList.registerClass(SCNProgramDelegate, 'SCNProgramDelegate');

_ClassList.registerClass(SCNPyramid, 'SCNPyramid');

_ClassList.registerClass(SCNQuaternion, 'SCNQuaternion');

_ClassList.registerClass(SCNReferenceLoadingPolicy, 'SCNReferenceLoadingPolicy');

_ClassList.registerClass(SCNReferenceNode, 'SCNReferenceNode');

_ClassList.registerClass(SCNRenderer, 'SCNRenderer');

_ClassList.registerClass(SCNRenderingAPI, 'SCNRenderingAPI');

_ClassList.registerClass(SCNScene, 'SCNScene');

_ClassList.registerClass(SCNSceneExportDelegate, 'SCNSceneExportDelegate');

_ClassList.registerClass(SCNSceneExportProgressHandler, 'SCNSceneExportProgressHandler');

_ClassList.registerClass(SCNSceneRenderer, 'SCNSceneRenderer');

_ClassList.registerClass(SCNSceneRendererDelegate, 'SCNSceneRendererDelegate');

_ClassList.registerClass(SCNSceneSource, 'SCNSceneSource');

_ClassList.registerClass(SCNSceneSourceStatus, 'SCNSceneSourceStatus');

_ClassList.registerClass(SCNSceneSourceStatusHandler, 'SCNSceneSourceStatusHandler');

_ClassList.registerClass(SCNShadable, 'SCNShadable');

_ClassList.registerClass(SCNShadableHelper, 'SCNShadableHelper');

_ClassList.registerClass(SCNShaderModifierEntryPoint, 'SCNShaderModifierEntryPoint');

_ClassList.registerClass(SCNShadowMode, 'SCNShadowMode');

_ClassList.registerClass(SCNShape, 'SCNShape');

_ClassList.registerClass(SCNSkinner, 'SCNSkinner');

_ClassList.registerClass(SCNSphere, 'SCNSphere');

_ClassList.registerClass(SCNTechnique, 'SCNTechnique');

_ClassList.registerClass(SCNTechniqueSupport, 'SCNTechniqueSupport');

_ClassList.registerClass(SCNTessellationSmoothingMode, 'SCNTessellationSmoothingMode');

_ClassList.registerClass(SCNText, 'SCNText');

_ClassList.registerClass(SCNTimingFunction, 'SCNTimingFunction');

_ClassList.registerClass(SCNTorus, 'SCNTorus');

_ClassList.registerClass(SCNTransaction, 'SCNTransaction');

_ClassList.registerClass(SCNTransformConstraint, 'SCNTransformConstraint');

_ClassList.registerClass(SCNTransparencyMode, 'SCNTransparencyMode');

_ClassList.registerClass(SCNTube, 'SCNTube');

_ClassList.registerClass(SCNVector3, 'SCNVector3');

_ClassList.registerClass(SCNVector3EqualToVector3, 'SCNVector3EqualToVector3');

_ClassList.registerClass(SCNVector3FromFloat3, 'SCNVector3FromFloat3');

_ClassList.registerClass(SCNVector3FromGLKVector3, 'SCNVector3FromGLKVector3');

_ClassList.registerClass(SCNVector3Make, 'SCNVector3Make');

_ClassList.registerClass(SCNVector3ToFloat3, 'SCNVector3ToFloat3');

_ClassList.registerClass(SCNVector3ToGLKVector3, 'SCNVector3ToGLKVector3');

_ClassList.registerClass(SCNVector3Zero, 'SCNVector3Zero');

_ClassList.registerClass(SCNVector4, 'SCNVector4');

_ClassList.registerClass(SCNVector4EqualToVector4, 'SCNVector4EqualToVector4');

_ClassList.registerClass(SCNVector4FromFloat4, 'SCNVector4FromFloat4');

_ClassList.registerClass(SCNVector4FromGLKVector4, 'SCNVector4FromGLKVector4');

_ClassList.registerClass(SCNVector4Make, 'SCNVector4Make');

_ClassList.registerClass(SCNVector4ToFloat4, 'SCNVector4ToFloat4');

_ClassList.registerClass(SCNVector4ToGLKVector4, 'SCNVector4ToGLKVector4');

_ClassList.registerClass(SCNView, 'SCNView');

_ClassList.registerClass(SCNWrapMode, 'SCNWrapMode');

_ClassList.registerClass(SKAction, 'SKAction');

_ClassList.registerClass(SKActionTimingMode, 'SKActionTimingMode');

_ClassList.registerClass(SKBlendMode, 'SKBlendMode');

_ClassList.registerClass(SKColor, 'SKColor');

_ClassList.registerClass(SKEffectNode, 'SKEffectNode');

_ClassList.registerClass(SKFade, 'SKFade');

_ClassList.registerClass(SKGroup, 'SKGroup');

_ClassList.registerClass(SKLabelHorizontalAlignmentMode, 'SKLabelHorizontalAlignmentMode');

_ClassList.registerClass(SKLabelNode, 'SKLabelNode');

_ClassList.registerClass(SKLabelVerticalAlignmentMode, 'SKLabelVerticalAlignmentMode');

_ClassList.registerClass(SKNode, 'SKNode');

_ClassList.registerClass(SKRepeat, 'SKRepeat');

_ClassList.registerClass(SKScale, 'SKScale');

_ClassList.registerClass(SKScene, 'SKScene');

_ClassList.registerClass(SKSceneScaleMode, 'SKSceneScaleMode');

_ClassList.registerClass(SKSequence, 'SKSequence');

_ClassList.registerClass(SKShapeNode, 'SKShapeNode');

_ClassList.registerClass(SKSpriteNode, 'SKSpriteNode');

_ClassList.registerClass(SKTexture, 'SKTexture');

_ClassList.registerClass(SKTextureFilteringMode, 'SKTextureFilteringMode');

_ClassList.registerClass(SKWait, 'SKWait');

/*global exports*/
// 

const kCAFillModeRemoved$1 = 'removed';
const kCAFillModeForwards$1 = 'forwards';
const kCAFillModeBackwards$1 = 'backwards';
const kCAFillModeBoth$1 = 'both'; // 

const kCAMediaTimingFunctionLinear$1 = 'linear';
const kCAMediaTimingFunctionEaseIn$1 = 'easeIn';
const kCAMediaTimingFunctionEaseOut$1 = 'easeOut';
const kCAMediaTimingFunctionEaseInEaseOut$1 = 'easeInEaseOut';
const kCAMediaTimingFunctionDefault$1 = 'default'; // Value calculation modes

const kCAAnimationLinear$1 = 'linear';
const kCAAnimationDiscrete$1 = 'discrete';
const kCAAnimationPaced$1 = 'paced';
const kCAAnimationCubic$1 = 'cubic';
const kCAAnimationCubicPaced$1 = 'cubicPaced'; // Rotation Mode Values

const kCAAnimationRotateAuto$1 = 'auto';
const kCAAnimationRotateAutoReverse$1 = 'autoReverse';

exports.NSColor = NSColor;
exports.NSColorSpaceModel = NSColorSpaceModel;
exports.AVAudioMixerNode = AVAudioMixerNode;
exports.AVAudioNode = AVAudioNode;
exports.CFAbsoluteTimeGetCurrent = CFAbsoluteTimeGetCurrent;
exports.CGBlendMode = CGBlendMode;
exports.CGLineCap = CGLineCap;
exports.CGLineJoin = CGLineJoin;
exports.CGMutablePath = CGMutablePath;
exports.CGPath = CGPath;
exports.CGPathApplierFunction = CGPathApplierFunction;
exports.CGPathFillRule = CGPathFillRule;
exports.CGPoint = CGPoint;
exports.CGRect = CGRect;
exports.CGSize = CGSize;
exports.CGVector = CGVector;
exports.DispatchObject = DispatchObject;
exports.DispatchQueue = DispatchQueue;
exports.DispatchTime = DispatchTime;
exports.DispatchTimeInterval = DispatchTimeInterval;
exports.NotificationCenter = NotificationCenter;
exports.NSArray = NSArray;
exports.NSCoder = NSCoder;
exports.NSColorSpace = NSColorSpace;
exports.NSData = NSData;
exports.NSDictionary = NSDictionary;
exports.NSKeyedArchiver = NSKeyedArchiver;
exports.NSKeyedUnarchiver = NSKeyedUnarchiver;
exports.NSMutableArray = NSMutableArray;
exports.NSMutableData = NSMutableData;
exports.NSMutableDictionary = NSMutableDictionary;
exports.NSNotification = NSNotification;
exports.NSURL = NSURL;
exports.NSValue = NSValue;
exports.GCController = GCController;
exports.GCControllerAxisInput = GCControllerAxisInput;
exports.GCControllerButtonInput = GCControllerButtonInput;
exports.GCControllerDirectionPad = GCControllerDirectionPad;
exports.GCControllerElement = GCControllerElement;
exports.GCExtendedGamepad = GCExtendedGamepad;
exports.GCGamepad = GCGamepad;
exports.GCMicroGamepad = GCMicroGamepad;
exports.GKAgent = GKAgent;
exports.GKAgent2D = GKAgent2D;
exports.GKAgentDelegate = GKAgentDelegate;
exports.GKBehavior = GKBehavior;
exports.GKComponent = GKComponent;
exports.GKEntity = GKEntity;
exports.GKGoal = GKGoal;
exports.GKPath = GKPath;
exports.GKScene = GKScene;
exports.GKSCNNodeComponent = GKSCNNodeComponent;
exports.MTLTessellationPartitionMode = MTLTessellationPartitionMode;
exports.NSObject = NSObject;
exports.CAAction = CAAction;
exports.CAAnimation = CAAnimation;
exports.CAAnimationDelegate = CAAnimationDelegate;
exports.CAAnimationGroup = CAAnimationGroup;
exports.CABasicAnimation = CABasicAnimation;
exports.CACodingProxy = CACodingProxy;
exports.CACurrentMediaTime = CACurrentMediaTime;
exports.CAKeyframeAnimation = CAKeyframeAnimation;
exports.CAMediaTiming = CAMediaTiming;
exports.CAMediaTimingFunction = CAMediaTimingFunction;
exports.CAPropertyAnimation = CAPropertyAnimation;
exports.CATransform3D = CATransform3D;
exports.LKNSArrayCodingProxy = LKNSArrayCodingProxy;
exports.LKNSValueCodingProxy = LKNSValueCodingProxy;
exports._SCNDefaultFragmentShader = _SCNDefaultFragmentShader;
exports._SCNDefaultHitTestFragmentShader = _SCNDefaultHitTestFragmentShader;
exports._SCNDefaultHitTestVertexShader = _SCNDefaultHitTestVertexShader;
exports._SCNDefaultParticleFragmentShader = _SCNDefaultParticleFragmentShader;
exports._SCNDefaultParticleVertexShader = _SCNDefaultParticleVertexShader;
exports._SCNDefaultPBRFragmentShader = _SCNDefaultPBRFragmentShader;
exports._SCNDefaultShadowFragmentShader = _SCNDefaultShadowFragmentShader;
exports._SCNDefaultShadowVertexShader = _SCNDefaultShadowVertexShader;
exports._SCNDefaultVertexShader = _SCNDefaultVertexShader;
exports._SCNMtlLoader = _SCNMtlLoader;
exports._SCNObjLoader = _SCNObjLoader;
exports.SCNAccelerationConstraint = SCNAccelerationConstraint;
exports.SCNAction = SCNAction;
exports.SCNActionable = SCNActionable;
exports.SCNActionCustom = SCNActionCustom;
exports.SCNActionFade = SCNActionFade;
exports.SCNActionGroup = SCNActionGroup;
exports.SCNActionHide = SCNActionHide;
exports.SCNActionJavaScript = SCNActionJavaScript;
exports.SCNActionMove = SCNActionMove;
exports.SCNActionPerformSelector = SCNActionPerformSelector;
exports.SCNActionPlaySound = SCNActionPlaySound;
exports.SCNActionReference = SCNActionReference;
exports.SCNActionRemove = SCNActionRemove;
exports.SCNActionRepeat = SCNActionRepeat;
exports.SCNActionRotate = SCNActionRotate;
exports.SCNActionRunAction = SCNActionRunAction;
exports.SCNActionRunBlock = SCNActionRunBlock;
exports.SCNActionScale = SCNActionScale;
exports.SCNActionSequence = SCNActionSequence;
exports.SCNActionTimingFunction = SCNActionTimingFunction;
exports.SCNActionTimingMode = SCNActionTimingMode;
exports.SCNActionWait = SCNActionWait;
exports.SCNAnimatable = SCNAnimatable;
exports.SCNAnimation = SCNAnimation;
exports.SCNAnimationEvent = SCNAnimationEvent;
exports.SCNAnimationEventBlock = SCNAnimationEventBlock;
exports.SCNAnimationPlayer = SCNAnimationPlayer;
exports.SCNAntialiasingMode = SCNAntialiasingMode;
exports.SCNAudioPlayer = SCNAudioPlayer;
exports.SCNAudioSource = SCNAudioSource;
exports.SCNBillboardAxis = SCNBillboardAxis;
exports.SCNBillboardConstraint = SCNBillboardConstraint;
exports.SCNBindingBlock = SCNBindingBlock;
exports.SCNBlendMode = SCNBlendMode;
exports.SCNBoundingVolume = SCNBoundingVolume;
exports.SCNBox = SCNBox;
exports.SCNBufferBindingBlock = SCNBufferBindingBlock;
exports.SCNBufferFrequency = SCNBufferFrequency;
exports.SCNBufferStream = SCNBufferStream;
exports.SCNCamera = SCNCamera;
exports.SCNCameraProjectionDirection = SCNCameraProjectionDirection;
exports.SCNCapsule = SCNCapsule;
exports.SCNChamferMode = SCNChamferMode;
exports.SCNColorMask = SCNColorMask;
exports.SCNCone = SCNCone;
exports.SCNConstraint = SCNConstraint;
exports.SCNCullMode = SCNCullMode;
exports.SCNCylinder = SCNCylinder;
exports.SCNDebugOptions = SCNDebugOptions;
exports.SCNDistanceConstraint = SCNDistanceConstraint;
exports.SCNFieldForceEvaluator = SCNFieldForceEvaluator;
exports.SCNFillMode = SCNFillMode;
exports.SCNFilterMode = SCNFilterMode;
exports.SCNFloor = SCNFloor;
exports.SCNGeometry = SCNGeometry;
exports.SCNGeometryElement = SCNGeometryElement;
exports.SCNGeometryPrimitiveType = SCNGeometryPrimitiveType;
exports.SCNGeometrySource = SCNGeometrySource;
exports.SCNGeometryTessellator = SCNGeometryTessellator;
exports.SCNHitTestOption = SCNHitTestOption;
exports.SCNHitTestResult = SCNHitTestResult;
exports.SCNIKConstraint = SCNIKConstraint;
exports.SCNLayer = SCNLayer;
exports.SCNLevelOfDetail = SCNLevelOfDetail;
exports.SCNLight = SCNLight;
exports.SCNLookAtConstraint = SCNLookAtConstraint;
exports.SCNMaterial = SCNMaterial;
exports.SCNMaterialProperty = SCNMaterialProperty;
exports.SCNMatrix4 = SCNMatrix4;
exports.SCNMatrix4EqualToMatrix4 = SCNMatrix4EqualToMatrix4;
exports.SCNMatrix4FromGLKMatrix4 = SCNMatrix4FromGLKMatrix4;
exports.SCNMatrix4FromMat4 = SCNMatrix4FromMat4;
exports.SCNMatrix4Invert = SCNMatrix4Invert;
exports.SCNMatrix4IsIdentity = SCNMatrix4IsIdentity;
exports.SCNMatrix4MakeRotation = SCNMatrix4MakeRotation;
exports.SCNMatrix4MakeScale = SCNMatrix4MakeScale;
exports.SCNMatrix4MakeTranslation = SCNMatrix4MakeTranslation;
exports.SCNMatrix4Mult = SCNMatrix4Mult;
exports.SCNMatrix4Rotate = SCNMatrix4Rotate;
exports.SCNMatrix4Scale = SCNMatrix4Scale;
exports.SCNMatrix4ToGLKMatrix4 = SCNMatrix4ToGLKMatrix4;
exports.SCNMatrix4ToMat4 = SCNMatrix4ToMat4;
exports.SCNMatrix4Translate = SCNMatrix4Translate;
exports.SCNMorpher = SCNMorpher;
exports.SCNMorpherCalculationMode = SCNMorpherCalculationMode;
exports.SCNMovabilityHint = SCNMovabilityHint;
exports.SCNNode = SCNNode;
exports.SCNNodeRendererDelegate = SCNNodeRendererDelegate;
exports.SCNOrderedDictionary = SCNOrderedDictionary;
exports.SCNParticleBirthDirection = SCNParticleBirthDirection;
exports.SCNParticleBirthLocation = SCNParticleBirthLocation;
exports.SCNParticleBlendMode = SCNParticleBlendMode;
exports.SCNParticleEvent = SCNParticleEvent;
exports.SCNParticleEventBlock = SCNParticleEventBlock;
exports.SCNParticleImageSequenceAnimationMode = SCNParticleImageSequenceAnimationMode;
exports.SCNParticleInputMode = SCNParticleInputMode;
exports.SCNParticleModifierBlock = SCNParticleModifierBlock;
exports.SCNParticleModifierStage = SCNParticleModifierStage;
exports.SCNParticleOrientationMode = SCNParticleOrientationMode;
exports.SCNParticlePropertyController = SCNParticlePropertyController;
exports.SCNParticleSortingMode = SCNParticleSortingMode;
exports.SCNParticleSystem = SCNParticleSystem;
exports.SCNPhysicsBallSocketJoint = SCNPhysicsBallSocketJoint;
exports.SCNPhysicsBehavior = SCNPhysicsBehavior;
exports.SCNPhysicsBody = SCNPhysicsBody;
exports.SCNPhysicsBodyType = SCNPhysicsBodyType;
exports.SCNPhysicsCollisionCategory = SCNPhysicsCollisionCategory;
exports.SCNPhysicsContact = SCNPhysicsContact;
exports.SCNPhysicsContactDelegate = SCNPhysicsContactDelegate;
exports.SCNPhysicsField = SCNPhysicsField;
exports.SCNPhysicsFieldScope = SCNPhysicsFieldScope;
exports.SCNPhysicsHingeJoint = SCNPhysicsHingeJoint;
exports.SCNPhysicsNoiseField = SCNPhysicsNoiseField;
exports.SCNPhysicsShape = SCNPhysicsShape;
exports.SCNPhysicsSliderJoint = SCNPhysicsSliderJoint;
exports.SCNPhysicsTurbulenceField = SCNPhysicsTurbulenceField;
exports.SCNPhysicsVehicle = SCNPhysicsVehicle;
exports.SCNPhysicsVehicleWheel = SCNPhysicsVehicleWheel;
exports.SCNPhysicsWorld = SCNPhysicsWorld;
exports.SCNPlane = SCNPlane;
exports.SCNProgram = SCNProgram;
exports.SCNProgramDelegate = SCNProgramDelegate;
exports.SCNPyramid = SCNPyramid;
exports.SCNQuaternion = SCNQuaternion;
exports.SCNReferenceLoadingPolicy = SCNReferenceLoadingPolicy;
exports.SCNReferenceNode = SCNReferenceNode;
exports.SCNRenderer = SCNRenderer;
exports.SCNRenderingAPI = SCNRenderingAPI;
exports.SCNScene = SCNScene;
exports.SCNSceneExportDelegate = SCNSceneExportDelegate;
exports.SCNSceneExportProgressHandler = SCNSceneExportProgressHandler;
exports.SCNSceneRenderer = SCNSceneRenderer;
exports.SCNSceneRendererDelegate = SCNSceneRendererDelegate;
exports.SCNSceneSource = SCNSceneSource;
exports.SCNSceneSourceStatus = SCNSceneSourceStatus;
exports.SCNSceneSourceStatusHandler = SCNSceneSourceStatusHandler;
exports.SCNShadable = SCNShadable;
exports.SCNShadableHelper = SCNShadableHelper;
exports.SCNShaderModifierEntryPoint = SCNShaderModifierEntryPoint;
exports.SCNShadowMode = SCNShadowMode;
exports.SCNShape = SCNShape;
exports.SCNSkinner = SCNSkinner;
exports.SCNSphere = SCNSphere;
exports.SCNTechnique = SCNTechnique;
exports.SCNTechniqueSupport = SCNTechniqueSupport;
exports.SCNTessellationSmoothingMode = SCNTessellationSmoothingMode;
exports.SCNText = SCNText;
exports.SCNTimingFunction = SCNTimingFunction;
exports.SCNTorus = SCNTorus;
exports.SCNTransaction = SCNTransaction;
exports.SCNTransformConstraint = SCNTransformConstraint;
exports.SCNTransparencyMode = SCNTransparencyMode;
exports.SCNTube = SCNTube;
exports.SCNVector3 = SCNVector3;
exports.SCNVector3EqualToVector3 = SCNVector3EqualToVector3;
exports.SCNVector3FromFloat3 = SCNVector3FromFloat3;
exports.SCNVector3FromGLKVector3 = SCNVector3FromGLKVector3;
exports.SCNVector3Make = SCNVector3Make;
exports.SCNVector3ToFloat3 = SCNVector3ToFloat3;
exports.SCNVector3ToGLKVector3 = SCNVector3ToGLKVector3;
exports.SCNVector3Zero = SCNVector3Zero;
exports.SCNVector4 = SCNVector4;
exports.SCNVector4EqualToVector4 = SCNVector4EqualToVector4;
exports.SCNVector4FromFloat4 = SCNVector4FromFloat4;
exports.SCNVector4FromGLKVector4 = SCNVector4FromGLKVector4;
exports.SCNVector4Make = SCNVector4Make;
exports.SCNVector4ToFloat4 = SCNVector4ToFloat4;
exports.SCNVector4ToGLKVector4 = SCNVector4ToGLKVector4;
exports.SCNView = SCNView;
exports.SCNWrapMode = SCNWrapMode;
exports.SKAction = SKAction;
exports.SKActionTimingMode = SKActionTimingMode;
exports.SKBlendMode = SKBlendMode;
exports.SKColor = SKColor;
exports.SKEffectNode = SKEffectNode;
exports.SKFade = SKFade;
exports.SKGroup = SKGroup;
exports.SKLabelHorizontalAlignmentMode = SKLabelHorizontalAlignmentMode;
exports.SKLabelNode = SKLabelNode;
exports.SKLabelVerticalAlignmentMode = SKLabelVerticalAlignmentMode;
exports.SKNode = SKNode;
exports.SKRepeat = SKRepeat;
exports.SKScale = SKScale;
exports.SKScene = SKScene;
exports.SKSceneScaleMode = SKSceneScaleMode;
exports.SKSequence = SKSequence;
exports.SKShapeNode = SKShapeNode;
exports.SKSpriteNode = SKSpriteNode;
exports.SKTexture = SKTexture;
exports.SKTextureFilteringMode = SKTextureFilteringMode;
exports.SKWait = SKWait;
exports._AjaxRequest = _AjaxRequest;
exports._BinaryReader = _BinaryReader;
exports._BinaryRequest = _BinaryRequest;
exports._Buffer = _Buffer$1;
exports._ClassList = _ClassList;
exports._File = File;
exports._FileReader = FileReader;
exports._HTMLCanvasElement = _HTMLCanvasElement$1;
exports._InstanceOf = _InstanceOf;
exports._TextReader = TextReader;
exports.CanUseWebGL2 = CanUseWebGL2;
exports.kCAFillModeRemoved = kCAFillModeRemoved$1;
exports.kCAFillModeForwards = kCAFillModeForwards$1;
exports.kCAFillModeBackwards = kCAFillModeBackwards$1;
exports.kCAFillModeBoth = kCAFillModeBoth$1;
exports.kCAMediaTimingFunctionLinear = kCAMediaTimingFunctionLinear$1;
exports.kCAMediaTimingFunctionEaseIn = kCAMediaTimingFunctionEaseIn$1;
exports.kCAMediaTimingFunctionEaseOut = kCAMediaTimingFunctionEaseOut$1;
exports.kCAMediaTimingFunctionEaseInEaseOut = kCAMediaTimingFunctionEaseInEaseOut$1;
exports.kCAMediaTimingFunctionDefault = kCAMediaTimingFunctionDefault$1;
exports.kCAAnimationLinear = kCAAnimationLinear$1;
exports.kCAAnimationDiscrete = kCAAnimationDiscrete$1;
exports.kCAAnimationPaced = kCAAnimationPaced$1;
exports.kCAAnimationCubic = kCAAnimationCubic$1;
exports.kCAAnimationCubicPaced = kCAAnimationCubicPaced$1;
exports.kCAAnimationRotateAuto = kCAAnimationRotateAuto$1;
exports.kCAAnimationRotateAutoReverse = kCAAnimationRotateAutoReverse$1;
